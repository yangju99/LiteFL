[
    {
        "name": "FastMath.pow#1611",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.pow(double, int)",
        "snippet": "    public static double pow(double d, int e) {\n\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n\n        // split d as two 26 bits numbers\n        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n        final int splitFactor = 0x8000001;\n        final double cd       = splitFactor * d;\n        final double d1High   = cd - (cd - d);\n        final double d1Low    = d - d1High;\n\n        // prepare result\n        double resultHigh = 1;\n        double resultLow  = 0;\n\n        // d^(2p)\n        double d2p     = d;\n        double d2pHigh = d1High;\n        double d2pLow  = d1Low;\n\n        while (e != 0) {\n\n            if ((e & 0x1) != 0) {\n                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n                final double tmpHigh = resultHigh * d2p;\n                final double cRH     = splitFactor * resultHigh;\n                final double rHH     = cRH - (cRH - resultHigh);\n                final double rHL     = resultHigh - rHH;\n                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh = tmpHigh;\n                resultLow  = resultLow * d2p + tmpLow;\n            }\n\n            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH   = splitFactor * d2pHigh;\n            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   = d2pHigh - d2pHH;\n            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     = d2pHigh + d2pLow;\n\n            e = e >> 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }\n",
        "begin_line": 1611,
        "end_line": 1668,
        "comment": "\n     * Raise a double to an int power.\n     *\n     * @param d Number to raise.\n     * @param e Exponent.\n     * @return d<sup>e</sup>\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "RandomDataImpl.RandomDataImpl#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/RandomDataImpl.java",
        "class_name": "org.apache.commons.math3.random.RandomDataImpl",
        "signature": "org.apache.commons.math3.random.RandomDataImpl.RandomDataImpl()",
        "snippet": "    public RandomDataImpl() {\n        delegate = new RandomDataGenerator();\n    }\n",
        "begin_line": 114,
        "end_line": 116,
        "comment": "\n     * Construct a RandomDataImpl, using a default random generator as the source\n     * of randomness.\n     *\n     * <p>The default generator is a {@link Well19937c} seeded\n     * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n     * The generator is initialized and seeded on first use.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "RandomDataGenerator.RandomDataGenerator#131",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java",
        "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
        "signature": "org.apache.commons.math3.random.RandomDataGenerator.RandomDataGenerator()",
        "snippet": "    public RandomDataGenerator() {\n    }\n",
        "begin_line": 131,
        "end_line": 132,
        "comment": "\n     * Construct a RandomDataGenerator, using a default random generator as the source\n     * of randomness.\n     *\n     * <p>The default generator is a {@link Well19937c} seeded\n     * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n     * The generator is initialized and seeded on first use.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "NormalDistribution.NormalDistribution#69",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
        "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double, double)",
        "snippet": "    public NormalDistribution(double mean, double sd)\n        throws NotStrictlyPositiveException {\n        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n",
        "begin_line": 69,
        "end_line": 72,
        "comment": "\n     * Create a normal distribution using the given mean and standard deviation.\n     *\n     * @param mean Mean for this distribution.\n     * @param sd Standard deviation for this distribution.\n     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "NormalDistribution.NormalDistribution#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
        "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double, double, double)",
        "snippet": "    public NormalDistribution(double mean, double sd, double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), mean, sd, inverseCumAccuracy);\n    }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": "\n     * Create a normal distribution using the given mean, standard deviation and\n     * inverse cumulative distribution accuracy.\n     *\n     * @param mean Mean for this distribution.\n     * @param sd Standard deviation for this distribution.\n     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n     * @since 2.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "NormalDistribution.NormalDistribution#99",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
        "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(org.apache.commons.math3.random.RandomGenerator, double, double, double)",
        "snippet": "    public NormalDistribution(RandomGenerator rng,\n                              double mean,\n                              double sd,\n                              double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (sd <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n        }\n\n        this.mean = mean;\n        standardDeviation = sd;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n",
        "begin_line": 99,
        "end_line": 113,
        "comment": "\n     * Creates a normal distribution.\n     *\n     * @param rng Random number generator.\n     * @param mean Mean for this distribution.\n     * @param sd Standard deviation for this distribution.\n     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "NormalDistribution.density#134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
        "signature": "org.apache.commons.math3.distribution.NormalDistribution.density(double)",
        "snippet": "    public double density(double x) {\n        final double x0 = x - mean;\n        final double x1 = x0 / standardDeviation;\n        return FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);\n    }\n",
        "begin_line": 134,
        "end_line": 138,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Returns the probability density function (PDF) of this distribution\n     * evaluated at the specified point {@code x}. In general, the PDF is\n     * the derivative of the {@link #cumulativeProbability(double) CDF}.\n     * If the derivative does not exist at {@code x}, then an appropriate\n     * replacement should be returned, e.g. {@code Double.POSITIVE_INFINITY},\n     * {@code Double.NaN}, or  the limit inferior or limit superior of the\n     * difference quotient.\n     *\n     * @param x the point at which the PDF is evaluated\n     * @return the value of the probability density function at point {@code x}\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealDistribution.AbstractRealDistribution#76",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.AbstractRealDistribution(org.apache.commons.math3.random.RandomGenerator)",
        "snippet": "    protected AbstractRealDistribution(RandomGenerator rng) {\n        random = rng;\n    }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "\n     * @param rng Random number generator.\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntA#6141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA()",
        "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A.clone();\n    }\n",
        "begin_line": 6141,
        "end_line": 6143,
        "comment": "\n     * Load \"EXP_INT_A\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntB#6149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB()",
        "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B.clone();\n    }\n",
        "begin_line": 6149,
        "end_line": 6151,
        "comment": "\n     * Load \"EXP_INT_B\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracA#6157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA()",
        "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A.clone();\n    }\n",
        "begin_line": 6157,
        "end_line": 6159,
        "comment": "\n     * Load \"EXP_FRAC_A\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracB#6165",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB()",
        "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B.clone();\n    }\n",
        "begin_line": 6165,
        "end_line": 6167,
        "comment": "\n     * Load \"EXP_FRAC_B\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.exp#830",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
        "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n",
        "begin_line": 830,
        "end_line": 832,
        "comment": "\n     * Exponential function.\n     *\n     * Computes exp(x), function result is nearly rounded.   It will be correctly\n     * rounded to the theoretical value for 99.9% of input values, otherwise it will\n     * have a 1 UPL error.\n     *\n     * Method:\n     *    Lookup intVal = exp(int(x))\n     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n     *    Compute z as the exponential of the remaining bits by a polynomial minus one\n     *    exp(x) = intVal * fracVal * (1 + z)\n     *\n     * Accuracy:\n     *    Calculation is done with 63 bits of precision, so result should be correctly\n     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n     *\n     * @param x   a double\n     * @return double e<sup>x</sup>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.exp#841",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.exp(double, double, double[])",
        "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n",
        "begin_line": 841,
        "end_line": 956,
        "comment": "\n     * Internal helper method for exponential function.\n     * @param x original argument of the exponential function\n     * @param extra extra bits of precision on input (To Be Confirmed)\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1129",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1129,
        "end_line": 1353,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.pow#1442",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.pow(double, double)",
        "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n",
        "begin_line": 1442,
        "end_line": 1600,
        "comment": "\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.preMultiply#370",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.preMultiply(double[])",
        "snippet": "    @Override\n    public double[] preMultiply(final double[] v)\n        throws DimensionMismatchException {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (v.length != nRows) {\n            throw new DimensionMismatchException(v.length, nRows);\n        }\n\n        final double[] out = new double[nCols];\n        for (int col = 0; col < nCols; ++col) {\n            double sum = 0;\n            for (int i = 0; i < nRows; ++i) {\n                sum += data[i][col] * v[i];\n            }\n            out[col] = sum;\n        }\n\n        return out;\n\n    }\n",
        "begin_line": 370,
        "end_line": 390,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the (row) vector result of premultiplying this by the vector {@code v}.\n     *\n     * @param v the row vector to premultiply by\n     * @return {@code v * this}\n     * @throws DimensionMismatchException if the length of {@code v} does not\n     * match the row dimension of {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultivariateNormalDistribution.density#177",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
        "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.density(double[])",
        "snippet": "    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n",
        "begin_line": 177,
        "end_line": 186,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution": null,
            "org.apache.commons.math3.distribution.MultivariateRealDistribution": "\n     * Returns the probability density function (PDF) of this distribution\n     * evaluated at the specified point {@code x}. In general, the PDF is the\n     * derivative of the cumulative distribution function. If the derivative\n     * does not exist at {@code x}, then an appropriate replacement should be\n     * returned, e.g. {@code Double.POSITIVE_INFINITY}, {@code Double.NaN}, or\n     * the limit inferior or limit superior of the difference quotient.\n     *\n     * @param x Point at which the PDF is evaluated.\n     * @return the value of the probability density function at point {@code x}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultivariateNormalDistribution.getExponentTerm#228",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
        "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.getExponentTerm(double[])",
        "snippet": "    private double getExponentTerm(final double[] values) {\n        final double[] centered = new double[values.length];\n        for (int i = 0; i < centered.length; i++) {\n            centered[i] = values[i] - getMeans()[i];\n        }\n        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);\n        double sum = 0;\n        for (int i = 0; i < preMultiplied.length; i++) {\n            sum += preMultiplied[i] * centered[i];\n        }\n        return FastMath.exp(-0.5 * sum);\n    }\n",
        "begin_line": 228,
        "end_line": 239,
        "comment": "\n     * Computes the term used in the exponent (see definition of the distribution).\n     *\n     * @param values Values at which to compute density.\n     * @return the multiplication factor of density calculations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultivariateNormalDistribution.getMeans#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
        "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.getMeans()",
        "snippet": "    public double[] getMeans() {\n        return MathArrays.copyOf(means);\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Gets the mean vector.\n     *\n     * @return the mean vector.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractMultivariateRealDistribution.getDimension#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractMultivariateRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution.getDimension()",
        "snippet": "    public int getDimension() {\n        return dimension;\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.MultivariateRealDistribution": "\n     * Gets the number of random variables of the distribution.\n     * It is the size of the array returned by the {@link #sample() sample}\n     * method.\n     *\n     * @return the number of variables.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
        "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "\n     * Returns {@code true} if there is no double value strictly between the\n     * arguments or the difference between them is within the range of allowed\n     * error (inclusive).\n     *\n     * @param x First value.\n     * @param y Second value.\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#330",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 330,
        "end_line": 345,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.checkNotNull#262",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathUtils.java",
        "class_name": "org.apache.commons.math3.util.MathUtils",
        "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 262,
        "end_line": 267,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#718",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
        "snippet": "     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n",
        "begin_line": 718,
        "end_line": 720,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#746",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[], int)",
        "snippet": "    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n",
        "begin_line": 746,
        "end_line": 750,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#378",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 378,
        "end_line": 380,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#2998",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 2998,
        "end_line": 3000,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3016",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3016,
        "end_line": 3018,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3420",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
        "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n",
        "begin_line": 3420,
        "end_line": 3422,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
        "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance()} with the only customizing that the\n     * maximum number of fraction digits is set to 10.\n     * @return the default number format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(java.util.Locale)",
        "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }\n",
        "begin_line": 53,
        "end_line": 57,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing that the maximum number of fraction digits is set to 10.\n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Well19937c.Well19937c#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/Well19937c.java",
        "class_name": "org.apache.commons.math3.random.Well19937c",
        "signature": "org.apache.commons.math3.random.Well19937c.Well19937c()",
        "snippet": "    public Well19937c() {\n        super(K, M1, M2, M3);\n    }\n",
        "begin_line": 56,
        "end_line": 58,
        "comment": " Creates a new random number generator.\n     * <p>The instance is initialized using the current time as the\n     * seed.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.BitsStreamGenerator#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
        "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Creates a new random number generator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.clear#169",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
        "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Clears the cache used by the default implementation of\n     * {@link #nextGaussian}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractWell.AbstractWell#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/AbstractWell.java",
        "class_name": "org.apache.commons.math3.random.AbstractWell",
        "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int, int, int, int)",
        "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\n        this(k, m1, m2, m3, null);\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": " Creates a new random number generator.\n     * <p>The instance is initialized using the current time plus the\n     * system identity hash code of this instance as the seed.</p>\n     * @param k number of bits in the pool (not necessarily a multiple of 32)\n     * @param m1 first parameter of the algorithm\n     * @param m2 second parameter of the algorithm\n     * @param m3 third parameter of the algorithm\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractWell.AbstractWell#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/AbstractWell.java",
        "class_name": "org.apache.commons.math3.random.AbstractWell",
        "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int, int, int, int, int[])",
        "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\n\n        // the bits pool contains k bits, k = r w - p where r is the number\n        // of w bits blocks, w is the block size (always 32 in the original paper)\n        // and p is the number of unused bits in the last block\n        final int w = 32;\n        final int r = (k + w - 1) / w;\n        this.v      = new int[r];\n        this.index  = 0;\n\n        // precompute indirection index tables. These tables are used for optimizing access\n        // they allow saving computations like \"(j + r - 2) % r\" with costly modulo operations\n        iRm1 = new int[r];\n        iRm2 = new int[r];\n        i1   = new int[r];\n        i2   = new int[r];\n        i3   = new int[r];\n        for (int j = 0; j < r; ++j) {\n            iRm1[j] = (j + r - 1) % r;\n            iRm2[j] = (j + r - 2) % r;\n            i1[j]   = (j + m1)    % r;\n            i2[j]   = (j + m2)    % r;\n            i3[j]   = (j + m3)    % r;\n        }\n\n        // initialize the pool content\n        setSeed(seed);\n\n    }\n",
        "begin_line": 94,
        "end_line": 122,
        "comment": " Creates a new random number generator using an int array seed.\n     * @param k number of bits in the pool (not necessarily a multiple of 32)\n     * @param m1 first parameter of the algorithm\n     * @param m2 second parameter of the algorithm\n     * @param m3 third parameter of the algorithm\n     * @param seed the initial seed (32 bits integers array), if null\n     * the seed of the generator will be related to the current time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractWell.setSeed#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/AbstractWell.java",
        "class_name": "org.apache.commons.math3.random.AbstractWell",
        "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(int[])",
        "snippet": "    @Override\n    public void setSeed(final int[] seed) {\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));\n\n        if (seed.length < v.length) {\n            for (int i = seed.length; i < v.length; ++i) {\n                final long l = v[i - seed.length];\n                v[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL);\n            }\n        }\n\n        index = 0;\n        clear();  // Clear normal deviate cache\n    }\n",
        "begin_line": 152,
        "end_line": 170,
        "comment": " Reinitialize the generator as if just built with the given int array seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integers array). If null\n     * the seed of the generator will be the system time plus the system identity\n     * hash code of the instance.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractWell.setSeed#177",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/AbstractWell.java",
        "class_name": "org.apache.commons.math3.random.AbstractWell",
        "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(long)",
        "snippet": "    @Override\n    public void setSeed(final long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }\n",
        "begin_line": 177,
        "end_line": 180,
        "comment": " Reinitialize the generator as if just built with the given long seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (64 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.TriDiagonalTransformer#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.TriDiagonalTransformer(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public TriDiagonalTransformer(RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getRowDimension();\n        householderVectors = matrix.getData();\n        main      = new double[m];\n        secondary = new double[m - 1];\n        cachedQ   = null;\n        cachedQt  = null;\n        cachedT   = null;\n\n        // transform matrix\n        transform();\n    }\n",
        "begin_line": 62,
        "end_line": 78,
        "comment": "\n     * Build the transformation to tridiagonal shape of a symmetrical matrix.\n     * <p>The specified matrix is assumed to be symmetrical without any check.\n     * Only the upper triangular part of the matrix is used.</p>\n     *\n     * @param matrix Symmetrical matrix to transform.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getQ#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQ()",
        "snippet": "    public RealMatrix getQ() {\n        if (cachedQ == null) {\n            cachedQ = getQT().transpose();\n        }\n        return cachedQ;\n    }\n",
        "begin_line": 85,
        "end_line": 90,
        "comment": "\n     * Returns the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getQT#97",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQT()",
        "snippet": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    double beta = 1.0 / secondary[k - 1];\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }\n",
        "begin_line": 97,
        "end_line": 132,
        "comment": "\n     * Returns the transpose of the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getMainDiagonalRef#174",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getMainDiagonalRef()",
        "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "\n     * Get the main diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the main diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getSecondaryDiagonalRef#184",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getSecondaryDiagonalRef()",
        "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Get the secondary diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the secondary diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.transform#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.transform()",
        "snippet": "    private void transform() {\n        final int m = householderVectors.length;\n        final double[] z = new double[m];\n        for (int k = 0; k < m - 1; k++) {\n\n            //zero-out a row and a column simultaneously\n            final double[] hK = householderVectors[k];\n            main[k] = hK[k];\n            double xNormSqr = 0;\n            for (int j = k + 1; j < m; ++j) {\n                final double c = hK[j];\n                xNormSqr += c * c;\n            }\n            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n            secondary[k] = a;\n            if (a != 0.0) {\n                // apply Householder transform from left and right simultaneously\n\n                hK[k + 1] -= a;\n                final double beta = -1 / (a * hK[k + 1]);\n\n                // compute a = beta A v, where v is the Householder vector\n                // this loop is written in such a way\n                //   1) only the upper triangular part of the matrix is accessed\n                //   2) access is cache-friendly for a matrix stored in rows\n                Arrays.fill(z, k + 1, m, 0);\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    final double hKI = hK[i];\n                    double zI = hI[i] * hKI;\n                    for (int j = i + 1; j < m; ++j) {\n                        final double hIJ = hI[j];\n                        zI   += hIJ * hK[j];\n                        z[j] += hIJ * hKI;\n                    }\n                    z[i] = beta * (z[i] + zI);\n                }\n\n                // compute gamma = beta vT z / 2\n                double gamma = 0;\n                for (int i = k + 1; i < m; ++i) {\n                    gamma += z[i] * hK[i];\n                }\n                gamma *= beta / 2;\n\n                // compute z = z - gamma v\n                for (int i = k + 1; i < m; ++i) {\n                    z[i] -= gamma * hK[i];\n                }\n\n                // update matrix: A = A - v zT - z vT\n                // only the upper triangular part of the matrix is updated\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    for (int j = i; j < m; ++j) {\n                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                    }\n                }\n            }\n        }\n        main[m - 1] = householderVectors[m - 1][m - 1];\n    }\n",
        "begin_line": 192,
        "end_line": 253,
        "comment": "\n     * Transform original matrix to tridiagonal form.\n     * <p>Transformation is done using Householder transforms.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }\n",
        "begin_line": 105,
        "end_line": 114,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param separator separator to use instead of the default \"; \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
        "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#170",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#98",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }\n",
        "begin_line": 112,
        "end_line": 117,
        "comment": "\n     * Create an instance with custom prefix, suffix and separator.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#130",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }\n",
        "begin_line": 130,
        "end_line": 143,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getFormat#206",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
        "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }\n",
        "begin_line": 206,
        "end_line": 208,
        "comment": "\n     * Get the components format.\n     * @return components format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getInstance#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
        "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getInstance#223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }\n",
        "begin_line": 127,
        "end_line": 136,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if {@code data} is not rectangular (not all rows have the same length).\n     * @throws NoDataException if a row or column is empty.\n     * @throws NullArgumentException if either {@code data} or {@code data[0]}\n     * is {@code null}.\n     * @throws DimensionMismatchException if {@code data} is not rectangular.\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.isSymmetricInternal#388",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetricInternal(org.apache.commons.math3.linear.RealMatrix, double, boolean)",
        "snippet": "    private static boolean isSymmetricInternal(RealMatrix matrix,\n                                               double relativeTolerance,\n                                               boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        if (rows != matrix.getColumnDimension()) {\n            if (raiseException) {\n                throw new NonSquareMatrixException(rows, matrix.getColumnDimension());\n            } else {\n                return false;\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = i + 1; j < rows; j++) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * relativeTolerance) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, relativeTolerance);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n",
        "begin_line": 388,
        "end_line": 414,
        "comment": "\n     * Checks whether a matrix is symmetric, within a given relative tolerance.\n     *\n     * @param matrix Matrix to check.\n     * @param relativeTolerance Tolerance of the symmetry check.\n     * @param raiseException If {@code true}, an exception will be raised if\n     * the matrix is not symmetric.\n     * @return {@code true} if {@code matrix} is symmetric.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.isSymmetric#438",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetric(org.apache.commons.math3.linear.RealMatrix, double)",
        "snippet": "    public static boolean isSymmetric(RealMatrix matrix,\n                                      double eps) {\n        return isSymmetricInternal(matrix, eps, false);\n    }\n",
        "begin_line": 438,
        "end_line": 441,
        "comment": "\n     * Checks whether a matrix is symmetric.\n     *\n     * @param matrix Matrix to check.\n     * @param eps Relative tolerance.\n     * @return {@code true} if {@code matrix} is symmetric.\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMatrixIndex#452",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix, int, int)",
        "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }\n",
        "begin_line": 452,
        "end_line": 457,
        "comment": "\n     * Check if matrix indices are valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code row} or {@code column} is not\n     * a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkRowIndex#466",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }\n",
        "begin_line": 466,
        "end_line": 473,
        "comment": "\n     * Check if a row index is valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @throws OutOfRangeException if {@code row} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkColumnIndex#482",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }\n",
        "begin_line": 482,
        "end_line": 488,
        "comment": "\n     * Check if a column index is valid.\n     *\n     * @param m Matrix.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code column} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#604",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }\n",
        "begin_line": 604,
        "end_line": 611,
        "comment": "\n     * Check if matrices are multiplication compatible\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws DimensionMismatchException if matrices are not multiplication\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.Solver#428",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.Solver.Solver(double[], double[], org.apache.commons.math3.linear.ArrayRealVector[])",
        "snippet": "        private Solver(final double[] realEigenvalues,\n                final double[] imagEigenvalues,\n                final ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors = eigenvectors;\n        }\n",
        "begin_line": 428,
        "end_line": 434,
        "comment": "\n         * Builds a solver from decomposed matrix.\n         *\n         * @param realEigenvalues Real parts of the eigenvalues.\n         * @param imagEigenvalues Imaginary parts of the eigenvalues.\n         * @param eigenvectors Eigenvectors.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.isNonSingular#515",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.Solver.isNonSingular()",
        "snippet": "        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if (realEigenvalues[i] == 0 &&\n                    imagEigenvalues[i] == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n",
        "begin_line": 515,
        "end_line": 523,
        "comment": "\n         * Checks whether the decomposed matrix is non-singular.\n         *\n         * @return true if the decomposed matrix is non-singular.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getInverse#531",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.Solver.getInverse()",
        "snippet": "        public RealMatrix getInverse() {\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return MatrixUtils.createRealMatrix(invData);\n        }\n",
        "begin_line": 531,
        "end_line": 551,
        "comment": "\n         * Get the inverse of the decomposed matrix.\n         *\n         * @return the inverse matrix.\n         * @throws SingularMatrixException if the decomposed matrix is singular.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.EigenDecomposition#117",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.EigenDecomposition(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public EigenDecomposition(final RealMatrix matrix)\n        throws MathArithmeticException {\n        final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\n        isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\n        if (isSymmetric) {\n            transformToTridiagonal(matrix);\n            findEigenVectors(transformer.getQ().getData());\n        } else {\n            final SchurTransformer t = transformToSchur(matrix);\n            findEigenVectorsFromSchur(t);\n        }\n    }\n",
        "begin_line": 117,
        "end_line": 128,
        "comment": "\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.hasComplexEigenvalues#271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.hasComplexEigenvalues()",
        "snippet": "    public boolean hasComplexEigenvalues() {\n        for (int i = 0; i < imagEigenvalues.length; i++) {\n            if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "begin_line": 271,
        "end_line": 278,
        "comment": "\n     * Returns whether the calculated eigen values are complex or real.\n     * <p>The method performs a zero check for each element of the\n     * {@link #getImagEigenvalues()} array and returns {@code true} if any\n     * element is not equal to zero.\n     *\n     * @return {@code true} if the eigen values are complex, {@code false} otherwise\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getRealEigenvalues#289",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getRealEigenvalues()",
        "snippet": "    public double[] getRealEigenvalues() {\n        return realEigenvalues.clone();\n    }\n",
        "begin_line": 289,
        "end_line": 291,
        "comment": "\n     * Gets a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @return a copy of the real parts of the eigenvalues of the original matrix.\n     *\n     * @see #getD()\n     * @see #getRealEigenvalue(int)\n     * @see #getImagEigenvalues()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getEigenvector#347",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getEigenvector(int)",
        "snippet": "    public RealVector getEigenvector(final int i) {\n        return eigenvectors[i].copy();\n    }\n",
        "begin_line": 347,
        "end_line": 349,
        "comment": "\n     * Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     *\n     * @param i Index of the eigenvector (counting from 0).\n     * @return a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     * @see #getD()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getDeterminant#356",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getDeterminant()",
        "snippet": "    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n",
        "begin_line": 356,
        "end_line": 362,
        "comment": "\n     * Computes the determinant of the matrix.\n     *\n     * @return the determinant of the matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getSolver#405",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getSolver()",
        "snippet": "    public DecompositionSolver getSolver() {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n",
        "begin_line": 405,
        "end_line": 410,
        "comment": "\n     * Gets a solver for finding the A &times; X = B solution in exact\n     * linear sense.\n     * <p>\n     * Since 3.1, eigen decomposition of a general matrix is supported,\n     * but the {@link DecompositionSolver} only supports real eigenvalues.\n     *\n     * @return a solver\n     * @throws MathUnsupportedOperationException if the decomposition resulted in\n     * complex eigenvalues\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.transformToTridiagonal#559",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void transformToTridiagonal(final RealMatrix matrix) {\n        // transform the matrix to tridiagonal\n        transformer = new TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n    }\n",
        "begin_line": 559,
        "end_line": 564,
        "comment": "\n     * Transforms the matrix to tridiagonal form.\n     *\n     * @param matrix Matrix to transform.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.findEigenVectors#572",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.findEigenVectors(double[][])",
        "snippet": "    private void findEigenVectors(final double[][] householderMatrix) {\n        final double[][]z = householderMatrix.clone();\n        final int n = main.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        final double[] e = new double[n];\n        for (int i = 0; i < n - 1; i++) {\n            realEigenvalues[i] = main[i];\n            e[i] = secondary[i];\n        }\n        realEigenvalues[n - 1] = main[n - 1];\n        e[n - 1] = 0;\n\n        // Determine the largest main and secondary value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n            }\n            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(e[i]);\n            }\n        }\n        // Make null any main and secondary value too small to be significant\n        if (maxAbsoluteValue != 0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    e[i]=0;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            int its = 0;\n            int m;\n            do {\n                for (m = j; m < n - 1; m++) {\n                    double delta = FastMath.abs(realEigenvalues[m]) +\n                        FastMath.abs(realEigenvalues[m + 1]);\n                    if (FastMath.abs(e[m]) + delta == delta) {\n                        break;\n                    }\n                }\n                if (m != j) {\n                    if (its == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    its++;\n                    double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                    double t = FastMath.sqrt(1 + q * q);\n                    if (q < 0.0) {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                    } else {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n                    }\n                    double u = 0.0;\n                    double s = 1.0;\n                    double c = 1.0;\n                    int i;\n                    for (i = m - 1; i >= j; i--) {\n                        double p = s * e[i];\n                        double h = c * e[i];\n                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                            c = q / p;\n                            t = FastMath.sqrt(c * c + 1.0);\n                            e[i + 1] = p * t;\n                            s = 1.0 / t;\n                            c = c * s;\n                        } else {\n                            s = p / q;\n                            t = FastMath.sqrt(s * s + 1.0);\n                            e[i + 1] = q * t;\n                            c = 1.0 / t;\n                            s = s * c;\n                        }\n                        if (e[i + 1] == 0.0) {\n                            realEigenvalues[i + 1] -= u;\n                            e[m] = 0.0;\n                            break;\n                        }\n                        q = realEigenvalues[i + 1] - u;\n                        t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n                        u = s * t;\n                        realEigenvalues[i + 1] = q + u;\n                        q = c * t - h;\n                        for (int ia = 0; ia < n; ia++) {\n                            p = z[ia][i + 1];\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\n                            z[ia][i] = c * z[ia][i] - s * p;\n                        }\n                    }\n                    if (t == 0.0 && i >= j) {\n                        continue;\n                    }\n                    realEigenvalues[j] -= u;\n                    e[j] = q;\n                    e[m] = 0.0;\n                }\n            } while (m != j);\n        }\n\n        //Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n            }\n        }\n        // Make null any eigen value too small to be significant\n        if (maxAbsoluteValue != 0.0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n            }\n        }\n        eigenvectors = new ArrayRealVector[n];\n        final double[] tmp = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tmp[j] = z[j][i];\n            }\n            eigenvectors[i] = new ArrayRealVector(tmp);\n        }\n    }\n",
        "begin_line": 572,
        "end_line": 721,
        "comment": "\n     * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\n     *\n     * @param householderMatrix Householder matrix of the transformation\n     * to tridiagonal form.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.start#32",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int, int, int, int, int, int)",
        "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }\n",
        "begin_line": 32,
        "end_line": 34,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.end#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
        "snippet": "    public double end() {\n        return 0;\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
        "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Construct a vector from an array, copying the input array.\n     *\n     * @param d Array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#202",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(org.apache.commons.math3.linear.ArrayRealVector, boolean)",
        "snippet": "    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }\n",
        "begin_line": 202,
        "end_line": 204,
        "comment": "\n     * Construct a vector from another vector.\n     *\n     * @param v Vector to copy.\n     * @param deep If {@code true} perform a deep copy, otherwise perform a\n     * shallow copy.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.copy#287",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.copy()",
        "snippet": "    @Override\n    public ArrayRealVector copy() {\n        return new ArrayRealVector(this, true);\n    }\n",
        "begin_line": 287,
        "end_line": 290,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Returns a (deep) copy of this vector.\n     *\n     * @return a vector copy.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.getDataRef#449",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDataRef()",
        "snippet": "    public double[] getDataRef() {\n        return data;\n    }\n",
        "begin_line": 449,
        "end_line": 451,
        "comment": "\n     * Get a reference to the underlying data array.\n     * This method does not make a fresh copy of the underlying data.\n     *\n     * @return the array of entries.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.toArray#724",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.toArray()",
        "snippet": "    @Override\n    public double[] toArray(){\n        return data.clone();\n    }\n",
        "begin_line": 724,
        "end_line": 727,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Convert the vector to an array of {@code double}s.\n     * The array is independent from this vector data: the elements\n     * are copied.\n     *\n     * @return an array containing a copy of the vector elements.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
        "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }\n",
        "begin_line": 58,
        "end_line": 63,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows in the new matrix.\n     * @param columnDimension Number of columns in the new matrix.\n     * @throws NotStrictlyPositiveException if the row or column dimension is\n     * not positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": "\n     * Create a new {@code RealMatrix} using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n     * with the second argument set to {@code true}.</p>\n     *\n     * @param d Data for the new matrix.\n     * @throws DimensionMismatchException if {@code d} is not rectangular.\n     * @throws NoDataException if {@code d} row or colum dimension is zero.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #Array2DRowRealMatrix(double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.createMatrix#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int, int)",
        "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }\n",
        "begin_line": 141,
        "end_line": 146,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Create a new RealMatrix of the same type as the instance with the\n     * supplied\n     * row and column dimensions.\n     *\n     * @param rowDimension the number of rows in the new matrix\n     * @param columnDimension the number of columns in the new matrix\n     * @return a new matrix of the same type as the instance\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getData#252",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }\n",
        "begin_line": 252,
        "end_line": 255,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return 2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setSubMatrix#267",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
        "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }\n",
        "begin_line": 267,
        "end_line": 300,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n    * Replace the submatrix starting at {@code row, column} using data in the\n    * input {@code subMatrix} array. Indexes are 0-based.\n    * <p>\n    * Example:<br>\n    * Starting with <pre>\n    * 1  2  3  4\n    * 5  6  7  8\n    * 9  0  1  2\n    * </pre>\n    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n    * {@code setSubMatrix(subMatrix,1,1))} will result in <pre>\n    * 1  2  3  4\n    * 5  3  4  8\n    * 9  5  6  2\n    * </pre></p>\n    *\n    * @param subMatrix  array containing the submatrix replacement data\n    * @param row  row coordinate of the top, left element to be replaced\n    * @param column  column coordinate of the top, left element to be replaced\n    * @throws NoDataException if {@code subMatrix} is empty.\n    * @throws OutOfRangeException if {@code subMatrix} does not fit into\n    * this matrix from element in {@code (row, column)}.\n    * @throws DimensionMismatchException if {@code subMatrix} is not rectangular\n    * (not all rows have the same length) or empty.\n    * @throws NullArgumentException if {@code subMatrix} is {@code null}.\n    * @since 2.0\n    "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getEntry#303",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }\n",
        "begin_line": 303,
        "end_line": 308,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be fetched.\n     * @param column Column index of entry to be fetched.\n     * @return the matrix entry at {@code (row, column)}.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setEntry#311",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }\n",
        "begin_line": 311,
        "end_line": 316,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Set the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be set.\n     * @param column Column index of entry to be set.\n     * @param value the new value of the entry.\n     * @throws OutOfRangeException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.multiplyEntry#328",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.multiplyEntry(int, int, double)",
        "snippet": "    @Override\n    public void multiplyEntry(final int row, final int column,\n                              final double factor)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] *= factor;\n    }\n",
        "begin_line": 328,
        "end_line": 334,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Multiplies (in place) the specified entry of {@code this} matrix by the\n     * specified value. Row and column indices start at 0.\n     *\n     * @param row Row index of the entry to be modified.\n     * @param column Column index of the entry to be modified.\n     * @param factor Multiplication factor for the matrix entry.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#337",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 337,
        "end_line": 340,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of rows of this matrix.\n     *\n     * @return the number of rows.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#343",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 343,
        "end_line": 346,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of columns of this matrix.\n     *\n     * @return the number of columns.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.walkInRowOrder#408",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 408,
        "end_line": 420,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyOut#527",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
        "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n",
        "begin_line": 527,
        "end_line": 535,
        "comment": "\n     * Get a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyIn#545",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
        "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }\n",
        "begin_line": 545,
        "end_line": 548,
        "comment": "\n     * Replace data with a fresh copy of the input array.\n     *\n     * @param in Data to copy.\n     * @throws NoDataException if the input array is empty.\n     * @throws DimensionMismatchException if the input array is not rectangular.\n     * @throws NullArgumentException if the input array is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.transpose#597",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
        "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }\n",
        "begin_line": 597,
        "end_line": 612,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.visit#604",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-df5ca6ce-f8b9-4cc3-b7a5-4e9a18c8ae65.visit(int, int, double)",
        "snippet": "            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n",
        "begin_line": 604,
        "end_line": 607,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {}\n",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }\n",
        "begin_line": 65,
        "end_line": 74,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws NotStrictlyPositiveException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.multiply#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 139,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.setColumn#570",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.setColumn(int, double[])",
        "snippet": "    public void setColumn(final int column, final double[] array)\n        throws OutOfRangeException, MatrixDimensionMismatchException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (array.length != nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, array[i]);\n        }\n    }\n",
        "begin_line": 570,
        "end_line": 580,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Sets the specified {@code column} of {@code this} matrix to the entries\n     * of the specified {@code array}. Column indices start at 0.\n     *\n     * @param column Column to be set.\n     * @param array Column array to be copied (must have the same number of\n     * rows as the instance).\n     * @throws OutOfRangeException if the specified column index is invalid.\n     * @throws MatrixDimensionMismatchException if the {@code array} length does\n     * not match the row dimension of {@code this} matrix.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.isSquare#615",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }\n",
        "begin_line": 615,
        "end_line": 617,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.walkInOptimizedOrder#872",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 872,
        "end_line": 874,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultivariateNormalDistribution.MultivariateNormalDistribution#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
        "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.MultivariateNormalDistribution(double[], double[][])",
        "snippet": "    public MultivariateNormalDistribution(final double[] means,\n                                          final double[][] covariances)\n        throws SingularMatrixException,\n               DimensionMismatchException,\n               NonPositiveDefiniteMatrixException {\n        this(new Well19937c(), means, covariances);\n    }\n",
        "begin_line": 71,
        "end_line": 77,
        "comment": "\n     * Creates a multivariate normal distribution with the given mean vector and\n     * covariance matrix.\n     * <br/>\n     * The number of dimensions is equal to the length of the mean vector\n     * and to the number of rows and columns of the covariance matrix.\n     * It is frequently written as \"p\" in formulae.\n     *\n     * @param means Vector of means.\n     * @param covariances Covariance matrix.\n     * @throws DimensionMismatchException if the arrays length are\n     * inconsistent.\n     * @throws SingularMatrixException if the eigenvalue decomposition cannot\n     * be performed on the provided covariance matrix.\n     * @throws NonPositiveDefiniteMatrixException if any of the eigenvalues is\n     * negative.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultivariateNormalDistribution.MultivariateNormalDistribution#97",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
        "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.MultivariateNormalDistribution(org.apache.commons.math3.random.RandomGenerator, double[], double[][])",
        "snippet": "    public MultivariateNormalDistribution(RandomGenerator rng,\n                                          final double[] means,\n                                          final double[][] covariances)\n            throws SingularMatrixException,\n                   DimensionMismatchException,\n                   NonPositiveDefiniteMatrixException {\n        super(rng, means.length);\n\n        final int dim = means.length;\n\n        if (covariances.length != dim) {\n            throw new DimensionMismatchException(covariances.length, dim);\n        }\n\n        for (int i = 0; i < dim; i++) {\n            if (dim != covariances[i].length) {\n                throw new DimensionMismatchException(covariances[i].length, dim);\n            }\n        }\n\n        this.means = MathArrays.copyOf(means);\n\n        covarianceMatrix = new Array2DRowRealMatrix(covariances);\n\n        // Covariance matrix eigen decomposition.\n        final EigenDecomposition covMatDec = new EigenDecomposition(covarianceMatrix);\n\n        // Compute and store the inverse.\n        covarianceMatrixInverse = covMatDec.getSolver().getInverse();\n        // Compute and store the determinant.\n        covarianceMatrixDeterminant = covMatDec.getDeterminant();\n\n        // Eigenvalues of the covariance matrix.\n        final double[] covMatEigenvalues = covMatDec.getRealEigenvalues();\n\n        for (int i = 0; i < covMatEigenvalues.length; i++) {\n            if (covMatEigenvalues[i] < 0) {\n                throw new NonPositiveDefiniteMatrixException(covMatEigenvalues[i], i, 0);\n            }\n        }\n\n        // Matrix where each column is an eigenvector of the covariance matrix.\n        final Array2DRowRealMatrix covMatEigenvectors = new Array2DRowRealMatrix(dim, dim);\n        for (int v = 0; v < dim; v++) {\n            final double[] evec = covMatDec.getEigenvector(v).toArray();\n            covMatEigenvectors.setColumn(v, evec);\n        }\n\n        final RealMatrix tmpMatrix = covMatEigenvectors.transpose();\n\n        // Scale each eigenvector by the square root of its eigenvalue.\n        for (int row = 0; row < dim; row++) {\n            final double factor = FastMath.sqrt(covMatEigenvalues[row]);\n            for (int col = 0; col < dim; col++) {\n                tmpMatrix.multiplyEntry(row, col, factor);\n            }\n        }\n\n        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n    }\n",
        "begin_line": 97,
        "end_line": 156,
        "comment": "\n     * Creates a multivariate normal distribution with the given mean vector and\n     * covariance matrix.\n     * <br/>\n     * The number of dimensions is equal to the length of the mean vector\n     * and to the number of rows and columns of the covariance matrix.\n     * It is frequently written as \"p\" in formulae.\n     *\n     * @param rng Random Number Generator.\n     * @param means Vector of means.\n     * @param covariances Covariance matrix.\n     * @throws DimensionMismatchException if the arrays length are\n     * inconsistent.\n     * @throws SingularMatrixException if the eigenvalue decomposition cannot\n     * be performed on the provided covariance matrix.\n     * @throws NonPositiveDefiniteMatrixException if any of the eigenvalues is\n     * negative.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractMultivariateRealDistribution.AbstractMultivariateRealDistribution#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractMultivariateRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution.AbstractMultivariateRealDistribution(org.apache.commons.math3.random.RandomGenerator, int)",
        "snippet": "    protected AbstractMultivariateRealDistribution(RandomGenerator rng,\n                                                   int n) {\n        random = rng;\n        dimension = n;\n    }\n",
        "begin_line": 40,
        "end_line": 44,
        "comment": "\n     * @param rng Random number generator.\n     * @param n Number of dimensions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    }
]