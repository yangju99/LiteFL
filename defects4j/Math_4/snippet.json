[
    {
        "name": "SubLine.intersection#110",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine, boolean)",
        "snippet": "    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n\n        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n",
        "begin_line": 110,
        "end_line": 127,
        "comment": " Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.SubLine#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public SubLine(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        this(new Line(start, end), buildIntervalSet(start, end));\n    }\n",
        "begin_line": 54,
        "end_line": 57,
        "comment": " Create a sub-line from two endpoints.\n     * @param start start point\n     * @param end end point\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.intersection#110",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine, boolean)",
        "snippet": "    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n        // compute the intersection on infinite line\n        Vector3D v1D = line.intersection(subLine.line);\n\n        // check location of point with respect to first sub-line\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n        // check location of point with respect to second sub-line\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\n        if (includeEndPoints) {\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n        } else {\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n        }\n\n    }\n",
        "begin_line": 110,
        "end_line": 127,
        "comment": " Get the intersection of the instance and another sub-line.\n     * <p>\n     * This method is related to the {@link Line#intersection(Line)\n     * intersection} method in the {@link Line Line} class, but in addition\n     * to compute the point along infinite lines, it also checks the point\n     * lies on both sub-line ranges.\n     * </p>\n     * @param subLine other sub-line which may intersect instance\n     * @param includeEndPoints if true, endpoints are considered to belong to\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\n     * occurring on endpoints lead to null being returned\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.contains#155",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.contains(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public boolean contains(final Vector3D p) {\n        return distance(p) < 1.0e-10;\n    }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": " Check if the instance contains a point.\n     * @param p point to check\n     * @return true if p belongs to the line\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.distance#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.distance(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public double distance(final Vector3D p) {\n        final Vector3D d = p.subtract(zero);\n        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);\n        return n.getNorm();\n    }\n",
        "begin_line": 163,
        "end_line": 167,
        "comment": " Compute the distance between the instance and a point.\n     * @param p to check\n     * @return distance between the instance and the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.closestPoint#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.closestPoint(org.apache.commons.math3.geometry.euclidean.threed.Line)",
        "snippet": "    public Vector3D closestPoint(final Line line) {\n\n        final double cos = direction.dotProduct(line.direction);\n        final double n = 1 - cos * cos;\n        if (n < Precision.EPSILON) {\n            // the lines are parallel\n            return zero;\n        }\n\n        final Vector3D delta0 = line.zero.subtract(zero);\n        final double a        = delta0.dotProduct(direction);\n        final double b        = delta0.dotProduct(line.direction);\n\n        return new Vector3D(1, zero, (a - b * cos) / n, direction);\n\n    }\n",
        "begin_line": 193,
        "end_line": 208,
        "comment": " Compute the point of the instance closest to another line.\n     * @param line line to check against the instance\n     * @return point of the instance closest to another line\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.intersection#215",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.intersection(org.apache.commons.math3.geometry.euclidean.threed.Line)",
        "snippet": "    public Vector3D intersection(final Line line) {\n        final Vector3D closest = closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }\n",
        "begin_line": 215,
        "end_line": 218,
        "comment": " Get the intersection point of the instance and another line.\n     * @param line other line\n     * @return intersection point of the instance and the other line\n     * or null if there are no intersection points\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.SubLine#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public SubLine(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        this(new Line(start, end), buildIntervalSet(start, end));\n    }\n",
        "begin_line": 54,
        "end_line": 57,
        "comment": " Create a sub-line from two endpoints.\n     * @param start start point\n     * @param end end point\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.buildIntervalSet#135",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n",
        "begin_line": 135,
        "end_line": 140,
        "comment": " Build an interval set from two points.\n     * @param start start point\n     * @param end end point\n     * @return an interval set\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.getAbscissa#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public double getAbscissa(final Vector3D point) {\n        return point.subtract(zero).dotProduct(direction);\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": " Get the abscissa of a point with respect to the line.\n     * <p>The abscissa is 0 if the projection of the point and the\n     * projection of the frame origin on the line are the same\n     * point.</p>\n     * @param point point to check\n     * @return abscissa of the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.toSubSpace#128",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector1D(getAbscissa((Vector3D) point));\n    }\n",
        "begin_line": 128,
        "end_line": 130,
        "comment": " {@inheritDoc}\n     * @see #getAbscissa(Vector3D)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.buildTree#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildTree(double, double)",
        "snippet": "    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n",
        "begin_line": 93,
        "end_line": 128,
        "comment": " Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.239
        },
        "num_failing_tests": 2
    },
    {
        "name": "SubLine.buildIntervalSet#138",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end)\n        throws MathIllegalArgumentException {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n",
        "begin_line": 135,
        "end_line": 140,
        "comment": " Build an interval set from two points.\n     * @param start start point\n     * @param end end point\n     * @return an interval set\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.IntervalsSet#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(double, double)",
        "snippet": "    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n",
        "begin_line": 46,
        "end_line": 48,
        "comment": " Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2265
        },
        "num_failing_tests": 2
    },
    {
        "name": "BSPTree.BSPTree#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, java.lang.Object)",
        "snippet": "    public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\n                   final Object attribute) {\n        this.cut       = cut;\n        this.plus      = plus;\n        this.minus     = minus;\n        this.parent    = null;\n        this.attribute = attribute;\n        plus.parent    = this;\n        minus.parent   = this;\n    }\n",
        "begin_line": 114,
        "end_line": 123,
        "comment": " Build a BSPTree from its underlying elements.\n     * <p>This method does <em>not</em> perform any verification on\n     * consistency of its arguments, it should therefore be used only\n     * when then caller knows what it is doing.</p>\n     * <p>This method is mainly useful kto build trees\n     * bottom-up. Building trees top-down is realized with the help of\n     * method {@link #insertCut insertCut}.</p>\n     * @param cut cut sub-hyperplane for the tree\n     * @param plus plus side sub-tree\n     * @param minus minus side sub-tree\n     * @param attribute attribute associated with the node (may be null)\n     * @see #insertCut\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "SubOrientedPoint.SubOrientedPoint#37",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\n                            final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": " Simple constructor.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "OrientedPoint.OrientedPoint#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.OrientedPoint(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, boolean)",
        "snippet": "    public OrientedPoint(final Vector1D location, final boolean direct) {\n        this.location = location;\n        this.direct   = direct;\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": " Simple constructor.\n     * @param location location of the hyperplane\n     * @param direct if true, the plus side of the hyperplane is towards\n     * abscissas greater than {@code location}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "OrientedPoint.wholeHyperplane#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeHyperplane()",
        "snippet": "    public SubOrientedPoint wholeHyperplane() {\n        return new SubOrientedPoint(this, null);\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": " Build a region covering the whole hyperplane.\n     * <p>Since this class represent zero dimension spaces which does\n     * not have lower dimension sub-spaces, this method returns a dummy\n     * implementation of a {@link\n     * org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane}.\n     * This implementation is only used to allow the {@link\n     * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n     * SubHyperplane} class implementation to work properly, it should\n     * <em>not</em> be used otherwise.</p>\n     * @return a dummy sub hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractSubHyperplane.AbstractSubHyperplane#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>, org.apache.commons.math3.geometry.partitioning.Region<T>)",
        "snippet": "    protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\n                                    final Region<T> remainingRegion) {\n        this.hyperplane      = hyperplane;\n        this.remainingRegion = remainingRegion;\n    }\n",
        "begin_line": 49,
        "end_line": 53,
        "comment": " Build a sub-hyperplane from an hyperplane and a region.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRegion.AbstractRegion#67",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "    protected AbstractRegion(final BSPTree<S> tree) {\n        this.tree = tree;\n    }\n",
        "begin_line": 67,
        "end_line": 69,
        "comment": " Build a region from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param tree inside/outside BSP tree representing the region\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 2
    },
    {
        "name": "Vector1D.Vector1D#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double)",
        "snippet": "    public Vector1D(double x) {\n        this.x = x;\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @see #getX()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 2
    },
    {
        "name": "Vector1D.getX#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector1D(double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 2
    },
    {
        "name": "BSPTree.BSPTree#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(java.lang.Object)",
        "snippet": "    public BSPTree(final Object attribute) {\n        cut    = null;\n        plus   = null;\n        minus  = null;\n        parent = null;\n        this.attribute = attribute;\n    }\n",
        "begin_line": 93,
        "end_line": 99,
        "comment": " Build a tree having only one root cell representing the whole space.\n     * @param attribute attribute of the tree (may be null)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 2
    },
    {
        "name": "Vector3D.getNorm#241",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm()",
        "snippet": "    public double getNorm() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return FastMath.sqrt (x * x + y * y + z * z);\n    }\n",
        "begin_line": 241,
        "end_line": 244,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": " Get the L<sub>2</sub> norm for the vector.\n     * @return Euclidean norm for the vector\n     "
        },
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.SubLine#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Line, org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet)",
        "snippet": "    public SubLine(final Line line, final IntervalsSet remainingRegion) {\n        this.line            = line;\n        this.remainingRegion = remainingRegion;\n    }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": " Simple constructor.\n     * @param line underlying line\n     * @param remainingRegion remaining region of the line\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.linearCombination#881",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }\n",
        "begin_line": 881,
        "end_line": 935,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n     * so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects. It is based\n     * on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub>\n     * @see #linearCombination(double, double, double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.linearCombination#960",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }\n",
        "begin_line": 960,
        "end_line": 1032,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * to high accuracy. It does so by using specific multiplication and\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\n     * It is based on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @param a3 first factor of the third term\n     * @param b3 second factor of the third term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * @see #linearCombination(double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double, double)",
        "snippet": "    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n",
        "begin_line": 95,
        "end_line": 99,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @see #getX()\n     * @see #getY()\n     * @see #getZ()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }\n",
        "begin_line": 137,
        "end_line": 141,
        "comment": " Multiplicative constructor\n     * Build a vector from another one and a scale factor.\n     * The vector built will be a * u\n     * @param a scale factor\n     * @param u base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": " Linear constructor\n     * Build a vector from two other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getNormSq#247",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
        "snippet": "    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }\n",
        "begin_line": 247,
        "end_line": 250,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": " Get the square of the norm for the vector.\n     * @return square of the Euclidean norm for the vector\n     "
        },
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.subtract#285",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }\n",
        "begin_line": 285,
        "end_line": 288,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": null
        },
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.dotProduct#452",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public double dotProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }\n",
        "begin_line": 452,
        "end_line": 455,
        "comment": " {@inheritDoc}\n     * <p>\n     * The implementation uses specific multiplication and addition\n     * algorithms to preserve accuracy and reduce cancellation effects.\n     * It should be very accurate even for nearly orthogonal vectors.\n     * </p>\n     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n     ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": null
        },
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.Line#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        reset(p1, p2);\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": " Build a line from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.reset#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }\n",
        "begin_line": 73,
        "end_line": 81,
        "comment": " Reset the instance as if built from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.atan2#2581",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.atan2(double, double)",
        "snippet": "    public static double atan2(double y, double x) {\n        if (x != x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1d / x;\n            final double invy = 1d / y;\n\n            if (invx == 0) { // X is infinite\n                if (x > 0) {\n                    return y; // return +/- 0.0\n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x < 0 || invx < 0) {\n                if (y < 0 || invy < 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        // y cannot now be zero\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0 || 1 / y > 0) {\n                return 0d;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -0d;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1 / y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI;\n            }\n        }\n\n        // Neither y nor x can be infinite or NAN here\n\n        if (x == 0) {\n            if (y > 0 || 1 / y > 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        // Compute ratio r = y/x\n        final double r = y / x;\n        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n            return atan(r, 0, x < 0);\n        }\n\n        double ra = doubleHighPart(r);\n        double rb = r - ra;\n\n        // Split x\n        final double xa = doubleHighPart(x);\n        final double xb = x - xa;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        if (ra == 0) { // Fix up the sign so atan works correctly\n            ra = copySign(0d, y);\n        }\n\n        // Call atan\n        final double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n",
        "begin_line": 2581,
        "end_line": 2696,
        "comment": "\n     * Two arguments arctangent function\n     * @param y ordinate\n     * @param x abscissa\n     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.hypot#3573",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.hypot(double, double)",
        "snippet": "    public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX = getExponent(x);\n            final int expY = getExponent(y);\n            if (expX > expY + 27) {\n                // y is neglectible with respect to x\n                return abs(x);\n            } else if (expY > expX + 27) {\n                // x is neglectible with respect to y\n                return abs(y);\n            } else {\n\n                // find an intermediate scale to avoid both overflow and underflow\n                final int middleExp = (expX + expY) / 2;\n\n                // scale parameters without losing precision\n                final double scaledX = scalb(x, -middleExp);\n                final double scaledY = scalb(y, -middleExp);\n\n                // compute scaled hypotenuse\n                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                // remove scaling\n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }\n",
        "begin_line": 3573,
        "end_line": 3606,
        "comment": "\n     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n     * avoiding intermediate overflow or underflow.\n     *\n     * <ul>\n     * <li> If either argument is infinite, then the result is positive infinity.</li>\n     * <li> else, if either argument is NaN then the result is NaN.</li>\n     * </ul>\n     *\n     * @param x a value\n     * @param y a value\n     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.intersection#197",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.intersection(org.apache.commons.math3.geometry.euclidean.threed.Line)",
        "snippet": "    public Vector3D intersection(final Line line) {\n        final Vector3D closest = closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }\n",
        "begin_line": 215,
        "end_line": 218,
        "comment": " Get the intersection point of the instance and another line.\n     * @param line other line\n     * @return intersection point of the instance and the other line\n     * or null if there are no intersection points\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.toSubSpace#180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector1D(getAbscissa((Vector3D) point));\n    }\n",
        "begin_line": 128,
        "end_line": 130,
        "comment": " {@inheritDoc}\n     * @see #getAbscissa(Vector3D)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null
        },
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sin#2227",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
        "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToRawLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2227,
        "end_line": 2286,
        "comment": "\n     * Sine function.\n     *\n     * @param x Argument.\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cos#2294",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
        "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2294,
        "end_line": 2340,
        "comment": "\n     * Cosine function.\n     *\n     * @param x Argument.\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getExponent#3683",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.getExponent(double)",
        "snippet": "    public static int getExponent(final double d) {\n        // NaN and Infinite will return 1024 anywho so can use raw bits\n        return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n    }\n",
        "begin_line": 3683,
        "end_line": 3686,
        "comment": "\n     * Return the exponent of a double number, removing the bias.\n     * <p>\n     * For double numbers of the form 2<sup>x</sup>, the unbiased\n     * exponent is exactly x.\n     * </p>\n     * @param d number from which exponent is requested\n     * @return exponent for d in IEEE754 representation, without bias\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.Line#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.revert()",
        "snippet": "    public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n        return reverted;\n    }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": " Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.reset#128",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }\n",
        "begin_line": 73,
        "end_line": 81,
        "comment": " Reset the instance as if built from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polySine#1678",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
        "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }\n",
        "begin_line": 1678,
        "end_line": 1691,
        "comment": "\n     *  Computes sin(x) - x, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return sin(x) - x\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polyCosine#1699",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
        "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n",
        "begin_line": 1699,
        "end_line": 1709,
        "comment": "\n     *  Computes cos(x) - 1, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return cos(x) - 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sinQ#1718",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
        "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n",
        "begin_line": 1718,
        "end_line": 1833,
        "comment": "\n     *  Compute sine over the first quadrant (0 < x < pi/2).\n     *  Use combination of table lookup and rational polynomial expansion.\n     *  @param xa number from which sine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return sin(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cosQ#1842",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
        "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n",
        "begin_line": 1842,
        "end_line": 1851,
        "comment": "\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n     *  @param xa number from which cosine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return cos(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.getRemainingRegion#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion()",
        "snippet": "    public Region<T> getRemainingRegion() {\n        return remainingRegion;\n    }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": " Get the remaining region of the hyperplane.\n     * <p>The returned region is expressed in the canonical hyperplane\n     * frame and has the hyperplane dimension. For example a chopped\n     * hyperplane in the 3D euclidean is a 2D plane and the\n     * corresponding region is a convex 2D polygon.</p>\n     * @return remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.Vector2D#68",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, double)",
        "snippet": "    public Vector2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n",
        "begin_line": 68,
        "end_line": 71,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @see #getX()\n     * @see #getY()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.getX#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector2D(double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.getY#157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getY()",
        "snippet": "    public double getY() {\n        return y;\n    }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": " Get the ordinate of the vector.\n     * @return ordinate of the vector\n     * @see #Vector2D(double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3024",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n    }\n",
        "begin_line": 3024,
        "end_line": 3026,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1104
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#384",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 384,
        "end_line": 386,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1043
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.getHyperplane#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getHyperplane()",
        "snippet": "    public Hyperplane<S> getHyperplane() {\n        return hyperplane;\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": " Get the underlying hyperplane.\n     * @return underlying hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.101
        },
        "num_failing_tests": 1
    }
]