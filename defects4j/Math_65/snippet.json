[
    {
        "name": "AbstractLeastSquaresOptimizer.getChiSquare#254",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.getChiSquare()",
        "snippet": "    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += residual * residual / residualsWeights[i];\n        }\n        return chiSquare;\n    }\n",
        "begin_line": 254,
        "end_line": 261,
        "comment": "\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.getCovariances#271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.getCovariances()",
        "snippet": "    public double[][] getCovariances()\n        throws FunctionEvaluationException, OptimizationException {\n\n        // set up the jacobian\n        updateJacobian();\n\n        // compute transpose(J).J, avoiding building big intermediate matrices\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            // compute the covariances matrix\n            RealMatrix inverse =\n                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (InvalidMatrixException ime) {\n            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n\n    }\n",
        "begin_line": 271,
        "end_line": 299,
        "comment": "\n     * Get the covariance matrix of optimized parameters.\n     * @return covariance matrix\n     * @exception FunctionEvaluationException if the function jacobian cannot\n     * be evaluated\n     * @exception OptimizationException if the covariance matrix\n     * cannot be computed (singular problem)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.guessParametersErrors#310",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.guessParametersErrors()",
        "snippet": "    public double[] guessParametersErrors()\n        throws FunctionEvaluationException, OptimizationException {\n        if (rows <= cols) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                    rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n",
        "begin_line": 310,
        "end_line": 324,
        "comment": "\n     * Guess the errors in optimized parameters.\n     * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n     * @return errors in optimized parameters\n     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n     * @exception OptimizationException if the covariances matrix cannot be computed\n     * or the number of degrees of freedom is not positive (number of measurements\n     * lesser or equal to number of parameters)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.solve#358",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.Solver.solve(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "        public RealMatrix solve(RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = pivot.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            final int nColB = b.getColumnDimension();\n\n            // Apply permutations to b\n            final double[][] bp = new double[m][nColB];\n            for (int row = 0; row < m; row++) {\n                final double[] bpRow = bp[row];\n                final int pRow = pivot[row];\n                for (int col = 0; col < nColB; col++) {\n                    bpRow[col] = b.getEntry(pRow, col);\n                }\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final double[] bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    final double[] bpI = bp[i];\n                    final double luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] -= bpCol[j] * luICol;\n                    }\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                final double[] bpCol = bp[col];\n                final double luDiag = lu[col][col];\n                for (int j = 0; j < nColB; j++) {\n                    bpCol[j] /= luDiag;\n                }\n                for (int i = 0; i < col; i++) {\n                    final double[] bpI = bp[i];\n                    final double luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] -= bpCol[j] * luICol;\n                    }\n                }\n            }\n\n            return new Array2DRowRealMatrix(bp, false);\n\n        }\n",
        "begin_line": 358,
        "end_line": 413,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.DecompositionSolver": " Solve the linear equation A &times; X = B for matrices A.\n     * <p>The A matrix is implicit, it is provided by the underlying\n     * decomposition algorithm.</p>\n     * @param b right-hand side of the equation A &times; X = B\n     * @return a matrix X that minimizes the two norm of A &times; X - B\n     * @exception IllegalArgumentException if matrices dimensions don't match\n     * @exception InvalidMatrixException if decomposed matrix is singular\n     ",
            "org.apache.commons.math.linear.LUDecomposition": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 114,
        "end_line": 140,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the <code>copyArray</code> may be\n     * set to <code>false</code. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.</p>\n     * @param d data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getEntry#351",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 351,
        "end_line": 360,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be fetched\n     * @param column  column location of entry to be fetched\n     * @return matrix entry in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(int, int)",
        "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "\n     * Returns a {@link RealMatrix} with specified dimensions.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The matrix elements are all set to 0.0.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @return  RealMatrix with specified dimensions\n     * @see #createRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#106",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if either <code>data</code> or\n     * <code>data[0]</code> is null\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealIdentityMatrix#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(int)",
        "snippet": "    public static RealMatrix createRealIdentityMatrix(int dimension) {\n        final RealMatrix m = createRealMatrix(dimension, dimension);\n        for (int i = 0; i < dimension; ++i) {\n            m.setEntry(i, i, 1.0);\n        }\n        return m;\n    }\n",
        "begin_line": 142,
        "end_line": 148,
        "comment": "\n     * Returns <code>dimension x dimension</code> identity matrix.\n     *\n     * @param dimension dimension of identity matrix to generate\n     * @return identity matrix\n     * @throws IllegalArgumentException if dimension is not positive\n     * @since 1.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.getInverse#416",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.Solver.getInverse()",
        "snippet": "        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n        }\n",
        "begin_line": 416,
        "end_line": 418,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.DecompositionSolver": " Get the inverse (or pseudo-inverse) of the decomposed matrix.\n     * @return inverse matrix\n     * @throws InvalidMatrixException if decomposed matrix is singular\n     ",
            "org.apache.commons.math.linear.LUDecomposition": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
        "snippet": "    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }\n",
        "begin_line": 75,
        "end_line": 79,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws IllegalArgumentException, NullPointerException {\n        copyIn(d);\n    }\n",
        "begin_line": 94,
        "end_line": 97,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n     * with the second argument set to <code>true</code>.</p>\n     *\n     * @param d data for new matrix\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowRealMatrix(double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getData#296",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }\n",
        "begin_line": 296,
        "end_line": 299,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return    2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setSubMatrix#313",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
        "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n    throws MatrixIndexException {\n        if (data == null) {\n            if (row > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }\n",
        "begin_line": 313,
        "end_line": 348,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n    * Replace the submatrix starting at <code>row, column</code> using data in\n    * the input <code>subMatrix</code> array. Indexes are 0-based.\n    * <p>\n    * Example:<br>\n    * Starting with <pre>\n    * 1  2  3  4\n    * 5  6  7  8\n    * 9  0  1  2\n    * </pre>\n    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n    * 1  2  3  4\n    * 5  3  4  8\n    * 9  5  6  2\n    * </pre></p>\n    *\n    * @param subMatrix  array containing the submatrix replacement data\n    * @param row  row coordinate of the top, left element to be replaced\n    * @param column  column coordinate of the top, left element to be replaced\n    * @throws MatrixIndexException  if subMatrix does not fit into this\n    *    matrix from element in (row, column)\n    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n    *  (not all rows have the same length) or empty\n    * @throws NullPointerException if <code>subMatrix</code> is null\n    * @since 2.0\n    "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setEntry#363",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            data[row][column] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 363,
        "end_line": 372,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Set the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be set\n     * @param column  column location of entry to be set\n     * @param value matrix entry to be set in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#399",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 399,
        "end_line": 402,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#405",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 405,
        "end_line": 408,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyOut#596",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyOut()",
        "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n",
        "begin_line": 596,
        "end_line": 604,
        "comment": "\n     * Returns a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyIn#616",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
        "snippet": "    private void copyIn(final double[][] in) {\n        setSubMatrix(in, 0, 0);\n    }\n",
        "begin_line": 616,
        "end_line": 618,
        "comment": "\n     * Replaces data with a fresh copy of the input array.\n     * <p>\n     * Verifies that the input array is rectangular and non-empty.</p>\n     *\n     * @param in data to copy in\n     * @throws IllegalArgumentException if input array is empty or not\n     *    rectangular\n     * @throws NullPointerException if input array is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.getEvaluations#148",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n",
        "begin_line": 148,
        "end_line": 150,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Get the number of evaluations of the objective function.\n     * <p>\n     * The number of evaluation correspond to the last call to the\n     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n     * double[], double[], double[]) optimize} method. It is 0 if\n     * the method has not been called yet.\n     * </p>\n     * @return number of evaluations of the objective function\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.getJacobianEvaluations#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.getJacobianEvaluations()",
        "snippet": "    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n",
        "begin_line": 153,
        "end_line": 155,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Get the number of evaluations of the objective function jacobian .\n     * <p>\n     * The number of evaluation correspond to the last call to the\n     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n     * double[], double[], double[]) optimize} method. It is 0 if\n     * the method has not been called yet.\n     * </p>\n     * @return number of evaluations of the objective function jacobian\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.LUDecompositionImpl#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.LUDecompositionImpl(org.apache.commons.math.linear.RealMatrix, double)",
        "snippet": "    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n        throws NonSquareMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            double sum = 0;\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int max = col; // permutation row\n            double largest = Double.NEGATIVE_INFINITY;\n            for (int row = col; row < m; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                // maintain best permutation choice\n                if (Math.abs(sum) > largest) {\n                    largest = Math.abs(sum);\n                    max = row;\n                }\n            }\n\n            // Singularity check\n            if (Math.abs(lu[max][col]) < singularityThreshold) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (max != col) {\n                double tmp = 0;\n                final double[] luMax = lu[max];\n                final double[] luCol = lu[col];\n                for (int i = 0; i < m; i++) {\n                    tmp = luMax[i];\n                    luMax[i] = luCol[i];\n                    luCol[i] = tmp;\n                }\n                int temp = pivot[max];\n                pivot[max] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n\n    }\n",
        "begin_line": 78,
        "end_line": 161,
        "comment": "\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @param singularityThreshold threshold (based on partial row norm)\n     * under which a matrix is considered singular\n     * @exception NonSquareMatrixException if matrix is not square\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.Solver#248",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.Solver.Solver(double[][], int[], boolean)",
        "snippet": "        private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\n            this.lu       = lu;\n            this.pivot    = pivot;\n            this.singular = singular;\n        }\n",
        "begin_line": 248,
        "end_line": 252,
        "comment": "\n         * Build a solver from decomposed matrix.\n         * @param lu entries of LU decomposition\n         * @param pivot pivot permutation associated with LU decomposition\n         * @param singular singularity indicator\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.LUDecompositionImpl#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.LUDecompositionImpl(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    public LUDecompositionImpl(RealMatrix matrix)\n        throws InvalidMatrixException {\n        this(matrix, DEFAULT_TOO_SMALL);\n    }\n",
        "begin_line": 66,
        "end_line": 69,
        "comment": "\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @exception InvalidMatrixException if matrix is not square\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecompositionImpl.getSolver#226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.LUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.LUDecompositionImpl.getSolver()",
        "snippet": "    public DecompositionSolver getSolver() {\n        return new Solver(lu, pivot, singular);\n    }\n",
        "begin_line": 226,
        "end_line": 228,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.DecompositionSolver": null,
            "org.apache.commons.math.linear.LUDecomposition": "\n     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n     * @return a solver\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.isSquare#637",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }\n",
        "begin_line": 637,
        "end_line": 639,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension < 1 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n        }\n        lu = null;\n    }\n",
        "begin_line": 55,
        "end_line": 66,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.doOptimize#240",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            // compute Qt.res\n            qTy(residuals);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // convergence has been reached\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at x + p and calculate its norm\n                updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n                } else {\n                    // failed iteration, reset the previous values\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n\n                // tests for convergence.\n                if (checker != null) {\n                    // we use the vectorial convergence checker\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                } else {\n                    // we use the Levenberg-Marquardt specific convergence parameters\n                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n",
        "begin_line": 240,
        "end_line": 469,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer": " Perform the bulk of optimization algorithm.\n     * @return the point/value pair giving the optimal value for objective function\n     * @exception FunctionEvaluationException if the objective function throws one during\n     * the search\n     * @exception OptimizationException if the algorithm failed to converge\n     * @exception IllegalArgumentException if the start point dimension is wrong\n     "
        },
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.getRMS#239",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.getRMS()",
        "snippet": "    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += residual * residual * residualsWeights[i];\n        }\n        return Math.sqrt(criterion / rows);\n    }\n",
        "begin_line": 239,
        "end_line": 246,
        "comment": "\n     * Get the Root Mean Square value.\n     * Get the Root Mean Square value, i.e. the root of the arithmetic\n     * mean of the square of all weighted residuals. This is related to the\n     * criterion that is minimized by the optimizer as follows: if\n     * <em>c</em> if the criterion, and <em>n</em> is the number of\n     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return RMS value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.qrDecomposition#788",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.qrDecomposition()",
        "snippet": "    private void qrDecomposition() throws OptimizationException {\n\n        // initializations\n        for (int k = 0; k < cols; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < jacobian.length; ++i) {\n                double akk = jacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = Math.sqrt(norm2);\n        }\n\n        // transform the matrix column after column\n        for (int k = 0; k < cols; ++k) {\n\n            // select the column with the greatest norm on active components\n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < cols; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    double aki = jacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                            rows, cols);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 <= qrRankingThreshold) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            // choose alpha such that Hk.u = alpha ek\n            double akk   = jacobian[k][pk];\n            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            // transform the current column\n            diagR[pk]        = alpha;\n            jacobian[k][pk] -= alpha;\n\n            // transform the remaining columns\n            for (int dk = cols - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < jacobian.length; ++j) {\n                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n                }\n            }\n\n        }\n\n        rank = solvedCols;\n\n    }\n",
        "begin_line": 788,
        "end_line": 856,
        "comment": "\n     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n     * <p>As suggested in the P. Lascaux and R. Theodor book\n     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n     * </pre>\n     * we use <sub>k</sub> non-unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n     * </pre>\n     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n     * them from the v<sub>k</sub> vectors would be costly.</p>\n     * <p>This decomposition handles rank deficient cases since the tranformations\n     * are performed in non-increasing columns norms order thanks to columns\n     * pivoting. The diagonal elements of the R matrix are therefore also in\n     * non-increasing absolute values order.</p>\n     * @exception OptimizationException if the decomposition cannot be performed\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 1
    },
    {
        "name": "VectorialPointValuePair.getPointRef#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java",
        "class_name": "org.apache.commons.math.optimization.VectorialPointValuePair",
        "signature": "org.apache.commons.math.optimization.VectorialPointValuePair.getPointRef()",
        "snippet": "    public double[] getPointRef() {\n        return point;\n    }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": " Get a reference to the point.\n     * <p>This method is provided as a convenience to avoid copying\n     * the array, the elements of the array should <em>not</em> be modified.</p>\n     * @return a reference to the internal array storing the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.determineLMParameter#493",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.determineLMParameter(double[], double, double[], double[], double[], double[])",
        "snippet": "    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = Math.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += jacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += jacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = Math.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / Math.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = Math.min(paru, Math.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = Math.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = Math.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = Math.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = Math.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = Math.max(parl, lmPar + correction);\n\n        }\n    }\n",
        "begin_line": 493,
        "end_line": 640,
        "comment": "\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.qTy#863",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.qTy(double[])",
        "snippet": "    private void qTy(double[] y) {\n        for (int k = 0; k < cols; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < rows; ++i) {\n                gamma += jacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < rows; ++i) {\n                y[i] -= gamma * jacobian[i][pk];\n            }\n        }\n    }\n",
        "begin_line": 863,
        "end_line": 875,
        "comment": "\n     * Compute the product Qt.y for some Q.R. decomposition.\n     *\n     * @param y vector to multiply (will be overwritten with the result)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer#166",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer()",
        "snippet": "    public LevenbergMarquardtOptimizer() {\n\n        // set up the superclass with a default  max cost evaluations setting\n        setMaxIterations(1000);\n\n        // default values for the tuning parameters\n        setConvergenceChecker(null);\n        setInitialStepBoundFactor(100.0);\n        setCostRelativeTolerance(1.0e-10);\n        setParRelativeTolerance(1.0e-10);\n        setOrthoTolerance(1.0e-10);\n        setQRRankingThreshold(MathUtils.SAFE_MIN);\n\n    }\n",
        "begin_line": 166,
        "end_line": 179,
        "comment": "\n     * Build an optimizer for least squares problems.\n     * <p>The default values for the algorithm settings are:\n     *   <ul>\n     *    <li>{@link #setConvergenceChecker(VectorialConvergenceChecker) vectorial convergence checker}: null</li>\n     *    <li>{@link #setInitialStepBoundFactor(double) initial step bound factor}: 100.0</li>\n     *    <li>{@link #setMaxIterations(int) maximal iterations}: 1000</li>\n     *    <li>{@link #setCostRelativeTolerance(double) cost relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setParRelativeTolerance(double) parameters relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setOrthoTolerance(double) orthogonality tolerance}: 1.0e-10</li>\n     *    <li>{@link #setQRRankingThreshold(double) QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n     *   </ul>\n     * </p>\n     * <p>These default values may be overridden after construction. If the {@link\n     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.setInitialStepBoundFactor#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.setInitialStepBoundFactor(double)",
        "snippet": "    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n        this.initialStepBoundFactor = initialStepBoundFactor;\n    }\n",
        "begin_line": 190,
        "end_line": 192,
        "comment": "\n     * Set the positive input variable used in determining the initial step bound.\n     * This bound is set to the product of initialStepBoundFactor and the euclidean\n     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n     * recommended value.\n     *\n     * @param initialStepBoundFactor initial step bound factor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.setCostRelativeTolerance#200",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.setCostRelativeTolerance(double)",
        "snippet": "    public void setCostRelativeTolerance(double costRelativeTolerance) {\n        this.costRelativeTolerance = costRelativeTolerance;\n    }\n",
        "begin_line": 200,
        "end_line": 202,
        "comment": "\n     * Set the desired relative error in the sum of squares.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param costRelativeTolerance desired relative error in the sum of squares\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.setParRelativeTolerance#211",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.setParRelativeTolerance(double)",
        "snippet": "    public void setParRelativeTolerance(double parRelativeTolerance) {\n        this.parRelativeTolerance = parRelativeTolerance;\n    }\n",
        "begin_line": 211,
        "end_line": 213,
        "comment": "\n     * Set the desired relative error in the approximate solution parameters.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param parRelativeTolerance desired relative error\n     * in the approximate solution parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.setOrthoTolerance#222",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.setOrthoTolerance(double)",
        "snippet": "    public void setOrthoTolerance(double orthoTolerance) {\n        this.orthoTolerance = orthoTolerance;\n    }\n",
        "begin_line": 222,
        "end_line": 224,
        "comment": "\n     * Set the desired max cosine on the orthogonality.\n     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n     * vectorial convergence checker} being null or non-null.</p>\n     * @param orthoTolerance desired max cosine on the orthogonality\n     * between the function vector and the columns of the jacobian\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.setQRRankingThreshold#235",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.setQRRankingThreshold(double)",
        "snippet": "    public void setQRRankingThreshold(final double threshold) {\n        this.qrRankingThreshold = threshold;\n    }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "\n     * Set the desired threshold for QR ranking.\n     * <p>\n     * If the squared norm of a column vector is smaller or equal to this threshold\n     * during QR decomposition, it is considered to be a zero vector and hence the\n     * rank of the matrix is reduced.\n     * </p>\n     * @param threshold threshold for QR ranking\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.updateJacobian#183",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateJacobian()",
        "snippet": "    protected void updateJacobian() throws FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n",
        "begin_line": 183,
        "end_line": 197,
        "comment": "\n     * Update the jacobian matrix.\n     * @exception FunctionEvaluationException if the function jacobian\n     * cannot be evaluated or its dimension doesn't match problem dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1187
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.updateResidualsAndCost#205",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateResidualsAndCost()",
        "snippet": "    protected void updateResidualsAndCost()\n        throws FunctionEvaluationException {\n\n        if (++objectiveEvaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += residualsWeights[i] * residual * residual;\n            index += cols;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n",
        "begin_line": 205,
        "end_line": 227,
        "comment": "\n     * Update the residuals array and cost function value.\n     * @exception FunctionEvaluationException if the function cannot be evaluated\n     * or its dimension doesn't match problem dimension or maximal number of\n     * of evaluations is exceeded\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1187
        },
        "num_failing_tests": 1
    },
    {
        "name": "VectorialPointValuePair.VectorialPointValuePair#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java",
        "class_name": "org.apache.commons.math.optimization.VectorialPointValuePair",
        "signature": "org.apache.commons.math.optimization.VectorialPointValuePair.VectorialPointValuePair(double[], double[])",
        "snippet": "    public VectorialPointValuePair(final double[] point, final double[] value) {\n        this.point = (point == null) ? null : point.clone();\n        this.value = (value == null) ? null : value.clone();\n    }\n",
        "begin_line": 46,
        "end_line": 49,
        "comment": " Build a point/objective function value pair.\n     * @param point point coordinates (the built instance will store\n     * a copy of the array, not the array passed as argument)\n     * @param value value of an objective function at the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1187
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.incrementIterationsCounter#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.incrementIterationsCounter()",
        "snippet": "    protected void incrementIterationsCounter()\n        throws OptimizationException {\n        if (++iterations > maxIterations) {\n            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n        }\n    }\n",
        "begin_line": 171,
        "end_line": 176,
        "comment": " Increment the iterations counter by 1.\n     * @exception OptimizationException if the maximal number\n     * of iterations is exceeded\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.optimize#327",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction, double[], double[], double[])",
        "snippet": "    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                            final double[] target, final double[] weights,\n                                            final double[] startPoint)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        if (target.length != weights.length) {\n            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                            target.length, weights.length);\n        }\n\n        // reset counters\n        iterations           = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations  = 0;\n\n        // store least squares problem characteristics\n        function         = f;\n        jF               = f.jacobian();\n        targetValues     = target.clone();\n        residualsWeights = weights.clone();\n        this.point       = startPoint.clone();\n        this.residuals   = new double[target.length];\n\n        // arrays shared with the other private methods\n        rows      = target.length;\n        cols      = point.length;\n        jacobian  = new double[rows][cols];\n\n        cost = Double.POSITIVE_INFINITY;\n\n        return doOptimize();\n\n    }\n",
        "begin_line": 327,
        "end_line": 359,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Optimizes an objective function.\n     * <p>\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * &sum;weight<sub>i</sub>(objective<sub>i</sub>-target<sub>i</sub>)<sup>2</sup>\n     * </p>\n     * @param f objective function\n     * @param target target value for the objective functions at optimum\n     * @param weights weight for the least squares cost computation\n     * @param startPoint the start point for optimization\n     * @return the point/value pair giving the optimal value for objective function\n     * @exception FunctionEvaluationException if the objective function throws one during\n     * the search\n     * @exception OptimizationException if the algorithm failed to converge\n     * @exception IllegalArgumentException if the start point dimension is wrong\n     "
        },
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer#116",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer()",
        "snippet": "    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new SimpleVectorialValueChecker());\n        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n",
        "begin_line": 116,
        "end_line": 120,
        "comment": " Simple constructor with default settings.\n     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n     * and the maximal number of evaluation is set to its default value.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.setMaxIterations#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.setMaxIterations(int)",
        "snippet": "    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Set the maximal number of iterations of the algorithm.\n     * @param maxIterations maximal number of function calls\n     * .\n     "
        },
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.setMaxEvaluations#138",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Set the maximal number of functions evaluations.\n    * @param maxEvaluations maximal number of function evaluations\n    "
        },
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.setConvergenceChecker#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker)",
        "snippet": "    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer": " Set the convergence checker.\n     * @param checker object to use to check for convergence\n     "
        },
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    },
    {
        "name": "SimpleVectorialValueChecker.SimpleVectorialValueChecker#50",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java",
        "class_name": "org.apache.commons.math.optimization.SimpleVectorialValueChecker",
        "signature": "org.apache.commons.math.optimization.SimpleVectorialValueChecker.SimpleVectorialValueChecker()",
        "snippet": "    public SimpleVectorialValueChecker() {\n        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n    }\n",
        "begin_line": 50,
        "end_line": 53,
        "comment": " Build an instance with default threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    }
]