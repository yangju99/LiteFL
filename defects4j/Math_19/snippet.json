[
    {
        "name": "FastMath.nextUp#766",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.nextUp(double)",
        "snippet": "    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }\n",
        "begin_line": 766,
        "end_line": 768,
        "comment": " Compute next number towards positive infinity.\n     * @param a number to which neighbor should be computed\n     * @return neighbor of a towards positive infinity\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.nextAfter#3218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.nextAfter(double, double)",
        "snippet": "    public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n\n    }\n",
        "begin_line": 3218,
        "end_line": 3241,
        "comment": "\n     * Get the next machine representable number after a number, moving\n     * in the direction of another number.\n     * <p>\n     * The ordering is as follows (increasing):\n     * <ul>\n     * <li>-INFINITY</li>\n     * <li>-MAX_VALUE</li>\n     * <li>-MIN_VALUE</li>\n     * <li>-0.0</li>\n     * <li>+0.0</li>\n     * <li>+MIN_VALUE</li>\n     * <li>+MAX_VALUE</li>\n     * <li>+INFINITY</li>\n     * <li></li>\n     * <p>\n     * If arguments compare equal, then the second argument is returned.\n     * <p>\n     * If {@code direction} is greater than {@code d},\n     * the smallest machine representable number strictly greater than\n     * {@code d} is returned; if less, then the largest representable number\n     * strictly less than {@code d} is returned.</p>\n     * <p>\n     * If {@code d} is infinite and direction does not\n     * bring it back to finite numbers, it is returned unchanged.</p>\n     *\n     * @param d base number\n     * @param direction (the only important thing is whether\n     * {@code direction} is greater or smaller than {@code d})\n     * @return the next machine representable number in the specified direction\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "LocalizedFormats.getLocalizedString#378",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java",
        "class_name": "org.apache.commons.math3.exception.util.LocalizedFormats",
        "signature": "org.apache.commons.math3.exception.util.LocalizedFormats.getLocalizedString(java.util.Locale)",
        "snippet": "    public String getLocalizedString(final Locale locale) {\n        try {\n            final String path = LocalizedFormats.class.getName().replaceAll(\"\\\\.\", \"/\");\n            ResourceBundle bundle =\n                    ResourceBundle.getBundle(\"assets/\" + path, locale);\n            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n                // the value of the resource is the translated format\n                return bundle.getString(toString());\n            }\n\n        } catch (MissingResourceException mre) {\n            // do nothing here\n        }\n\n        // either the locale is not supported or the resource is unknown\n        // don't translate and fall back to using the source format\n        return sourceFormat;\n\n    }\n",
        "begin_line": 378,
        "end_line": 396,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExceptionContext.getLocalizedMessage#136",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java",
        "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
        "signature": "org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage()",
        "snippet": "    public String getLocalizedMessage() {\n        return getMessage(Locale.getDefault());\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "\n     * Gets the message in the default locale.\n     *\n     * @return the localized message.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExceptionContext.getMessage#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java",
        "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
        "signature": "org.apache.commons.math3.exception.util.ExceptionContext.getMessage(java.util.Locale)",
        "snippet": "    public String getMessage(final Locale locale) {\n        return buildMessage(locale, \": \");\n    }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": "\n     * Gets the message in a specified locale.\n     *\n     * @param locale Locale in which the message should be translated.\n     * @return the localized message.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExceptionContext.buildMessage#169",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java",
        "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
        "signature": "org.apache.commons.math3.exception.util.ExceptionContext.buildMessage(java.util.Locale, java.lang.String)",
        "snippet": "    private String buildMessage(Locale locale,\n                                String separator) {\n        final StringBuilder sb = new StringBuilder();\n        int count = 0;\n        final int len = msgPatterns.size();\n        for (int i = 0; i < len; i++) {\n            final Localizable pat = msgPatterns.get(i);\n            final Object[] args = msgArguments.get(i);\n            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                        locale);\n            sb.append(fmt.format(args));\n            if (++count < len) {\n                // Add a separator if there are other messages.\n                sb.append(separator);\n            }\n        }\n\n        return sb.toString();\n    }\n",
        "begin_line": 169,
        "end_line": 187,
        "comment": "\n     * Builds a message string.\n     *\n     * @param locale Locale in which the message should be translated.\n     * @param separator Message separator.\n     * @return a localized message string.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException(org.apache.commons.math3.exception.util.Localizable, java.lang.Object...)",
        "snippet": "    public MathIllegalStateException(Localizable pattern,\n                                     Object ... args) {\n        context = new ExceptionContext(this);\n        context.addMessage(pattern, args);\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Simple constructor.\n     *\n     * @param pattern Message pattern explaining the cause of the error.\n     * @param args Arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#68",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException()",
        "snippet": "    public MathIllegalStateException() {\n        this(LocalizedFormats.ILLEGAL_STATE);\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.getLocalizedMessage#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.getLocalizedMessage()",
        "snippet": "    @Override\n    public String getLocalizedMessage() {\n        return context.getLocalizedMessage();\n    }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.exception.util.ExceptionContextProvider": null,
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()",
        "snippet": "    public CMAESOptimizer() {\n        this(0);\n    }\n",
        "begin_line": 245,
        "end_line": 247,
        "comment": "\n     * Default constructor, uses default parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#252",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)",
        "snippet": "    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n",
        "begin_line": 252,
        "end_line": 256,
        "comment": "\n     * @param lambda Population size.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.initializeCMA#568",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.initializeCMA(double[])",
        "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        // initialize sigma\n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; // minor increment\n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective\n                                                           // variables\n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }\n",
        "begin_line": 568,
        "end_line": 635,
        "comment": "\n     * Initialization of the dynamic search parameters\n     *\n     * @param guess Initial guess for the arguments of the fitness function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.encode#912",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.encode(double[])",
        "snippet": "        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n            }\n            return res;\n        }\n",
        "begin_line": 912,
        "end_line": 922,
        "comment": "\n         * @param x Original objective variables.\n         * @return the normalized objective variables.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.decode#938",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.decode(double[])",
        "snippet": "        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n            }\n            return res;\n        }\n",
        "begin_line": 938,
        "end_line": 948,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the original objective variables.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.value#954",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.value(double[])",
        "snippet": "        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }\n",
        "begin_line": 954,
        "end_line": 966,
        "comment": "\n         * @param point Normalized objective variables.\n         * @return the objective value + penalty for violated bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.repair#998",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.repair(double[])",
        "snippet": "        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }\n",
        "begin_line": 998,
        "end_line": 1010,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the repaired objective variables - all in bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.checkParameters#504",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n",
        "begin_line": 504,
        "end_line": 561,
        "comment": "\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.optimize#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int, FUNC, org.apache.commons.math3.optimization.GoalType, double[], double[], double[])",
        "snippet": "    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                       double[] startPoint,\n                                       double[] lower, double[] upper) {\n        // Checks.\n        final int dim = startPoint.length;\n        if (lower != null) {\n            if (lower.length != dim) {\n                throw new DimensionMismatchException(lower.length, dim);\n            }\n            for (int i = 0; i < dim; i++) {\n                final double v = startPoint[i];\n                final double lo = lower[i];\n                if (v < lo) {\n                    throw new NumberIsTooSmallException(v, lo, true);\n                }\n            }\n        }\n        if (upper != null) {\n            if (upper.length != dim) {\n                throw new DimensionMismatchException(upper.length, dim);\n            }\n            for (int i = 0; i < dim; i++) {\n                final double v = startPoint[i];\n                final double hi = upper[i];\n                if (v > hi) {\n                    throw new NumberIsTooLargeException(v, hi, true);\n                }\n            }\n        }\n\n        // Initialization.\n        if (lower == null) {\n            lowerBound = new double[dim];\n            for (int i = 0; i < dim; i++) {\n                lowerBound[i] = Double.NEGATIVE_INFINITY;\n            }\n        } else {\n            lowerBound = lower.clone();\n        }\n        if (upper == null) {\n            upperBound = new double[dim];\n            for (int i = 0; i < dim; i++) {\n                upperBound[i] = Double.POSITIVE_INFINITY;\n            }\n        } else {\n            upperBound = upper.clone();\n        }\n\n        // Base class method performs the non bound-specific initializations.\n        return super.optimize(maxEval, f, goalType, startPoint);\n    }\n",
        "begin_line": 91,
        "end_line": 141,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @param lowerBound Lower bound for each of the parameters.\n     * @param upperBound Upper bound for each of the parameters.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the array sizes are wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n     * @throws org.apache.commons.math3.exception.NumberIsTooSmallException if any\n     * of the initial values is less than its lower bound.\n     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException if any\n     * of the initial values is greater than its upper bound.\n     ",
            "org.apache.commons.math3.optimization.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "LocalizedFormats.LocalizedFormats#368",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java",
        "class_name": "org.apache.commons.math3.exception.util.LocalizedFormats",
        "signature": "org.apache.commons.math3.exception.util.LocalizedFormats.LocalizedFormats(java.lang.String)",
        "snippet": "    private LocalizedFormats(final String sourceFormat) {\n        this.sourceFormat = sourceFormat;\n    }\n",
        "begin_line": 368,
        "end_line": 370,
        "comment": " Simple constructor.\n     * @param sourceFormat source English format to use when no\n     * localized version is available\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExceptionContext.ExceptionContext#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java",
        "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
        "signature": "org.apache.commons.math3.exception.util.ExceptionContext.ExceptionContext(java.lang.Throwable)",
        "snippet": "    public ExceptionContext(final Throwable throwable) {\n        this.throwable = throwable;\n        msgPatterns    = new ArrayList<Localizable>();\n        msgArguments   = new ArrayList<Object[]>();\n        context        = new HashMap<String, Object>();\n    }\n",
        "begin_line": 64,
        "end_line": 69,
        "comment": " Simple constructor.\n     * @param throwable the exception this context refers too\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExceptionContext.addMessage#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ExceptionContext.java",
        "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
        "signature": "org.apache.commons.math3.exception.util.ExceptionContext.addMessage(org.apache.commons.math3.exception.util.Localizable, java.lang.Object...)",
        "snippet": "    public void addMessage(Localizable pattern,\n                           Object ... arguments) {\n        msgPatterns.add(pattern);\n        msgArguments.add(ArgUtils.flatten(arguments));\n    }\n",
        "begin_line": 85,
        "end_line": 89,
        "comment": "\n     * Adds a message.\n     *\n     * @param pattern Message pattern.\n     * @param arguments Values for replacing the placeholders in the message\n     * pattern.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArgUtils.flatten#41",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/util/ArgUtils.java",
        "class_name": "org.apache.commons.math3.exception.util.ArgUtils",
        "signature": "org.apache.commons.math3.exception.util.ArgUtils.flatten(java.lang.Object[])",
        "snippet": "    public static Object[] flatten(Object[] array) {\n        final List<Object> list = new ArrayList<Object>();\n        if (array != null) {\n            for (Object o : array) {\n                if (o instanceof Object[]) {\n                    for (Object oR : flatten((Object[]) o)) {\n                        list.add(oR);\n                    }\n                } else {\n                    list.add(o);\n                }\n            }\n        }\n        return list.toArray();\n    }\n",
        "begin_line": 41,
        "end_line": 55,
        "comment": "\n     * Transform a multidimensional array into a one-dimensional list.\n     *\n     * @param array Array (possibly multidimensional).\n     * @return a list of all the {@code Object} instances contained in\n     * {@code array}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getMaximalCount#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
        "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Gets the upper limit of the counter.\n     *\n     * @return the counter upper limit.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 154,
        "end_line": 158,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.FitnessFunction#903",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.FitnessFunction()",
        "snippet": "        public FitnessFunction() {\n            valueRange = 1.0;\n            isRepairMode = true;\n        }\n",
        "begin_line": 903,
        "end_line": 906,
        "comment": " Simple constructor.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.doOptimize#354",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }\n",
        "begin_line": 354,
        "end_line": 499,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.MultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer": "\n     * Perform the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value for the\n     * objective function.\n     ",
            "org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.log#1033",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.log(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1033,
        "end_line": 1041,
        "comment": "\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.square#1062",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.square(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1062,
        "end_line": 1071,
        "comment": "\n     * @param m Input matrix\n     * @return Matrix representing the element-wise square (^2) of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.times#1078",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.times(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1078,
        "end_line": 1086,
        "comment": "\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.diag#1154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.diag(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n",
        "begin_line": 1154,
        "end_line": 1168,
        "comment": "\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.ones#1189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.ones(int, int)",
        "snippet": "    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1189,
        "end_line": 1195,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix filled with 1.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.eye#1202",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.eye(int, int)",
        "snippet": "    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1202,
        "end_line": 1210,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0.0-values, diagonal has values 1.0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.zeros#1217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.zeros(int, int)",
        "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n",
        "begin_line": 1217,
        "end_line": 1219,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0.0-values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.repmat#1227",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.repmat(org.apache.commons.math3.linear.RealMatrix, int, int)",
        "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1227,
        "end_line": 1237,
        "comment": "\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.sequence#1245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sequence(double, double, double)",
        "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1245,
        "end_line": 1254,
        "comment": "\n     * @param start Start value.\n     * @param end End value.\n     * @param step Step size.\n     * @return a sequence as column matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.max#1260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }\n",
        "begin_line": 1260,
        "end_line": 1271,
        "comment": "\n     * @param m Input matrix.\n     * @return the maximum of the matrix element values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getMaxEvaluations#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getMaxEvaluations()",
        "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": "\n     * Get the maximal number of function evaluations.\n     *\n     * @return the maximal number of function evaluations.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.computeObjectiveValue#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.computeObjectiveValue(double[])",
        "snippet": "    protected double computeObjectiveValue(double[] point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }\n",
        "begin_line": 93,
        "end_line": 100,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at the specified point.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getGoalType#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 154,
        "end_line": 156,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound()",
        "snippet": "    public double[] getLowerBound() {\n        return lowerBound.clone();\n    }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * @return the lower bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound()",
        "snippet": "    public double[] getUpperBound() {\n        return upperBound.clone();\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * @return the upper bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.optimize#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(int, FUNC, org.apache.commons.math3.optimization.GoalType, double[])",
        "snippet": "    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                       double[] startPoint) {\n        return optimizeInternal(maxEval, f, goalType, startPoint);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.optimizeInternal#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimizeInternal(int, org.apache.commons.math3.analysis.MultivariateFunction, org.apache.commons.math3.optimization.GoalType, double[])",
        "snippet": "    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f, GoalType goalType,\n                                              double[] startPoint) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n        if (startPoint == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Store optimization problem characteristics.\n        function = f;\n        goal = goalType;\n        start = startPoint.clone();\n\n        // Perform computation.\n        return doOptimize();\n    }\n",
        "begin_line": 125,
        "end_line": 149,
        "comment": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getStartPoint#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getStartPoint()",
        "snippet": "    public double[] getStartPoint() {\n        return start.clone();\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 61,
        "end_line": 69,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int, org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 79,
        "end_line": 86,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     * @throws NullArgumentException if {@code cb} is {@code null}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3463",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
        "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n",
        "begin_line": 3463,
        "end_line": 3465,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.MersenneTwister#106",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
        "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": " Creates a new random number generator.\n     * <p>The instance is initialized using the current time plus the\n     * system identity hash code of this instance as the seed.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
        "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }\n",
        "begin_line": 141,
        "end_line": 155,
        "comment": " Reinitialize the generator as if just built with the given int seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
        "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }\n",
        "begin_line": 164,
        "end_line": 207,
        "comment": " Reinitialize the generator as if just built with the given int array seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integers array), if null\n     * the seed of the generator will be the current system time plus the\n     * system identity hash code of this instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
        "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }\n",
        "begin_line": 214,
        "end_line": 217,
        "comment": " Reinitialize the generator as if just built with the given long seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (64 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.BitsStreamGenerator#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
        "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": " Creates a new random number generator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.clear#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
        "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 164,
        "end_line": 166,
        "comment": "\n     * Clears the cache used by the default implementation of\n     * {@link #nextGaussian}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#283",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int, double[], int, double, boolean, int, int, org.apache.commons.math3.random.RandomGenerator, boolean)",
        "snippet": "    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }\n",
        "begin_line": 283,
        "end_line": 291,
        "comment": "\n     * @param lambda Population size.\n     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n     * @param maxIterations Maximal number of iterations.\n     * @param stopFitness Whether to stop if objective function value is smaller than\n     * {@code stopFitness}.\n     * @param isActiveCMA Chooses the covariance matrix update method.\n     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n     * remains diagonal.\n     * @param checkFeasableCount Determines how often new random objective variables are\n     * generated in case they are out of bounds.\n     * @param random Random generator.\n     * @param generateStatistics Whether statistic data is collected.\n     * @deprecated See {@link SimpleValueChecker#SimpleValueChecker()}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#308",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int, double[], int, double, boolean, int, int, org.apache.commons.math3.random.RandomGenerator, boolean, org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }\n",
        "begin_line": 308,
        "end_line": 323,
        "comment": "\n     * @param lambda Population size.\n     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n     * @param maxIterations Maximal number of iterations.\n     * @param stopFitness Whether to stop if objective function value is smaller than\n     * {@code stopFitness}.\n     * @param isActiveCMA Chooses the covariance matrix update method.\n     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n     * remains diagonal.\n     * @param checkFeasableCount Determines how often new random objective variables are\n     * generated in case they are out of bounds.\n     * @param random Random generator.\n     * @param generateStatistics Whether statistic data is collected.\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer(org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer(org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        this.checker = checker;\n    }\n",
        "begin_line": 66,
        "end_line": 68,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "SimpleValueChecker.SimpleValueChecker#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java",
        "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
        "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.SimpleValueChecker()",
        "snippet": "    @Deprecated\n    public SimpleValueChecker() {}\n",
        "begin_line": 40,
        "end_line": 41,
        "comment": "\n     * Build an instance with default thresholds.\n     * @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractConvergenceChecker.AbstractConvergenceChecker#63",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.AbstractConvergenceChecker()",
        "snippet": "    @Deprecated\n    public AbstractConvergenceChecker() {\n        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n    }\n",
        "begin_line": 63,
        "end_line": 67,
        "comment": "\n     * Build an instance with default thresholds.\n     * @deprecated in 3.1 (to be removed in 4.0). Convergence thresholds are\n     * problem-dependent. As this class is intended for users who want to set\n     * their own convergence criterion instead of relying on an algorithm's\n     * default procedure, they should also set the thresholds appropriately\n     * (cf. MATH-798).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    }
]