[
    {
        "name": "EigenDecompositionImpl.computeShiftIncrement#1430",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(int, int, int)",
        "snippet": "    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }\n",
        "begin_line": 1430,
        "end_line": 1672,
        "comment": "\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math.linear.ArrayRealVector",
        "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[])",
        "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n",
        "begin_line": 77,
        "end_line": 79,
        "comment": "\n     * Construct a vector from an array, copying the input array.\n     * @param d array of doubles.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.goodStep#990",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.goodStep(int, int)",
        "snippet": "    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        // step 1: accepting realEigenvalues\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                // the array has been completely deflated\n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                // one eigenvalue found, deflate array\n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                // two realEigenvalues found, deflate array\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                // no more realEigenvalues found, we need to iterate\n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        // step 2: flip array if needed\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            // step 3: choose a shift\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            // step 4a: dqds\n            for (boolean loop = true; loop;) {\n\n                // perform one dqds step with the chosen shift\n                dqds(start, deflatedEnd);\n\n                // check result of the dqds step\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    // the shift was good\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   // convergence hidden by negative DN.\n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    // tau too big. Select new tau and try again.\n                    if (tType < -22) {\n                        // failed twice. Play it safe.\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        // late failure. Gives excellent shift.\n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        // early failure. Divide by 4.\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }\n",
        "begin_line": 990,
        "end_line": 1122,
        "comment": "\n     * Perform one \"good\" dqd/dqds step.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLAZQ3.</p>\n     * @param start start index\n     * @param end end index\n     * @return new end (maybe deflated)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.EigenDecompositionImpl#189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.EigenDecompositionImpl(double[], double[], double)",
        "snippet": "    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }\n",
        "begin_line": 189,
        "end_line": 207,
        "comment": "\n     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n     * @param main the main diagonal of the matrix (will be copied)\n     * @param secondary the secondary diagonal of the matrix (will be copied)\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.findEigenvalues#611",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues()",
        "snippet": "    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                // apply dedicated method for dimension 1\n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                // apply dedicated method for dimension 2\n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                // apply dedicated method for dimension 3\n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                // choose an initial shift for LDL<sup>T</sup> decomposition\n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                // decompose T-&lambda;I as LDL<sup>T</sup>\n                ldlTDecomposition(lambda, begin, n);\n\n                // apply general dqd/dqds method\n                processGeneralBlock(n);\n\n                // extract realEigenvalues\n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }\n",
        "begin_line": 611,
        "end_line": 684,
        "comment": "\n     * Find the realEigenvalues.\n     * @exception InvalidMatrixException if a block cannot be diagonalized\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.processGeneralBlock#822",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(int)",
        "snippet": "    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }\n",
        "begin_line": 822,
        "end_line": 928,
        "comment": "\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.initialSplits#934",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.initialSplits(int)",
        "snippet": "    private void initialSplits(final int n) {\n\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n\n            // apply Li's reverse test\n            double d = work[4 * (n - 1) + pingPong];\n            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= TOLERANCE_2 * d) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n\n            // apply dqd plus Li's forward test.\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n                final int j = i - 2 * pingPong - 1;\n                work[j] = d + work[i];\n                if (work[i] <= TOLERANCE_2 * d) {\n                    work[i]     = -0.0;\n                    work[j]     = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n               }\n            }\n            work[4 * n - 3 - pingPong] = d;\n\n            // from ping to pong\n            pingPong = 1 - pingPong;\n\n        }\n\n    }\n",
        "begin_line": 934,
        "end_line": 977,
        "comment": "\n     * Perform two iterations with Li's tests for initial splits.\n     * @param n number of rows of the matrix to process\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.flipIfWarranted#1131",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.flipIfWarranted(int, int)",
        "snippet": "    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n",
        "begin_line": 1131,
        "end_line": 1146,
        "comment": "\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.eigenvaluesRange#1154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.eigenvaluesRange(int, int)",
        "snippet": "    private double[] eigenvaluesRange(final int index, final int n) {\n\n        // find the bounds of the spectra of the local block\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = Math.min(lower, work[lowerStart + index +i]);\n            upper = Math.max(upper, work[upperStart + index +i]);\n        }\n\n        // set thresholds\n        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter =\n            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n\n        // search lower eigenvalue\n        double left  = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                // search has converged\n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n\n        // search upper eigenvalue\n        left  = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                // search has converged\n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n\n        return new double[] { lower, upper };\n\n    }\n",
        "begin_line": 1154,
        "end_line": 1220,
        "comment": "\n     * Compute an interval containing all realEigenvalues of a block.\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return an interval containing the realEigenvalues\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.countEigenValues#1229",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.countEigenValues(double, int, int)",
        "snippet": "    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n",
        "begin_line": 1229,
        "end_line": 1239,
        "comment": "\n     * Count the number of realEigenvalues below a point.\n     * @param t value below which we must count the number of realEigenvalues\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return number of realEigenvalues smaller than t\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.ldlTDecomposition#1252",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.ldlTDecomposition(double, int, int)",
        "snippet": "    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int    fourI = 4 * i;\n            final double eiM1  = secondary[index + i - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = ratio * ratio * Math.abs(di);\n            di = (main[index + i] - lambda) - eiM1 * ratio;\n            work[fourI] = Math.abs(di);\n        }\n    }\n",
        "begin_line": 1252,
        "end_line": 1263,
        "comment": "\n     * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>.\n     * <p>A shifted symmetric tridiagonal matrix T can be decomposed as\n     * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal\n     * and D is a diagonal matrix. This method is an implementation of\n     * algorithm 4.4.7 from Dhillon's thesis.</p>\n     * @param lambda shift to add to the matrix before decomposing it\n     * to ensure it is positive definite\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.dqds#1271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.dqds(int, int)",
        "snippet": "    private void dqds(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[4 * start + pingPong];\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = Math.min(work[j4 - 1], eMin);\n            }\n        }\n\n        // unroll last two steps.\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n",
        "begin_line": 1271,
        "end_line": 1319,
        "comment": "\n     * Perform a dqds step, using current shift increment.\n     * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p>\n     * @param start start index\n     * @param end end index\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.dqd#1328",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.dqd(int, int)",
        "snippet": "    private void dqd(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong];\n        dMin = d;\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4 - 1]);\n            }\n        }\n\n        // Unroll last two steps\n        dN2   = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1  = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN   = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }\n",
        "begin_line": 1328,
        "end_line": 1421,
        "comment": "\n     * Perform a dqd step.\n     * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>\n     * @param start start index\n     * @param end end index\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.updateSigma#1678",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.updateSigma(double)",
        "snippet": "    private void updateSigma(final double shift) {\n        // BEWARE: do NOT attempt to simplify the following statements\n        // the expressions below take care to accumulate the part of sigma\n        // that does not fit within a double variable into sigmaLow\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n",
        "begin_line": 1678,
        "end_line": 1692,
        "comment": "\n     * Update sigma.\n     * @param shift shift to apply to sigma\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math.util.CompositeFormat",
        "signature": "org.apache.commons.math.util.CompositeFormat.getDefaultNumberFormat(java.util.Locale)",
        "snippet": "    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }\n",
        "begin_line": 52,
        "end_line": 56,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing that the maximum number of fraction digits is set to 2.\n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math.linear.RealVectorFormat",
        "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#116",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math.linear.RealVectorFormat",
        "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }\n",
        "begin_line": 116,
        "end_line": 125,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param separator separator to use instead of the default \"; \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#172",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math.linear.RealVectorFormat",
        "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance()",
        "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 172,
        "end_line": 174,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#181",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math.linear.RealVectorFormat",
        "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.start#33",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.start(int, int, int, int, int, int)",
        "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }\n",
        "begin_line": 33,
        "end_line": 35,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.end#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.end()",
        "snippet": "    public double end() {\n        return 0;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrixPreservingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.createMatrix#157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.createMatrix(int, int)",
        "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }\n",
        "begin_line": 157,
        "end_line": 161,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Create a new RealMatrix of the same type as the instance with the supplied\n     * row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @return a new matrix of the same type as the instance\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.walkInRowOrder#479",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
        "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 479,
        "end_line": 492,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.transpose#601",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.transpose()",
        "snippet": "    public RealMatrix transpose() {\n\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n\n    }\n",
        "begin_line": 601,
        "end_line": 618,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.visit#609",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.Anonymous-5d5b1da9-b5d5-47b0-86df-e080d421a951.visit(int, int, double)",
        "snippet": "            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n",
        "begin_line": 609,
        "end_line": 612,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.walkInOptimizedOrder#917",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
        "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 917,
        "end_line": 920,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#74",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
        "snippet": "    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }\n",
        "begin_line": 74,
        "end_line": 78,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1796
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setEntry#363",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            data[row][column] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 363,
        "end_line": 373,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Set the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be set\n     * @param column  column location of entry to be set\n     * @param value matrix entry to be set in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.1796
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }\n",
        "begin_line": 54,
        "end_line": 67,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1796
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#648",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 648,
        "end_line": 656,
        "comment": "\n     * Check if matrices are multiplication compatible\n     * @param left left hand side matrix\n     * @param right right hand side matrix\n     * @exception IllegalArgumentException if matrices are not multiplication compatible\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"some rows have length {0} while others have length {1}\",\n                            nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 113,
        "end_line": 138,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the <code>copyArray</code> may be\n     * set to <code>false</code. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.</p>\n     * @param d data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.multiply#250",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    @Override\n    public RealMatrix multiply(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return multiply((Array2DRowRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return super.multiply(m);\n        }\n    }\n",
        "begin_line": 250,
        "end_line": 258,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Compute the sum of this and m.\n     *\n     * @param m    matrix to be added\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     "
        },
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.multiply#267",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }\n",
        "begin_line": 267,
        "end_line": 291,
        "comment": "\n     * Returns the result of postmultiplying this by <code>m</code>.\n     * @param m    matrix to postmultiply by\n     * @return     this*m\n     * @throws     IllegalArgumentException\n     *             if columnDimension(this) != rowDimension(m)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }\n",
        "begin_line": 105,
        "end_line": 108,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if either <code>data</code> or\n     * <code>data[0]</code> is null\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.computeGershgorinCircles#569",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeGershgorinCircles()",
        "snippet": "    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }\n",
        "begin_line": 569,
        "end_line": 605,
        "comment": "\n     * Compute the Gershgorin circles for all rows.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.computeSplits#690",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeSplits()",
        "snippet": "    private List<Integer> computeSplits() {\n\n        final List<Integer> list = new ArrayList<Integer>();\n\n        // splitting preserving relative accuracy\n        double absDCurrent = Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = Math.abs(main[i + 1]);\n            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n            if (Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n\n        list.add(secondary.length + 1);\n        return list;\n\n    }\n",
        "begin_line": 690,
        "end_line": 710,
        "comment": "\n     * Compute splitting points.\n     * @return list of indices after matrix can be split\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws IllegalArgumentException, NullPointerException {\n        copyIn(d);\n    }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n     * with the second argument set to <code>true</code>.</p>\n     *\n     * @param d data for new matrix\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowRealMatrix(double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setSubMatrix#311",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
        "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n    throws MatrixIndexException {\n        if (data == null) {\n            if (row > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                        \"first {0} rows are not initialized yet\",\n                        row);\n            }\n            if (column > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                        \"first {0} columns are not initialized yet\",\n                        column);\n            }\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"some rows have length {0} while others have length {1}\",\n                            nCols, subMatrix[i].length);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }\n",
        "begin_line": 311,
        "end_line": 347,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n    * Replace the submatrix starting at <code>row, column</code> using data in\n    * the input <code>subMatrix</code> array. Indexes are 0-based.\n    * <p>\n    * Example:<br>\n    * Starting with <pre>\n    * 1  2  3  4\n    * 5  6  7  8\n    * 9  0  1  2\n    * </pre>\n    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n    * 1  2  3  4\n    * 5  3  4  8\n    * 9  5  6  2\n    * </pre></p>\n    *\n    * @param subMatrix  array containing the submatrix replacement data\n    * @param row  row coordinate of the top, left element to be replaced\n    * @param column  column coordinate of the top, left element to be replaced\n    * @throws MatrixIndexException  if subMatrix does not fit into this\n    *    matrix from element in (row, column)\n    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n    *  (not all rows have the same length) or empty\n    * @throws NullPointerException if <code>subMatrix</code> is null\n    * @since 2.0\n    "
        },
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyIn#621",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
        "snippet": "    private void copyIn(final double[][] in) {\n        setSubMatrix(in, 0, 0);\n    }\n",
        "begin_line": 621,
        "end_line": 623,
        "comment": "\n     * Replaces data with a fresh copy of the input array.\n     * <p>\n     * Verifies that the input array is rectangular and non-empty.</p>\n     *\n     * @param in data to copy in\n     * @throws IllegalArgumentException if input array is empty or not\n     *    rectangular\n     * @throws NullPointerException if input array is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecompositionImpl.decompose#235",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
        "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.decompose()",
        "snippet": "    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }\n",
        "begin_line": 235,
        "end_line": 251,
        "comment": "\n     * Decompose a tridiagonal symmetric matrix.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#402",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 402,
        "end_line": 405,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#408",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 408,
        "end_line": 411,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 1
    }
]