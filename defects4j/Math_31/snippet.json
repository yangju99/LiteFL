[
    {
        "name": "ContinuedFraction.evaluate#123",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/util/ContinuedFraction.java",
        "class_name": "org.apache.commons.math3.util.ContinuedFraction",
        "signature": "org.apache.commons.math3.util.ContinuedFraction.evaluate(double, double, int)",
        "snippet": "    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double cN = a * hPrev + b * p0;\n            double q2 = a * q1 + b * dPrev;\n            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n                }\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                    } else if (b != 0) {\n                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                    }\n                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                        break;\n                    }\n                }\n            }\n\n            final double deltaN = cN / q2 / cPrev;\n            hN = cPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }\n",
        "begin_line": 123,
        "end_line": 199,
        "comment": "\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException(org.apache.commons.math3.exception.util.Localizable, java.lang.Object...)",
        "snippet": "    public MathIllegalStateException(Localizable pattern,\n                                     Object ... args) {\n        context = new ExceptionContext(this);\n        context.addMessage(pattern, args);\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Simple constructor.\n     *\n     * @param pattern Message pattern explaining the cause of the error.\n     * @param args Arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#68",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException()",
        "snippet": "    public MathIllegalStateException() {\n        this(LocalizedFormats.ILLEGAL_STATE);\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "MathIllegalStateException.getContext#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.getContext()",
        "snippet": "    public ExceptionContext getContext() {\n        return context;\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.exception.util.ExceptionContextProvider": "\n     * Gets a reference to the \"rich context\" data structure that allows to\n     * customize error messages and store key, value pairs in exceptions.\n     *\n     * @return a reference to the exception context.\n     ",
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "ConvergenceException.ConvergenceException#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/ConvergenceException.java",
        "class_name": "org.apache.commons.math3.exception.ConvergenceException",
        "signature": "org.apache.commons.math3.exception.ConvergenceException.ConvergenceException(org.apache.commons.math3.exception.util.Localizable, java.lang.Object...)",
        "snippet": "    public ConvergenceException(Localizable pattern,\n                                Object ... args) {\n        getContext().addMessage(pattern, args);\n    }\n",
        "begin_line": 47,
        "end_line": 50,
        "comment": "\n     * Construct the exception with a specific context and arguments.\n     *\n     * @param pattern Message pattern providing the specific context of\n     * the error.\n     * @param args Arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "MathIllegalStateException.getMessage#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.getMessage()",
        "snippet": "    @Override\n    public String getMessage() {\n        return context.getMessage();\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.exception.util.ExceptionContextProvider": null,
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.getLocalizedMessage#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math3.exception.MathIllegalStateException.getLocalizedMessage()",
        "snippet": "    @Override\n    public String getLocalizedMessage() {\n        return context.getLocalizedMessage();\n    }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.exception.util.ExceptionContextProvider": null,
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getSolverAbsoluteAccuracy#176",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getSolverAbsoluteAccuracy()",
        "snippet": "    @Override\n    protected double getSolverAbsoluteAccuracy() {\n        return solverAbsoluteAccuracy;\n    }\n",
        "begin_line": 176,
        "end_line": 179,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": "\n     * Returns the solver absolute accuracy for inverse cumulative computation.\n     * You can override this method in order to use a Brent solver with an\n     * absolute accuracy different from the default.\n     *\n     * @return the maximum absolute error in inverse cumulative probability estimates\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getNumericalMean#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getNumericalMean()",
        "snippet": "    public double getNumericalMean() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 2) {\n            return denominatorDF / (denominatorDF - 2);\n        }\n\n        return Double.NaN;\n    }\n",
        "begin_line": 190,
        "end_line": 198,
        "comment": "\n     * {@inheritDoc}\n     *\n     * For denominator degrees of freedom parameter {@code b}, the mean is\n     * <ul>\n     *  <li>if {@code b > 2} then {@code b / (b - 2)},</li>\n     *  <li>else undefined ({@code Double.NaN}).\n     * </ul>\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Use this method to get the numerical value of the mean of this\n     * distribution.\n     *\n     * @return the mean or {@code Double.NaN} if it is not defined\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.calculateNumericalVariance#226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.calculateNumericalVariance()",
        "snippet": "    protected double calculateNumericalVariance() {\n        final double denominatorDF = getDenominatorDegreesOfFreedom();\n\n        if (denominatorDF > 4) {\n            final double numeratorDF = getNumeratorDegreesOfFreedom();\n            final double denomDFMinusTwo = denominatorDF - 2;\n\n            return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n                   ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n        }\n\n        return Double.NaN;\n    }\n",
        "begin_line": 226,
        "end_line": 238,
        "comment": "\n     * used by {@link #getNumericalVariance()}\n     *\n     * @return the variance of this distribution\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.cumulativeProbability#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.cumulativeProbability(double)",
        "snippet": "    public double cumulativeProbability(double x)  {\n        double ret;\n        if (x <= 0) {\n            ret = 0;\n        } else {\n            double n = numeratorDegreesOfFreedom;\n            double m = denominatorDegreesOfFreedom;\n\n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n",
        "begin_line": 142,
        "end_line": 155,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The implementation of this method is based on\n     * <ul>\n     *  <li>\n     *   <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n     *   F-Distribution</a>, equation (4).\n     *  </li>\n     * </ul>\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * For a random variable {@code X} whose values are distributed according\n     * to this distribution, this method returns {@code P(X <= x)}. In other\n     * words, this method represents the (cumulative) distribution function\n     * (CDF) for this distribution.\n     *\n     * @param x the point at which the CDF is evaluated\n     * @return the probability that a random variable with this\n     * distribution takes a value less than or equal to {@code x}\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getNumeratorDegreesOfFreedom#162",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getNumeratorDegreesOfFreedom()",
        "snippet": "    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n",
        "begin_line": 162,
        "end_line": 164,
        "comment": "\n     * Access the numerator degrees of freedom.\n     *\n     * @return the numerator degrees of freedom.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getNumericalVariance#213",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getNumericalVariance()",
        "snippet": "    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n",
        "begin_line": 213,
        "end_line": 219,
        "comment": "\n     * {@inheritDoc}\n     *\n     * For numerator degrees of freedom parameter {@code a} and denominator\n     * degrees of freedom parameter {@code b}, the variance is\n     * <ul>\n     *  <li>\n     *    if {@code b > 4} then\n     *    {@code [2 * b^2 * (a + b - 2)] / [a * (b - 2)^2 * (b - 4)]},\n     *  </li>\n     *  <li>else undefined ({@code Double.NaN}).\n     * </ul>\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Use this method to get the numerical value of the variance of this\n     * distribution.\n     *\n     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as\n     * for certain cases in {@link TDistribution}) or {@code Double.NaN} if it\n     * is not defined\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getSupportLowerBound#247",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getSupportLowerBound()",
        "snippet": "    public double getSupportLowerBound() {\n        return 0;\n    }\n",
        "begin_line": 247,
        "end_line": 249,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 no matter the parameters.\n     *\n     * @return lower bound of the support (always 0)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Access the lower bound of the support. This method must return the same\n     * value as {@code inverseCumulativeProbability(0)}. In other words, this\n     * method must return\n     * <p><code>inf {x in R | P(X <= x) > 0}</code>.</p>\n     *\n     * @return lower bound of the support (might be\n     * {@code Double.NEGATIVE_INFINITY})\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getSupportUpperBound#259",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getSupportUpperBound()",
        "snippet": "    public double getSupportUpperBound() {\n        return Double.POSITIVE_INFINITY;\n    }\n",
        "begin_line": 259,
        "end_line": 261,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is always positive infinity\n     * no matter the parameters.\n     *\n     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractRealDistribution": null,
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Access the upper bound of the support. This method must return the same\n     * value as {@code inverseCumulativeProbability(1)}. In other words, this\n     * method must return\n     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>\n     *\n     * @return upper bound of the support (might be\n     * {@code Double.POSITIVE_INFINITY})\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.getNumericalMean#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.getNumericalMean()",
        "snippet": "    public double getNumericalMean() {\n        return numberOfTrials * probabilityOfSuccess;\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * {@inheritDoc}\n     *\n     * For {@code n} trials and probability parameter {@code p}, the mean is\n     * {@code n * p}.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractIntegerDistribution": null,
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * Use this method to get the numerical value of the mean of this\n     * distribution.\n     *\n     * @return the mean or {@code Double.NaN} if it is not defined\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.getNumericalVariance#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.getNumericalVariance()",
        "snippet": "    public double getNumericalVariance() {\n        final double p = probabilityOfSuccess;\n        return numberOfTrials * p * (1 - p);\n    }\n",
        "begin_line": 123,
        "end_line": 126,
        "comment": "\n     * {@inheritDoc}\n     *\n     * For {@code n} trials and probability parameter {@code p}, the variance is\n     * {@code n * p * (1 - p)}.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractIntegerDistribution": null,
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * Use this method to get the numerical value of the variance of this\n     * distribution.\n     *\n     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} or\n     * {@code Double.NaN} if it is not defined)\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.getSupportLowerBound#136",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.getSupportLowerBound()",
        "snippet": "    public int getSupportLowerBound() {\n        return probabilityOfSuccess < 1.0 ? 0 : numberOfTrials;\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The lower bound of the support is always 0 except for the probability\n     * parameter {@code p = 1}.\n     *\n     * @return lower bound of the support (0 or the number of trials)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractIntegerDistribution": null,
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * Access the lower bound of the support. This method must return the same\n     * value as {@code inverseCumulativeProbability(0)}. In other words, this\n     * method must return\n     * <p><code>inf {x in Z | P(X <= x) > 0}</code>.</p>\n     *\n     * @return lower bound of the support ({@code Integer.MIN_VALUE}\n     * for negative infinity)\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.getSupportUpperBound#148",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.getSupportUpperBound()",
        "snippet": "    public int getSupportUpperBound() {\n        return probabilityOfSuccess > 0.0 ? numberOfTrials : 0;\n    }\n",
        "begin_line": 148,
        "end_line": 150,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The upper bound of the support is the number of trials except for the\n     * probability parameter {@code p = 0}.\n     *\n     * @return upper bound of the support (number of trials or 0)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractIntegerDistribution": null,
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * Access the upper bound of the support. This method must return the same\n     * value as {@code inverseCumulativeProbability(1)}. In other words, this\n     * method must return\n     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>\n     *\n     * @return upper bound of the support ({@code Integer.MAX_VALUE}\n     * for positive infinity)\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.getDenominatorDegreesOfFreedom#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.getDenominatorDegreesOfFreedom()",
        "snippet": "    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "\n     * Access the denominator degrees of freedom.\n     *\n     * @return the denominator degrees of freedom.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.cumulativeProbability#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.cumulativeProbability(int)",
        "snippet": "    public double cumulativeProbability(int x) {\n        double ret;\n        if (x < 0) {\n            ret = 0.0;\n        } else if (x >= numberOfTrials) {\n            ret = 1.0;\n        } else {\n            ret = 1.0 - Beta.regularizedBeta(probabilityOfSuccess,\n                    x + 1.0, numberOfTrials - x);\n        }\n        return ret;\n    }\n",
        "begin_line": 94,
        "end_line": 105,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.AbstractIntegerDistribution": null,
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * For a random variable {@code X} whose values are distributed according\n     * to this distribution, this method returns {@code P(X <= x)}.  In other\n     * words, this method represents the (cumulative) distribution function\n     * (CDF) for this distribution.\n     *\n     * @param x the point at which the CDF is evaluated\n     * @return the probability that a random variable with this\n     * distribution takes a value less than or equal to {@code x}\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BinomialDistribution.BinomialDistribution#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.BinomialDistribution",
        "signature": "org.apache.commons.math3.distribution.BinomialDistribution.BinomialDistribution(int, double)",
        "snippet": "    public BinomialDistribution(int trials, double p) {\n        if (trials < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_TRIALS,\n                                           trials);\n        }\n        if (p < 0 || p > 1) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        probabilityOfSuccess = p;\n        numberOfTrials = trials;\n    }\n",
        "begin_line": 49,
        "end_line": 60,
        "comment": "\n     * Create a binomial distribution with the given number of trials and\n     * probability of success.\n     *\n     * @param trials Number of trials.\n     * @param p Probability of success.\n     * @throws NotPositiveException if {@code trials < 0}.\n     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Beta.regularizedBeta#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Beta.java",
        "class_name": "org.apache.commons.math3.special.Beta",
        "signature": "org.apache.commons.math3.special.Beta.regularizedBeta(double, double, double, double, int)",
        "snippet": "    public static double regularizedBeta(double x,\n                                         final double a, final double b,\n                                         double epsilon, int maxIterations) {\n        double ret;\n\n        if (Double.isNaN(x) ||\n            Double.isNaN(a) ||\n            Double.isNaN(b) ||\n            x < 0 ||\n            x > 1 ||\n            a <= 0.0 ||\n            b <= 0.0) {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\n                FastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 115,
        "end_line": 160,
        "comment": "\n     * Returns the regularized beta function I(x, a, b).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n     * Regularized Beta Function</a>.</li>\n     * <li>\n     * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n     * Regularized Beta Function</a>.</li>\n     * </ul>\n     *\n     * @param x the value.\n     * @param a Parameter {@code a}.\n     * @param b Parameter {@code b}.\n     * @param epsilon When the absolute value of the nth item in the\n     * series is less than epsilon the approximation ceases to calculate\n     * further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete.\n     * @return the regularized beta function I(x, a, b)\n     * @throws org.apache.commons.math3.exception.MaxCountExceededException\n     * if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2209
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractIntegerDistribution.inverseCumulativeProbability#74",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractIntegerDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability(double)",
        "snippet": "    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }\n",
        "begin_line": 74,
        "end_line": 117,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.IntegerDistribution": "\n     * Computes the quantile function of this distribution.\n     * For a random variable {@code X} distributed according to this distribution,\n     * the returned value is\n     * <ul>\n     * <li><code>inf{x in Z | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>\n     * <li><code>inf{x in Z | P(X<=x) > 0}</code> for {@code p = 0}.</li>\n     * </ul>\n     * If the result exceeds the range of the data type {@code int},\n     * then {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.\n     *\n     * @param p the cumulative probability\n     * @return the smallest {@code p}-quantile of this distribution\n     * (largest 0-quantile for {@code p = 0})\n     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "Beta.getB#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Beta.java",
        "class_name": "org.apache.commons.math3.special.Beta",
        "signature": "org.apache.commons.math3.special.Beta.Anonymous-b591e839-9f1a-48a1-ba08-b01a215001bb.getB(int, double)",
        "snippet": "                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n",
        "begin_line": 133,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractIntegerDistribution.solveInverseCumulativeProbability#131",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractIntegerDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability(double, int, int)",
        "snippet": "    protected int solveInverseCumulativeProbability(final double p, int lower, int upper) {\n        while (lower + 1 < upper) {\n            int xm = (lower + upper) / 2;\n            if (xm < lower || xm > upper) {\n                /*\n                 * Overflow.\n                 * There will never be an overflow in both calculation methods\n                 * for xm at the same time\n                 */\n                xm = lower + (upper - lower) / 2;\n            }\n\n            double pm = checkedCumulativeProbability(xm);\n            if (pm >= p) {\n                upper = xm;\n            } else {\n                lower = xm;\n            }\n        }\n        return upper;\n    }\n",
        "begin_line": 131,
        "end_line": 151,
        "comment": "\n     * This is a utility function used by {@link\n     * #inverseCumulativeProbability(double)}. It assumes {@code 0 < p < 1} and\n     * that the inverse cumulative probability lies in the bracket {@code\n     * (lower, upper]}. The implementation does simple bisection to find the\n     * smallest {@code p}-quantile <code>inf{x in Z | P(X<=x) >= p}</code>.\n     *\n     * @param p the cumulative probability\n     * @param lower a value satisfying {@code cumulativeProbability(lower) < p}\n     * @param upper a value satisfying {@code p <= cumulativeProbability(upper)}\n     * @return the smallest {@code p}-quantile of this distribution\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegerDistribution.checkedCumulativeProbability#198",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractIntegerDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution.checkedCumulativeProbability(int)",
        "snippet": "    private double checkedCumulativeProbability(int argument)\n        throws MathInternalError {\n        double result = Double.NaN;\n        result = cumulativeProbability(argument);\n        if (Double.isNaN(result)) {\n            throw new MathInternalError(LocalizedFormats\n                    .DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n        }\n        return result;\n    }\n",
        "begin_line": 198,
        "end_line": 207,
        "comment": "\n     * Computes the cumulative probability function and checks for {@code NaN}\n     * values returned. Throws {@code MathInternalError} if the value is\n     * {@code NaN}. Rethrows any exception encountered evaluating the cumulative\n     * probability function. Throws {@code MathInternalError} if the cumulative\n     * probability function returns {@code NaN}.\n     *\n     * @param argument input value\n     * @return the cumulative probability\n     * @throws MathInternalError if the cumulative probability is {@code NaN}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Beta.getA#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Beta.java",
        "class_name": "org.apache.commons.math3.special.Beta",
        "signature": "org.apache.commons.math3.special.Beta.Anonymous-74fe2e0b-b1ef-41a1-9e58-65409cef6d31.getA(int, double)",
        "snippet": "                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n",
        "begin_line": 149,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1841
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.logBeta#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Beta.java",
        "class_name": "org.apache.commons.math3.special.Beta",
        "signature": "org.apache.commons.math3.special.Beta.logBeta(double, double, double, int)",
        "snippet": "    public static double logBeta(double a, double b,\n                                 double epsilon,\n                                 int maxIterations) {\n        double ret;\n\n        if (Double.isNaN(a) ||\n            Double.isNaN(b) ||\n            a <= 0.0 ||\n            b <= 0.0) {\n            ret = Double.NaN;\n        } else {\n            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n                Gamma.logGamma(a + b);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 190,
        "end_line": 206,
        "comment": "\n     * Returns the natural logarithm of the beta function B(a, b).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n     * Beta Function</a>, equation (1).</li>\n     * </ul>\n     *\n     * @param a Parameter {@code a}.\n     * @param b Parameter {@code b}.\n     * @param epsilon When the absolute value of the nth item in the\n     * series is less than epsilon the approximation ceases to calculate\n     * further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete.\n     * @return log(B(a, b)).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1811
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.regularizedBeta#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Beta.java",
        "class_name": "org.apache.commons.math3.special.Beta",
        "signature": "org.apache.commons.math3.special.Beta.regularizedBeta(double, double, double)",
        "snippet": "    public static double regularizedBeta(double x, double a, double b) {\n        return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": "\n     * Returns the\n     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n     * regularized beta function</a> I(x, a, b).\n     *\n     * @param x Value.\n     * @param a Parameter {@code a}.\n     * @param b Parameter {@code b}.\n     * @return the regularized beta function I(x, a, b).\n     * @throws org.apache.commons.math3.exception.MaxCountExceededException\n     * if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1728
        },
        "num_failing_tests": 2
    },
    {
        "name": "FDistribution.FDistribution#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.FDistribution(double, double)",
        "snippet": "    public FDistribution(double numeratorDegreesOfFreedom,\n                             double denominatorDegreesOfFreedom)\n        throws NotStrictlyPositiveException {\n        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n",
        "begin_line": 65,
        "end_line": 70,
        "comment": "\n     * Create a F distribution using the given degrees of freedom.\n     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n     * @throws NotStrictlyPositiveException if\n     * {@code numeratorDegreesOfFreedom <= 0} or\n     * {@code denominatorDegreesOfFreedom <= 0}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "FDistribution.FDistribution#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/FDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.FDistribution",
        "signature": "org.apache.commons.math3.distribution.FDistribution.FDistribution(double, double, double)",
        "snippet": "    public FDistribution(double numeratorDegreesOfFreedom,\n                             double denominatorDegreesOfFreedom,\n                             double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        if (numeratorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   numeratorDegreesOfFreedom);\n        }\n        if (denominatorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   denominatorDegreesOfFreedom);\n        }\n        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n",
        "begin_line": 85,
        "end_line": 100,
        "comment": "\n     * Create an F distribution using the given degrees of freedom\n     * and inverse cumulative probability accuracy.\n     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n     * @param inverseCumAccuracy the maximum absolute error in inverse\n     * cumulative probability estimates.\n     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n     * @throws NotStrictlyPositiveException if\n     * {@code numeratorDegreesOfFreedom <= 0} or\n     * {@code denominatorDegreesOfFreedom <= 0}.\n     * @since 2.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.doSolve#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.doSolve()",
        "snippet": "    @Override\n    protected double doSolve() {\n        double min = getMin();\n        double max = getMax();\n        final double initial = getStartValue();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        verifySequence(min, initial, max);\n\n        // Return the initial guess if it is good enough.\n        double yInitial = computeObjectiveValue(initial);\n        if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n            return initial;\n        }\n\n        // Return the first endpoint if it is good enough.\n        double yMin = computeObjectiveValue(min);\n        if (FastMath.abs(yMin) <= functionValueAccuracy) {\n            return min;\n        }\n\n        // Reduce interval if min and initial bracket the root.\n        if (yInitial * yMin < 0) {\n            return brent(min, initial, yMin, yInitial);\n        }\n\n        // Return the second endpoint if it is good enough.\n        double yMax = computeObjectiveValue(max);\n        if (FastMath.abs(yMax) <= functionValueAccuracy) {\n            return max;\n        }\n\n        // Reduce interval if initial and max bracket the root.\n        if (yInitial * yMax < 0) {\n            return brent(initial, max, yInitial, yMax);\n        }\n\n        throw new NoBracketingException(min, max, yMin, yMax);\n    }\n",
        "begin_line": 81,
        "end_line": 119,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver": null,
            "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the root.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the initial search interval does not bracket\n     * a root and the solver requires it.\n     ",
            "org.apache.commons.math3.analysis.solvers.UnivariateSolver": null,
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": null
        },
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.exp#817",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.exp(double, double, double[])",
        "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n",
        "begin_line": 817,
        "end_line": 932,
        "comment": "\n     * Internal helper method for exponential function.\n     * @param x original argument of the exponential function\n     * @param extra extra bits of precision on input (To Be Confirmed)\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealDistribution.inverseCumulativeProbability#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.inverseCumulativeProbability(double)",
        "snippet": "    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        /*\n         * IMPLEMENTATION NOTES\n         * --------------------\n         * Where applicable, use is made of the one-sided Chebyshev inequality\n         * to bracket the root. This inequality states that\n         * P(X - mu >= k * sig) <= 1 / (1 + k^2),\n         * mu: mean, sig: standard deviation. Equivalently\n         * 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),\n         * F(mu + k * sig) >= k^2 / (1 + k^2).\n         *\n         * For k = sqrt(p / (1 - p)), we find\n         * F(mu + k * sig) >= p,\n         * and (mu + k * sig) is an upper-bound for the root.\n         *\n         * Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and\n         * P(Y >= -mu + k * sig) <= 1 / (1 + k^2),\n         * P(-X >= -mu + k * sig) <= 1 / (1 + k^2),\n         * P(X <= mu - k * sig) <= 1 / (1 + k^2),\n         * F(mu - k * sig) <= 1 / (1 + k^2).\n         *\n         * For k = sqrt((1 - p) / p), we find\n         * F(mu - k * sig) <= p,\n         * and (mu - k * sig) is a lower-bound for the root.\n         *\n         * In cases where the Chebyshev inequality does not apply, geometric\n         * progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket\n         * the root.\n         */\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        double lowerBound = getSupportLowerBound();\n        if (p == 0.0) {\n            return lowerBound;\n        }\n\n        double upperBound = getSupportUpperBound();\n        if (p == 1.0) {\n            return upperBound;\n        }\n\n        final double mu = getNumericalMean();\n        final double sig = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies;\n        chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                             Double.isInfinite(sig) || Double.isNaN(sig));\n\n        if (lowerBound == Double.NEGATIVE_INFINITY) {\n            if (chebyshevApplies) {\n                lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n            } else {\n                lowerBound = -1.0;\n                while (cumulativeProbability(lowerBound) >= p) {\n                    lowerBound *= 2.0;\n                }\n            }\n        }\n\n        if (upperBound == Double.POSITIVE_INFINITY) {\n            if (chebyshevApplies) {\n                upperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n            } else {\n                upperBound = 1.0;\n                while (cumulativeProbability(upperBound) < p) {\n                    upperBound *= 2.0;\n                }\n            }\n        }\n\n        final UnivariateFunction toSolve = new UnivariateFunction() {\n\n            public double value(final double x) {\n                return cumulativeProbability(x) - p;\n            }\n        };\n\n        double x = UnivariateSolverUtils.solve(toSolve,\n                                                   lowerBound,\n                                                   upperBound,\n                                                   getSolverAbsoluteAccuracy());\n\n        if (!isSupportConnected()) {\n            /* Test for plateau. */\n            final double dx = getSolverAbsoluteAccuracy();\n            if (x - dx >= getSupportLowerBound()) {\n                double px = cumulativeProbability(x);\n                if (cumulativeProbability(x - dx) == px) {\n                    upperBound = x;\n                    while (upperBound - lowerBound > dx) {\n                        final double midPoint = 0.5 * (lowerBound + upperBound);\n                        if (cumulativeProbability(midPoint) < px) {\n                            lowerBound = midPoint;\n                        } else {\n                            upperBound = midPoint;\n                        }\n                    }\n                    return upperBound;\n                }\n            }\n        }\n        return x;\n    }\n",
        "begin_line": 78,
        "end_line": 181,
        "comment": "\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}.</li>\n     * </ul>\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.distribution.RealDistribution": "\n     * Computes the quantile function of this distribution. For a random\n     * variable {@code X} distributed according to this distribution, the\n     * returned value is\n     * <ul>\n     * <li><code>inf{x in R | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>\n     * <li><code>inf{x in R | P(X<=x) > 0}</code> for {@code p = 0}.</li>\n     * </ul>\n     *\n     * @param p the cumulative probability\n     * @return the smallest {@code p}-quantile of this distribution\n     * (largest 0-quantile for {@code p = 0})\n     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 60,
        "end_line": 68,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int, org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealDistribution.value#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.Anonymous-e4f51bdb-b3bf-4a03-959a-2e60ad07af5f.value(double)",
        "snippet": "            public double value(final double x) {\n                return cumulativeProbability(x) - p;\n            }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateSolverUtils.solve#70",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
        "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.solve(org.apache.commons.math3.analysis.UnivariateFunction, double, double, double)",
        "snippet": "    public static double solve(UnivariateFunction function,\n                               double x0, double x1,\n                               double absoluteAccuracy) {\n        if (function == null) {\n            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        }\n        final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n    }\n",
        "begin_line": 70,
        "end_line": 78,
        "comment": "\n     * Convenience method to find a zero of a univariate real function.  A default\n     * solver is used.\n     *\n     * @param function Function.\n     * @param x0 Lower bound for the interval.\n     * @param x1 Upper bound for the interval.\n     * @param absoluteAccuracy Accuracy to be used by the solver.\n     * @return a value where the function is zero.\n     * @throws IllegalArgumentException if {@code function} is {@code null},\n     * the endpoints do not specify a valid interval, or the absolute accuracy\n     * is not valid for the default solver.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateSolverUtils.verifyInterval#334",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
        "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifyInterval(double, double)",
        "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper) {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }\n",
        "begin_line": 334,
        "end_line": 340,
        "comment": "\n     * Check that the endpoints specify an interval.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateSolverUtils.verifySequence#351",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
        "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifySequence(double, double, double)",
        "snippet": "    public static void verifySequence(final double lower,\n                                      final double initial,\n                                      final double upper) {\n        verifyInterval(lower, initial);\n        verifyInterval(initial, upper);\n    }\n",
        "begin_line": 351,
        "end_line": 356,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n     * {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.BrentSolver#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.BrentSolver(double)",
        "snippet": "    public BrentSolver(double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Construct a solver.\n     *\n     * @param absoluteAccuracy Absolute accuracy.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double)",
        "snippet": "    protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\n        this(DEFAULT_RELATIVE_ACCURACY,\n             absoluteAccuracy,\n             DEFAULT_FUNCTION_VALUE_ACCURACY);\n    }\n",
        "begin_line": 64,
        "end_line": 68,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double, double, double)",
        "snippet": "    protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getMin#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getMax#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getStartValue#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getFunctionValueAccuracy#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getFunctionValueAccuracy()",
        "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }\n",
        "begin_line": 139,
        "end_line": 141,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Get the function value accuracy of the solver.  If {@code v} is\n     * a value returned by the solver for a function {@code f},\n     * then by contract, {@code |f(v)|} should be less than or equal to\n     * the function value accuracy configured for the solver.\n     *\n     * @return the function value accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.computeObjectiveValue#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.setup#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.setup(int, FUNC, double, double, double)",
        "snippet": "    protected void setup(int maxEval,\n                         FUNC f,\n                         double min, double max,\n                         double startValue) {\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 168,
        "end_line": 182,
        "comment": "\n     * Prepare for computation.\n     * Subclasses must call this method if they override any of the\n     * {@code solve} methods.\n     *\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.solve#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.solve(int, FUNC, double, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n        // Initialization.\n        setup(maxEval, f, min, max, startValue);\n\n        // Perform computation.\n        return doSolve();\n    }\n",
        "begin_line": 185,
        "end_line": 191,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.solve#194",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.solve(int, FUNC, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max) {\n        return solve(maxEval, f, min, max, min + 0.5 * (max - min));\n    }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Solve for a zero root in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.verifySequence#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.verifySequence(double, double, double)",
        "snippet": "    protected void verifySequence(final double lower,\n                                  final double initial,\n                                  final double upper) {\n        UnivariateSolverUtils.verifySequence(lower, initial, upper);\n    }\n",
        "begin_line": 265,
        "end_line": 269,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n     * if {@code lower >= initial} or {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.incrementEvaluationCount#292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount() {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }\n",
        "begin_line": 292,
        "end_line": 298,
        "comment": "\n     * Increment the evaluation count by one.\n     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n     * It is provided for subclasses that do not exclusively use\n     * {@code computeObjectiveValue} to solve the function.\n     * See e.g. {@link AbstractDifferentiableUnivariateSolver}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateSolver.AbstractUnivariateSolver#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver(double)",
        "snippet": "    protected AbstractUnivariateSolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#264",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
        "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }\n",
        "begin_line": 264,
        "end_line": 266,
        "comment": "\n     * Returns {@code true} if there is no double value strictly between the\n     * arguments or the difference between them is within the range of allowed\n     * error (inclusive).\n     *\n     * @param x First value.\n     * @param y Second value.\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1361
        },
        "num_failing_tests": 2
    },
    {
        "name": "ContinuedFraction.ContinuedFraction#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ContinuedFraction.java",
        "class_name": "org.apache.commons.math3.util.ContinuedFraction",
        "signature": "org.apache.commons.math3.util.ContinuedFraction.ContinuedFraction()",
        "snippet": "    protected ContinuedFraction() {\n        super();\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1361
        },
        "num_failing_tests": 2
    },
    {
        "name": "Precision.equals#300",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 300,
        "end_line": 315,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.abs#3001",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 3001,
        "end_line": 3003,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 2
    },
    {
        "name": "MathUtils.checkNotNull#255",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathUtils.java",
        "class_name": "org.apache.commons.math3.util.MathUtils",
        "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 255,
        "end_line": 260,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "Gamma.logGamma#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Gamma.java",
        "class_name": "org.apache.commons.math3.special.Gamma",
        "signature": "org.apache.commons.math3.special.Gamma.logGamma(double)",
        "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double g = 607.0 / 128.0;\n            double sum = lanczos(x);\n            double tmp = x + g + .5;\n            ret = ((x + .5) * FastMath.log(tmp)) - tmp +\n                HALF_LOG_2_PI + FastMath.log(sum / x);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 92,
        "end_line": 106,
        "comment": "\n     * Returns the natural logarithm of the gamma function &#915;(x).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n     * Gamma Function</a>, equation (28).</li>\n     * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n     * Lanczos Approximation</a>, equations (1) through (5).</li>\n     * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n     * the computation of the convergent Lanczos complex Gamma approximation\n     * </a></li>\n     * </ul>\n     *\n     * @param x Value.\n     * @return log(&#915;(x))\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 2
    },
    {
        "name": "Gamma.lanczos#349",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/special/Gamma.java",
        "class_name": "org.apache.commons.math3.special.Gamma",
        "signature": "org.apache.commons.math3.special.Gamma.lanczos(double)",
        "snippet": "    public static double lanczos(final double x) {\n        double sum = 0.0;\n        for (int i = LANCZOS.length - 1; i > 0; --i) {\n            sum = sum + (LANCZOS[i] / (x + i));\n        }\n        return sum + LANCZOS[0];\n    }\n",
        "begin_line": 349,
        "end_line": 355,
        "comment": "\n     * <p>\n     * Returns the Lanczos approximation used to compute the gamma function.\n     * The Lanczos approximation is related to the Gamma function by the\n     * following equation\n     * <center>\n     * {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)\n     *                   * exp(-x - g - 0.5) * lanczos(x)},\n     * </center>\n     * where {@code g} is a constant, returned by {@link #getLanczosG()}.\n     * </p>\n     *\n     * @param x the argument\n     * @return the Lanczos approximation\n     * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>,\n     * equations (1) through (5), and Paul Godfrey's\n     * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n     * of the convergent Lanczos complex Gamma approximation</a>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.abs#3019",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3019,
        "end_line": 3021,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1088
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.exp#806",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
        "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }\n",
        "begin_line": 806,
        "end_line": 808,
        "comment": "\n     * Exponential function.\n     *\n     * Computes exp(x), function result is nearly rounded.   It will be correctly\n     * rounded to the theoretical value for 99.9% of input values, otherwise it will\n     * have a 1 UPL error.\n     *\n     * Method:\n     *    Lookup intVal = exp(int(x))\n     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n     *    Compute z as the exponential of the remaining bits by a polynomial minus one\n     *    exp(x) = intVal * fracVal * (1 + z)\n     *\n     * Accuracy:\n     *    Calculation is done with 63 bits of precision, so result should be correctly\n     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n     *\n     * @param x   a double\n     * @return double e<sup>x</sup>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1078
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.ResizableDoubleArray#160",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.ResizableDoubleArray(int)",
        "snippet": "    public ResizableDoubleArray(int initialCapacity) {\n        setInitialCapacity(initialCapacity);\n        internalArray = new double[this.initialCapacity];\n    }\n",
        "begin_line": 160,
        "end_line": 163,
        "comment": "\n     * Create a ResizableArray with the specified initial capacity.  Other\n     * properties take default values:\n      * <ul>\n     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n     * <li><code>expansionFactor = 2.5</code></li>\n     * <li><code>contractionFactor = 2.0</code></li>\n     * </ul>\n     * @param initialCapacity The initial size of the internal storage array\n     * @throws IllegalArgumentException if initialCapacity is not > 0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.addElement#300",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.addElement(double)",
        "snippet": "    public synchronized void addElement(double value) {\n        numElements++;\n        if ((startIndex + numElements) > internalArray.length) {\n            expand();\n        }\n        internalArray[startIndex + (numElements - 1)] = value;\n        if (shouldContract()) {\n            contract();\n        }\n    }\n",
        "begin_line": 300,
        "end_line": 309,
        "comment": "\n     * Adds an element to the end of this expandable array.\n     *\n     * @param value to be added to end of array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.contract#431",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.contract()",
        "snippet": "    public synchronized void contract() {\n        double[] tempArray = new double[numElements + 1];\n\n        // Copy and swap - copy only the element array from the src array.\n        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n        internalArray = tempArray;\n\n        // Reset the start index to zero\n        startIndex = 0;\n    }\n",
        "begin_line": 431,
        "end_line": 440,
        "comment": "\n     * Contracts the storage array to the (size of the element set) + 1 - to\n     * avoid a zero length array. This function also resets the startIndex to\n     * zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.expand#525",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.expand()",
        "snippet": "    protected synchronized void expand() {\n\n        // notice the use of FastMath.ceil(), this guarantees that we will always\n        // have an array of at least currentSize + 1.   Assume that the\n        // current initial capacity is 1 and the expansion factor\n        // is 1.000000000000000001.  The newly calculated size will be\n        // rounded up to 2 after the multiplication is performed.\n        int newSize = 0;\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\n        } else {\n            newSize = internalArray.length + FastMath.round(expansionFactor);\n        }\n        double[] tempArray = new double[newSize];\n\n        // Copy and swap\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n        internalArray = tempArray;\n    }\n",
        "begin_line": 525,
        "end_line": 543,
        "comment": "\n     * Expands the internal storage array using the expansion factor.\n     * <p>\n     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n     * after expansion will be <code>internalArray.length + expansionFactor</code>\n     * </p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.getElements#598",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.getElements()",
        "snippet": "    public synchronized double[] getElements() {\n        double[] elementArray = new double[numElements];\n        System.arraycopy( internalArray, startIndex, elementArray, 0,\n                numElements);\n        return elementArray;\n    }\n",
        "begin_line": 598,
        "end_line": 603,
        "comment": "\n     * Returns a double array containing the elements of this\n     * <code>ResizableArray</code>.  This method returns a copy, not a\n     * reference to the underlying array, so that changes made to the returned\n     *  array have no effect on this <code>ResizableArray.</code>\n     * @return the double array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.setInitialCapacity#754",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.setInitialCapacity(int)",
        "snippet": "    protected void setInitialCapacity(int initialCapacity) {\n        if (initialCapacity > 0) {\n            synchronized(this) {\n                this.initialCapacity = initialCapacity;\n            }\n        } else {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE,\n                    initialCapacity);\n        }\n    }\n",
        "begin_line": 754,
        "end_line": 764,
        "comment": "\n     * Sets the initial capacity.  Should only be invoked by constructors.\n     *\n     * @param initialCapacity of the array\n     * @throws IllegalArgumentException if <code>initialCapacity</code> is not\n     *         positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.shouldContract#799",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math3.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math3.util.ResizableDoubleArray.shouldContract()",
        "snippet": "    private synchronized boolean shouldContract() {\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            return (internalArray.length / ((float) numElements)) > contractionCriteria;\n        } else {\n            return (internalArray.length - numElements) > contractionCriteria;\n        }\n    }\n",
        "begin_line": 799,
        "end_line": 805,
        "comment": "\n     * Returns true if the internal storage array has too many unused\n     * storage positions.\n     *\n     * @return true if array satisfies the contraction criteria\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.floor#3331",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
        "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3331,
        "end_line": 3352,
        "comment": " Get the largest whole number smaller than x.\n     * @param x number from which floor is requested\n     * @return a double number f such that f is an integer f <= x < f + 1.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.ceil#3358",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.ceil(double)",
        "snippet": "    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3358,
        "end_line": 3377,
        "comment": " Get the smallest whole number larger than x.\n     * @param x number from which ceil is requested\n     * @return a double number c such that c is an integer c - 1.0 < x <= c\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArithmeticUtils.factorial#298",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java",
        "class_name": "org.apache.commons.math3.util.ArithmeticUtils",
        "signature": "org.apache.commons.math3.util.ArithmeticUtils.factorial(int)",
        "snippet": "    public static long factorial(final int n) {\n        if (n < 0) {\n            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                                           n);\n        }\n        if (n > 20) {\n            throw new MathArithmeticException();\n        }\n        return FACTORIALS[n];\n    }\n",
        "begin_line": 298,
        "end_line": 307,
        "comment": "\n     * Returns n!. Shorthand for {@code n} <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers {@code 1,...,n}.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> {@code n >= 0} (otherwise\n     * {@code IllegalArgumentException} is thrown)</li>\n     * <li> The result is small enough to fit into a {@code long}. The\n     * largest value of {@code n} for which {@code n!} <\n     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n     * an {@code ArithMeticException } is thrown.</li>\n     * </ul>\n     * </p>\n     *\n     * @param n argument\n     * @return {@code n!}\n     * @throws MathArithmeticException if the result is too large to be represented\n     * by a {@code long}.\n     * @throws NotPositiveException if {@code n < 0}.\n     * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n     * large to fit in a {@code long}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "RandomDataImpl.RandomDataImpl#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/RandomDataImpl.java",
        "class_name": "org.apache.commons.math3.random.RandomDataImpl",
        "signature": "org.apache.commons.math3.random.RandomDataImpl.RandomDataImpl()",
        "snippet": "    public RandomDataImpl() {\n    }\n",
        "begin_line": 168,
        "end_line": 169,
        "comment": "\n     * Construct a RandomDataImpl, using a default random generator as the source\n     * of randomness.\n     *\n     * <p>The default generator is a {@link Well19937c} seeded\n     * with {@code System.currentTimeMillis() + System.identityHashCode(this))}.\n     * The generator is initialized and seeded on first use.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractIntegerDistribution.AbstractIntegerDistribution#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractIntegerDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractIntegerDistribution.AbstractIntegerDistribution()",
        "snippet": "    protected AbstractIntegerDistribution() { }\n",
        "begin_line": 47,
        "end_line": 47,
        "comment": " Default constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            double numer = bits & 0x3ffffffffffL;\n            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1105,
        "end_line": 1325,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0889
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.pow#1419",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.pow(double, double)",
        "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n",
        "begin_line": 1419,
        "end_line": 1577,
        "comment": "\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0889
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntA#6141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA()",
        "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A.clone();\n    }\n",
        "begin_line": 6141,
        "end_line": 6143,
        "comment": "\n     * Load \"EXP_INT_A\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntB#6149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB()",
        "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B.clone();\n    }\n",
        "begin_line": 6149,
        "end_line": 6151,
        "comment": "\n     * Load \"EXP_INT_B\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracA#6157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA()",
        "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A.clone();\n    }\n",
        "begin_line": 6157,
        "end_line": 6159,
        "comment": "\n     * Load \"EXP_FRAC_A\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracB#6165",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB()",
        "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B.clone();\n    }\n",
        "begin_line": 6165,
        "end_line": 6167,
        "comment": "\n     * Load \"EXP_FRAC_B\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0847
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.log#1095",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double)",
        "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }\n",
        "begin_line": 1095,
        "end_line": 1097,
        "comment": "\n     * Natural logarithm.\n     *\n     * @param x   a double\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0847
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealDistribution.AbstractRealDistribution#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java",
        "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
        "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.AbstractRealDistribution()",
        "snippet": "    protected AbstractRealDistribution() { }\n",
        "begin_line": 53,
        "end_line": 53,
        "comment": " Default constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0493
        },
        "num_failing_tests": 1
    }
]