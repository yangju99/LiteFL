[
    {
        "name": "Vector3D.getNormSq#222",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.getNormSq()",
        "snippet": "    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }\n",
        "begin_line": 222,
        "end_line": 225,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.geometry.Vector": " Get the square of the norm for the vector.\n     * @return square of the Euclidean norm for the vector\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Rotation.Rotation#313",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Rotation",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Rotation.Rotation(org.apache.commons.math.geometry.euclidean.threed.Vector3D, org.apache.commons.math.geometry.euclidean.threed.Vector3D, org.apache.commons.math.geometry.euclidean.threed.Vector3D, org.apache.commons.math.geometry.euclidean.threed.Vector3D)",
        "snippet": "  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // preliminary computation\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  if (c == 0) {\n    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n    // we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        // the (q1, q2, q3) vector is aligned with everything\n        // this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      // we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  // compute the vectorial part\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  // compute the scalar part\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n",
        "begin_line": 313,
        "end_line": 390,
        "comment": " Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Rotation.getQ0#480",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Rotation",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Rotation.getQ0()",
        "snippet": "  public double getQ0() {\n    return q0;\n  }\n",
        "begin_line": 480,
        "end_line": 482,
        "comment": " Get the scalar coordinate of the quaternion.\n   * @return scalar coordinate of the quaternion\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z);\n    }\n",
        "begin_line": 134,
        "end_line": 138,
        "comment": " Linear constructor\n     * Build a vector from two other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "Rotation.Rotation#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Rotation",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Rotation.Rotation(double, double, double, double, boolean)",
        "snippet": "  public Rotation(double q0, double q1, double q2, double q3,\n                  boolean needsNormalization) {\n\n    if (needsNormalization) {\n      // normalization preprocessing\n      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n      q0 *= inv;\n      q1 *= inv;\n      q2 *= inv;\n      q3 *= inv;\n    }\n\n    this.q0 = q0;\n    this.q1 = q1;\n    this.q2 = q2;\n    this.q3 = q3;\n\n  }\n",
        "begin_line": 133,
        "end_line": 150,
        "comment": " Build a rotation from the quaternion coordinates.\n   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n   * the constructor can normalize it in a preprocessing step.</p>\n   * <p>Note that some conventions put the scalar part of the quaternion\n   * as the 4<sup>th</sup> component and the vector part as the first three\n   * components. This is <em>not</em> our convention. We put the scalar part\n   * as the first component.</p>\n   * @param q0 scalar part of the quaternion\n   * @param q1 first coordinate of the vectorial part of the quaternion\n   * @param q2 second coordinate of the vectorial part of the quaternion\n   * @param q3 third coordinate of the vectorial part of the quaternion\n   * @param needsNormalization if true, the coordinates are considered\n   * not to be normalized, a normalization preprocessing step is performed\n   * before using them\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#120",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }\n",
        "begin_line": 120,
        "end_line": 124,
        "comment": " Multiplicative constructor\n     * Build a vector from another one and a scale factor.\n     * The vector built will be a * u\n     * @param a scale factor\n     * @param u base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.linearCombination#2360",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.linearCombination(double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they shoud NOT be simplified, as they\n        // do use IEEE753 floating point arithmetic rouding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        return s12High + (prod1Low + prod2Low + s12Low);\n\n    }\n",
        "begin_line": 2360,
        "end_line": 2407,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n     * so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects. It is based\n     * on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub>\n     * @see #linearCombination(double, double, double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.subtract#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.subtract(org.apache.commons.math.geometry.Vector<org.apache.commons.math.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }\n",
        "begin_line": 260,
        "end_line": 263,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.geometry.Vector": null,
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.crossProduct#436",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math.geometry.Vector<org.apache.commons.math.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(MathUtils.linearCombination(y, v3.z, -z, v3.y),\n                            MathUtils.linearCombination(z, v3.x, -x, v3.z),\n                            MathUtils.linearCombination(x, v3.y, -y, v3.x));\n    }\n",
        "begin_line": 436,
        "end_line": 441,
        "comment": " Compute the cross-product of the instance with another vector.\n     * @param v other vector\n     * @return the cross product this ^ v as a new Vector3D\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.linearCombination#2432",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.linearCombination(double, double, double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they shoud NOT be simplified, as they\n        // do use IEEE753 floating point arithmetic rouding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        return s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n    }\n",
        "begin_line": 2432,
        "end_line": 2497,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * to high accuracy. It does so by using specific multiplication and\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\n     * It is based on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @param a3 first factor of the third term\n     * @param b3 second factor of the third term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * @see #linearCombination(double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.dotProduct#427",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math.geometry.Vector<org.apache.commons.math.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public double dotProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return MathUtils.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }\n",
        "begin_line": 427,
        "end_line": 430,
        "comment": " {@inheritDoc}\n     * <p>\n     * The implementation uses specific multiplication and addition\n     * algorithms to preserve accuracy and reduce cancellation effects.\n     * It should be very accurate even for nearly orthogonal vectors.\n     * </p>\n     * @see MathUtils#linearCombination(double, double, double, double, double, double)\n     ",
        "resolved_comments": {
            "org.apache.commons.math.geometry.Vector": null,
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getX#180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 180,
        "end_line": 182,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getY#188",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.getY()",
        "snippet": "    public double getY() {\n        return y;\n    }\n",
        "begin_line": 188,
        "end_line": 190,
        "comment": " Get the ordinate of the vector.\n     * @return ordinate of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getZ#196",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.getZ()",
        "snippet": "    public double getZ() {\n        return z;\n    }\n",
        "begin_line": 196,
        "end_line": 198,
        "comment": " Get the height of the vector.\n     * @return height of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#301",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 301,
        "end_line": 303,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowexp#1011",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowexp(double, double[])",
        "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1011,
        "end_line": 1038,
        "comment": "\n     *  For x between 0 and 1, returns exp(x), uses extended precision\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n     *  @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.split#1045",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.split(double, double[])",
        "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n",
        "begin_line": 1045,
        "end_line": 1055,
        "comment": " Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.resplit#1061",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
        "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n",
        "begin_line": 1061,
        "end_line": 1074,
        "comment": " Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitMult#1081",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[])",
        "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n",
        "begin_line": 1081,
        "end_line": 1087,
        "comment": " Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitAdd#1094",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[])",
        "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n",
        "begin_line": 1094,
        "end_line": 1099,
        "comment": " Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitReciprocal#1119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[])",
        "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n",
        "begin_line": 1119,
        "end_line": 1147,
        "comment": " Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.quadMult#1154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[])",
        "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n",
        "begin_line": 1154,
        "end_line": 1201,
        "comment": " Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.expint#1208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.expint(int, double[])",
        "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1208,
        "end_line": 1246,
        "comment": " Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowLog#1742",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
        "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n",
        "begin_line": 1742,
        "end_line": 1784,
        "comment": " xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowSin#1792",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowSin(double, double[])",
        "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1792,
        "end_line": 1826,
        "comment": "\n     * For x between 0 and pi/4 compute sine.\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowCos#1834",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowCos(double, double[])",
        "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1834,
        "end_line": 1869,
        "comment": "\n     *  For x between 0 and pi/4 compute cosine\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.buildSinCosTables#1873",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
        "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n",
        "begin_line": 1873,
        "end_line": 1965,
        "comment": " Build the sine and cosine tables.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D.Vector3D(double, double, double)",
        "snippet": "    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n",
        "begin_line": 93,
        "end_line": 97,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @see #getX()\n     * @see #getY()\n     * @see #getZ()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    }
]