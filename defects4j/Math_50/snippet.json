[
    {
        "name": "BaseSecantSolver.doSolve#128",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseSecantSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseSecantSolver.doSolve()",
        "snippet": "    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n",
        "begin_line": 128,
        "end_line": 253,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the root.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the initial search interval does not bracket\n     * a root and the solver requires it.\n     ",
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegulaFalsiSolver.RegulaFalsiSolver#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.RegulaFalsiSolver",
        "signature": "org.apache.commons.math.analysis.solvers.RegulaFalsiSolver.RegulaFalsiSolver()",
        "snippet": "    public RegulaFalsiSolver() {\n        super(DEFAULT_ABSOLUTE_ACCURACY, Method.REGULA_FALSI);\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": " Construct a solver with default accuracy (1e-6). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseSecantSolver.solve#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseSecantSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseSecantSolver.solve(int, org.apache.commons.math.analysis.UnivariateRealFunction, double, double, double)",
        "snippet": "    @Override\n    public double solve(final int maxEval, final UnivariateRealFunction f,\n                        final double min, final double max, final double startValue) {\n        return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);\n    }\n",
        "begin_line": 121,
        "end_line": 125,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.solve#194",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(int, FUNC, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max) {\n        return solve(maxEval, f, min, max, min + 0.5 * (max - min));\n    }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Solve for a zero root in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseSecantSolver.BaseSecantSolver#67",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseSecantSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseSecantSolver.BaseSecantSolver(double, org.apache.commons.math.analysis.solvers.BaseSecantSolver.Method)",
        "snippet": "    protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n        super(absoluteAccuracy);\n        this.allowed = AllowedSolution.ANY_SIDE;\n        this.method = method;\n    }\n",
        "begin_line": 67,
        "end_line": 71,
        "comment": "\n     * Construct a solver.\n     *\n     * @param absoluteAccuracy absolute accuracy\n     * @param method <em>Secant</em>-based root-finding method to use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3409",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3409,
        "end_line": 3411,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3924",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3924,
        "end_line": 3942,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifyBracketing#368",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifyBracketing(org.apache.commons.math.analysis.UnivariateRealFunction, double, double)",
        "snippet": "    public static void verifyBracketing(UnivariateRealFunction function,\n                                        final double lower,\n                                        final double upper) {\n        if (function == null) {\n            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        }\n        verifyInterval(lower, upper);\n        if (!isBracketing(function, lower, upper)) {\n            throw new NoBracketingException(lower, upper,\n                                            function.value(lower),\n                                            function.value(upper));\n        }\n    }\n",
        "begin_line": 368,
        "end_line": 380,
        "comment": "\n     * Check that the endpoints specify an interval and the end points\n     * bracket a root.\n     *\n     * @param function Function.\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NoBracketingException if function has the same sign at the\n     * endpoints.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the absolute accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getRelativeAccuracy#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the relative accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy()",
        "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }\n",
        "begin_line": 139,
        "end_line": 141,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the function value accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.verifyBracketing#280",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.verifyBracketing(double, double)",
        "snippet": "    protected void verifyBracketing(final double lower,\n                                    final double upper) {\n        UnivariateRealSolverUtils.verifyBracketing(function, lower, upper);\n    }\n",
        "begin_line": 280,
        "end_line": 283,
        "comment": "\n     * Check that the endpoints specify an interval and the function takes\n     * opposite signs at the endpoints.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws org.apache.commons.math.exception.NoBracketingException if\n     * the function has the same sign at the endpoints.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowexp#1011",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowexp(double, double[])",
        "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1011,
        "end_line": 1038,
        "comment": "\n     *  For x between 0 and 1, returns exp(x), uses extended precision\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n     *  @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.split#1045",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.split(double, double[])",
        "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n",
        "begin_line": 1045,
        "end_line": 1055,
        "comment": " Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.resplit#1061",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
        "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n",
        "begin_line": 1061,
        "end_line": 1074,
        "comment": " Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitMult#1081",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[])",
        "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n",
        "begin_line": 1081,
        "end_line": 1087,
        "comment": " Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitAdd#1094",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[])",
        "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n",
        "begin_line": 1094,
        "end_line": 1099,
        "comment": " Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitReciprocal#1119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[])",
        "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n",
        "begin_line": 1119,
        "end_line": 1147,
        "comment": " Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.quadMult#1154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[])",
        "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n",
        "begin_line": 1154,
        "end_line": 1201,
        "comment": " Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.expint#1208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.expint(int, double[])",
        "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1208,
        "end_line": 1246,
        "comment": " Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowLog#1742",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
        "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n",
        "begin_line": 1742,
        "end_line": 1784,
        "comment": " xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowSin#1792",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowSin(double, double[])",
        "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1792,
        "end_line": 1826,
        "comment": "\n     * For x between 0 and pi/4 compute sine.\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowCos#1834",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowCos(double, double[])",
        "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1834,
        "end_line": 1869,
        "comment": "\n     *  For x between 0 and pi/4 compute cosine\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.buildSinCosTables#1873",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
        "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n",
        "begin_line": 1873,
        "end_line": 1965,
        "comment": " Build the sine and cosine tables.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.isBracketing#302",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.isBracketing(org.apache.commons.math.analysis.UnivariateRealFunction, double, double)",
        "snippet": "    public static boolean isBracketing(UnivariateRealFunction function,\n                                       final double lower,\n                                       final double upper) {\n        if (function == null) {\n            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        }\n        final double fLo = function.value(lower);\n        final double fHi = function.value(upper);\n        return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n    }\n",
        "begin_line": 302,
        "end_line": 311,
        "comment": "\n     * Check whether the interval bounds bracket a root. That is, if the\n     * values at the endpoints are not equal to zero, then the function takes\n     * opposite signs at the endpoints.\n     *\n     * @param function Function.\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @return {@code true} if the function values have opposite signs at the\n     * given points.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifyInterval#334",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifyInterval(double, double)",
        "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper) {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }\n",
        "begin_line": 334,
        "end_line": 340,
        "comment": "\n     * Check that the endpoints specify an interval.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseSecantSolver.solve#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseSecantSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseSecantSolver.solve(int, org.apache.commons.math.analysis.UnivariateRealFunction, double, double, double, org.apache.commons.math.analysis.solvers.AllowedSolution)",
        "snippet": "    public double solve(final int maxEval, final UnivariateRealFunction f,\n                        final double min, final double max, final double startValue,\n                        final AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n",
        "begin_line": 113,
        "end_line": 118,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": "\n     * Solve for a zero in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return A value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     ",
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver(double)",
        "snippet": "    protected BaseAbstractUnivariateRealSolver(final double absoluteAccuracy) {\n        this(DEFAULT_RELATIVE_ACCURACY,\n             absoluteAccuracy,\n             DEFAULT_FUNCTION_VALUE_ACCURACY);\n    }\n",
        "begin_line": 64,
        "end_line": 68,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealSolver.AbstractUnivariateRealSolver#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver.AbstractUnivariateRealSolver(double)",
        "snippet": "    protected AbstractUnivariateRealSolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.checkNotNull#2332",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 2332,
        "end_line": 2337,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Set the upper limit for the counter.\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            throw new MaxCountExceededException(maximalCount);\n        }\n    }\n",
        "begin_line": 83,
        "end_line": 87,
        "comment": "\n     * Add one to the current iteration count.\n     *\n     * @throws MaxCountExceededException at counter exhaustion.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n     * Reset the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver(double, double, double)",
        "snippet": "    protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMin#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMax#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.computeObjectiveValue#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.setup#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.setup(int, FUNC, double, double, double)",
        "snippet": "    protected void setup(int maxEval,\n                         FUNC f,\n                         double min, double max,\n                         double startValue) {\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 168,
        "end_line": 182,
        "comment": "\n     * Prepare for computation.\n     * Subclasses must call this method if they override any of the\n     * {@code solve} methods.\n     *\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.solve#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(int, FUNC, double, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n        // Initialization.\n        setup(maxEval, f, min, max, startValue);\n\n        // Perform computation.\n        return doSolve();\n    }\n",
        "begin_line": 185,
        "end_line": 191,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.incrementEvaluationCount#292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount() {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }\n",
        "begin_line": 292,
        "end_line": 298,
        "comment": "\n     * Increment the evaluation count by one.\n     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n     * It is provided for subclasses that do not exclusively use\n     * {@code computeObjectiveValue} to solve the function.\n     * See e.g. {@link AbstractDifferentiableUnivariateRealSolver}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    }
]