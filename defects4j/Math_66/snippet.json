[
    {
        "name": "AbstractUnivariateRealOptimizer.getEvaluations#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations;\n    }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Get the number of evaluations of the objective function.\n     * <p>\n     * The number of evaluations corresponds to the last call to the\n     * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method. It is 0 if the method has not been called yet.\n     * </p>\n     * @return the number of evaluations of the objective function.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.866
        },
        "num_failing_tests": 3
    },
    {
        "name": "ConvergingAlgorithmImpl.getIterationCount#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getIterationCount()",
        "snippet": "    public int getIterationCount() {\n        return iterationCount;\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the number of iterations in the last run of the algorithm.\n     * <p>\n     * This is mainly meant for testing purposes. It may occasionally\n     * help track down performance problems: if the iteration count\n     * is notoriously high, check whether the problem is evaluated\n     * properly, and whether another algorithm is more amenable to the\n     * problem.</p>\n     *\n     * @return the last iteration count.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     "
        },
        "susp": {
            "ochiai_susp": 0.75
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getFunctionValue#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getFunctionValue()",
        "snippet": "    public double getFunctionValue() {\n        if (functionValue == Double.NaN) {\n            final double opt = getResult();\n            try {\n                functionValue = function.value(opt);\n            } catch (FunctionEvaluationException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return functionValue;\n    }\n",
        "begin_line": 104,
        "end_line": 114,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Get the result of the last run of the optimizer.\n     *\n     * @return the value of the function at the optimum.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer(org.apache.commons.math.optimization.UnivariateRealOptimizer, int, org.apache.commons.math.random.RandomGenerator)",
        "snippet": "    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n",
        "begin_line": 78,
        "end_line": 88,
        "comment": "\n     * Create a multi-start optimizer from a single-start optimizer\n     * @param optimizer single-start optimizer to wrap\n     * @param starts number of starts to perform (including the\n     * first one), multi-start is disabled if value is less than or\n     * equal to 1\n     * @param generator random generator to use for restarts\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setMaximalIterationCount#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaximalIterationCount(int)",
        "snippet": "    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the upper limit for the number of iterations.\n     * <p>\n     * Usually a high iteration count indicates convergence problems. However,\n     * the \"reasonable value\" varies widely for different algorithms. Users are\n     * advised to use the default value supplied by the algorithm.</p>\n     * <p>\n     * A {@link ConvergenceException} will be thrown if this number\n     * is exceeded.</p>\n     *\n     * @param count maximum number of iterations\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setMaxEvaluations#156",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n",
        "begin_line": 156,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Set the maximal number of functions evaluations.\n     * @param maxEvaluations maximal number of function evaluations\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getOptima#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptima()",
        "snippet": "    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n",
        "begin_line": 192,
        "end_line": 197,
        "comment": " Get all the optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>The optimizer stores all the optima found during a set of\n     * restarts. The {@link #optimize(UnivariateRealFunction, GoalType,\n     * double, double) optimize} method returns the best point only. This\n     * method returns all the points found at the end of each starts,\n     * including the best one already returned by the {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method.\n     * </p>\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptimaValues()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getOptimaValues#218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptimaValues()",
        "snippet": "    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }\n",
        "begin_line": 218,
        "end_line": 223,
        "comment": " Get all the function values at optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptima()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.optimize#226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws ConvergenceException,\n            FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        // multi-start loop\n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        // sort the optima from best to worst, followed by NaN elements\n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                // the current element should be inserted closer to the beginning\n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        // return the found point given the best objective function value\n        return optima[0];\n\n    }\n",
        "begin_line": 226,
        "end_line": 310,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Find an optimum in the given interval.\n     * <p>\n     * An optimizer may require that the interval brackets a single optimum.\n     * </p>\n     * @param f the function to optimize.\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n     * or {@link GoalType#MINIMIZE}.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return a value where the function is optimum.\n     * @throws ConvergenceException if the maximum iteration count is exceeded\n     * or the optimizer detects convergence problems otherwise.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if min > max or the endpoints do not\n     * satisfy the requirements specified by the optimizer.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 2
    },
    {
        "name": "BrentOptimizer.localMin#93",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.localMin(boolean, org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double, double, double, double)",
        "snippet": "    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n",
        "begin_line": 93,
        "end_line": 244,
        "comment": "\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6667
        },
        "num_failing_tests": 4
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#43",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer()",
        "snippet": "    public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }\n",
        "begin_line": 43,
        "end_line": 48,
        "comment": "\n     * Construct a solver.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "BrentOptimizer.optimize#59",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double, double)",
        "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }\n",
        "begin_line": 59,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer()",
        "snippet": "    protected AbstractUnivariateRealOptimizer() {}\n",
        "begin_line": 82,
        "end_line": 82,
        "comment": "\n     * Default constructor.\n     * To be removed once the single non-default one has been removed.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.setResult#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setResult(double, double, int)",
        "snippet": "    protected final void setResult(final double x, final double fx,\n                                   final int iterationCount) {\n        this.result         = x;\n        this.functionValue  = fx;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }\n",
        "begin_line": 124,
        "end_line": 130,
        "comment": "\n     * Convenience function for implementations.\n     *\n     * @param x the result to set\n     * @param fx the result to set\n     * @param iterationCount the iteration count to set\n     * @deprecated in 2.2 (no alternative).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.clearResult#136",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.clearResult()",
        "snippet": "    protected final void clearResult() {\n        this.resultComputed = false;\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "\n     * Convenience function for implementations.\n     * @deprecated in 2.2 (no alternative).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.setMaxEvaluations#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Set the maximal number of functions evaluations.\n     * @param maxEvaluations maximal number of function evaluations\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getGoalType#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractUnivariateRealOptimizer.computeObjectiveValue#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.computeObjectiveValue(org.apache.commons.math.analysis.UnivariateRealFunction, double)",
        "snippet": "    protected double computeObjectiveValue(final UnivariateRealFunction f,\n                                           final double point)\n        throws FunctionEvaluationException {\n        if (++evaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        return f.value(point);\n    }\n",
        "begin_line": 190,
        "end_line": 198,
        "comment": "\n     * Compute the objective function value.\n     * @param f objective function\n     * @param point point at which the objective function must be evaluated\n     * @return objective function value at specified point\n     * @exception FunctionEvaluationException if the function cannot be evaluated\n     * or the maximal number of iterations is exceeded\n     * @deprecated in 2.2. Use this {@link #computeObjectiveValue(double)\n     * replacement} instead.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl()",
        "snippet": "    protected ConvergingAlgorithmImpl() {}\n",
        "begin_line": 78,
        "end_line": 78,
        "comment": "\n     * Default constructor.\n     *\n     * @since 2.2\n     * @deprecated in 2.2 (to be removed as soon as the single non-default one\n     * has been removed).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
        "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the absolute accuracy.\n     * <p>\n     * The default is usually chosen so that results in the interval\n     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n     * expected absolute value of your results is of much smaller magnitude, set\n     * this to a smaller value.</p>\n     * <p>\n     * Algorithms are advised to do a plausibility check with the relative\n     * accuracy, but clients should not rely on this.</p>\n     *\n     * @param accuracy the accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     * the solver or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.getAbsoluteAccuracy#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual absolute accuracy.\n     *\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.setMaximalIterationCount#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
        "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the upper limit for the number of iterations.\n     * <p>\n     * Usually a high iteration count indicates convergence problems. However,\n     * the \"reasonable value\" varies widely for different algorithms. Users are\n     * advised to use the default value supplied by the algorithm.</p>\n     * <p>\n     * A {@link ConvergenceException} will be thrown if this number\n     * is exceeded.</p>\n     *\n     * @param count maximum number of iterations\n     "
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.setRelativeAccuracy#116",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setRelativeAccuracy(double)",
        "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        relativeAccuracy = accuracy;\n    }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the relative accuracy.\n     * <p>\n     * This is used to stop iterations if the absolute accuracy can't be\n     * achieved due to large values or short mantissa length.</p>\n     * <p>\n     * If this should be the primary criterion for convergence rather then a\n     * safety measure, set the absolute accuracy to a ridiculously small value,\n     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n     *\n     * @param accuracy the relative accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     *  the algorithm or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvergingAlgorithmImpl.getRelativeAccuracy#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual relative accuracy.\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 4
    },
    {
        "name": "BrentOptimizer.optimize#65",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6124
        },
        "num_failing_tests": 3
    },
    {
        "name": "LocalizedFormats.LocalizedFormats#305",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/LocalizedFormats.java",
        "class_name": "org.apache.commons.math.util.LocalizedFormats",
        "signature": "org.apache.commons.math.util.LocalizedFormats.LocalizedFormats(java.lang.String)",
        "snippet": "    private LocalizedFormats(final String sourceFormat) {\n        this.sourceFormat = sourceFormat;\n    }\n",
        "begin_line": 305,
        "end_line": 307,
        "comment": " Simple constructor.\n     * @param sourceFormat source English format to use when no\n     * localized version is available\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 2
    },
    {
        "name": "ResizableDoubleArray.ResizableDoubleArray#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.ResizableDoubleArray()",
        "snippet": "    public ResizableDoubleArray() {\n        internalArray = new double[initialCapacity];\n    }\n",
        "begin_line": 142,
        "end_line": 144,
        "comment": "\n     * Create a ResizableArray with default properties.\n     * <ul>\n     * <li><code>initialCapacity = 16</code></li>\n     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n     * <li><code>expansionFactor = 2.5</code></li>\n     * <li><code>contractionFactor = 2.0</code></li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.addElement#266",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.addElement(double)",
        "snippet": "    public synchronized void addElement(double value) {\n        numElements++;\n        if ((startIndex + numElements) > internalArray.length) {\n            expand();\n        }\n        internalArray[startIndex + (numElements - 1)] = value;\n        if (shouldContract()) {\n            contract();\n        }\n    }\n",
        "begin_line": 266,
        "end_line": 275,
        "comment": "\n     * Adds an element to the end of this expandable array.\n     *\n     * @param value to be added to end of array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.contract#381",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.contract()",
        "snippet": "    public synchronized void contract() {\n        double[] tempArray = new double[numElements + 1];\n\n        // Copy and swap - copy only the element array from the src array.\n        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n        internalArray = tempArray;\n\n        // Reset the start index to zero\n        startIndex = 0;\n    }\n",
        "begin_line": 381,
        "end_line": 390,
        "comment": "\n     * Contracts the storage array to the (size of the element set) + 1 - to\n     * avoid a zero length array. This function also resets the startIndex to\n     * zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.expand#473",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.expand()",
        "snippet": "    protected synchronized void expand() {\n\n        // notice the use of Math.ceil(), this guarantees that we will always\n        // have an array of at least currentSize + 1.   Assume that the\n        // current initial capacity is 1 and the expansion factor\n        // is 1.000000000000000001.  The newly calculated size will be\n        // rounded up to 2 after the multiplication is performed.\n        int newSize = 0;\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n        } else {\n            newSize = internalArray.length + Math.round(expansionFactor);\n        }\n        double[] tempArray = new double[newSize];\n\n        // Copy and swap\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n        internalArray = tempArray;\n    }\n",
        "begin_line": 473,
        "end_line": 491,
        "comment": "\n     * Expands the internal storage array using the expansion factor.\n     * <p>\n     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n     * after expansion will be <code>internalArray.length + expansionFactor</code>\n     * </p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.getNumElements#602",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.getNumElements()",
        "snippet": "    public synchronized int getNumElements() {\n        return numElements;\n    }\n",
        "begin_line": 602,
        "end_line": 604,
        "comment": "\n     * Returns the number of elements currently in the array.  Please note\n     * that this is different from the length of the internal storage array.\n     *\n     * @return number of elements\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.getInternalValues#635",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.getInternalValues()",
        "snippet": "    public synchronized double[] getInternalValues() {\n        return internalArray;\n    }\n",
        "begin_line": 635,
        "end_line": 637,
        "comment": "\n     * Returns the internal storage array.  Note that this method returns\n     * a reference to the internal storage array, not a copy, and to correctly\n     * address elements of the array, the <code>startIndex</code> is\n     * required (available via the {@link #start} method).  This method should\n     * only be used in cases where copying the internal array is not practical.\n     * The {@link #getElements} method should be used in all other cases.\n     *\n     *\n     * @return the internal storage array used by this object\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.shouldContract#770",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.shouldContract()",
        "snippet": "    private synchronized boolean shouldContract() {\n        if (expansionMode == MULTIPLICATIVE_MODE) {\n            return (internalArray.length / ((float) numElements)) > contractionCriteria;\n        } else {\n            return (internalArray.length - numElements) > contractionCriteria;\n        }\n    }\n",
        "begin_line": 770,
        "end_line": 776,
        "comment": "\n     * Returns true if the internal storage array has too many unused\n     * storage positions.\n     *\n     * @return true if array satisfies the contraction criteria\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ResizableDoubleArray.start#787",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java",
        "class_name": "org.apache.commons.math.util.ResizableDoubleArray",
        "signature": "org.apache.commons.math.util.ResizableDoubleArray.start()",
        "snippet": "    public synchronized int start() {\n        return startIndex;\n    }\n",
        "begin_line": 787,
        "end_line": 789,
        "comment": "\n     * Returns the starting index of the internal array.  The starting index is\n     * the position of the first addressable element in the internal storage\n     * array.  The addressable elements in the array are <code>\n     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n     * </code>\n     *\n     * @return starting index\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "SumOfSquares.SumOfSquares#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java",
        "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares",
        "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares.SumOfSquares()",
        "snippet": "    public SumOfSquares() {\n        n = 0;\n        value = Double.NaN;\n    }\n",
        "begin_line": 52,
        "end_line": 55,
        "comment": "\n     * Create a SumOfSquares instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "SumOfLogs.SumOfLogs#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java",
        "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs",
        "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs.SumOfLogs()",
        "snippet": "    public SumOfLogs() {\n       value = 0d;\n       n = 0;\n    }\n",
        "begin_line": 60,
        "end_line": 63,
        "comment": "\n     * Create a SumOfLogs instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sum.Sum#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java",
        "class_name": "org.apache.commons.math.stat.descriptive.summary.Sum",
        "signature": "org.apache.commons.math.stat.descriptive.summary.Sum.Sum()",
        "snippet": "    public Sum() {\n        n = 0;\n        value = Double.NaN;\n    }\n",
        "begin_line": 53,
        "end_line": 56,
        "comment": "\n     * Create a Sum instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sum.evaluate#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java",
        "class_name": "org.apache.commons.math.stat.descriptive.summary.Sum",
        "signature": "org.apache.commons.math.stat.descriptive.summary.Sum.evaluate(double[], int, int)",
        "snippet": "    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n        double sum = Double.NaN;\n        if (test(values, begin, length)) {\n            sum = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                sum += values[i];\n            }\n        }\n        return sum;\n    }\n",
        "begin_line": 119,
        "end_line": 129,
        "comment": "\n     * The sum of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     *\n     * @param values the input array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the sum of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null or the array index\n     *  parameters are not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Percentile.Percentile#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Percentile",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Percentile.Percentile()",
        "snippet": "    public Percentile() {\n        this(50.0);\n    }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "\n     * Constructs a Percentile with a default quantile\n     * value of 50.0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Percentile.Percentile#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Percentile",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Percentile.Percentile(double)",
        "snippet": "    public Percentile(final double p) {\n        setQuantile(p);\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n     * Constructs a Percentile with the specific quantile value.\n     * @param p the quantile\n     * @throws IllegalArgumentException  if p is not greater than 0 and less\n     * than or equal to 100\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Percentile.evaluate#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Percentile",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Percentile.evaluate(double[], int, int)",
        "snippet": "    @Override\n    public double evaluate( final double[] values, final int start, final int length) {\n        return evaluate(values, start, length, quantile);\n    }\n",
        "begin_line": 161,
        "end_line": 164,
        "comment": "\n     * Returns an estimate of the <code>quantile</code>th percentile of the\n     * designated values in the <code>values</code> array.  The quantile\n     * estimated is determined by the <code>quantile</code> property.\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n     * <li>Returns (for any value of <code>quantile</code>)\n     * <code>values[begin]</code> if <code>length = 1 </code></li>\n     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n     * is null,  or <code>start</code> or <code>length</code>\n     * is invalid</li>\n     * </ul></p>\n     * <p>\n     * See {@link Percentile} for a description of the percentile estimation\n     * algorithm used.</p>\n     *\n     * @param values the input array\n     * @param start index of the first array element to include\n     * @param length the number of elements to include\n     * @return the percentile value\n     * @throws IllegalArgumentException if the parameters are not valid\n     *\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Percentile.evaluate#196",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Percentile",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Percentile.evaluate(double[], int, int, double)",
        "snippet": "    public double evaluate(final double[] values, final int begin,\n            final int length, final double p) {\n\n        test(values, begin, length);\n\n        if ((p > 100) || (p <= 0)) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n        }\n        if (length == 0) {\n            return Double.NaN;\n        }\n        if (length == 1) {\n            return values[begin]; // always return single value for n = 1\n        }\n        double n = length;\n        double pos = p * (n + 1) / 100;\n        double fpos = Math.floor(pos);\n        int intPos = (int) fpos;\n        double dif = pos - fpos;\n        double[] sorted = new double[length];\n        System.arraycopy(values, begin, sorted, 0, length);\n        Arrays.sort(sorted);\n\n        if (pos < 1) {\n            return sorted[0];\n        }\n        if (pos >= n) {\n            return sorted[length - 1];\n        }\n        double lower = sorted[intPos - 1];\n        double upper = sorted[intPos];\n        return lower + dif * (upper - lower);\n    }\n",
        "begin_line": 196,
        "end_line": 229,
        "comment": "\n     * Returns an estimate of the <code>p</code>th percentile of the values\n     * in the <code>values</code> array, starting with the element in (0-based)\n     * position <code>begin</code> in the array and including <code>length</code>\n     * values.\n     * <p>\n     * Calls to this method do not modify the internal <code>quantile</code>\n     * state of this statistic.</p>\n     * <p>\n     * <ul>\n     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n     *  if <code>length = 1 </code></li>\n     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n     *  is null , <code>begin</code> or <code>length</code> is invalid, or\n     * <code>p</code> is not a valid quantile value (p must be greater than 0\n     * and less than or equal to 100)</li>\n     * </ul></p>\n     * <p>\n     * See {@link Percentile} for a description of the percentile estimation\n     * algorithm used.</p>\n     *\n     * @param values array of input values\n     * @param p  the percentile to compute\n     * @param begin  the first (0-based) element to include in the computation\n     * @param length  the number of array elements to include\n     * @return  the percentile value\n     * @throws IllegalArgumentException if the parameters are not valid or the\n     * input array is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Percentile.setQuantile#249",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Percentile",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Percentile.setQuantile(double)",
        "snippet": "    public void setQuantile(final double p) {\n        if (p <= 0 || p > 100) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE, p);\n        }\n        quantile = p;\n    }\n",
        "begin_line": 249,
        "end_line": 255,
        "comment": "\n     * Sets the value of the quantile field (determines what percentile is\n     * computed when evaluate() is called with no quantile argument).\n     *\n     * @param p a value between 0 < p <= 100\n     * @throws IllegalArgumentException  if p is not greater than 0 and less\n     * than or equal to 100\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Min.Min#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Min",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Min.Min()",
        "snippet": "    public Min() {\n        n = 0;\n        value = Double.NaN;\n    }\n",
        "begin_line": 54,
        "end_line": 57,
        "comment": "\n     * Create a Min instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Max.Max#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java",
        "class_name": "org.apache.commons.math.stat.descriptive.rank.Max",
        "signature": "org.apache.commons.math.stat.descriptive.rank.Max.Max()",
        "snippet": "    public Max() {\n        n = 0;\n        value = Double.NaN;\n    }\n",
        "begin_line": 54,
        "end_line": 57,
        "comment": "\n     * Create a Max instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Variance.Variance#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
        "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.Variance()",
        "snippet": "    public Variance() {\n        moment = new SecondMoment();\n    }\n",
        "begin_line": 94,
        "end_line": 96,
        "comment": "\n     * Constructs a Variance with default (true) <code>isBiasCorrected</code>\n     * property.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "ThirdMoment.ThirdMoment#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.ThirdMoment",
        "signature": "org.apache.commons.math.stat.descriptive.moment.ThirdMoment.ThirdMoment()",
        "snippet": "    public ThirdMoment() {\n        super();\n        m3 = Double.NaN;\n        nDevSq = Double.NaN;\n    }\n",
        "begin_line": 65,
        "end_line": 69,
        "comment": "\n     * Create a FourthMoment instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Skewness.Skewness#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.Skewness",
        "signature": "org.apache.commons.math.stat.descriptive.moment.Skewness.Skewness()",
        "snippet": "    public Skewness() {\n        incMoment = true;\n        moment = new ThirdMoment();\n    }\n",
        "begin_line": 59,
        "end_line": 62,
        "comment": "\n     * Constructs a Skewness\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "SecondMoment.SecondMoment#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.SecondMoment",
        "signature": "org.apache.commons.math.stat.descriptive.moment.SecondMoment.SecondMoment()",
        "snippet": "    public SecondMoment() {\n        super();\n        m2 = Double.NaN;\n    }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "\n     * Create a SecondMoment instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Mean.Mean#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
        "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.Mean()",
        "snippet": "    public Mean() {\n        incMoment = true;\n        moment = new FirstMoment();\n    }\n",
        "begin_line": 77,
        "end_line": 80,
        "comment": " Constructs a Mean. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Mean.evaluate#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
        "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.evaluate(double[], int, int)",
        "snippet": "    @Override\n    public double evaluate(final double[] values,final int begin, final int length) {\n        if (test(values, begin, length)) {\n            Sum sum = new Sum();\n            double sampleSize = length;\n\n            // Compute initial estimate using definitional formula\n            double xbar = sum.evaluate(values, begin, length) / sampleSize;\n\n            // Compute correction factor in second pass\n            double correction = 0;\n            for (int i = begin; i < begin + length; i++) {\n                correction += values[i] - xbar;\n            }\n            return xbar + (correction/sampleSize);\n        }\n        return Double.NaN;\n    }\n",
        "begin_line": 153,
        "end_line": 170,
        "comment": "\n     * Returns the arithmetic mean of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     * <p>\n     * See {@link Mean} for details on the computing algorithm.</p>\n     *\n     * @param values the input array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the mean of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null or the array index\n     *  parameters are not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Kurtosis.Kurtosis#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.Kurtosis",
        "signature": "org.apache.commons.math.stat.descriptive.moment.Kurtosis.Kurtosis()",
        "snippet": "    public Kurtosis() {\n        incMoment = true;\n        moment = new FourthMoment();\n    }\n",
        "begin_line": 65,
        "end_line": 68,
        "comment": "\n     * Construct a Kurtosis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "GeometricMean.GeometricMean#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.GeometricMean",
        "signature": "org.apache.commons.math.stat.descriptive.moment.GeometricMean.GeometricMean()",
        "snippet": "    public GeometricMean() {\n        sumOfLogs = new SumOfLogs();\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n     * Create a GeometricMean instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "FourthMoment.FourthMoment#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.FourthMoment",
        "signature": "org.apache.commons.math.stat.descriptive.moment.FourthMoment.FourthMoment()",
        "snippet": "    public FourthMoment() {\n        super();\n        m4 = Double.NaN;\n    }\n",
        "begin_line": 64,
        "end_line": 67,
        "comment": "\n     * Create a FourthMoment instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "FirstMoment.FirstMoment#76",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java",
        "class_name": "org.apache.commons.math.stat.descriptive.moment.FirstMoment",
        "signature": "org.apache.commons.math.stat.descriptive.moment.FirstMoment.FirstMoment()",
        "snippet": "    public FirstMoment() {\n        n = 0;\n        m1 = Double.NaN;\n        dev = Double.NaN;\n        nDev = Double.NaN;\n    }\n",
        "begin_line": 76,
        "end_line": 81,
        "comment": "\n     * Create a FirstMoment instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DescriptiveStatistics.DescriptiveStatistics#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java",
        "class_name": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics",
        "signature": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics.DescriptiveStatistics()",
        "snippet": "    public DescriptiveStatistics() {\n    }\n",
        "begin_line": 113,
        "end_line": 114,
        "comment": "\n     * Construct a DescriptiveStatistics instance with an infinite window\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DescriptiveStatistics.addValue#143",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java",
        "class_name": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics",
        "signature": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics.addValue(double)",
        "snippet": "    public void addValue(double v) {\n        if (windowSize != INFINITE_WINDOW) {\n            if (getN() == windowSize) {\n                eDA.addElementRolling(v);\n            } else if (getN() < windowSize) {\n                eDA.addElement(v);\n            }\n        } else {\n            eDA.addElement(v);\n        }\n    }\n",
        "begin_line": 143,
        "end_line": 153,
        "comment": "\n     * Adds the value to the dataset. If the dataset is at the maximum size\n     * (i.e., the number of stored elements equals the currently configured\n     * windowSize), the first (oldest) element in the dataset is discarded\n     * to make room for the new value.\n     *\n     * @param v the value to be added\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DescriptiveStatistics.getMean#178",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java",
        "class_name": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics",
        "signature": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics.getMean()",
        "snippet": "    public double getMean() {\n        return apply(meanImpl);\n    }\n",
        "begin_line": 178,
        "end_line": 180,
        "comment": "\n     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n     * arithmetic mean </a> of the available values\n     * @return The mean or Double.NaN if no values have been added.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DescriptiveStatistics.getPercentile#379",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java",
        "class_name": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics",
        "signature": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics.getPercentile(double)",
        "snippet": "    public double getPercentile(double p) {\n        if (percentileImpl instanceof Percentile) {\n            ((Percentile) percentileImpl).setQuantile(p);\n        } else {\n            try {\n                percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME,\n                        new Class[] {Double.TYPE}).invoke(percentileImpl,\n                                new Object[] {Double.valueOf(p)});\n            } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD,\n                      percentileImpl.getClass().getName(), SET_QUANTILE_METHOD_NAME);\n            } catch (IllegalAccessException e2) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD,\n                      SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName());\n            } catch (InvocationTargetException e3) {\n                throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n            }\n        }\n        return apply(percentileImpl);\n    }\n",
        "begin_line": 379,
        "end_line": 400,
        "comment": "\n     * Returns an estimate for the pth percentile of the stored values.\n     * <p>\n     * The implementation provided here follows the first estimation procedure presented\n     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n     * </p><p>\n     * <strong>Preconditions</strong>:<ul>\n     * <li><code>0 &lt; p &le; 100</code> (otherwise an\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li>at least one value must be stored (returns <code>Double.NaN\n     *     </code> otherwise)</li>\n     * </ul></p>\n     *\n     * @param p the requested percentile (scaled from 0 - 100)\n     * @return An estimate for the pth percentile of the stored data\n     * @throws IllegalStateException if percentile implementation has been\n     *  overridden and the supplied implementation does not support setQuantile\n     * values\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DescriptiveStatistics.apply#431",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java",
        "class_name": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics",
        "signature": "org.apache.commons.math.stat.descriptive.DescriptiveStatistics.apply(org.apache.commons.math.stat.descriptive.UnivariateStatistic)",
        "snippet": "    public double apply(UnivariateStatistic stat) {\n        return stat.evaluate(eDA.getInternalValues(), eDA.start(), eDA.getNumElements());\n    }\n",
        "begin_line": 431,
        "end_line": 433,
        "comment": "\n     * Apply the given statistic to the data associated with this set of statistics.\n     * @param stat the statistic to apply\n     * @return the computed value of the statistic.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateStatistic.test#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java",
        "class_name": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic",
        "signature": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic.test(double[], int, int)",
        "snippet": "    protected boolean test(\n        final double[] values,\n        final int begin,\n        final int length) {\n\n        if (values == null) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n        }\n\n        if (begin < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.NEGATIVE_START_POSITION, begin);\n        }\n\n        if (length < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.NEGATIVE_LENGTH, length);\n        }\n\n        if (begin + length > values.length) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END);\n        }\n\n        if (length == 0) {\n            return false;\n        }\n\n        return true;\n\n    }\n",
        "begin_line": 75,
        "end_line": 105,
        "comment": "\n     * This method is used by <code>evaluate(double[], int, int)</code> methods\n     * to verify that the input parameters designate a subarray of positive length.\n     * <p>\n     * <ul>\n     * <li>returns <code>true</code> iff the parameters designate a subarray of\n     * positive length</li>\n     * <li>throws <code>IllegalArgumentException</code> if the array is null or\n     * or the indices are invalid</li>\n     * <li>returns <code>false</li> if the array is non-null, but\n     * <code>length</code> is 0.\n     * </ul></p>\n     *\n     * @param values the input array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return true if the parameters are valid and designate a subarray of positive length\n     * @throws IllegalArgumentException if the indices are invalid or the array is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getResult#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getResult()",
        "snippet": "    public double getResult() {\n        if (!resultComputed) {\n            throw new NoDataException();\n        }\n        return result;\n    }\n",
        "begin_line": 96,
        "end_line": 101,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Get the result of the last run of the optimizer.\n     *\n     * @return the optimum.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getMaxEvaluations#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMaxEvaluations()",
        "snippet": "    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Get the maximal number of functions evaluations.\n     * @return the maximal number of functions evaluations.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual absolute accuracy.\n     *\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getEvaluations#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return totalEvaluations;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Get the number of evaluations of the objective function.\n     * <p>\n     * The number of evaluations corresponds to the last call to the\n     * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method. It is 0 if the method has not been called yet.\n     * </p>\n     * @return the number of evaluations of the objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getRelativeAccuracy#126",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual relative accuracy.\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy(double)",
        "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the absolute accuracy.\n     * <p>\n     * The default is usually chosen so that results in the interval\n     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n     * expected absolute value of your results is of much smaller magnitude, set\n     * this to a smaller value.</p>\n     * <p>\n     * Algorithms are advised to do a plausibility check with the relative\n     * accuracy, but clients should not rely on this.</p>\n     *\n     * @param accuracy the accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     * the solver or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setRelativeAccuracy#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setRelativeAccuracy(double)",
        "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the relative accuracy.\n     * <p>\n     * This is used to stop iterations if the absolute accuracy can't be\n     * achieved due to large values or short mantissa length.</p>\n     * <p>\n     * If this should be the primary criterion for convergence rather then a\n     * safety measure, set the absolute accuracy to a ridiculously small value,\n     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n     *\n     * @param accuracy the relative accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     *  the algorithm or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "NoDataException.NoDataException#32",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/NoDataException.java",
        "class_name": "org.apache.commons.math.exception.NoDataException",
        "signature": "org.apache.commons.math.exception.NoDataException.NoDataException()",
        "snippet": "    public NoDataException() {\n        this(null);\n    }\n",
        "begin_line": 32,
        "end_line": 34,
        "comment": "\n     * Construct the exception.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "NoDataException.NoDataException#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/NoDataException.java",
        "class_name": "org.apache.commons.math.exception.NoDataException",
        "signature": "org.apache.commons.math.exception.NoDataException.NoDataException(org.apache.commons.math.util.Localizable)",
        "snippet": "    public NoDataException(Localizable specific) {\n        super(specific, LocalizedFormats.NO_DATA, null);\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Construct the exception with a specific context.\n     *\n     * @param specific Contextual information on what caused the exception.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalArgumentException.MathIllegalArgumentException#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
        "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.MathIllegalArgumentException(org.apache.commons.math.util.Localizable, org.apache.commons.math.util.Localizable, java.lang.Object...)",
        "snippet": "    protected MathIllegalArgumentException(Localizable specific,\n                                           Localizable general,\n                                           Object ... args) {\n        this.specific = specific;\n        this.general = general;\n        arguments = flatten(args).toArray();\n    }\n",
        "begin_line": 54,
        "end_line": 60,
        "comment": "\n     * @param specific Message pattern providing the specific context of\n     * the error.\n     * @param general Message pattern explaining the cause of the error.\n     * @param args Arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalArgumentException.flatten#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalArgumentException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalArgumentException",
        "signature": "org.apache.commons.math.exception.MathIllegalArgumentException.flatten(java.lang.Object[])",
        "snippet": "    private List<Object> flatten(Object[] array) {\n        final List<Object> list = new ArrayList<Object>();\n        if (array != null) {\n            for (Object o : array) {\n                if (o instanceof Object[]) {\n                    list.addAll(flatten((Object[]) o));\n                } else {\n                    list.add(o);\n                }\n            }\n        }\n        return list;\n    }\n",
        "begin_line": 105,
        "end_line": 117,
        "comment": "\n     * Transform a multidimensional array into a one-dimensional list.\n     *\n     * @param array Array (possibly multidimensional).\n     * @return a list of all the {@code Object} instances contained in\n     * {@code array}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathRuntimeException.createIllegalStateException#442",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/MathRuntimeException.java",
        "class_name": "org.apache.commons.math.MathRuntimeException",
        "signature": "org.apache.commons.math.MathRuntimeException.createIllegalStateException(org.apache.commons.math.util.Localizable, java.lang.Object...)",
        "snippet": "    public static IllegalStateException createIllegalStateException(final Localizable pattern,\n                                                                    final Object ... arguments) {\n        return new IllegalStateException() {\n\n            /** Serializable version identifier. */\n            private static final long serialVersionUID = 6880901520234515725L;\n\n            /** {@inheritDoc} */\n            @Override\n            public String getMessage() {\n                return buildMessage(Locale.US, pattern, arguments);\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public String getLocalizedMessage() {\n                return buildMessage(Locale.getDefault(), pattern, arguments);\n            }\n\n        };\n    }\n",
        "begin_line": 442,
        "end_line": 462,
        "comment": "\n     * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n     * Message formatting is delegated to {@link java.text.MessageFormat}.\n     * @param pattern format specifier\n     * @param arguments format arguments\n     * @return built exception\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    }
]