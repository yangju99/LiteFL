[
    {
        "name": "AVLTree.getNotSmaller#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.getNotSmaller(T)",
        "snippet": "    public Node getNotSmaller(final T reference) {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }\n",
        "begin_line": 151,
        "end_line": 168,
        "comment": " Get the node whose element is not smaller than the reference object.\n     * @param reference reference object (may not be in the tree)\n     * @return the tree node containing the smallest element not smaller\n     * than the reference object or null if either the tree is empty or\n     * all its elements are smaller than the reference object\n     * @see #getSmallest\n     * @see #getLargest\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.SubLine#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
        "snippet": "    public SubLine(final Vector2D start, final Vector2D end) {\n        super(new Line(start, end), buildIntervalSet(start, end));\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": " Create a sub-line from two endpoints.\n     * @param start start point\n     * @param end end point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.buildIntervalSet#138",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
        "snippet": "    private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }\n",
        "begin_line": 138,
        "end_line": 142,
        "comment": " Build an interval set from two points.\n     * @param start start point\n     * @param end end point\n     * @return an interval set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.computeGeometricalProperties#129",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties()",
        "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n",
        "begin_line": 129,
        "end_line": 181,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": " Compute some geometrical properties.\n     * <p>The properties to compute are the barycenter and the size.</p>\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.followLoop#293",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.followLoop(org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node, org.apache.commons.math3.geometry.partitioning.utilities.AVLTree<org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.ComparableSegment>)",
        "snippet": "    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n",
        "begin_line": 293,
        "end_line": 350,
        "comment": " Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.PolyhedronsSet#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet(java.util.Collection<org.apache.commons.math3.geometry.partitioning.SubHyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>>)",
        "snippet": "    public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) {\n        super(boundary);\n    }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": " Build a polyhedrons set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polyhedrons with holes\n     * or a set of disjoint polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link Region#checkPoint(Vector) checkPoint} method will\n     * not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements, as a\n     * collection of {@link SubHyperplane SubHyperplane} objects\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.atan#2435",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.atan(double, double, boolean)",
        "snippet": "    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa == 0.0) { // Matches +/- 0.0; return correct sign\n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa < 0) {\n            // negative\n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { // Very large input\n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n        if (xa < 1) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        /* Compute eps = eps / (1.0 + xa*tangent) */\n        temp = xa * HEX_40000000;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        //if (idx > 8 || idx == 0)\n        if (idx == 0) {\n            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1d + temp2;\n            double zb = -(za - 1d - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            /* Correct for rounding in division */\n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        /* Evaluate polynomial */\n        final double epsA2 = epsA * epsA;\n\n        /*\n    yb = -0.09001346640161823;\n    yb = yb * epsA2 + 0.11110718400605211;\n    yb = yb * epsA2 + -0.1428571349122913;\n    yb = yb * epsA2 + 0.19999999999273194;\n    yb = yb * epsA2 + -0.33333333333333093;\n    yb = yb * epsA2 * epsA;\n         */\n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n        yb += epsB / (1d + epsA * epsA);\n\n        //result = yb + eighths[idx] + ya;\n        double za = EIGHTHS[idx] + ya;\n        double zb = -(za - EIGHTHS[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        double result = za + zb;\n        double resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            // Result is in the left plane\n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n",
        "begin_line": 2435,
        "end_line": 2574,
        "comment": " Internal helper function to compute arctangent.\n     * @param xa number from which arctangent is requested\n     * @param xb extra bits for x (may be 0.0)\n     * @param leftPlane if true, result angle must be put in the left half plane\n     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.Plane#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\n        this(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)));\n    }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": " Build a plane from three points.\n     * <p>The plane is oriented in the direction of\n     * {@code (p2-p1) ^ (p3-p1)}</p>\n     * @param p1 first point belonging to the plane\n     * @param p2 second point belonging to the plane\n     * @param p3 third point belonging to the plane\n     * @exception MathArithmeticException if the points do not constitute a plane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.insertCuts#174",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.insertCuts(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, java.util.Collection<org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>>)",
        "snippet": "    private void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) {\n\n        final Iterator<SubHyperplane<S>> iterator = boundary.iterator();\n\n        // build the current level\n        Hyperplane<S> inserted = null;\n        while ((inserted == null) && iterator.hasNext()) {\n            inserted = iterator.next().getHyperplane();\n            if (!node.insertCut(inserted.copySelf())) {\n                inserted = null;\n            }\n        }\n\n        if (!iterator.hasNext()) {\n            return;\n        }\n\n        // distribute the remaining edges in the two sub-trees\n        final ArrayList<SubHyperplane<S>> plusList  = new ArrayList<SubHyperplane<S>>();\n        final ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>();\n        while (iterator.hasNext()) {\n            final SubHyperplane<S> other = iterator.next();\n            switch (other.side(inserted)) {\n            case PLUS:\n                plusList.add(other);\n                break;\n            case MINUS:\n                minusList.add(other);\n                break;\n            case BOTH:\n                final SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted);\n                plusList.add(split.getPlus());\n                minusList.add(split.getMinus());\n                break;\n            default:\n                // ignore the sub-hyperplanes belonging to the cut hyperplane\n            }\n        }\n\n        // recurse through lower levels\n        insertCuts(node.getPlus(),  plusList);\n        insertCuts(node.getMinus(), minusList);\n\n    }\n",
        "begin_line": 174,
        "end_line": 217,
        "comment": " Recursively build a tree by inserting cut sub-hyperplanes.\n     * @param node current tree node (it is a leaf node at the beginning\n     * of the call)\n     * @param boundary collection of edges belonging to the cell defined\n     * by the node\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubPlane.side#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubPlane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.side(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    @Override\n    public Side side(Hyperplane<Euclidean3D> hyperplane) {\n\n        final Plane otherPlane = (Plane) hyperplane;\n        final Plane thisPlane  = (Plane) getHyperplane();\n        final Line  inter      = otherPlane.intersection(thisPlane);\n\n        if (inter == null) {\n            // the hyperplanes are parallel,\n            // any point can be used to check their relative position\n            final double global = otherPlane.getOffset(thisPlane);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        // create a 2D line in the otherPlane canonical 2D frame such that:\n        //   - the line is the crossing line of the two planes in 3D\n        //   - the line splits the otherPlane in two half planes with an\n        //     orientation consistent with the orientation of the instance\n        //     (i.e. the 3D half space on the plus side (resp. minus side)\n        //      of the instance contains the 2D half plane on the plus side\n        //      (resp. minus side) of the 2D line\n        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n            final Vector2D tmp = p;\n            p           = q;\n            q           = tmp;\n        }\n        final org.apache.commons.math3.geometry.euclidean.twod.Line line2D =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(p, q);\n\n        // check the side on the 2D plane\n        return getRemainingRegion().side(line2D);\n\n    }\n",
        "begin_line": 53,
        "end_line": 88,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubPlane.split#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubPlane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.split(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean3D> split(Hyperplane<Euclidean3D> hyperplane) {\n\n        final Plane otherPlane = (Plane) hyperplane;\n        final Plane thisPlane  = (Plane) getHyperplane();\n        final Line  inter      = otherPlane.intersection(thisPlane);\n\n        if (inter == null) {\n            // the hyperplanes are parallel\n            final double global = otherPlane.getOffset(thisPlane);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean3D>(null, this) :\n                   new SplitSubHyperplane<Euclidean3D>(this, null);\n        }\n\n        // the hyperplanes do intersect\n        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n            final Vector2D tmp = p;\n            p           = q;\n            q           = tmp;\n        }\n        final SubHyperplane<Euclidean2D> l2DMinus =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(p, q).wholeHyperplane();\n        final SubHyperplane<Euclidean2D> l2DPlus =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(q, p).wholeHyperplane();\n\n        final BSPTree<Euclidean2D> splitTree = getRemainingRegion().getTree(false).split(l2DMinus);\n        final BSPTree<Euclidean2D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean2D>(l2DPlus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n\n        final BSPTree<Euclidean2D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n                                                   new BSPTree<Euclidean2D>(l2DMinus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n                                                                            splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean3D>(new SubPlane(thisPlane.copySelf(), new PolygonsSet(plusTree)),\n                                                   new SubPlane(thisPlane.copySelf(), new PolygonsSet(minusTree)));\n\n    }\n",
        "begin_line": 96,
        "end_line": 139,
        "comment": " Split the instance in two parts by an hyperplane.\n     * @param hyperplane splitting hyperplane\n     * @return an object containing both the part of the instance\n     * on the plus side of the instance and the part of the\n     * instance on the minus side of the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.intersection#321",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.intersection(org.apache.commons.math3.geometry.euclidean.threed.Plane)",
        "snippet": "    public Line intersection(final Plane other) {\n        final Vector3D direction = Vector3D.crossProduct(w, other.w);\n        if (direction.getNorm() < 1.0e-10) {\n            return null;\n        }\n        final Vector3D point = intersection(this, other, new Plane(direction));\n        return new Line(point, point.add(direction));\n    }\n",
        "begin_line": 321,
        "end_line": 328,
        "comment": " Build the line shared by the instance and another plane.\n     * @param other other plane\n     * @return line at the intersection of the instance and the\n     * other plane (really a {@link Line Line} instance)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.getOffset#405",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.getOffset(org.apache.commons.math3.geometry.euclidean.threed.Plane)",
        "snippet": "    public double getOffset(final Plane plane) {\n        return originOffset + (sameOrientationAs(plane) ? -plane.originOffset : plane.originOffset);\n    }\n",
        "begin_line": 405,
        "end_line": 407,
        "comment": " Get the offset (oriented distance) of a parallel plane.\n     * <p>This method should be called only for parallel planes otherwise\n     * the result is not meaningful.</p>\n     * <p>The offset is 0 if both planes are the same, it is\n     * positive if the plane is on the plus side of the instance and\n     * negative if it is on the minus side, according to its natural\n     * orientation.</p>\n     * @param plane plane to check\n     * @return offset of the plane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.sameOrientationAs#426",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean3D> other) {\n        return (((Plane) other).w).dotProduct(w) > 0.0;\n    }\n",
        "begin_line": 426,
        "end_line": 428,
        "comment": " Check if the instance has the same orientation as another hyperplane.\n     * @param other other hyperplane to check against the instance\n     * @return true if the instance and the other hyperplane have\n     * the same orientation\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.linearCombination#659",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }\n",
        "begin_line": 659,
        "end_line": 713,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n     * so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects. It is based\n     * on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub>\n     * @see #linearCombination(double, double, double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.linearCombination#738",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double)",
        "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }\n",
        "begin_line": 738,
        "end_line": 810,
        "comment": "\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * to high accuracy. It does so by using specific multiplication and\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\n     * It is based on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @param a3 first factor of the third term\n     * @param b3 second factor of the third term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * @see #linearCombination(double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.getBarycenter#394",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBarycenter()",
        "snippet": "    public Vector<S> getBarycenter() {\n        if (barycenter == null) {\n            computeGeometricalProperties();\n        }\n        return barycenter;\n    }\n",
        "begin_line": 394,
        "end_line": 399,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Get the barycenter of the instance.\n     * @return an object representing the barycenter\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.recurseSides#437",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseSides(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides)",
        "snippet": "    private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) {\n\n        if (node.getCut() == null) {\n            if ((Boolean) node.getAttribute()) {\n                // this is an inside cell expanding across the hyperplane\n                sides.rememberPlusFound();\n                sides.rememberMinusFound();\n            }\n            return;\n        }\n\n        final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n        switch (sub.side(hyperplane)) {\n        case PLUS :\n            // the sub-hyperplane is entirely in the plus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getPlus(), sub, sides);\n            }\n            break;\n        case MINUS :\n            // the sub-hyperplane is entirely in the minus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getMinus(), sub, sides);\n            }\n            break;\n        case BOTH :\n            // the sub-hyperplane extends in both sub-trees\n            final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n\n            // explore first the plus sub-tree\n            recurseSides(node.getPlus(), split.getPlus(), sides);\n\n            // if needed, explore the minus sub-tree\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getMinus(), split.getMinus(), sides);\n            }\n            break;\n        default :\n            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n            } else {\n                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n            }\n        }\n\n    }\n",
        "begin_line": 437,
        "end_line": 511,
        "comment": " Search recursively for inside leaf nodes on each side of the given hyperplane.\n\n     * <p>The algorithm used here is directly derived from the one\n     * described in section III (<i>Binary Partitioning of a BSP\n     * Tree</i>) of the Bruce Naylor, John Amanatides and William\n     * Thibault paper <a\n     * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n     * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph\n     * '90, Computer Graphics 24(4), August 1990, pp 115-124, published\n     * by the Association for Computing Machinery (ACM)..</p>\n\n     * @param node current BSP tree node\n     * @param sub sub-hyperplane\n     * @param sides object holding the sides found\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.PolygonsSet#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet()",
        "snippet": "    public PolygonsSet() {\n        super();\n    }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": " Build a polygons set representing the whole real line.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double, double)",
        "snippet": "    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n",
        "begin_line": 95,
        "end_line": 99,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @param z height\n     * @see #getX()\n     * @see #getY()\n     * @see #getZ()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }\n",
        "begin_line": 137,
        "end_line": 141,
        "comment": " Multiplicative constructor\n     * Build a vector from another one and a scale factor.\n     * The vector built will be a * u\n     * @param a scale factor\n     * @param u base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": " Linear constructor\n     * Build a vector from two other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.Vector3D#167",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n    }\n",
        "begin_line": 167,
        "end_line": 172,
        "comment": " Linear constructor\n     * Build a vector from three other ones and corresponding scale factors.\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n     * @param a1 first scale factor\n     * @param u1 first base (unscaled) vector\n     * @param a2 second scale factor\n     * @param u2 second base (unscaled) vector\n     * @param a3 third scale factor\n     * @param u3 third base (unscaled) vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getX#197",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 197,
        "end_line": 199,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getY#205",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getY()",
        "snippet": "    public double getY() {\n        return y;\n    }\n",
        "begin_line": 205,
        "end_line": 207,
        "comment": " Get the ordinate of the vector.\n     * @return ordinate of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getZ#213",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZ()",
        "snippet": "    public double getZ() {\n        return z;\n    }\n",
        "begin_line": 213,
        "end_line": 215,
        "comment": " Get the height of the vector.\n     * @return height of the vector\n     * @see #Vector3D(double, double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getNorm#241",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm()",
        "snippet": "    public double getNorm() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return FastMath.sqrt (x * x + y * y + z * z);\n    }\n",
        "begin_line": 241,
        "end_line": 244,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": " Get the L<sub>2</sub> norm for the vector.\n     * @return Euclidean norm for the vector\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.getNormSq#247",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
        "snippet": "    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }\n",
        "begin_line": 247,
        "end_line": 250,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": " Get the square of the norm for the vector.\n     * @return square of the Euclidean norm for the vector\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.add#274",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D add(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n    }\n",
        "begin_line": 274,
        "end_line": 277,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.subtract#285",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }\n",
        "begin_line": 285,
        "end_line": 288,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.orthogonal#319",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.orthogonal()",
        "snippet": "    public Vector3D orthogonal() {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if ((x >= -threshold) && (x <= threshold)) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new Vector3D(0, inverse * z, -inverse * y);\n        } else if ((y >= -threshold) && (y <= threshold)) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new Vector3D(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new Vector3D(inverse * y, -inverse * x, 0);\n\n    }\n",
        "begin_line": 319,
        "end_line": 336,
        "comment": " Get a vector orthogonal to the instance.\n     * <p>There are an infinite number of normalized vectors orthogonal\n     * to the instance. This method picks up one of them almost\n     * arbitrarily. It is useful when one needs to compute a reference\n     * frame with one of the axes in a predefined direction. The\n     * following example shows how to build a frame having the k axis\n     * aligned with the known vector u :\n     * <pre><code>\n     *   Vector3D k = u.normalize();\n     *   Vector3D i = k.orthogonal();\n     *   Vector3D j = Vector3D.crossProduct(k, i);\n     * </code></pre></p>\n     * @return a new normalized vector orthogonal to the instance\n     * @exception MathArithmeticException if the norm of the instance is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.dotProduct#452",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public double dotProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }\n",
        "begin_line": 452,
        "end_line": 455,
        "comment": " {@inheritDoc}\n     * <p>\n     * The implementation uses specific multiplication and addition\n     * algorithms to preserve accuracy and reduce cancellation effects.\n     * It should be very accurate even for nearly orthogonal vectors.\n     * </p>\n     * @see MathArrays#linearCombination(double, double, double, double, double, double)\n     ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.geometry.Vector": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.crossProduct#461",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\n                            MathArrays.linearCombination(z, v3.x, -x, v3.z),\n                            MathArrays.linearCombination(x, v3.y, -y, v3.x));\n    }\n",
        "begin_line": 461,
        "end_line": 466,
        "comment": " Compute the cross-product of the instance with another vector.\n     * @param v other vector\n     * @return the cross product this ^ v as a new Vector3D\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector3D.crossProduct#518",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n        return v1.crossProduct(v2);\n    }\n",
        "begin_line": 518,
        "end_line": 520,
        "comment": " Compute the cross-product of two vectors.\n     * @param v1 first vector\n     * @param v2 second vector\n     * @return the cross product v1 ^ v2 as a new Vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubPlane.SubPlane#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubPlane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.SubPlane(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    public SubPlane(final Hyperplane<Euclidean3D> hyperplane,\n                    final Region<Euclidean2D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": " Simple constructor.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubPlane.buildNew#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubPlane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean3D, Euclidean2D> buildNew(final Hyperplane<Euclidean3D> hyperplane,\n                                                                       final Region<Euclidean2D> remainingRegion) {\n        return new SubPlane(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 46,
        "end_line": 50,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.FacetsContributionVisitor#137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.FacetsContributionVisitor()",
        "snippet": "        public FacetsContributionVisitor() {\n            setSize(0);\n            setBarycenter(new Vector3D(0, 0, 0));\n        }\n",
        "begin_line": 137,
        "end_line": 140,
        "comment": " Simple constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.visitOrder#143",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "        public Order visitOrder(final BSPTree<Euclidean3D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n",
        "begin_line": 143,
        "end_line": 145,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.visitInternalNode#148",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "        public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean3D> attribute =\n                (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n",
        "begin_line": 148,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.visitLeafNode#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "        public void visitLeafNode(final BSPTree<Euclidean3D> node) {\n        }\n",
        "begin_line": 161,
        "end_line": 162,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.addContribution#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.FacetsContributionVisitor.addContribution(org.apache.commons.math3.geometry.partitioning.SubHyperplane<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>, boolean)",
        "snippet": "        private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n\n            final Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion();\n            final double area    = polygon.getSize();\n\n            if (Double.isInfinite(area)) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector3D.NaN);\n            } else {\n\n                final Plane    plane  = (Plane) facet.getHyperplane();\n                final Vector3D facetB = plane.toSpace(polygon.getBarycenter());\n                double   scaled = area * facetB.dotProduct(plane.getNormal());\n                if (reversed) {\n                    scaled = -scaled;\n                }\n\n                setSize(getSize() + scaled);\n                setBarycenter(new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));\n\n            }\n\n        }\n",
        "begin_line": 168,
        "end_line": 190,
        "comment": " Add he contribution of a boundary facet.\n         * @param facet boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolyhedronsSet.computeGeometricalProperties#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties()",
        "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n\n        // compute the contribution of all boundary facets\n        getTree(true).visit(new FacetsContributionVisitor());\n\n        if (getSize() < 0) {\n            // the polyhedrons set as a finite outside\n            // surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector3D.NaN);\n        } else {\n            // the polyhedrons set is finite, apply the remaining scaling factors\n            setSize(getSize() / 3.0);\n            setBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n        }\n\n    }\n",
        "begin_line": 114,
        "end_line": 131,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": " Compute some geometrical properties.\n     * <p>The properties to compute are the barycenter and the size.</p>\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.Plane#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Plane(final Vector3D normal) {\n        setNormal(normal);\n        originOffset = 0;\n        setFrame();\n    }\n",
        "begin_line": 55,
        "end_line": 59,
        "comment": " Build a plane normal to a given direction and containing the origin.\n     * @param normal normal direction to the plane\n     * @exception MathArithmeticException if the normal norm is too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.Plane#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Plane(final Vector3D p, final Vector3D normal) {\n        setNormal(normal);\n        originOffset = -p.dotProduct(w);\n        setFrame();\n    }\n",
        "begin_line": 66,
        "end_line": 70,
        "comment": " Build a plane from a point and a normal.\n     * @param p point belonging to the plane\n     * @param normal normal direction to the plane\n     * @exception MathArithmeticException if the normal norm is too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.Plane#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(org.apache.commons.math3.geometry.euclidean.threed.Plane)",
        "snippet": "    public Plane(final Plane plane) {\n        originOffset = plane.originOffset;\n        origin = plane.origin;\n        u      = plane.u;\n        v      = plane.v;\n        w      = plane.w;\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": " Copy constructor.\n     * <p>The instance created is completely independant of the original\n     * one. A deep copy is used, none of the underlying object are\n     * shared.</p>\n     * @param plane plane to copy\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.copySelf#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.copySelf()",
        "snippet": "    public Plane copySelf() {\n        return new Plane(this);\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": " Copy the instance.\n     * <p>The instance created is completely independant of the original\n     * one. A deep copy is used, none of the underlying objects are\n     * shared (except for immutable objects).</p>\n     * @return a new hyperplane, copy of the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.setNormal#136",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.setNormal(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    private void setNormal(final Vector3D normal) {\n        final double norm = normal.getNorm();\n        if (norm < 1.0e-10) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        w = new Vector3D(1.0 / norm, normal);\n    }\n",
        "begin_line": 136,
        "end_line": 142,
        "comment": " Set the normal vactor.\n     * @param normal normal direction to the plane (will be copied)\n     * @exception MathArithmeticException if the normal norm is too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.setFrame#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.setFrame()",
        "snippet": "    private void setFrame() {\n        origin = new Vector3D(-originOffset, w);\n        u = w.orthogonal();\n        v = Vector3D.crossProduct(w, u);\n    }\n",
        "begin_line": 146,
        "end_line": 150,
        "comment": " Reset the plane frame.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.getNormal#170",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.getNormal()",
        "snippet": "    public Vector3D getNormal() {\n        return w;\n    }\n",
        "begin_line": 170,
        "end_line": 172,
        "comment": " Get the normalized normal vector.\n     * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},\n     * {@link #getNormal getNormal}) is a rigth-handed orthonormalized\n     * frame).</p>\n     * @return normalized normal vector\n     * @see #getU\n     * @see #getV\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.toSubSpace#224",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.toSubSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector2D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector2D(point.dotProduct(u), point.dotProduct(v));\n    }\n",
        "begin_line": 224,
        "end_line": 226,
        "comment": " Transform a 3D space point into an in-plane point.\n     * @param point point of the space (must be a {@link Vector3D\n     * Vector3D} instance)\n     * @return in-plane point (really a {@link\n     * org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)\n     * @see #toSpace\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.toSpace#234",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.toSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    public Vector3D toSpace(final Vector<Euclidean2D> point) {\n        final Vector2D p2D = (Vector2D) point;\n        return new Vector3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);\n    }\n",
        "begin_line": 234,
        "end_line": 237,
        "comment": " Transform an in-plane point into a 3D space point.\n     * @param point in-plane point (must be a {@link\n     * org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance)\n     * @return 3D space point (really a {@link Vector3D Vector3D} instance)\n     * @see #toSubSpace\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.intersection#336",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.intersection(org.apache.commons.math3.geometry.euclidean.threed.Plane, org.apache.commons.math3.geometry.euclidean.threed.Plane, org.apache.commons.math3.geometry.euclidean.threed.Plane)",
        "snippet": "    public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n\n        // coefficients of the three planes linear equations\n        final double a1 = plane1.w.getX();\n        final double b1 = plane1.w.getY();\n        final double c1 = plane1.w.getZ();\n        final double d1 = plane1.originOffset;\n\n        final double a2 = plane2.w.getX();\n        final double b2 = plane2.w.getY();\n        final double c2 = plane2.w.getZ();\n        final double d2 = plane2.originOffset;\n\n        final double a3 = plane3.w.getX();\n        final double b3 = plane3.w.getY();\n        final double c3 = plane3.w.getZ();\n        final double d3 = plane3.originOffset;\n\n        // direct Cramer resolution of the linear system\n        // (this is still feasible for a 3x3 system)\n        final double a23         = b2 * c3 - b3 * c2;\n        final double b23         = c2 * a3 - c3 * a2;\n        final double c23         = a2 * b3 - a3 * b2;\n        final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n        if (FastMath.abs(determinant) < 1.0e-10) {\n            return null;\n        }\n\n        final double r = 1.0 / determinant;\n        return new Vector3D(\n                            (-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r,\n                            (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r,\n                            (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n\n    }\n",
        "begin_line": 336,
        "end_line": 370,
        "comment": " Get the intersection point of three planes.\n     * @param plane1 first plane1\n     * @param plane2 second plane2\n     * @param plane3 third plane2\n     * @return intersection point of three planes, null if some planes are parallel\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Plane.wholeHyperplane#375",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Plane.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.wholeHyperplane()",
        "snippet": "    public SubPlane wholeHyperplane() {\n        return new SubPlane(this, new PolygonsSet());\n    }\n",
        "begin_line": 375,
        "end_line": 377,
        "comment": " Build a region covering the whole hyperplane.\n     * @return a region covering the whole hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.Line#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public Line(final Vector3D p1, final Vector3D p2) {\n        reset(p1, p2);\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": " Build a line from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.reset#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }\n",
        "begin_line": 73,
        "end_line": 81,
        "comment": " Reset the instance as if built from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.getDirection#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getDirection()",
        "snippet": "    public Vector3D getDirection() {\n        return direction;\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": " Get the normalized direction vector.\n     * @return normalized direction vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.pointAt#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.pointAt(double)",
        "snippet": "    public Vector3D pointAt(final double abscissa) {\n        return new Vector3D(1.0, zero, abscissa, direction);\n    }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": " Get one point from the line.\n     * @param abscissa desired abscissa for the point\n     * @return one point belonging to the line, at specified abscissa\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.toSpace#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public Vector3D toSpace(final Vector<Euclidean1D> point) {\n        return pointAt(((Vector1D) point).getX());\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": " {@inheritDoc}\n     * @see #pointAt(double)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rebalanceLeftShrunk#493",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rebalanceLeftShrunk()",
        "snippet": "        private boolean rebalanceLeftShrunk() {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } else if (right.skew == Skew.BALANCED) {\n                    rotateCCW();\n                    skew      = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }\n",
        "begin_line": 493,
        "end_line": 533,
        "comment": " Re-balance the instance as left sub-tree has shrunk.\n         * @return true if the parent tree should be reSkew.BALANCED too\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.sameOrientationAs#241",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) {\n        final Line otherL = (Line) other;\n        return (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n    }\n",
        "begin_line": 241,
        "end_line": 244,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null,
            "org.apache.commons.math3.geometry.partitioning.Hyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rebalanceLeftGrown#415",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rebalanceLeftGrown()",
        "snippet": "        private boolean rebalanceLeftGrown() {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }\n",
        "begin_line": 415,
        "end_line": 449,
        "comment": " Re-balance the instance as left sub-tree has grown.\n         * @return true if the parent tree should be reSkew.BALANCED too\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rebalanceRightGrown#454",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rebalanceRightGrown()",
        "snippet": "        private boolean rebalanceRightGrown() {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return true;\n            }\n        }\n",
        "begin_line": 454,
        "end_line": 488,
        "comment": " Re-balance the instance as right sub-tree has grown.\n         * @return true if the parent tree should be reSkew.BALANCED too\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.doubleHighPart#360",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.doubleHighPart(double)",
        "snippet": "    private static double doubleHighPart(double d) {\n        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n            return d; // These are un-normalised - don't try to convert\n        }\n        long xl = Double.doubleToLongBits(d);\n        xl = xl & MASK_30BITS; // Drop low order bits\n        return Double.longBitsToDouble(xl);\n    }\n",
        "begin_line": 360,
        "end_line": 367,
        "comment": "\n     * Get the high order bits from the mantissa.\n     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n     *\n     * @param d the value to split\n     * @return the high order part of the mantissa\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cos#2232",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
        "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2232,
        "end_line": 2310,
        "comment": "\n     *  Cosine function\n     *  @param x a number\n     *  @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.atan2#2582",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.atan2(double, double)",
        "snippet": "    public static double atan2(double y, double x) {\n        if (x != x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1d / x;\n            final double invy = 1d / y;\n\n            if (invx == 0) { // X is infinite\n                if (x > 0) {\n                    return y; // return +/- 0.0\n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x < 0 || invx < 0) {\n                if (y < 0 || invy < 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        // y cannot now be zero\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0 || 1 / y > 0) {\n                return 0d;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -0d;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1 / y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI;\n            }\n        }\n\n        // Neither y nor x can be infinite or NAN here\n\n        if (x == 0) {\n            if (y > 0 || 1 / y > 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        // Compute ratio r = y/x\n        final double r = y / x;\n        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n            return atan(r, 0, x < 0);\n        }\n\n        double ra = doubleHighPart(r);\n        double rb = r - ra;\n\n        // Split x\n        final double xa = doubleHighPart(x);\n        final double xb = x - xa;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        if (ra == 0) { // Fix up the sign so atan works correctly\n            ra = copySign(0d, y);\n        }\n\n        // Call atan\n        final double result = atan(ra, rb, x < 0);\n\n        return result;\n    }\n",
        "begin_line": 2582,
        "end_line": 2697,
        "comment": "\n     * Two arguments arctangent function\n     * @param y ordinate\n     * @param x abscissa\n     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.scalb#3053",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.scalb(double, int)",
        "snippet": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }\n",
        "begin_line": 3053,
        "end_line": 3129,
        "comment": "\n     * Multiply a double number by a power of 2.\n     * @param d number to multiply\n     * @param n power of 2\n     * @return d &times; 2<sup>n</sup>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.hypot#3568",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.hypot(double, double)",
        "snippet": "    public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX = getExponent(x);\n            final int expY = getExponent(y);\n            if (expX > expY + 27) {\n                // y is neglectible with respect to x\n                return abs(x);\n            } else if (expY > expX + 27) {\n                // x is neglectible with respect to y\n                return abs(y);\n            } else {\n\n                // find an intermediate scale to avoid both overflow and underflow\n                final int middleExp = (expX + expY) / 2;\n\n                // scale parameters without losing precision\n                final double scaledX = scalb(x, -middleExp);\n                final double scaledY = scalb(y, -middleExp);\n\n                // compute scaled hypotenuse\n                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                // remove scaling\n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }\n",
        "begin_line": 3568,
        "end_line": 3601,
        "comment": "\n     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n     * avoiding intermediate overflow or underflow.\n     *\n     * <ul>\n     * <li> If either argument is infinite, then the result is positive infinity.</li>\n     * <li> else, if either argument is NaN then the result is NaN.</li>\n     * </ul>\n     *\n     * @param x a value\n     * @param y a value\n     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sin#2134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
        "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2134,
        "end_line": 2225,
        "comment": "\n     *  Sine function.\n     *  @param x a number\n     *  @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.merge#383",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, boolean)",
        "snippet": "    private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger,\n                             final BSPTree<S> parentTree, final boolean isPlusChild) {\n        if (cut == null) {\n            // cell/tree operation\n            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n        } else if (tree.cut == null) {\n            // tree/cell operation\n            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n        } else {\n            // tree/tree operation\n            final BSPTree<S> merged = tree.split(cut);\n            if (parentTree != null) {\n                merged.parent = parentTree;\n                if (isPlusChild) {\n                    parentTree.plus = merged;\n                } else {\n                    parentTree.minus = merged;\n                }\n            }\n\n            // merging phase\n            plus.merge(merged.plus, leafMerger, merged, true);\n            minus.merge(merged.minus, leafMerger, merged, false);\n            merged.condense();\n            if (merged.cut != null) {\n                merged.cut =\n                    merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n            }\n\n            return merged;\n\n        }\n    }\n",
        "begin_line": 383,
        "end_line": 415,
        "comment": " Merge a BSP tree with the instance.\n     * @param tree other tree to merge with the instance (will be\n     * <em>unusable</em> after the operation, as well as the\n     * instance itself)\n     * @param leafMerger object implementing the final merging phase\n     * (this is where the semantic of the operation occurs, generally\n     * depending on the attribute of the leaf node)\n     * @param parentTree parent tree to connect to (may be null)\n     * @param isPlusChild if true and if parentTree is not null, the\n     * resulting tree should be the plus child of its parent, ignored if\n     * parentTree is null\n     * @return a new tree, result of <code>instance &lt;op&gt;\n     * tree</code>, this value can be ignored if parentTree is not null\n     * since all connections have already been established\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.getLargest#287",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.getLargest()",
        "snippet": "        Node getLargest() {\n            Node node = this;\n            while (node.right != null) {\n                node = node.right;\n            }\n            return node;\n        }\n",
        "begin_line": 287,
        "end_line": 293,
        "comment": " Get the node whose element is the largest one in the tree\n         * rooted at this node.\n         * @return the tree node containing the largest element in the\n         * tree rooted at this node or null if the tree is empty\n         * @see #getSmallest\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.buildNew#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }\n",
        "begin_line": 123,
        "end_line": 126,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rotateCW#584",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rotateCW()",
        "snippet": "        private void rotateCW() {\n\n            final T tmpElt       = element;\n            element              = left.element;\n            left.element         = tmpElt;\n\n            final Node tmpNode   = left;\n            left                 = tmpNode.left;\n            tmpNode.left         = tmpNode.right;\n            tmpNode.right        = right;\n            right                = tmpNode;\n\n            if (left != null) {\n                left.parent = this;\n            }\n            if (right.right != null) {\n                right.right.parent = right;\n            }\n\n        }\n",
        "begin_line": 584,
        "end_line": 603,
        "comment": " Perform a clockwise rotation rooted at the instance.\n         * <p>The skew factor are not updated by this method, they\n         * <em>must</em> be updated by the caller</p>\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getParent#216",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getParent()",
        "snippet": "    public BSPTree<S> getParent() {\n        return parent;\n    }\n",
        "begin_line": 216,
        "end_line": 218,
        "comment": " Get the parent node.\n     * @return parent node, null if the node has no parents\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.split#487",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.split(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>)",
        "snippet": "    public BSPTree<S> split(final SubHyperplane<S> sub) {\n\n        if (cut == null) {\n            return new BSPTree<S>(sub, copySelf(),\n                    new BSPTree<S>(attribute), null);\n        }\n\n        final Hyperplane<S> cHyperplane = cut.getHyperplane();\n        final Hyperplane<S> sHyperplane = sub.getHyperplane();\n        switch (sub.side(cHyperplane)) {\n        case PLUS :\n        { // the partitioning sub-hyperplane is entirely in the plus sub-tree\n            final BSPTree<S> split = plus.split(sub);\n            if (cut.side(sHyperplane) == Side.PLUS) {\n                split.plus =\n                    new BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute);\n                split.plus.condense();\n                split.plus.parent = split;\n            } else {\n                split.minus =\n                    new BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute);\n                split.minus.condense();\n                split.minus.parent = split;\n            }\n            return split;\n        }\n        case MINUS :\n        { // the partitioning sub-hyperplane is entirely in the minus sub-tree\n            final BSPTree<S> split = minus.split(sub);\n            if (cut.side(sHyperplane) == Side.PLUS) {\n                split.plus =\n                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute);\n                split.plus.condense();\n                split.plus.parent = split;\n            } else {\n                split.minus =\n                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute);\n                split.minus.condense();\n                split.minus.parent = split;\n            }\n            return split;\n        }\n        case BOTH :\n        {\n            final SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane);\n            final SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane);\n            final BSPTree<S> split =\n                new BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),\n                               null);\n            split.plus.cut          = cutParts.getPlus();\n            split.minus.cut         = cutParts.getMinus();\n            final BSPTree<S> tmp    = split.plus.minus;\n            split.plus.minus        = split.minus.plus;\n            split.plus.minus.parent = split.plus;\n            split.minus.plus        = tmp;\n            split.minus.plus.parent = split.minus;\n            split.plus.condense();\n            split.minus.condense();\n            return split;\n        }\n        default :\n            return cHyperplane.sameOrientationAs(sHyperplane) ?\n                   new BSPTree<S>(sub, plus.copySelf(),  minus.copySelf(), attribute) :\n                   new BSPTree<S>(sub, minus.copySelf(), plus.copySelf(),  attribute);\n        }\n\n    }\n",
        "begin_line": 487,
        "end_line": 553,
        "comment": " Split a BSP tree by an external sub-hyperplane.\n     * <p>Split a tree in two halves, on each side of the\n     * sub-hyperplane. The instance is not modified.</p>\n     * <p>The tree returned is not upward-consistent: despite all of its\n     * sub-trees cut sub-hyperplanes (including its own cut\n     * sub-hyperplane) are bounded to the current cell, it is <em>not</em>\n     * attached to any parent tree yet. This tree is intended to be\n     * later inserted into an higher level tree.</p>\n     * <p>The algorithm used here is the one given in Naylor, Amanatides\n     * and Thibault paper (section III, Binary Partitioning of a BSP\n     * Tree).</p>\n     * @param sub partitioning sub-hyperplane, must be already clipped\n     * to the convex region represented by the instance, will be used as\n     * the cut sub-hyperplane of the returned tree\n     * @return a tree having the specified sub-hyperplane as its cut\n     * sub-hyperplane, the two parts of the split instance as its two\n     * sub-trees and a null parent\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.AbstractRegion#89",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(java.util.Collection<org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>>)",
        "snippet": "    protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\n\n        if (boundary.size() == 0) {\n\n            // the tree represents the whole space\n            tree = new BSPTree<S>(Boolean.TRUE);\n\n        } else {\n\n            // sort the boundary elements in decreasing size order\n            // (we don't want equal size elements to be removed, so\n            // we use a trick to fool the TreeSet)\n            final TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\n                public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\n                    final double size1 = o1.getSize();\n                    final double size2 = o2.getSize();\n                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n                }\n            });\n            ordered.addAll(boundary);\n\n            // build the tree top-down\n            tree = new BSPTree<S>();\n            insertCuts(tree, ordered);\n\n            // set up the inside/outside flags\n            tree.visit(new BSPTreeVisitor<S>() {\n\n                /** {@inheritDoc} */\n                public Order visitOrder(final BSPTree<S> node) {\n                    return Order.PLUS_SUB_MINUS;\n                }\n\n                /** {@inheritDoc} */\n                public void visitInternalNode(final BSPTree<S> node) {\n                }\n\n                /** {@inheritDoc} */\n                public void visitLeafNode(final BSPTree<S> node) {\n                    node.setAttribute((node == node.getParent().getPlus()) ?\n                                                                            Boolean.FALSE : Boolean.TRUE);\n                }\n            });\n\n        }\n\n    }\n",
        "begin_line": 89,
        "end_line": 135,
        "comment": " Build a Region from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoints polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link #checkPoint(Vector) checkPoint} method will not be\n     * meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements, as a\n     * collection of {@link SubHyperplane SubHyperplane} objects\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.visitOrder#118",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Anonymous-edda5903-5a6e-453c-8319-794d0ef02bd4.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "                public Order visitOrder(final BSPTree<S> node) {\n                    return Order.PLUS_SUB_MINUS;\n                }\n",
        "begin_line": 118,
        "end_line": 120,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Build a region using the instance as a prototype.\n     * <p>This method allow to create new instances without knowing\n     * exactly the type of the region. It is an application of the\n     * prototype design pattern.</p>\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param newTree inside/outside BSP tree representing the new region\n     * @return the built region\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.visitInternalNode#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Anonymous-c26dee8d-1595-477c-a299-dba17daff432.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "                public void visitInternalNode(final BSPTree<S> node) {\n                }\n",
        "begin_line": 123,
        "end_line": 124,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Build a region using the instance as a prototype.\n     * <p>This method allow to create new instances without knowing\n     * exactly the type of the region. It is an application of the\n     * prototype design pattern.</p>\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param newTree inside/outside BSP tree representing the new region\n     * @return the built region\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.visitLeafNode#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Anonymous-3f051a33-a42c-49c1-a923-08e0182de769.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "                public void visitLeafNode(final BSPTree<S> node) {\n                    node.setAttribute((node == node.getParent().getPlus()) ?\n                                                                            Boolean.FALSE : Boolean.TRUE);\n                }\n",
        "begin_line": 127,
        "end_line": 130,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Build a region using the instance as a prototype.\n     * <p>This method allow to create new instances without knowing\n     * exactly the type of the region. It is an application of the\n     * prototype design pattern.</p>\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param newTree inside/outside BSP tree representing the new region\n     * @return the built region\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.compare#102",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Anonymous-d4c1ea64-9969-4e55-b8e0-62f4b97339ad.compare(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>)",
        "snippet": "                public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\n                    final double size1 = o1.getSize();\n                    final double size2 = o2.getSize();\n                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n                }\n",
        "begin_line": 102,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.recurseBuildBoundary#289",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseBuildBoundary(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "    private void recurseBuildBoundary(final BSPTree<S> node) {\n        if (node.getCut() != null) {\n\n            SubHyperplane<S> plusOutside = null;\n            SubHyperplane<S> plusInside  = null;\n\n            // characterize the cut sub-hyperplane,\n            // first with respect to the plus sub-tree\n            final Characterization<S> plusChar = new Characterization<S>();\n            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n\n            if (plusChar.hasOut()) {\n                // plusChar.getOut() corresponds to a subset of the cut\n                // sub-hyperplane known to have outside cells on its plus\n                // side, we want to check if parts of this subset do have\n                // inside cells on their minus side\n                final Characterization<S> minusChar = new Characterization<S>();\n                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n                if (minusChar.hasIn()) {\n                    plusOutside = minusChar.getIn();\n                }\n            }\n\n            if (plusChar.hasIn()) {\n                // plusChar.getIn() corresponds to a subset of the cut\n                // sub-hyperplane known to have inside cells on its plus\n                // side, we want to check if parts of this subset do have\n                // outside cells on their minus side\n                final Characterization<S> minusChar = new Characterization<S>();\n                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n                if (minusChar.hasOut()) {\n                    plusInside = minusChar.getOut();\n                }\n            }\n\n            node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));\n            recurseBuildBoundary(node.getPlus());\n            recurseBuildBoundary(node.getMinus());\n\n        }\n    }\n",
        "begin_line": 289,
        "end_line": 329,
        "comment": " Recursively build the boundary shell tree.\n     * @param node current node in the inout tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.characterize#344",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.characterize(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.Characterization<S>)",
        "snippet": "    private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\n                              final Characterization<S> characterization) {\n        if (node.getCut() == null) {\n            // we have reached a leaf node\n            final boolean inside = (Boolean) node.getAttribute();\n            characterization.add(sub, inside);\n        } else {\n            final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n            switch (sub.side(hyperplane)) {\n            case PLUS:\n                characterize(node.getPlus(), sub, characterization);\n                break;\n            case MINUS:\n                characterize(node.getMinus(), sub, characterization);\n                break;\n            case BOTH:\n                final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n                characterize(node.getPlus(),  split.getPlus(),  characterization);\n                characterize(node.getMinus(), split.getMinus(), characterization);\n                break;\n            default:\n                // this should not happen\n                throw new MathInternalError();\n            }\n        }\n    }\n",
        "begin_line": 344,
        "end_line": 369,
        "comment": " Filter the parts of an hyperplane belonging to the boundary.\n     * <p>The filtering consist in splitting the specified\n     * sub-hyperplane into several parts lying in inside and outside\n     * cells of the tree. The principle is to call this method twice for\n     * each cut sub-hyperplane in the tree, once one the plus node and\n     * once on the minus node. The parts that have the same flag\n     * (inside/inside or outside/outside) do not belong to the boundary\n     * while parts that have different flags (inside/outside or\n     * outside/inside) do belong to the boundary.</p>\n     * @param node current BSP tree node\n     * @param sub sub-hyperplane to characterize\n     * @param characterization placeholder where to put the characterized parts\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.PolygonsSet#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet(java.util.Collection<org.apache.commons.math3.geometry.partitioning.SubHyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>>)",
        "snippet": "    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n        super(boundary);\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": " Build a polygons set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoint polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements, as a\n     * collection of {@link SubHyperplane SubHyperplane} objects\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.delete#369",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.delete()",
        "snippet": "        public void delete() {\n            if ((parent == null) && (left == null) && (right == null)) {\n                // this was the last node, the tree is now empty\n                element = null;\n                top     = null;\n            } else {\n\n                Node node;\n                Node child;\n                boolean leftShrunk;\n                if ((left == null) && (right == null)) {\n                    node       = this;\n                    element    = null;\n                    leftShrunk = node == node.parent.left;\n                    child      = null;\n                } else {\n                    node       = (left != null) ? left.getLargest() : right.getSmallest();\n                    element    = node.element;\n                    leftShrunk = node == node.parent.left;\n                    child      = (node.left != null) ? node.left : node.right;\n                }\n\n                node = node.parent;\n                if (leftShrunk) {\n                    node.left = child;\n                } else {\n                    node.right = child;\n                }\n                if (child != null) {\n                    child.parent = node;\n                }\n\n                while (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) {\n                    if (node.parent == null) {\n                        return;\n                    }\n                    leftShrunk = node == node.parent.left;\n                    node = node.parent;\n                }\n\n            }\n        }\n",
        "begin_line": 369,
        "end_line": 410,
        "comment": " Delete the node from the tree.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.chopOffMinus#613",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffMinus(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>)",
        "snippet": "    private void chopOffMinus(final Hyperplane<S> hyperplane) {\n        if (cut != null) {\n            cut = cut.split(hyperplane).getPlus();\n            plus.chopOffMinus(hyperplane);\n            minus.chopOffMinus(hyperplane);\n        }\n    }\n",
        "begin_line": 613,
        "end_line": 619,
        "comment": " Chop off parts of the tree.\n     * <p>The instance is modified in place, all the parts that are on\n     * the minus side of the chopping hyperplane are discarded, only the\n     * parts on the plus side remain.</p>\n     * @param hyperplane chopping hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.PolygonsSet#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n        super(tree);\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": " Build a polygons set from a BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the region\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.computeGeometricalProperties#137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.computeGeometricalProperties()",
        "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getLength();\n                sum  += interval.getLength() * interval.getMidPoint();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }\n",
        "begin_line": 137,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": " Compute some geometrical properties.\n     * <p>The properties to compute are the barycenter and the size.</p>\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Interval.getLength#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getLength()",
        "snippet": "    public double getLength() {\n        return upper - lower;\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": " Get the length of the interval.\n     * @return length of the interval\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Interval.getMidPoint#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getMidPoint()",
        "snippet": "    public double getMidPoint() {\n        return 0.5 * (lower + upper);\n    }\n",
        "begin_line": 66,
        "end_line": 68,
        "comment": " Get the midpoint of the interval.\n     * @return midpoint of the interval\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.split#173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.split(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            // the lines are parallel\n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean2D>(null, this) :\n                   new SplitSubHyperplane<Euclidean2D>(this, null);\n        }\n\n        // the lines do intersect\n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x      = thisLine.toSubSpace(crossing);\n        final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n        final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n\n        final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\n        final BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n        final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n    }\n",
        "begin_line": 173,
        "end_line": 207,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.IntervalsSet#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(double, double)",
        "snippet": "    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }\n",
        "begin_line": 46,
        "end_line": 48,
        "comment": " Build an intervals set corresponding to a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.buildTree#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildTree(double, double)",
        "snippet": "    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }\n",
        "begin_line": 93,
        "end_line": 128,
        "comment": " Build an inside/outside tree representing a single interval.\n     * @param lower lower bound of the interval, must be lesser or equal\n     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n     * @param upper upper bound of the interval, must be greater or equal\n     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n     * @return the built tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.getSmallest#273",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.getSmallest()",
        "snippet": "        Node getSmallest() {\n            Node node = this;\n            while (node.left != null) {\n                node = node.left;\n            }\n            return node;\n        }\n",
        "begin_line": 273,
        "end_line": 279,
        "comment": " Get the node whose element is the smallest one in the tree\n         * rooted at this node.\n         * @return the tree node containing the smallest element in the\n         * tree rooted at this node or null if the tree is empty\n         * @see #getLargest\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.getNext#325",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.getNext()",
        "snippet": "        public Node getNext() {\n\n            if (right != null) {\n                final Node node = right.getSmallest();\n                if (node != null) {\n                    return node;\n                }\n            }\n\n            for (Node node = this; node.parent != null; node = node.parent) {\n                if (node != node.parent.right) {\n                    return node.parent;\n                }\n            }\n\n            return null;\n\n        }\n",
        "begin_line": 325,
        "end_line": 342,
        "comment": " Get the node containing the next larger or equal element.\n         * @return node containing the next larger or equal element (in\n         * which case the node is guaranteed not to be empty) or null if\n         * there is no larger or equal element in the tree\n         * @see #getPrevious\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.insert#348",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.insert(T)",
        "snippet": "        boolean insert(final T newElement) {\n            if (newElement.compareTo(this.element) < 0) {\n                // the inserted element is smaller than the node\n                if (left == null) {\n                    left = new Node(newElement, this);\n                    return rebalanceLeftGrown();\n                }\n                return left.insert(newElement) ? rebalanceLeftGrown() : false;\n            }\n\n            // the inserted element is equal to or greater than the node\n            if (right == null) {\n                right = new Node(newElement, this);\n                return rebalanceRightGrown();\n            }\n            return right.insert(newElement) ? rebalanceRightGrown() : false;\n\n        }\n",
        "begin_line": 348,
        "end_line": 365,
        "comment": " Insert an element in a sub-tree.\n         * @param newElement element to insert\n         * @return true if the parent tree should be re-Skew.BALANCED\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rotateCCW#609",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rotateCCW()",
        "snippet": "        private void rotateCCW() {\n\n            final T tmpElt        = element;\n            element               = right.element;\n            right.element         = tmpElt;\n\n            final Node tmpNode    = right;\n            right                 = tmpNode.right;\n            tmpNode.right         = tmpNode.left;\n            tmpNode.left          = left;\n            left                  = tmpNode;\n\n            if (right != null) {\n                right.parent = this;\n            }\n            if (left.left != null) {\n                left.left.parent = left;\n            }\n\n        }\n",
        "begin_line": 609,
        "end_line": 628,
        "comment": " Perform a counter-clockwise rotation rooted at the instance.\n         * <p>The skew factor are not updated by this method, they\n         * <em>must</em> be updated by the caller</p>\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.fitToCell#291",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>)",
        "snippet": "    private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n        SubHyperplane<S> s = sub;\n        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n            if (tree == tree.parent.plus) {\n                s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n            } else {\n                s = s.split(tree.parent.cut.getHyperplane()).getMinus();\n            }\n        }\n        return s;\n    }\n",
        "begin_line": 291,
        "end_line": 301,
        "comment": " Fit a sub-hyperplane inside the cell defined by the instance.\n     * <p>Fitting is done by chopping off the parts of the\n     * sub-hyperplane that lie outside of the cell using the\n     * cut-hyperplanes of the parent nodes of the instance.</p>\n     * @param sub sub-hyperplane to fit\n     * @return a new sub-hyperplane, gueranteed to have no part outside\n     * of the instance cell\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.condense#335",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.condense()",
        "snippet": "    private void condense() {\n        if ((cut != null) && (plus.cut == null) && (minus.cut == null) &&\n            (((plus.attribute == null) && (minus.attribute == null)) ||\n             ((plus.attribute != null) && plus.attribute.equals(minus.attribute)))) {\n            attribute = (plus.attribute == null) ? minus.attribute : plus.attribute;\n            cut       = null;\n            plus      = null;\n            minus     = null;\n        }\n    }\n",
        "begin_line": 335,
        "end_line": 344,
        "comment": " Perform condensation on a tree.\n     * <p>The condensation operation is not recursive, it must be called\n     * explicitely from leaves to root.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.insertInTree#564",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertInTree(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, boolean)",
        "snippet": "    public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) {\n\n        // set up parent/child links\n        parent = parentTree;\n        if (parentTree != null) {\n            if (isPlusChild) {\n                parentTree.plus = this;\n            } else {\n                parentTree.minus = this;\n            }\n        }\n\n        // make sure the inserted tree lies in the cell defined by its parent nodes\n        if (cut != null) {\n\n            // explore the parent nodes from here towards tree root\n            for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n\n                // this is an hyperplane of some parent node\n                final Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane();\n\n                // chop off the parts of the inserted tree that extend\n                // on the wrong side of this parent hyperplane\n                if (tree == tree.parent.plus) {\n                    cut = cut.split(hyperplane).getPlus();\n                    plus.chopOffMinus(hyperplane);\n                    minus.chopOffMinus(hyperplane);\n                } else {\n                    cut = cut.split(hyperplane).getMinus();\n                    plus.chopOffPlus(hyperplane);\n                    minus.chopOffPlus(hyperplane);\n                }\n\n            }\n\n            // since we may have drop some parts of the inserted tree,\n            // perform a condensation pass to keep the tree structure simple\n            condense();\n\n        }\n\n    }\n",
        "begin_line": 564,
        "end_line": 605,
        "comment": " Insert the instance into another tree.\n     * <p>The instance itself is modified so its former parent should\n     * not be used anymore.</p>\n     * @param parentTree parent tree to connect to (may be null)\n     * @param isPlusChild if true and if parentTree is not null, the\n     * resulting tree should be the plus child of its parent, ignored if\n     * parentTree is null\n     * @see LeafMerger\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.chopOffPlus#627",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffPlus(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>)",
        "snippet": "    private void chopOffPlus(final Hyperplane<S> hyperplane) {\n        if (cut != null) {\n            cut = cut.split(hyperplane).getMinus();\n            plus.chopOffPlus(hyperplane);\n            minus.chopOffPlus(hyperplane);\n        }\n    }\n",
        "begin_line": 627,
        "end_line": 633,
        "comment": " Chop off parts of the tree.\n     * <p>The instance is modified in place, all the parts that are on\n     * the plus side of the chopping hyperplane are discarded, only the\n     * parts on the minus side remain.</p>\n     * @param hyperplane chopping hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.visitInternalNode#427",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n",
        "begin_line": 427,
        "end_line": 436,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.addContribution#446",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.addContribution(org.apache.commons.math3.geometry.partitioning.SubHyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>, boolean)",
        "snippet": "        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n",
        "begin_line": 446,
        "end_line": 463,
        "comment": " Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.getVertices#206",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.getVertices()",
        "snippet": "    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n",
        "begin_line": 206,
        "end_line": 284,
        "comment": " Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3423",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
        "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n",
        "begin_line": 3423,
        "end_line": 3425,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3491",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
        "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n",
        "begin_line": 3491,
        "end_line": 3493,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.OrderedTuple#132",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.OrderedTuple(double...)",
        "snippet": "    public OrderedTuple(final double ... components) {\n        this.components = components.clone();\n        int msb = Integer.MIN_VALUE;\n        lsb     = Integer.MAX_VALUE;\n        posInf  = false;\n        negInf  = false;\n        nan     = false;\n        for (int i = 0; i < components.length; ++i) {\n            if (Double.isInfinite(components[i])) {\n                if (components[i] < 0) {\n                    negInf = true;\n                } else {\n                    posInf = true;\n                }\n            } else if (Double.isNaN(components[i])) {\n                nan = true;\n            } else {\n                final long b = Double.doubleToLongBits(components[i]);\n                final long m = mantissa(b);\n                if (m != 0) {\n                    final int e = exponent(b);\n                    msb = FastMath.max(msb, e + computeMSB(m));\n                    lsb = FastMath.min(lsb, e + computeLSB(m));\n                }\n            }\n        }\n\n        if (posInf && negInf) {\n            // instance cannot be sorted logically\n            posInf = false;\n            negInf = false;\n            nan    = true;\n        }\n\n        if (lsb <= msb) {\n            // encode the T-upple with the specified offset\n            encode(msb + 16);\n        } else {\n            encoding = new long[] {\n                0x0L\n            };\n        }\n\n    }\n",
        "begin_line": 132,
        "end_line": 175,
        "comment": " Build an ordered T-uple from its components.\n     * @param components double components of the T-uple\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.encode#181",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.encode(int)",
        "snippet": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\n                    word |= 0x1L << shift;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }\n",
        "begin_line": 181,
        "end_line": 215,
        "comment": " Encode the T-uple with a given offset.\n     * @param minOffset minimal scale of the offset to add to all\n     * components (must be greater than the MSBs of all components)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.compareTo#247",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.compareTo(org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple)",
        "snippet": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\n                        return +1;\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }\n",
        "begin_line": 247,
        "end_line": 287,
        "comment": " Compares this ordered T-uple with the specified object.\n\n     * <p>The ordering method is detailed in the general description of\n     * the class. Its main property is to be consistent with distance:\n     * geometrically close T-uples stay close to each other when stored\n     * in a sorted collection using this comparison method.</p>\n\n     * <p>T-uples with negative infinite, positive infinite are sorted\n     * logically.</p>\n\n     * <p>Some arbitrary choices have been made to handle specific\n     * cases. The rationale for these choices is to keep\n     * <em>normal</em> and consistent T-uples together.</p>\n     * <ul>\n     * <li>instances with different dimensions are sorted according to\n     * their dimension regardless of their components values</li>\n     * <li>instances with {@code Double.NaN} components are sorted\n     * after all other ones (evan after instances with positive infinite\n     * components</li>\n     * <li>instances with both positive and negative infinite components\n     * are considered as if they had {@code Double.NaN}\n     * components</li>\n     * </ul>\n\n     * @param ot T-uple to compare instance with\n     * @return a negative integer if the instance is less than the\n     * object, zero if they are equal, or a positive integer if the\n     * instance is greater than the object\n\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.sign#323",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.sign(long)",
        "snippet": "    private static long sign(final long bits) {\n        return bits & SIGN_MASK;\n    }\n",
        "begin_line": 323,
        "end_line": 325,
        "comment": " Extract the sign from the bits of a double.\n     * @param bits binary representation of the double\n     * @return sign bit (zero if positive, non zero if negative)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.exponent#331",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.exponent(long)",
        "snippet": "    private static int exponent(final long bits) {\n        return ((int) ((bits & EXPONENT_MASK) >> 52)) - 1075;\n    }\n",
        "begin_line": 331,
        "end_line": 333,
        "comment": " Extract the exponent from the bits of a double.\n     * @param bits binary representation of the double\n     * @return exponent\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.mantissa#339",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.mantissa(long)",
        "snippet": "    private static long mantissa(final long bits) {\n        return ((bits & EXPONENT_MASK) == 0) ?\n               ((bits & MANTISSA_MASK) << 1) :          // subnormal number\n               (IMPLICIT_ONE | (bits & MANTISSA_MASK)); // normal number\n    }\n",
        "begin_line": 339,
        "end_line": 343,
        "comment": " Extract the mantissa from the bits of a double.\n     * @param bits binary representation of the double\n     * @return mantissa\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.computeMSB#351",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.computeMSB(long)",
        "snippet": "    private static int computeMSB(final long l) {\n\n        long ll = l;\n        long mask  = 0xffffffffL;\n        int  scale = 32;\n        int  msb   = 0;\n\n        while (scale != 0) {\n            if ((ll & mask) != ll) {\n                msb |= scale;\n                ll = ll >> scale;\n            }\n            scale = scale >> 1;\n            mask  = mask >> scale;\n        }\n\n        return msb;\n\n    }\n",
        "begin_line": 351,
        "end_line": 369,
        "comment": " Compute the most significant bit of a long.\n     * @param l long from which the most significant bit is requested\n     * @return scale of the most significant bit of {@code l},\n     * or 0 if {@code l} is zero\n     * @see #computeLSB\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.computeLSB#377",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.computeLSB(long)",
        "snippet": "    private static int computeLSB(final long l) {\n\n        long ll = l;\n        long mask  = 0xffffffff00000000L;\n        int  scale = 32;\n        int  lsb   = 0;\n\n        while (scale != 0) {\n            if ((ll & mask) == ll) {\n                lsb |= scale;\n                ll = ll >> scale;\n            }\n            scale = scale >> 1;\n            mask  = mask >> scale;\n        }\n\n        return lsb;\n\n    }\n",
        "begin_line": 377,
        "end_line": 395,
        "comment": " Compute the least significant bit of a long.\n     * @param l long from which the least significant bit is requested\n     * @return scale of the least significant bit of {@code l},\n     * or 63 if {@code l} is zero\n     * @see #computeMSB\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrderedTuple.getBit#403",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.getBit(int, int)",
        "snippet": "    private int getBit(final int i, final int k) {\n        final long bits = Double.doubleToLongBits(components[i]);\n        final int e = exponent(bits);\n        if ((k < e) || (k > offset)) {\n            return 0;\n        } else if (k == offset) {\n            return (sign(bits) == 0L) ? 1 : 0;\n        } else if (k > (e + 52)) {\n            return (sign(bits) == 0L) ? 0 : 1;\n        } else {\n            final long m = (sign(bits) == 0L) ? mantissa(bits) : -mantissa(bits);\n            return (int) ((m >> (k - e)) & 0x1L);\n        }\n    }\n",
        "begin_line": 403,
        "end_line": 416,
        "comment": " Get a bit from the mantissa of a double.\n     * @param i index of the component\n     * @param k scale of the requested bit\n     * @return the specified bit (either 0 or 1), after the offset has\n     * been added to the double\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.Node#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.Node(T, org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node)",
        "snippet": "        Node(final T element, final Node parent) {\n            this.element = element;\n            left         = null;\n            right        = null;\n            this.parent  = parent;\n            skew         = Skew.BALANCED;\n        }\n",
        "begin_line": 245,
        "end_line": 251,
        "comment": " Build a node for a specified element.\n         * @param element element\n         * @param parent parent node\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.getElement#256",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.getElement()",
        "snippet": "        public T getElement() {\n            return element;\n        }\n",
        "begin_line": 256,
        "end_line": 258,
        "comment": " Get the contained element.\n         * @return element contained in the node\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.rebalanceRightShrunk#538",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.Node.rebalanceRightShrunk()",
        "snippet": "        private boolean rebalanceRightShrunk() {\n            switch (skew) {\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                    return true;\n                } else if (left.skew == Skew.BALANCED) {\n                    rotateCW();\n                    skew       = Skew.RIGHT_HIGH;\n                    right.skew = Skew.LEFT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.LEFT_HIGH;\n                return false;\n            }\n        }\n",
        "begin_line": 538,
        "end_line": 578,
        "comment": " Re-balance the instance as right sub-tree has shrunk.\n         * @return true if the parent tree should be reSkew.BALANCED too\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.AVLTree#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.AVLTree()",
        "snippet": "    public AVLTree() {\n        top = null;\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": " Build an empty tree.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.insert#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.insert(T)",
        "snippet": "    public void insert(final T element) {\n        if (element != null) {\n            if (top == null) {\n                top = new Node(element, null);\n            } else {\n                top.insert(element);\n            }\n        }\n    }\n",
        "begin_line": 61,
        "end_line": 69,
        "comment": " Insert an element in the tree.\n     * @param element element to insert (silently ignored if null)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.isEmpty#102",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return top == null;\n    }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": " Check if the tree is empty.\n     * @return true if the tree is empty\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AVLTree.getSmallest#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.getSmallest()",
        "snippet": "    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": " Get the node whose element is the smallest one in the tree.\n     * @return the tree node containing the smallest element in the tree\n     * or null if the tree is empty\n     * @see #getLargest\n     * @see #getNotSmaller\n     * @see #getNotLarger\n     * @see Node#getPrevious\n     * @see Node#getNext\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.distance#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    public double distance(Vector<Euclidean2D> p) {\n        Vector2D p3 = (Vector2D) p;\n        final double dx = p3.x - x;\n        final double dy = p3.y - y;\n        return FastMath.sqrt(dx * dx + dy * dy);\n    }\n",
        "begin_line": 260,
        "end_line": 265,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.Vector": null,
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Segment.Segment#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.Segment(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Line)",
        "snippet": "    public Segment(final Vector2D start, final Vector2D end, final Line line) {\n        this.start  = start;\n        this.end    = end;\n        this.line   = line;\n    }\n",
        "begin_line": 40,
        "end_line": 44,
        "comment": " Build a segment.\n     * @param start start point of the segment\n     * @param end end point of the segment\n     * @param line line containing the segment\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Segment.getStart#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.getStart()",
        "snippet": "    public Vector2D getStart() {\n        return start;\n    }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": " Get the start point of the segment.\n     * @return start point of the segment\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "Segment.getEnd#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.getEnd()",
        "snippet": "    public Vector2D getEnd() {\n        return end;\n    }\n",
        "begin_line": 56,
        "end_line": 58,
        "comment": " Get the end point of the segment.\n     * @return end point of the segment\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.SegmentsBuilder#417",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.SegmentsBuilder()",
        "snippet": "        public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n",
        "begin_line": 417,
        "end_line": 419,
        "comment": " Simple constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.visitOrder#422",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n",
        "begin_line": 422,
        "end_line": 424,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.visitLeafNode#439",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n",
        "begin_line": 439,
        "end_line": 440,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.getSorted#468",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.SegmentsBuilder.getSorted()",
        "snippet": "        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n",
        "begin_line": 468,
        "end_line": 470,
        "comment": " Get the sorted segments.\n         * @return sorted segments\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.ComparableSegment#363",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.ComparableSegment.ComparableSegment(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Line)",
        "snippet": "        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n",
        "begin_line": 363,
        "end_line": 368,
        "comment": " Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.ComparableSegment#379",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.ComparableSegment.ComparableSegment(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, double)",
        "snippet": "        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n",
        "begin_line": 379,
        "end_line": 382,
        "comment": " Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "PolygonsSet.compareTo#385",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.ComparableSegment.compareTo(org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.ComparableSegment)",
        "snippet": "        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n",
        "begin_line": 385,
        "end_line": 387,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.euclidean.twod.Segment": null,
            "java.lang.Comparable": null,
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.merge#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.UnionMerger.merge(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, boolean, boolean)",
        "snippet": "        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n                                final BSPTree<S> parentTree,\n                                final boolean isPlusChild, final boolean leafFromInstance) {\n            if ((Boolean) leaf.getAttribute()) {\n                // the leaf node represents an inside cell\n                leaf.insertInTree(parentTree, isPlusChild);\n                return leaf;\n            }\n            // the leaf node represents an outside cell\n            tree.insertInTree(parentTree, isPlusChild);\n            return tree;\n        }\n",
        "begin_line": 161,
        "end_line": 172,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger": null
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.Characterization#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.Characterization()",
        "snippet": "    public Characterization() {\n        in  = null;\n        out = null;\n    }\n",
        "begin_line": 36,
        "end_line": 39,
        "comment": " Create an empty characterization of a sub-hyperplane.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.hasIn#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.hasIn()",
        "snippet": "    public boolean hasIn() {\n        return (in != null) && (!in.isEmpty());\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": " Check if the sub-hyperplane that have inside cells on the tested side.\n     * @return true if the sub-hyperplane that have inside cells on the tested side\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.getIn#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.getIn()",
        "snippet": "    public SubHyperplane<S> getIn() {\n        return in;\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": " Get the parts of the sub-hyperplane that have inside cells on the tested side.\n     * @return parts of the sub-hyperplane that have inside cells on the tested side\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.hasOut#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.hasOut()",
        "snippet": "    public boolean hasOut() {\n        return (out != null) && (!out.isEmpty());\n    }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": " Check if the sub-hyperplane that have outside cells on the tested side.\n     * @return true if the sub-hyperplane that have outside cells on the tested side\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.getOut#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.getOut()",
        "snippet": "    public SubHyperplane<S> getOut() {\n        return out;\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": " Get the parts of the sub-hyperplane that have outside cells on the tested side.\n     * @return parts of the sub-hyperplane that have outside cells on the tested side\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Characterization.add#74",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/Characterization.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
        "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.add(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, boolean)",
        "snippet": "    public void add(final SubHyperplane<S> sub, final boolean inside) {\n        if (inside) {\n            if (in == null) {\n                in = sub;\n            } else {\n                in = in.reunite(sub);\n            }\n        } else {\n            if (out == null) {\n                out = sub;\n            } else {\n                out = out.reunite(sub);\n            }\n        }\n    }\n",
        "begin_line": 74,
        "end_line": 88,
        "comment": " Add a part of the sub-hyperplane known to have inside or outside cell on the tested side.\n     * @param sub part of the sub-hyperplane to add\n     * @param inside if true, the part added as an inside cell on the tested side, otherwise\n     * it has an outside cell on the tested side\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BoundaryAttribute.BoundaryAttribute#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BoundaryAttribute.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
        "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.BoundaryAttribute(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>)",
        "snippet": "    public BoundaryAttribute(final SubHyperplane<S> plusOutside,\n                             final SubHyperplane<S> plusInside) {\n        this.plusOutside = plusOutside;\n        this.plusInside  = plusInside;\n    }\n",
        "begin_line": 56,
        "end_line": 60,
        "comment": " Simple constructor.\n     * @param plusOutside part of the node cut sub-hyperplane that\n     * belongs to the boundary and has the outside of the region on\n     * the plus side of its underlying hyperplane (may be null)\n     * @param plusInside part of the node cut sub-hyperplane that\n     * belongs to the boundary and has the inside of the region on the\n     * plus side of its underlying hyperplane (may be null)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BoundaryAttribute.getPlusOutside#69",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BoundaryAttribute.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
        "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.getPlusOutside()",
        "snippet": "    public SubHyperplane<S> getPlusOutside() {\n        return plusOutside;\n    }\n",
        "begin_line": 69,
        "end_line": 71,
        "comment": " Get the part of the node cut sub-hyperplane that belongs to the\n     * boundary and has the outside of the region on the plus side of\n     * its underlying hyperplane.\n     * @return part of the node cut sub-hyperplane that belongs to the\n     * boundary and has the outside of the region on the plus side of\n     * its underlying hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BoundaryAttribute.getPlusInside#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BoundaryAttribute.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
        "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.getPlusInside()",
        "snippet": "    public SubHyperplane<S> getPlusInside() {\n        return plusInside;\n    }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": " Get the part of the node cut sub-hyperplane that belongs to the\n     * boundary and has the inside of the region on the plus side of\n     * its underlying hyperplane.\n     * @return part of the node cut sub-hyperplane that belongs to the\n     * boundary and has the inside of the region on the plus side of\n     * its underlying hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.BSPTree#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree()",
        "snippet": "    public BSPTree() {\n        cut       = null;\n        plus      = null;\n        minus     = null;\n        parent    = null;\n        attribute = null;\n    }\n",
        "begin_line": 82,
        "end_line": 88,
        "comment": " Build a tree having only one root cell representing the whole space.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.insertCut#148",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>)",
        "snippet": "    public boolean insertCut(final Hyperplane<S> hyperplane) {\n\n        if (cut != null) {\n            plus.parent  = null;\n            minus.parent = null;\n        }\n\n        final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane());\n        if (chopped.isEmpty()) {\n            cut          = null;\n            plus         = null;\n            minus        = null;\n            return false;\n        }\n\n        cut          = chopped;\n        plus         = new BSPTree<S>();\n        plus.parent  = this;\n        minus        = new BSPTree<S>();\n        minus.parent = this;\n        return true;\n\n    }\n",
        "begin_line": 148,
        "end_line": 170,
        "comment": " Insert a cut sub-hyperplane in a node.\n     * <p>The sub-tree starting at this node will be completely\n     * overwritten. The new cut sub-hyperplane will be built from the\n     * intersection of the provided hyperplane with the cell. If the\n     * hyperplane does intersect the cell, the cell will have two\n     * children cells with {@code null} attributes on each side of\n     * the inserted cut sub-hyperplane. If the hyperplane does not\n     * intersect the cell then <em>no</em> cut hyperplane will be\n     * inserted and the cell will be changed to a leaf cell. The\n     * attribute of the node is never changed.</p>\n     * <p>This method is mainly useful when called on leaf nodes\n     * (i.e. nodes for which {@link #getCut getCut} returns\n     * {@code null}), in this case it provides a way to build a\n     * tree top-down (whereas the {@link #BSPTree(SubHyperplane,\n     * BSPTree, BSPTree, Object) 4 arguments constructor} is devoted to\n     * build trees bottom-up).</p>\n     * @param hyperplane hyperplane to insert, it will be chopped in\n     * order to fit in the cell defined by the parent nodes of the\n     * instance\n     * @return true if a cut sub-hyperplane has been inserted (i.e. if\n     * the cell now has two leaf child nodes)\n     * @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.copySelf#179",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.copySelf()",
        "snippet": "    public BSPTree<S> copySelf() {\n\n        if (cut == null) {\n            return new BSPTree<S>(attribute);\n        }\n\n        return new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n                           attribute);\n\n    }\n",
        "begin_line": 179,
        "end_line": 188,
        "comment": " Copy the instance.\n     * <p>The instance created is completely independant of the original\n     * one. A deep copy is used, none of the underlying objects are\n     * shared (except for the nodes attributes and immutable\n     * objects).</p>\n     * @return a new tree, copy of the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.visit#241",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.visit(org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor<S>)",
        "snippet": "    public void visit(final BSPTreeVisitor<S> visitor) {\n        if (cut == null) {\n            visitor.visitLeafNode(this);\n        } else {\n            switch (visitor.visitOrder(this)) {\n            case PLUS_MINUS_SUB:\n                plus.visit(visitor);\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case PLUS_SUB_MINUS:\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                break;\n            case MINUS_PLUS_SUB:\n                minus.visit(visitor);\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case MINUS_SUB_PLUS:\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                break;\n            case SUB_PLUS_MINUS:\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                minus.visit(visitor);\n                break;\n            case SUB_MINUS_PLUS:\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                plus.visit(visitor);\n                break;\n            default:\n                throw new MathInternalError();\n            }\n\n        }\n    }\n",
        "begin_line": 241,
        "end_line": 281,
        "comment": " Visit the BSP tree nodes.\n     * @param visitor object visiting the tree nodes\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getCell#310",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCell(org.apache.commons.math3.geometry.Vector<S>)",
        "snippet": "    public BSPTree<S> getCell(final Vector<S> point) {\n\n        if (cut == null) {\n            return this;\n        }\n\n        // position of the point with respect to the cut hyperplane\n        final double offset = cut.getHyperplane().getOffset(point);\n\n        if (FastMath.abs(offset) < 1.0e-10) {\n            return this;\n        } else if (offset <= 0) {\n            // point is on the minus side of the cut hyperplane\n            return minus.getCell(point);\n        } else {\n            // point is on the plus side of the cut hyperplane\n            return plus.getCell(point);\n        }\n\n    }\n",
        "begin_line": 310,
        "end_line": 329,
        "comment": " Get the cell to which a point belongs.\n     * <p>If the returned cell is a leaf node the points belongs to the\n     * interior of the node, if the cell is an internal node the points\n     * belongs to the node cut sub-hyperplane.</p>\n     * @param point point to check\n     * @return the tree cell to which the point belongs (can be\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.getSize#88",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getSize()",
        "snippet": "    public double getSize() {\n        return remainingRegion.getSize();\n    }\n",
        "begin_line": 88,
        "end_line": 90,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": " Get the size of the instance.\n     * @return the size of the instance (this is a length in 1D, an area\n     * in 2D, a volume in 3D ...)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.getTree#278",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getTree(boolean)",
        "snippet": "    public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {\n        if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n            // we need to compute the boundary attributes\n            recurseBuildBoundary(tree);\n        }\n        return tree;\n    }\n",
        "begin_line": 278,
        "end_line": 284,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Get the underlying BSP tree.\n\n     * <p>Regions are represented by an underlying inside/outside BSP\n     * tree whose leaf attributes are {@code Boolean} instances\n     * representing inside leaf cells if the attribute value is\n     * {@code true} and outside leaf cells if the attribute is\n     * {@code false}. These leaf attributes are always present and\n     * guaranteed to be non null.</p>\n\n     * <p>In addition to the leaf attributes, the internal nodes which\n     * correspond to cells split by cut sub-hyperplanes may contain\n     * {@link BoundaryAttribute BoundaryAttribute} objects representing\n     * the parts of the corresponding cut sub-hyperplane that belong to\n     * the boundary. When the boundary attributes have been computed,\n     * all internal nodes are guaranteed to have non-null\n     * attributes, however some {@link BoundaryAttribute\n     * BoundaryAttribute} instances may have their {@link\n     * BoundaryAttribute#plusInside plusInside} and {@link\n     * BoundaryAttribute#plusOutside plusOutside} fields both null if\n     * the corresponding cut sub-hyperplane does not have any parts\n     * belonging to the boundary.</p>\n\n     * <p>Since computing the boundary is not always required and can be\n     * time-consuming for large trees, these internal nodes attributes\n     * are computed using lazy evaluation only when required by setting\n     * the {@code includeBoundaryAttributes} argument to\n     * {@code true}. Once computed, these attributes remain in the\n     * tree, which implies that in this case, further calls to the\n     * method for the same region will always include these attributes\n     * regardless of the value of the\n     * {@code includeBoundaryAttributes} argument.</p>\n\n     * @param includeBoundaryAttributes if true, the boundary attributes\n     * at internal nodes are guaranteed to be included (they may be\n     * included even if the argument is false, if they have already been\n     * computed due to a previous call)\n     * @return underlying BSP tree\n     * @see BoundaryAttribute\n     "
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.toSpace#186",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public Vector3D toSpace(final Vector<Euclidean1D> point) {\n        return pointAt(((Vector1D) point).getX());\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": " {@inheritDoc}\n     * @see #pointAt(double)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Interval.getLower#45",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getLower()",
        "snippet": "    public double getLower() {\n        return lower;\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": " Get the lower bound of the interval.\n     * @return lower bound of the interval\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "Interval.getUpper#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getUpper()",
        "snippet": "    public double getUpper() {\n        return upper;\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": " Get the upper bound of the interval.\n     * @return upper bound of the interval\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.visitOrder#233",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.NodesCleaner.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "        public Order visitOrder(final BSPTree<S> node) {\n            return Order.PLUS_SUB_MINUS;\n        }\n",
        "begin_line": 233,
        "end_line": 235,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": " Determine the visit order for this node.\n     * <p>Before attempting to visit an internal node, this method is\n     * called to determine the desired ordering of the visit. It is\n     * guaranteed that this method will be called before {@link\n     * #visitInternalNode visitInternalNode} for a given node, it will be\n     * called exactly once for each internal node.</p>\n     * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n     * @return desired visit order, must be one of\n     * {@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n     * {@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n     * {@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}\n     "
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.visitInternalNode#238",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.NodesCleaner.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "        public void visitInternalNode(final BSPTree<S> node) {\n            node.setAttribute(null);\n        }\n",
        "begin_line": 238,
        "end_line": 240,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": " Determine the visit order for this node.\n     * <p>Before attempting to visit an internal node, this method is\n     * called to determine the desired ordering of the visit. It is\n     * guaranteed that this method will be called before {@link\n     * #visitInternalNode visitInternalNode} for a given node, it will be\n     * called exactly once for each internal node.</p>\n     * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n     * @return desired visit order, must be one of\n     * {@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n     * {@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n     * {@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}\n     "
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.union#74",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.union(org.apache.commons.math3.geometry.partitioning.Region<S>, org.apache.commons.math3.geometry.partitioning.Region<S>)",
        "snippet": "    public Region<S> union(final Region<S> region1, final Region<S> region2) {\n        final BSPTree<S> tree =\n            region1.getTree(false).merge(region2.getTree(false), new UnionMerger());\n        tree.visit(nodeCleaner);\n        return region1.buildNew(tree);\n    }\n",
        "begin_line": 74,
        "end_line": 79,
        "comment": " Compute the union of two regions.\n     * @param region1 first region (will be unusable after the operation as\n     * parts of it will be reused in the new region)\n     * @param region2 second region (will be unusable after the operation as\n     * parts of it will be reused in the new region)\n     * @return a new region, result of {@code region1 union region2}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.reunite#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.reunite(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>)",
        "snippet": "    public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {\n        @SuppressWarnings(\"unchecked\")\n        AbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;\n        return buildNew(hyperplane,\n                        new RegionFactory<T>().union(remainingRegion, o.remainingRegion));\n    }\n",
        "begin_line": 93,
        "end_line": 98,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": " Compute the union of the instance and another sub-hyperplane.\n     * @param other other sub-hyperplane to union (<em>must</em> be in the\n     * same hyperplane as the instance)\n     * @return a new sub-hyperplane, union of the instance and other\n     "
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.getSize#379",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize()",
        "snippet": "    public double getSize() {\n        if (barycenter == null) {\n            computeGeometricalProperties();\n        }\n        return size;\n    }\n",
        "begin_line": 379,
        "end_line": 384,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Get the size of the instance.\n     * @return the size of the instance (this is a length in 1D, an area\n     * in 2D, a volume in 3D ...)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.setSize#389",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setSize(double)",
        "snippet": "    protected void setSize(final double size) {\n        this.size = size;\n    }\n",
        "begin_line": 389,
        "end_line": 391,
        "comment": " Set the size of the instance.\n     * @param size size of the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.setBarycenter#404",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setBarycenter(org.apache.commons.math3.geometry.Vector<S>)",
        "snippet": "    protected void setBarycenter(final Vector<S> barycenter) {\n        this.barycenter = barycenter;\n    }\n",
        "begin_line": 404,
        "end_line": 406,
        "comment": " Set the barycenter of the instance.\n     * @param barycenter barycenter of the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubOrientedPoint.split#63",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.split(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean1D> split(final Hyperplane<Euclidean1D> hyperplane) {\n        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global < -1.0e-10) ?\n                                    new SplitSubHyperplane<Euclidean1D>(null, this) :\n                                        new SplitSubHyperplane<Euclidean1D>(this, null);\n    }\n",
        "begin_line": 63,
        "end_line": 69,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.buildNew#131",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }\n",
        "begin_line": 131,
        "end_line": 134,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractRegion": null,
            "org.apache.commons.math3.geometry.partitioning.Region": null
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getExponent#3670",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.getExponent(double)",
        "snippet": "    public static int getExponent(final double d) {\n        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n    }\n",
        "begin_line": 3670,
        "end_line": 3672,
        "comment": "\n     * Return the exponent of a double number, removing the bias.\n     * <p>\n     * For double numbers of the form 2<sup>x</sup>, the unbiased\n     * exponent is exactly x.\n     * </p>\n     * @param d number from which exponent is requested\n     * @return exponent for d in IEEE754 representation, without bias\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.side#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.side(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>)",
        "snippet": "    @Override\n    public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            // the lines are parallel,\n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        // the lines do intersect\n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x = thisLine.toSubSpace(crossing);\n        return getRemainingRegion().side(new OrientedPoint(x, direct));\n\n    }\n",
        "begin_line": 152,
        "end_line": 170,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.Line#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.revert()",
        "snippet": "    public Line revert() {\n        return new Line(zero, zero.subtract(direction));\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": " Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.reset#128",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }\n",
        "begin_line": 73,
        "end_line": 81,
        "comment": " Reset the instance as if built from two points.\n     * @param p1 first point belonging to the line (this can be any point)\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\n     * @exception MathIllegalArgumentException if the points are equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.intersection#197",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.intersection(org.apache.commons.math3.geometry.euclidean.threed.Line)",
        "snippet": "    public Vector3D intersection(final Line line) {\n        final Vector3D closest = closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }\n",
        "begin_line": 213,
        "end_line": 216,
        "comment": " Get the intersection point of the instance and another line.\n     * @param line other line\n     * @return intersection point of the instance and the other line\n     * or null if there are no intersection points\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.getOffset#229",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(org.apache.commons.math3.geometry.euclidean.twod.Line)",
        "snippet": "    public double getOffset(final Line line) {\n        return originOffset +\n               ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n    }\n",
        "begin_line": 229,
        "end_line": 232,
        "comment": " Get the offset (oriented distance) of a parallel line.\n     * <p>This method should be called only for parallel lines otherwise\n     * the result is not meaningful.</p>\n     * <p>The offset is 0 if both lines are the same, it is\n     * positive if the line is on the right side of the instance and\n     * negative if it is on the left side, according to its natural\n     * orientation.</p>\n     * @param line line to check\n     * @return offset of the line\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.normalizeAngle#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathUtils.java",
        "class_name": "org.apache.commons.math3.util.MathUtils",
        "signature": "org.apache.commons.math3.util.MathUtils.normalizeAngle(double, double)",
        "snippet": "     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n     }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * Normalize an angle in a 2&pi wide interval around a center value.\n     * <p>This method has three main uses:</p>\n     * <ul>\n     *   <li>normalize an angle between 0 and 2&pi;:<br/>\n     *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n     *   <li>normalize an angle between -&pi; and +&pi;<br/>\n     *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n     *   <li>compute the angle between two defining angular positions:<br>\n     *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n     * </ul>\n     * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n     * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n     * as would be more satisfactory in a purely mathematical view.</p>\n     * @param a angle to normalize\n     * @param center center of the desired 2&pi; interval for the result\n     * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n     * @since 1.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polySine#1586",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
        "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }\n",
        "begin_line": 1586,
        "end_line": 1599,
        "comment": "\n     *  Computes sin(x) - x, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return sin(x) - x\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polyCosine#1607",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
        "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n",
        "begin_line": 1607,
        "end_line": 1617,
        "comment": "\n     *  Computes cos(x) - 1, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return cos(x) - 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sinQ#1626",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
        "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n",
        "begin_line": 1626,
        "end_line": 1741,
        "comment": "\n     *  Compute sine over the first quadrant (0 < x < pi/2).\n     *  Use combination of table lookup and rational polynomial expansion.\n     *  @param xa number from which sine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return sin(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cosQ#1750",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
        "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n",
        "begin_line": 1750,
        "end_line": 1759,
        "comment": "\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n     *  @param xa number from which cosine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return cos(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3019",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3019,
        "end_line": 3021,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.floor#3331",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
        "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3331,
        "end_line": 3352,
        "comment": " Get the largest whole number smaller than x.\n     * @param x number from which floor is requested\n     * @return a double number f such that f is an integer f <= x < f + 1.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubHyperplane.SplitSubHyperplane#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/SubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.SubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane.SplitSubHyperplane.SplitSubHyperplane(org.apache.commons.math3.geometry.partitioning.SubHyperplane<U>, org.apache.commons.math3.geometry.partitioning.SubHyperplane<U>)",
        "snippet": "        public SplitSubHyperplane(final SubHyperplane<U> plus,\n                                  final SubHyperplane<U> minus) {\n            this.plus  = plus;\n            this.minus = minus;\n        }\n",
        "begin_line": 103,
        "end_line": 107,
        "comment": " Build a SplitSubHyperplane from its parts.\n         * @param plus part of the sub-hyperplane on the plus side of the\n         * splitting hyperplane\n         * @param minus part of the sub-hyperplane on the minus side of the\n         * splitting hyperplane\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubHyperplane.getPlus#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/SubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.SubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane.SplitSubHyperplane.getPlus()",
        "snippet": "        public SubHyperplane<U> getPlus() {\n            return plus;\n        }\n",
        "begin_line": 112,
        "end_line": 114,
        "comment": " Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.\n         * @return part of the sub-hyperplane on the plus side of the splitting hyperplane\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubHyperplane.getMinus#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/SubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.SubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane.SplitSubHyperplane.getMinus()",
        "snippet": "        public SubHyperplane<U> getMinus() {\n            return minus;\n        }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": " Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.\n         * @return part of the sub-hyperplane on the minus side of the splitting hyperplane\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.visitLeafNode#243",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.NodesCleaner.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "        public void visitLeafNode(final BSPTree<S> node) {\n        }\n",
        "begin_line": 243,
        "end_line": 244,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor": " Determine the visit order for this node.\n     * <p>Before attempting to visit an internal node, this method is\n     * called to determine the desired ordering of the visit. It is\n     * guaranteed that this method will be called before {@link\n     * #visitInternalNode visitInternalNode} for a given node, it will be\n     * called exactly once for each internal node.</p>\n     * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n     * @return desired visit order, must be one of\n     * {@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n     * {@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n     * {@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "RegionFactory.RegionFactory#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/RegionFactory.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
        "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.RegionFactory()",
        "snippet": "    public RegionFactory() {\n        nodeCleaner = new NodesCleaner();\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": " Simple constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.BSPTree#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(java.lang.Object)",
        "snippet": "    public BSPTree(final Object attribute) {\n        cut    = null;\n        plus   = null;\n        minus  = null;\n        parent = null;\n        this.attribute = attribute;\n    }\n",
        "begin_line": 93,
        "end_line": 99,
        "comment": " Build a tree having only one root cell representing the whole space.\n     * @param attribute attribute of the tree (may be null)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.BSPTree#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(org.apache.commons.math3.geometry.partitioning.SubHyperplane<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree<S>, java.lang.Object)",
        "snippet": "    public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\n                   final Object attribute) {\n        this.cut       = cut;\n        this.plus      = plus;\n        this.minus     = minus;\n        this.parent    = null;\n        this.attribute = attribute;\n        plus.parent    = this;\n        minus.parent   = this;\n    }\n",
        "begin_line": 114,
        "end_line": 123,
        "comment": " Build a BSPTree from its underlying elements.\n     * <p>This method does <em>not</em> perform any verification on\n     * consistency of its arguments, it should therefore be used only\n     * when then caller knows what it is doing.</p>\n     * <p>This method is mainly useful kto build trees\n     * bottom-up. Building trees top-down is realized with the help of\n     * method {@link #insertCut insertCut}.</p>\n     * @param cut cut sub-hyperplane for the tree\n     * @param plus plus side sub-tree\n     * @param minus minus side sub-tree\n     * @param attribute attribute associated with the node (may be null)\n     * @see #insertCut\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getCut#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCut()",
        "snippet": "    public SubHyperplane<S> getCut() {\n        return cut;\n    }\n",
        "begin_line": 193,
        "end_line": 195,
        "comment": " Get the cut sub-hyperplane.\n     * @return cut sub-hyperplane, null if this is a leaf tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getPlus#201",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getPlus()",
        "snippet": "    public BSPTree<S> getPlus() {\n        return plus;\n    }\n",
        "begin_line": 201,
        "end_line": 203,
        "comment": " Get the tree on the plus side of the cut hyperplane.\n     * @return tree on the plus side of the cut hyperplane, null if this\n     * is a leaf tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getMinus#209",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getMinus()",
        "snippet": "    public BSPTree<S> getMinus() {\n        return minus;\n    }\n",
        "begin_line": 209,
        "end_line": 211,
        "comment": " Get the tree on the minus side of the cut hyperplane.\n     * @return tree on the minus side of the cut hyperplane, null if this\n     * is a leaf tree\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.setAttribute#224",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.setAttribute(java.lang.Object)",
        "snippet": "    public void setAttribute(final Object attribute) {\n        this.attribute = attribute;\n    }\n",
        "begin_line": 224,
        "end_line": 226,
        "comment": " Associate an attribute with the instance.\n     * @param attribute attribute to associate with the node\n     * @see #getAttribute\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.getAttribute#234",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getAttribute()",
        "snippet": "    public Object getAttribute() {\n        return attribute;\n    }\n",
        "begin_line": 234,
        "end_line": 236,
        "comment": " Get the attribute associated with the instance.\n     * @return attribute associated with the node or null if no\n     * attribute has been explicitly set using the {@link #setAttribute\n     * setAttribute} method\n     * @see #setAttribute\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "BSPTree.merge#364",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
        "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger<S>)",
        "snippet": "    public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) {\n        return merge(tree, leafMerger, null, false);\n    }\n",
        "begin_line": 364,
        "end_line": 366,
        "comment": " Merge a BSP tree with the instance.\n     * <p>All trees are modified (parts of them are reused in the new\n     * tree), it is the responsibility of the caller to ensure a copy\n     * has been done before if any of the former tree should be\n     * preserved, <em>no</em> such copy is done here!</p>\n     * <p>The algorithm used here is directly derived from the one\n     * described in the Naylor, Amanatides and Thibault paper (section\n     * III, Binary Partitioning of a BSP Tree).</p>\n     * @param tree other tree to merge with the instance (will be\n     * <em>unusable</em> after the operation, as well as the\n     * instance itself)\n     * @param leafMerger object implementing the final merging phase\n     * (this is where the semantic of the operation occurs, generally\n     * depending on the attribute of the leaf node)\n     * @return a new tree, result of <code>instance &lt;op&gt;\n     * tree</code>, this value can be ignored if parentTree is not null\n     * since all connections have already been established\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.AbstractSubHyperplane#50",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>, org.apache.commons.math3.geometry.partitioning.Region<T>)",
        "snippet": "    protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\n                                    final Region<T> remainingRegion) {\n        this.hyperplane      = hyperplane;\n        this.remainingRegion = remainingRegion;\n    }\n",
        "begin_line": 50,
        "end_line": 54,
        "comment": " Build a sub-hyperplane from an hyperplane and a region.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.copySelf#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.copySelf()",
        "snippet": "    public AbstractSubHyperplane<S, T> copySelf() {\n        return buildNew(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": " Copy the instance.\n     * <p>The instance created is completely independent of the original\n     * one. A deep copy is used, none of the underlying objects are\n     * shared (except for the nodes attributes and immutable\n     * objects).</p>\n     * @return a new sub-hyperplane, copy of the instance\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.getHyperplane#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getHyperplane()",
        "snippet": "    public Hyperplane<S> getHyperplane() {\n        return hyperplane;\n    }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": " Get the underlying hyperplane.\n     * @return underlying hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.getRemainingRegion#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion()",
        "snippet": "    public Region<T> getRemainingRegion() {\n        return remainingRegion;\n    }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": " Get the remaining region of the hyperplane.\n     * <p>The returned region is expressed in the canonical hyperplane\n     * frame and has the hyperplane dimension. For example a chopped\n     * hyperplane in the 3D euclidean is a 2D plane and the\n     * corresponding region is a convex 2D polygon.</p>\n     * @return remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractSubHyperplane.isEmpty#155",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return remainingRegion.isEmpty();\n    }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": " Check if the instance is empty.\n     * @return true if the instance is empty\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.Sides#524",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides.Sides()",
        "snippet": "        public Sides() {\n            plusFound  = false;\n            minusFound = false;\n        }\n",
        "begin_line": 524,
        "end_line": 527,
        "comment": " Simple constructor.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.rememberPlusFound#531",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides.rememberPlusFound()",
        "snippet": "        public void rememberPlusFound() {\n            plusFound = true;\n        }\n",
        "begin_line": 531,
        "end_line": 533,
        "comment": " Remember the fact that inside leaf nodes have been found on the plus side.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.plusFound#538",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides.plusFound()",
        "snippet": "        public boolean plusFound() {\n            return plusFound;\n        }\n",
        "begin_line": 538,
        "end_line": 540,
        "comment": " Check if inside leaf nodes have been found on the plus side.\n         * @return true if inside leaf nodes have been found on the plus side\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.rememberMinusFound#544",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides.rememberMinusFound()",
        "snippet": "        public void rememberMinusFound() {\n            minusFound = true;\n        }\n",
        "begin_line": 544,
        "end_line": 546,
        "comment": " Remember the fact that inside leaf nodes have been found on the minus side.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.minusFound#551",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides.minusFound()",
        "snippet": "        public boolean minusFound() {\n            return minusFound;\n        }\n",
        "begin_line": 551,
        "end_line": 553,
        "comment": " Check if inside leaf nodes have been found on the minus side.\n         * @return true if inside leaf nodes have been found on the minus side\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.AbstractRegion#50",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion()",
        "snippet": "    protected AbstractRegion() {\n        tree = new BSPTree<S>(Boolean.TRUE);\n    }\n",
        "begin_line": 50,
        "end_line": 52,
        "comment": " Build a region representing the whole space.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.AbstractRegion#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "    protected AbstractRegion(final BSPTree<S> tree) {\n        this.tree = tree;\n    }\n",
        "begin_line": 66,
        "end_line": 68,
        "comment": " Build a region from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param tree inside/outside BSP tree representing the region\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.isEmpty#225",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty()",
        "snippet": "    public boolean isEmpty() {\n        return isEmpty(tree);\n    }\n",
        "begin_line": 225,
        "end_line": 227,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Check if the instance is empty.\n     * @return true if the instance is empty\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.isEmpty#230",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty(org.apache.commons.math3.geometry.partitioning.BSPTree<S>)",
        "snippet": "    public boolean isEmpty(final BSPTree<S> node) {\n\n        // we use a recursive function rather than the BSPTreeVisitor\n        // interface because we can stop visiting the tree as soon as we\n        // have found an inside cell\n\n        if (node.getCut() == null) {\n            // if we find an inside node, the region is not empty\n            return !((Boolean) node.getAttribute());\n        }\n\n        // check both sides of the sub-tree\n        return isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n\n    }\n",
        "begin_line": 230,
        "end_line": 244,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Build a region using the instance as a prototype.\n     * <p>This method allow to create new instances without knowing\n     * exactly the type of the region. It is an application of the\n     * prototype design pattern.</p>\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n     * tree also <em>must</em> have either null internal nodes or\n     * internal nodes representing the boundary as specified in the\n     * {@link #getTree getTree} method).</p>\n     * @param newTree inside/outside BSP tree representing the new region\n     * @return the built region\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.checkPoint#263",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(org.apache.commons.math3.geometry.partitioning.BSPTree<S>, org.apache.commons.math3.geometry.Vector<S>)",
        "snippet": "    protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {\n        final BSPTree<S> cell = node.getCell(point);\n        if (cell.getCut() == null) {\n            // the point is in the interior of a cell, just check the attribute\n            return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n        }\n\n        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n        final Location minusCode = checkPoint(cell.getMinus(), point);\n        final Location plusCode  = checkPoint(cell.getPlus(),  point);\n        return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n\n    }\n",
        "begin_line": 263,
        "end_line": 275,
        "comment": " Check a point with respect to the region starting at a given node.\n     * @param node root node of the region\n     * @param point point to check\n     * @return a code representing the point status: either {@link\n     * Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE\n     * OUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRegion.side#414",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
        "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
        "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.side(org.apache.commons.math3.geometry.partitioning.Hyperplane<S>)",
        "snippet": "    public Side side(final Hyperplane<S> hyperplane) {\n        final Sides sides = new Sides();\n        recurseSides(tree, hyperplane.wholeHyperplane(), sides);\n        return sides.plusFound() ?\n              (sides.minusFound() ? Side.BOTH  : Side.PLUS) :\n              (sides.minusFound() ? Side.MINUS : Side.HYPER);\n    }\n",
        "begin_line": 414,
        "end_line": 420,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Region": " Compute the relative position of the instance with respect to an\n     * hyperplane.\n     * @param hyperplane reference hyperplane\n     * @return one of {@link Side#PLUS Side.PLUS}, {@link Side#MINUS\n     * Side.MINUS}, {@link Side#BOTH Side.BOTH} or {@link Side#HYPER\n     * Side.HYPER} (the latter result can occur only if the tree\n     * contains only one cut hyperplane)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.Vector2D#68",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, double)",
        "snippet": "    public Vector2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n",
        "begin_line": 68,
        "end_line": 71,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @param y ordinate\n     * @see #getX()\n     * @see #getY()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.getX#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector2D(double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector2D.getY#157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getY()",
        "snippet": "    public double getY() {\n        return y;\n    }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": " Get the ordinate of the vector.\n     * @return ordinate of the vector\n     * @see #Vector2D(double, double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.SubLine#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public SubLine(final Hyperplane<Euclidean2D> hyperplane,\n                   final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 46,
        "end_line": 49,
        "comment": " Simple constructor.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubLine.buildNew#145",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane,\n                                                                       final Region<Euclidean1D> remainingRegion) {\n        return new SubLine(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 145,
        "end_line": 149,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.Line#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
        "snippet": "    public double getAbscissa(final Vector3D point) {\n        return point.subtract(zero).dotProduct(direction);\n    }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": " Get the abscissa of a point with respect to the line.\n     * <p>The abscissa is 0 if the projection of the point and the\n     * projection of the frame origin on the line are the same\n     * point.</p>\n     * @param point point to check\n     * @return abscissa of the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.copySelf#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.copySelf()",
        "snippet": "    public Line copySelf() {\n        return new Line(this);\n    }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null,
            "org.apache.commons.math3.geometry.partitioning.Hyperplane": " Copy the instance.\n     * <p>The instance created is completely independant of the original\n     * one. A deep copy is used, none of the underlying objects are\n     * shared (except for immutable objects).</p>\n     * @return a new hyperplane, copy of the instance\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.toSubSpace#180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.threed.Euclidean3D>)",
        "snippet": "    public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector1D(getAbscissa((Vector3D) point));\n    }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": " {@inheritDoc}\n     * @see #getAbscissa(Vector3D)\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.wholeHyperplane#207",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeHyperplane()",
        "snippet": "    public SubLine wholeHyperplane() {\n        return new SubLine(this, new IntervalsSet());\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Embedding": null,
            "org.apache.commons.math3.geometry.partitioning.Hyperplane": " Build a sub-hyperplane covering the whole hyperplane.\n     * @return a sub-hyperplane covering the whole hyperplane\n     "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Line.getAngle#285",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
        "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getAngle()",
        "snippet": "    public double getAngle() {\n        return MathUtils.normalizeAngle(angle, FastMath.PI);\n    }\n",
        "begin_line": 285,
        "end_line": 287,
        "comment": " Get the angle of the line.\n     * @return the angle of the line with respect to the abscissa axis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector1D.Vector1D#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double)",
        "snippet": "    public Vector1D(double x) {\n        this.x = x;\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": " Simple constructor.\n     * Build a vector from its coordinates\n     * @param x abscissa\n     * @see #getX()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Vector1D.getX#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getX()",
        "snippet": "    public double getX() {\n        return x;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": " Get the abscissa of the vector.\n     * @return abscissa of the vector\n     * @see #Vector1D(double)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubOrientedPoint.SubOrientedPoint#37",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\n                            final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": " Simple constructor.\n     * @param hyperplane underlying hyperplane\n     * @param remainingRegion remaining region of the hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubOrientedPoint.buildNew#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>, org.apache.commons.math3.geometry.partitioning.Region<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean1D, Euclidean1D> buildNew(final Hyperplane<Euclidean1D> hyperplane,\n                                                                       final Region<Euclidean1D> remainingRegion) {\n        return new SubOrientedPoint(hyperplane, remainingRegion);\n    }\n",
        "begin_line": 49,
        "end_line": 53,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "SubOrientedPoint.side#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.side(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    @Override\n    public Side side(final Hyperplane<Euclidean1D> hyperplane) {\n        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n    }\n",
        "begin_line": 56,
        "end_line": 60,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane": null,
            "org.apache.commons.math3.geometry.partitioning.SubHyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.OrientedPoint#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.OrientedPoint(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, boolean)",
        "snippet": "    public OrientedPoint(final Vector1D location, final boolean direct) {\n        this.location = location;\n        this.direct   = direct;\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": " Simple constructor.\n     * @param location location of the hyperplane\n     * @param direct if true, the plus side of the hyperplane is towards\n     * abscissas greater than {@code location}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.getOffset#57",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getOffset(org.apache.commons.math3.geometry.Vector<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public double getOffset(final Vector<Euclidean1D> point) {\n        final double delta = ((Vector1D) point).getX() - location.getX();\n        return direct ? delta : -delta;\n    }\n",
        "begin_line": 57,
        "end_line": 60,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Hyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.wholeHyperplane#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeHyperplane()",
        "snippet": "    public SubOrientedPoint wholeHyperplane() {\n        return new SubOrientedPoint(this, null);\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": " Build a region covering the whole hyperplane.\n     * <p>Since this class represent zero dimension spaces which does\n     * not have lower dimension sub-spaces, this method returns a dummy\n     * implementation of a {@link\n     * org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane}.\n     * This implementation is only used to allow the {@link\n     * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n     * SubHyperplane} class implementation to work properly, it should\n     * <em>not</em> be used otherwise.</p>\n     * @return a dummy sub hyperplane\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.sameOrientationAs#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean1D> other) {\n        return !(direct ^ ((OrientedPoint) other).direct);\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.geometry.partitioning.Hyperplane": null
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.getLocation#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getLocation()",
        "snippet": "    public Vector1D getLocation() {\n        return location;\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": " Get the hyperplane location on the real line.\n     * @return the hyperplane location\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "OrientedPoint.isDirect#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.isDirect()",
        "snippet": "    public boolean isDirect() {\n        return direct;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": " Check if the hyperplane orientation is direct.\n     * @return true if the plus side of the hyperplane is towards\n     * abscissae greater than hyperplane location\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.IntervalsSet#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet()",
        "snippet": "    public IntervalsSet() {\n        super();\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": " Build an intervals set representing the whole real line.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.IntervalsSet#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>)",
        "snippet": "    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": " Build an intervals set from an inside/outside BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the intervals set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.asList#207",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.asList()",
        "snippet": "    public List<Interval> asList() {\n        final List<Interval> list = new ArrayList<Interval>();\n        recurseList(getTree(false), list,\n                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        return list;\n    }\n",
        "begin_line": 207,
        "end_line": 212,
        "comment": " Build an ordered list of intervals representing the instance.\n     * <p>This method builds this intervals set as an ordered list of\n     * {@link Interval Interval} elements. If the intervals set has no\n     * lower limit, the first interval will have its low bound equal to\n     * {@code Double.NEGATIVE_INFINITY}. If the intervals set has\n     * no upper limit, the last interval will have its upper bound equal\n     * to {@code Double.POSITIVE_INFINITY}. An empty tree will\n     * build an empty list while a tree representing the whole real line\n     * will build a one element list with both bounds beeing\n     * infinite.</p>\n     * @return a new ordered list containing {@link Interval Interval}\n     * elements\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "IntervalsSet.recurseList#220",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.recurseList(org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D>, java.util.List<org.apache.commons.math3.geometry.euclidean.oned.Interval>, double, double)",
        "snippet": "    private void recurseList(final BSPTree<Euclidean1D> node,\n                             final List<Interval> list,\n                             final double lower, final double upper) {\n\n        if (node.getCut() == null) {\n            if ((Boolean) node.getAttribute()) {\n                // this leaf cell is an inside cell: an interval\n                list.add(new Interval(lower, upper));\n            }\n        } else {\n            final OrientedPoint op  = (OrientedPoint) node.getCut().getHyperplane();\n            final Vector1D       loc = op.getLocation();\n            double              x   = loc.getX();\n\n            // make sure we explore the tree in increasing order\n            final BSPTree<Euclidean1D> low  =\n                op.isDirect() ? node.getMinus() : node.getPlus();\n            final BSPTree<Euclidean1D> high =\n                op.isDirect() ? node.getPlus()  : node.getMinus();\n\n            recurseList(low, list, lower, x);\n            if ((checkPoint(low,  loc) == Location.INSIDE) &&\n                (checkPoint(high, loc) == Location.INSIDE)) {\n                // merge the last interval added and the first one of the high sub-tree\n                x = list.remove(list.size() - 1).getLower();\n            }\n            recurseList(high, list, x, upper);\n\n        }\n\n    }\n",
        "begin_line": 220,
        "end_line": 250,
        "comment": " Update an intervals list.\n     * @param node current node\n     * @param list list to update\n     * @param lower lower bound of the current convex cell\n     * @param upper upper bound of the current convex cell\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Interval.Interval#37",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java",
        "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
        "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.Interval(double, double)",
        "snippet": "    public Interval(final double lower, final double upper) {\n        this.lower = lower;\n        this.upper = upper;\n    }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": " Simple constructor.\n     * @param lower lower bound of the interval\n     * @param upper upper bound of the interval\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    }
]