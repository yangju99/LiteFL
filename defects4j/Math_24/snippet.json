[
    {
        "name": "MathArrays.isMonotonic#159",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.isMonotonic(T[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
        "snippet": "    public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val,\n                                      OrderDirection dir,\n                                      boolean strict) {\n        T previous = val[0];\n        final int max = val.length;\n        for (int i = 1; i < max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[i];\n        }\n        return true;\n    }\n",
        "begin_line": 159,
        "end_line": 199,
        "comment": "\n     * Check that an array is monotonically increasing or decreasing.\n     *\n     * @param <T> the type of the elements in the specified array\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @return {@code true} if sorted, {@code false} otherwise.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.checkOrder#226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean, boolean)",
        "snippet": "    public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort) {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            // Loop completed.\n            return true;\n        }\n\n        // Loop early exit means wrong ordering.\n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }\n",
        "begin_line": 226,
        "end_line": 276,
        "comment": "\n     * Check that the given array is sorted.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @param abort Whether to throw an exception if the check fails.\n     * @return {@code true} if the array is sorted.\n     * @throws NonMonotonicSequenceException if the array is not sorted\n     * and {@code abort} is {@code true}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.checkOrder#287",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
        "snippet": "    public static void checkOrder(double[] val, OrderDirection dir,\n                                  boolean strict) {\n        checkOrder(val, dir, strict, true);\n    }\n",
        "begin_line": 287,
        "end_line": 290,
        "comment": "\n     * Check that the given array is sorted.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @throws NonMonotonicSequenceException if the array is not sorted.\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.checkOrder#299",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[])",
        "snippet": "    public static void checkOrder(double[] val) {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }\n",
        "begin_line": 299,
        "end_line": 301,
        "comment": "\n     * Check that the given array is sorted in strictly increasing order.\n     *\n     * @param val Values.\n     * @throws NonMonotonicSequenceException if the array is not sorted.\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "StepFunction.StepFunction#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/StepFunction.java",
        "class_name": "org.apache.commons.math3.analysis.function.StepFunction",
        "signature": "org.apache.commons.math3.analysis.function.StepFunction.StepFunction(double[], double[])",
        "snippet": "    public StepFunction(double[] x,\n                        double[] y)\n        throws NullArgumentException,\n               NoDataException,\n               DimensionMismatchException {\n        if (x == null ||\n            y == null) {\n            throw new NullArgumentException();\n        }\n        if (x.length == 0 ||\n            y.length == 0) {\n            throw new NoDataException();\n        }\n        if (y.length != x.length) {\n            throw new DimensionMismatchException(y.length, x.length);\n        }\n        MathArrays.checkOrder(x);\n\n        abscissa = MathArrays.copyOf(x);\n        ordinate = MathArrays.copyOf(y);\n    }\n",
        "begin_line": 60,
        "end_line": 80,
        "comment": "\n     * Builds a step function from a list of arguments and the corresponding\n     * values. Specifically, returns the function h(x) defined by <pre><code>\n     * h(x) = y[0] for all x < x[1]\n     *        y[1] for x[1] <= x < x[2]\n     *        ...\n     *        y[y.length - 1] for x >= x[x.length - 1]\n     * </code></pre>\n     * The value of {@code x[0]} is ignored, but it must be strictly less than\n     * {@code x[1]}.\n     *\n     * @param x Domain values where the function changes value.\n     * @param y Values of the function.\n     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n     * if the {@code x} array is not sorted in strictly increasing order.\n     * @throws NullArgumentException if {@code x} or {@code y} are {@code null}.\n     * @throws NoDataException if {@code x} or {@code y} are zero-length.\n     * @throws DimensionMismatchException if {@code x} and {@code y} do not\n     * have the same length.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "StepFunction.value#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/StepFunction.java",
        "class_name": "org.apache.commons.math3.analysis.function.StepFunction",
        "signature": "org.apache.commons.math3.analysis.function.StepFunction.value(double)",
        "snippet": "    public double value(double x) {\n        int index = Arrays.binarySearch(abscissa, x);\n        double fx = 0;\n\n        if (index < -1) {\n            // \"x\" is between \"abscissa[-index-2]\" and \"abscissa[-index-1]\".\n            fx = ordinate[-index-2];\n        } else if (index >= 0) {\n            // \"x\" is exactly \"abscissa[index]\".\n            fx = ordinate[index];\n        } else {\n            // Otherwise, \"x\" is smaller than the first value in \"abscissa\"\n            // (hence the returned value should be \"ordinate[0]\").\n            fx = ordinate[0];\n        }\n\n        return fx;\n    }\n",
        "begin_line": 83,
        "end_line": 100,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.UnivariateFunction": "\n     * Compute the value of the function.\n     *\n     * @param x Point at which the function value should be computed.\n     * @return the value of the function.\n     * @throws IllegalArgumentException when the activated method itself can\n     * ascertain that a precondition, specified in the API expressed at the\n     * level of the activated method, has been violated.\n     * When Commons Math throws an {@code IllegalArgumentException}, it is\n     * usually the consequence of checking the actual parameters passed to\n     * the method.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionUtils.add#140",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java",
        "class_name": "org.apache.commons.math3.analysis.FunctionUtils",
        "signature": "org.apache.commons.math3.analysis.FunctionUtils.add(org.apache.commons.math3.analysis.UnivariateFunction...)",
        "snippet": "    public static UnivariateFunction add(final UnivariateFunction ... f) {\n        return new UnivariateFunction() {\n            /** {@inheritDoc} */\n            public double value(double x) {\n                double r = f[0].value(x);\n                for (int i = 1; i < f.length; i++) {\n                    r += f[i].value(x);\n                }\n                return r;\n            }\n        };\n    }\n",
        "begin_line": 140,
        "end_line": 151,
        "comment": "\n     * Adds functions.\n     *\n     * @param f List of functions.\n     * @return a function that computes the sum of the functions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionUtils.value#143",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java",
        "class_name": "org.apache.commons.math3.analysis.FunctionUtils",
        "signature": "org.apache.commons.math3.analysis.FunctionUtils.Anonymous-56c45f24-7b4a-4126-8b8c-b7034c365f56.value(double)",
        "snippet": "            public double value(double x) {\n                double r = f[0].value(x);\n                for (int i = 1; i < f.length; i++) {\n                    r += f[i].value(x);\n                }\n                return r;\n            }\n",
        "begin_line": 143,
        "end_line": 149,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#531",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
        "snippet": "     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n",
        "begin_line": 531,
        "end_line": 533,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#559",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[], int)",
        "snippet": "    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n",
        "begin_line": 559,
        "end_line": 563,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sin.value#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/Sin.java",
        "class_name": "org.apache.commons.math3.analysis.function.Sin",
        "signature": "org.apache.commons.math3.analysis.function.Sin.value(double)",
        "snippet": "    public double value(double x) {\n        return FastMath.sin(x);\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiable": null,
            "org.apache.commons.math3.analysis.DifferentiableUnivariateFunction": null,
            "org.apache.commons.math3.analysis.UnivariateFunction": "\n     * Compute the value of the function.\n     *\n     * @param x Point at which the function value should be computed.\n     * @return the value of the function.\n     * @throws IllegalArgumentException when the activated method itself can\n     * ascertain that a precondition, specified in the API expressed at the\n     * level of the activated method, has been violated.\n     * When Commons Math throws an {@code IllegalArgumentException}, it is\n     * usually the consequence of checking the actual parameters passed to\n     * the method.\n     "
        },
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.CodyWaite#3784",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.CodyWaite(double, double)",
        "snippet": "        CodyWaite(double xa,\n                  double xb) {\n            // Estimate k.\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder.\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2.\n                --k;\n            }\n\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n",
        "begin_line": 3784,
        "end_line": 3821,
        "comment": "\n         * @param xa Argument.\n         * @param xb Argument.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getK#3826",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getK()",
        "snippet": "        int getK() {\n            return finalK;\n        }\n",
        "begin_line": 3826,
        "end_line": 3828,
        "comment": "\n         * @return k\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getRemA#3832",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemA()",
        "snippet": "        double getRemA() {\n            return finalRemA;\n        }\n",
        "begin_line": 3832,
        "end_line": 3834,
        "comment": "\n         * @return remA\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getRemB#3838",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemB()",
        "snippet": "        double getRemB() {\n            return finalRemB;\n        }\n",
        "begin_line": 3838,
        "end_line": 3840,
        "comment": "\n         * @return remB\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polySine#1651",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
        "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }\n",
        "begin_line": 1651,
        "end_line": 1664,
        "comment": "\n     *  Computes sin(x) - x, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return sin(x) - x\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polyCosine#1672",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
        "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n",
        "begin_line": 1672,
        "end_line": 1682,
        "comment": "\n     *  Computes cos(x) - 1, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return cos(x) - 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sinQ#1691",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
        "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n",
        "begin_line": 1691,
        "end_line": 1806,
        "comment": "\n     *  Compute sine over the first quadrant (0 < x < pi/2).\n     *  Use combination of table lookup and rational polynomial expansion.\n     *  @param xa number from which sine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return sin(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cosQ#1815",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
        "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n",
        "begin_line": 1815,
        "end_line": 1824,
        "comment": "\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n     *  @param xa number from which cosine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return cos(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sin#2200",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
        "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2200,
        "end_line": 2259,
        "comment": "\n     * Sine function.\n     *\n     * @param x Argument.\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3395",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
        "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n",
        "begin_line": 3395,
        "end_line": 3397,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.doOptimize#108",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }\n",
        "begin_line": 108,
        "end_line": 271,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the optimum and its corresponding function value.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getEvaluations#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.univariate.UnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.univariate.BaseUnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": "\n     * Get the number of evaluations of the objective function.\n     * The number of evaluations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getCount#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.getCount()",
        "snippet": "    public int getCount() {\n        return count;\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Gets the current count.\n     *\n     * @return the current count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.optimize#138",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.optimize(int, org.apache.commons.math3.analysis.UnivariateFunction, org.apache.commons.math3.optimization.GoalType, double, double)",
        "snippet": "    public UnivariatePointValuePair optimize(int maxEval,\n                                                 UnivariateFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max){\n        return optimize(maxEval, f, goalType, min, max, min + 0.5 * (max - min));\n    }\n",
        "begin_line": 138,
        "end_line": 143,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.univariate.UnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.univariate.BaseUnivariateOptimizer": "\n     * Find an optimum in the given interval.\n     *\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param maxEval Maximum number of function evaluations.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math3.exception.ConvergenceException\n     * if the optimizer detects a convergence problem.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#102",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.BrentOptimizer(double, double)",
        "snippet": "    public BrentOptimizer(double rel,\n                          double abs) {\n        this(rel, abs, null);\n    }\n",
        "begin_line": 102,
        "end_line": 105,
        "comment": "\n     * The arguments are used for implementing the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#242",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double)",
        "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n",
        "begin_line": 242,
        "end_line": 244,
        "comment": "\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#306",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 306,
        "end_line": 321,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#2973",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 2973,
        "end_line": 2975,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariatePointValuePair.UnivariatePointValuePair#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/UnivariatePointValuePair.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair",
        "signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair.UnivariatePointValuePair(double, double)",
        "snippet": "    public UnivariatePointValuePair(final double point,\n                                    final double value) {\n        this.point = point;\n        this.value = value;\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Build a point/objective function value pair.\n     *\n     * @param point Point.\n     * @param value Value of an objective function at the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariatePointValuePair.getPoint#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/UnivariatePointValuePair.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair",
        "signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair.getPoint()",
        "snippet": "    public double getPoint() {\n        return point;\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Get the point.\n     *\n     * @return the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 61,
        "end_line": 69,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int, org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 79,
        "end_line": 86,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     * @throws NullArgumentException if {@code cb} is {@code null}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 154,
        "end_line": 158,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#2991",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 2991,
        "end_line": 2993,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ulp#3000",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.ulp(double)",
        "snippet": "    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n",
        "begin_line": 3000,
        "end_line": 3005,
        "comment": "\n     * Compute least significant bit (Unit in Last Position) for a number.\n     * @param x number from which ulp is requested\n     * @return ulp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.BrentOptimizer(double, double, org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair>)",
        "snippet": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }\n",
        "begin_line": 72,
        "end_line": 86,
        "comment": "\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.BaseAbstractUnivariateOptimizer#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.BaseAbstractUnivariateOptimizer(org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair>)",
        "snippet": "    protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\n        this.checker = checker;\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * @param checker Convergence checking procedure.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getGoalType#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getMin#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getMax#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getStartValue#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.computeObjectiveValue#102",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }\n",
        "begin_line": 102,
        "end_line": 109,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.optimize#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.optimize(int, org.apache.commons.math3.analysis.UnivariateFunction, org.apache.commons.math3.optimization.GoalType, double, double, double)",
        "snippet": "    public UnivariatePointValuePair optimize(int maxEval, UnivariateFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max,\n                                                 double startValue) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        goal = goalType;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Perform computation.\n        return doOptimize();\n    }\n",
        "begin_line": 112,
        "end_line": 135,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.univariate.UnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.univariate.BaseUnivariateOptimizer": "\n     * Find an optimum in the given interval, start at startValue.\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of function evaluations.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math3.exception.ConvergenceException if the\n     * optimizer detects a convergence problem.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if any\n     * argument is {@code null}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateOptimizer.getConvergenceChecker#148",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BaseAbstractUnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getConvergenceChecker()",
        "snippet": "    public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\n        return checker;\n    }\n",
        "begin_line": 148,
        "end_line": 150,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.univariate.UnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.univariate.BaseUnivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": "\n     * Get the convergence checker.\n     *\n     * @return the object used to check for convergence.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    }
]