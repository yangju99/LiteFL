[
    {
        "name": "CMAESOptimizer.CMAESOptimizer#239",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()",
        "snippet": "    public CMAESOptimizer() {\n        this(0);\n    }\n",
        "begin_line": 239,
        "end_line": 241,
        "comment": "\n     * Default constructor, uses default parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#246",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)",
        "snippet": "    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }\n",
        "begin_line": 246,
        "end_line": 250,
        "comment": "\n     * @param lambda Population size.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.initializeCMA#560",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.initializeCMA(double[])",
        "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        // initialize sigma\n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; // minor increment\n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective\n                                                           // variables\n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }\n",
        "begin_line": 560,
        "end_line": 627,
        "comment": "\n     * Initialization of the dynamic search parameters\n     *\n     * @param guess Initial guess for the arguments of the fitness function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.repair#989",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.repair(double[])",
        "snippet": "        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }\n",
        "begin_line": 989,
        "end_line": 1001,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the repaired objective variables - all in bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.doOptimize#348",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }\n",
        "begin_line": 348,
        "end_line": 493,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.MultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer": "\n     * Perform the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value for the\n     * objective function.\n     ",
            "org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.encode#904",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.encode(double[])",
        "snippet": "        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n            }\n            return res;\n        }\n",
        "begin_line": 904,
        "end_line": 914,
        "comment": "\n         * @param x Original objective variables.\n         * @return the normalized objective variables.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.decode#929",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.decode(double[])",
        "snippet": "        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n            }\n            return res;\n        }\n",
        "begin_line": 929,
        "end_line": 939,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the original objective variables.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.value#945",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.value(double[])",
        "snippet": "        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }\n",
        "begin_line": 945,
        "end_line": 957,
        "comment": "\n         * @param point Normalized objective variables.\n         * @return the objective value + penalty for violated bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.penalty#1008",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.penalty(double[], double[])",
        "snippet": "        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }\n",
        "begin_line": 1008,
        "end_line": 1015,
        "comment": "\n         * @param x Normalized objective variables.\n         * @param repaired Repaired objective variables.\n         * @return Penalty value according to the violation of the bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.checkParameters#498",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n",
        "begin_line": 498,
        "end_line": 553,
        "comment": "\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.optimize#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int, FUNC, org.apache.commons.math3.optimization.GoalType, double[], double[], double[])",
        "snippet": "    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                       double[] startPoint,\n                                       double[] lower, double[] upper) {\n        // Checks.\n        final int dim = startPoint.length;\n        if (lower != null) {\n            if (lower.length != dim) {\n                throw new DimensionMismatchException(lower.length, dim);\n            }\n            for (int i = 0; i < dim; i++) {\n                final double v = startPoint[i];\n                final double lo = lower[i];\n                if (v < lo) {\n                    throw new NumberIsTooSmallException(v, lo, true);\n                }\n            }\n        }\n        if (upper != null) {\n            if (upper.length != dim) {\n                throw new DimensionMismatchException(upper.length, dim);\n            }\n            for (int i = 0; i < dim; i++) {\n                final double v = startPoint[i];\n                final double hi = upper[i];\n                if (v > hi) {\n                    throw new NumberIsTooLargeException(v, hi, true);\n                }\n            }\n        }\n\n        // Initialization.\n        if (lower == null) {\n            lowerBound = new double[dim];\n            for (int i = 0; i < dim; i++) {\n                lowerBound[i] = Double.NEGATIVE_INFINITY;\n            }\n        } else {\n            lowerBound = lower.clone();\n        }\n        if (upper == null) {\n            upperBound = new double[dim];\n            for (int i = 0; i < dim; i++) {\n                upperBound[i] = Double.POSITIVE_INFINITY;\n            }\n        } else {\n            upperBound = upper.clone();\n        }\n\n        // Base class method performs the non bound-specific initializations.\n        return super.optimize(maxEval, f, goalType, startPoint);\n    }\n",
        "begin_line": 91,
        "end_line": 141,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @param lowerBound Lower bound for each of the parameters.\n     * @param upperBound Upper bound for each of the parameters.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the array sizes are wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n     * @throws org.apache.commons.math3.exception.NumberIsTooSmallException if any\n     * of the initial values is less than its lower bound.\n     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException if any\n     * of the initial values is greater than its upper bound.\n     ",
            "org.apache.commons.math3.optimization.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.compareTo#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, double)",
        "snippet": "    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n            return -1;\n        }\n        return 1;\n    }\n",
        "begin_line": 95,
        "end_line": 102,
        "comment": "\n     * Compares two numbers given some amount of allowed error.\n     *\n     * @param x the first number\n     * @param y the second number\n     * @param eps the amount of error to allow when checking for equality\n     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
        "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "\n     * Returns {@code true} if there is no double value strictly between the\n     * arguments or the difference between them is within the range of allowed\n     * error (inclusive).\n     *\n     * @param x First value.\n     * @param y Second value.\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#329",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 329,
        "end_line": 344,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.checkNotNull#262",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathUtils.java",
        "class_name": "org.apache.commons.math3.util.MathUtils",
        "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 262,
        "end_line": 267,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#2973",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 2973,
        "end_line": 2975,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.updateCovariance#694",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateCovariance(boolean, org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix, int[], org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n            final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma); // mu difference vectors\n            RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n            oldFac += 1. - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);\n                double negminresidualvariance = 0.66;\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                double negalphaold = 0.5; // where to make up for the variance\n                                          // loss,\n                // prepare vectors, compute negative updating matrix Cneg\n                int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                int[] idxReverse = reverse(idxnorms);\n                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                int[] idxInv = inverse(idxnorms);\n                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                RealMatrix artmp = BD.multiply(arzneg);\n                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                        // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(\n                                // plus rank mu update\n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n",
        "begin_line": 694,
        "end_line": 760,
        "comment": "\n     * Update of the covariance matrix C.\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n     * current offspring.\n     * @param arz Unsorted matrix containing the gaussian random values of the\n     * current offspring.\n     * @param arindex Indices indicating the fitness-order of the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.updateBD#767",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateBD(double)",
        "snippet": "    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }\n",
        "begin_line": 767,
        "end_line": 796,
        "comment": "\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.divide#1084",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.divide(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1084,
        "end_line": 1092,
        "comment": "\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.triu#1114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.triu(org.apache.commons.math3.linear.RealMatrix, int)",
        "snippet": "    private static RealMatrix triu(final RealMatrix m, int k) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1114,
        "end_line": 1122,
        "comment": "\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.sumRows#1128",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sumRows(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix sumRows(final RealMatrix m) {\n        double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1128,
        "end_line": 1138,
        "comment": "\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.inverse#1313",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.inverse(int[])",
        "snippet": "    private static int[] inverse(final int[] indices) {\n        int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }\n",
        "begin_line": 1313,
        "end_line": 1319,
        "comment": "\n     * @param indices Input index array.\n     * @return the inverse of the mapping defined by indices.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.reverse#1325",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.reverse(int[])",
        "snippet": "    private static int[] reverse(final int[] indices) {\n        int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }\n",
        "begin_line": 1325,
        "end_line": 1331,
        "comment": "\n     * @param indices Input index array.\n     * @return the indices in inverse order (last is first).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.TriDiagonalTransformer#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.TriDiagonalTransformer(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public TriDiagonalTransformer(RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getRowDimension();\n        householderVectors = matrix.getData();\n        main      = new double[m];\n        secondary = new double[m - 1];\n        cachedQ   = null;\n        cachedQt  = null;\n        cachedT   = null;\n\n        // transform matrix\n        transform();\n    }\n",
        "begin_line": 62,
        "end_line": 78,
        "comment": "\n     * Build the transformation to tridiagonal shape of a symmetrical matrix.\n     * <p>The specified matrix is assumed to be symmetrical without any check.\n     * Only the upper triangular part of the matrix is used.</p>\n     *\n     * @param matrix Symmetrical matrix to transform.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getQ#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQ()",
        "snippet": "    public RealMatrix getQ() {\n        if (cachedQ == null) {\n            cachedQ = getQT().transpose();\n        }\n        return cachedQ;\n    }\n",
        "begin_line": 85,
        "end_line": 90,
        "comment": "\n     * Returns the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getQT#97",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQT()",
        "snippet": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    double beta = 1.0 / secondary[k - 1];\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }\n",
        "begin_line": 97,
        "end_line": 132,
        "comment": "\n     * Returns the transpose of the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getMainDiagonalRef#174",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getMainDiagonalRef()",
        "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "\n     * Get the main diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the main diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.getSecondaryDiagonalRef#184",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getSecondaryDiagonalRef()",
        "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Get the secondary diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the secondary diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "TriDiagonalTransformer.transform#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.transform()",
        "snippet": "    private void transform() {\n        final int m = householderVectors.length;\n        final double[] z = new double[m];\n        for (int k = 0; k < m - 1; k++) {\n\n            //zero-out a row and a column simultaneously\n            final double[] hK = householderVectors[k];\n            main[k] = hK[k];\n            double xNormSqr = 0;\n            for (int j = k + 1; j < m; ++j) {\n                final double c = hK[j];\n                xNormSqr += c * c;\n            }\n            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n            secondary[k] = a;\n            if (a != 0.0) {\n                // apply Householder transform from left and right simultaneously\n\n                hK[k + 1] -= a;\n                final double beta = -1 / (a * hK[k + 1]);\n\n                // compute a = beta A v, where v is the Householder vector\n                // this loop is written in such a way\n                //   1) only the upper triangular part of the matrix is accessed\n                //   2) access is cache-friendly for a matrix stored in rows\n                Arrays.fill(z, k + 1, m, 0);\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    final double hKI = hK[i];\n                    double zI = hI[i] * hKI;\n                    for (int j = i + 1; j < m; ++j) {\n                        final double hIJ = hI[j];\n                        zI   += hIJ * hK[j];\n                        z[j] += hIJ * hKI;\n                    }\n                    z[i] = beta * (z[i] + zI);\n                }\n\n                // compute gamma = beta vT z / 2\n                double gamma = 0;\n                for (int i = k + 1; i < m; ++i) {\n                    gamma += z[i] * hK[i];\n                }\n                gamma *= beta / 2;\n\n                // compute z = z - gamma v\n                for (int i = k + 1; i < m; ++i) {\n                    z[i] -= gamma * hK[i];\n                }\n\n                // update matrix: A = A - v zT - z vT\n                // only the upper triangular part of the matrix is updated\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    for (int j = i; j < m; ++j) {\n                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                    }\n                }\n            }\n        }\n        main[m - 1] = householderVectors[m - 1][m - 1];\n    }\n",
        "begin_line": 192,
        "end_line": 253,
        "comment": "\n     * Transform original matrix to tridiagonal form.\n     * <p>Transformation is done using Householder transforms.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }\n",
        "begin_line": 105,
        "end_line": 114,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param separator separator to use instead of the default \"; \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
        "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealVectorFormat.getInstance#170",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }\n",
        "begin_line": 127,
        "end_line": 136,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if {@code data} is not rectangular (not all rows have the same length).\n     * @throws NoDataException if a row or column is empty.\n     * @throws NullArgumentException if either {@code data} or {@code data[0]}\n     * is {@code null}.\n     * @throws DimensionMismatchException if {@code data} is not rectangular.\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealDiagonalMatrix#215",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
        "snippet": "    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n",
        "begin_line": 215,
        "end_line": 221,
        "comment": "\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.EigenDecomposition#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.EigenDecomposition(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public EigenDecomposition(final RealMatrix matrix)\n        throws MathArithmeticException {\n        if (isSymmetric(matrix, false)) {\n            transformToTridiagonal(matrix);\n            findEigenVectors(transformer.getQ().getData());\n        } else {\n            final SchurTransformer t = transformToSchur(matrix);\n            findEigenVectorsFromSchur(t);\n        }\n    }\n",
        "begin_line": 114,
        "end_line": 123,
        "comment": "\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.isSymmetric#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.isSymmetric(org.apache.commons.math3.linear.RealMatrix, boolean)",
        "snippet": "    private boolean isSymmetric(final RealMatrix matrix,\n                                boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = 10 * rows * columns * Precision.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    (FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * eps)) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, eps);\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n",
        "begin_line": 190,
        "end_line": 209,
        "comment": "\n     * Check if a matrix is symmetric.\n     *\n     * @param matrix Matrix to check.\n     * @param raiseException If {@code true}, the method will throw an\n     * exception if {@code matrix} is not symmetric.\n     * @return {@code true} if {@code matrix} is symmetric.\n     * @throws NonSymmetricMatrixException if the matrix is not symmetric and\n     * {@code raiseException} is {@code true}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getV#221",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getV()",
        "snippet": "    public RealMatrix getV() {\n\n        if (cachedV == null) {\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        // return the cached matrix\n        return cachedV;\n    }\n",
        "begin_line": 221,
        "end_line": 232,
        "comment": "\n     * Gets the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the V matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.getD#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getD()",
        "snippet": "    public RealMatrix getD() {\n\n        if (cachedD == null) {\n            // cache the matrix for subsequent calls\n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n\n            for (int i = 0; i < imagEigenvalues.length; i++) {\n                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                }\n            }\n        }\n        return cachedD;\n    }\n",
        "begin_line": 245,
        "end_line": 260,
        "comment": "\n     * Gets the block diagonal matrix D of the decomposition.\n     * D is a block diagonal matrix.\n     * Real eigenvalues are on the diagonal while complex values are on\n     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\n     *\n     * @return the D matrix.\n     *\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalues()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.transformToTridiagonal#553",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void transformToTridiagonal(final RealMatrix matrix) {\n        // transform the matrix to tridiagonal\n        transformer = new TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n    }\n",
        "begin_line": 553,
        "end_line": 558,
        "comment": "\n     * Transforms the matrix to tridiagonal form.\n     *\n     * @param matrix Matrix to transform.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "EigenDecomposition.findEigenVectors#566",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.findEigenVectors(double[][])",
        "snippet": "    private void findEigenVectors(final double[][] householderMatrix) {\n        final double[][]z = householderMatrix.clone();\n        final int n = main.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        final double[] e = new double[n];\n        for (int i = 0; i < n - 1; i++) {\n            realEigenvalues[i] = main[i];\n            e[i] = secondary[i];\n        }\n        realEigenvalues[n - 1] = main[n - 1];\n        e[n - 1] = 0;\n\n        // Determine the largest main and secondary value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n            }\n            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(e[i]);\n            }\n        }\n        // Make null any main and secondary value too small to be significant\n        if (maxAbsoluteValue != 0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    e[i]=0;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            int its = 0;\n            int m;\n            do {\n                for (m = j; m < n - 1; m++) {\n                    double delta = FastMath.abs(realEigenvalues[m]) +\n                        FastMath.abs(realEigenvalues[m + 1]);\n                    if (FastMath.abs(e[m]) + delta == delta) {\n                        break;\n                    }\n                }\n                if (m != j) {\n                    if (its == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    its++;\n                    double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                    double t = FastMath.sqrt(1 + q * q);\n                    if (q < 0.0) {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                    } else {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n                    }\n                    double u = 0.0;\n                    double s = 1.0;\n                    double c = 1.0;\n                    int i;\n                    for (i = m - 1; i >= j; i--) {\n                        double p = s * e[i];\n                        double h = c * e[i];\n                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                            c = q / p;\n                            t = FastMath.sqrt(c * c + 1.0);\n                            e[i + 1] = p * t;\n                            s = 1.0 / t;\n                            c = c * s;\n                        } else {\n                            s = p / q;\n                            t = FastMath.sqrt(s * s + 1.0);\n                            e[i + 1] = q * t;\n                            c = 1.0 / t;\n                            s = s * c;\n                        }\n                        if (e[i + 1] == 0.0) {\n                            realEigenvalues[i + 1] -= u;\n                            e[m] = 0.0;\n                            break;\n                        }\n                        q = realEigenvalues[i + 1] - u;\n                        t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n                        u = s * t;\n                        realEigenvalues[i + 1] = q + u;\n                        q = c * t - h;\n                        for (int ia = 0; ia < n; ia++) {\n                            p = z[ia][i + 1];\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\n                            z[ia][i] = c * z[ia][i] - s * p;\n                        }\n                    }\n                    if (t == 0.0 && i >= j) {\n                        continue;\n                    }\n                    realEigenvalues[j] -= u;\n                    e[j] = q;\n                    e[m] = 0.0;\n                }\n            } while (m != j);\n        }\n\n        //Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n            }\n        }\n        // Make null any eigen value too small to be significant\n        if (maxAbsoluteValue != 0.0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n            }\n        }\n        eigenvectors = new ArrayRealVector[n];\n        final double[] tmp = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tmp[j] = z[j][i];\n            }\n            eigenvectors[i] = new ArrayRealVector(tmp);\n        }\n    }\n",
        "begin_line": 566,
        "end_line": 715,
        "comment": "\n     * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\n     *\n     * @param householderMatrix Householder matrix of the transformation\n     * to tridiagonal form.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
        "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Construct a vector from an array, copying the input array.\n     *\n     * @param d Array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.getEntry#597",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getEntry(int)",
        "snippet": "    @Override\n    public double getEntry(int index) throws OutOfRangeException {\n        try {\n            return data[index];\n        } catch (IndexOutOfBoundsException e) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n                getDimension() - 1);\n        }\n    }\n",
        "begin_line": 597,
        "end_line": 605,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Return the entry at the specified index.\n     *\n     * @param index Index location of entry to be fetched.\n     * @return the vector entry at {@code index}.\n     * @throws OutOfRangeException if the index is not valid.\n     * @see #setEntry(int, double)\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.getDimension#608",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDimension()",
        "snippet": "    @Override\n    public int getDimension() {\n        return data.length;\n    }\n",
        "begin_line": 608,
        "end_line": 611,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Returns the size of the vector.\n     *\n     * @return the size of this vector.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": "\n     * Create a new {@code RealMatrix} using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n     * with the second argument set to {@code true}.</p>\n     *\n     * @param d Data for the new matrix.\n     * @throws DimensionMismatchException if {@code d} is not rectangular.\n     * @throws NoDataException if {@code d} row or colum dimension is zero.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #Array2DRowRealMatrix(double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getData#250",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }\n",
        "begin_line": 250,
        "end_line": 253,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return 2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setSubMatrix#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
        "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }\n",
        "begin_line": 265,
        "end_line": 298,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n    * Replace the submatrix starting at {@code row, column} using data in the\n    * input {@code subMatrix} array. Indexes are 0-based.\n    * <p>\n    * Example:<br>\n    * Starting with <pre>\n    * 1  2  3  4\n    * 5  6  7  8\n    * 9  0  1  2\n    * </pre>\n    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n    * {@code setSubMatrix(subMatrix,1,1))} will result in <pre>\n    * 1  2  3  4\n    * 5  3  4  8\n    * 9  5  6  2\n    * </pre></p>\n    *\n    * @param subMatrix  array containing the submatrix replacement data\n    * @param row  row coordinate of the top, left element to be replaced\n    * @param column  column coordinate of the top, left element to be replaced\n    * @throws NoDataException if {@code subMatrix} is empty.\n    * @throws OutOfRangeException if {@code subMatrix} does not fit into\n    * this matrix from element in {@code (row, column)}.\n    * @throws DimensionMismatchException if {@code subMatrix} is not rectangular\n    * (not all rows have the same length) or empty.\n    * @throws NullArgumentException if {@code subMatrix} is {@code null}.\n    * @since 2.0\n    "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyOut#523",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
        "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n",
        "begin_line": 523,
        "end_line": 531,
        "comment": "\n     * Get a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.copyIn#541",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
        "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }\n",
        "begin_line": 541,
        "end_line": 544,
        "comment": "\n     * Replace data with a fresh copy of the input array.\n     *\n     * @param in Data to copy.\n     * @throws NoDataException if the input array is empty.\n     * @throws DimensionMismatchException if the input array is not rectangular.\n     * @throws NullArgumentException if the input array is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.setColumnVector#519",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.setColumnVector(int, org.apache.commons.math3.linear.RealVector)",
        "snippet": "    public void setColumnVector(final int column, final RealVector vector)\n        throws OutOfRangeException, MatrixDimensionMismatchException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (vector.getDimension() != nRows) {\n            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n                                                       nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n    }\n",
        "begin_line": 519,
        "end_line": 530,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": "\n     * Returns the result of multiplying {@code this} by the vector {@code x}.\n     *\n     * @param x the vector to operate on\n     * @return the product of {@code this} instance with {@code x}\n     * @throws DimensionMismatchException if the column dimension does not match\n     * the size of {@code x}\n     ",
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Sets the specified {@code row} of {@code this} matrix to the entries of\n     * the specified {@code vector}. Row indices start at 0.\n     *\n     * @param row Row to be set.\n     * @param vector row vector to be copied (must have the same number of\n     * column as the instance).\n     * @throws OutOfRangeException if the specified row index is invalid.\n     * @throws MatrixDimensionMismatchException if the {@code vector} dimension\n     * does not match the column dimension of {@code this} matrix.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.getRow#533",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getRow(int)",
        "snippet": "    public double[] getRow(final int row) throws OutOfRangeException {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols = getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int i = 0; i < nCols; ++i) {\n            out[i] = getEntry(row, i);\n        }\n\n        return out;\n    }\n",
        "begin_line": 533,
        "end_line": 542,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given row index. Row indices start at 0.\n     *\n     * @param row Row to be fetched.\n     * @return the array of entries in the row.\n     * @throws OutOfRangeException if the specified row index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.isSquare#615",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }\n",
        "begin_line": 615,
        "end_line": 617,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "Pair.getKey#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.getKey()",
        "snippet": "    public K getKey() {\n        return key;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Get the key.\n     *\n     * @return the key (first element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Pair.getValue#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.getValue()",
        "snippet": "    public V getValue() {\n        return value;\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": "\n     * Get the value.\n     *\n     * @return the value (second element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#546",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[], int)",
        "snippet": "    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n",
        "begin_line": 546,
        "end_line": 550,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getMaximalCount#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
        "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Gets the upper limit of the counter.\n     *\n     * @return the counter upper limit.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 154,
        "end_line": 158,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.CodyWaite#3784",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.CodyWaite(double, double)",
        "snippet": "        CodyWaite(double xa,\n                  double xb) {\n            // Estimate k.\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder.\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2.\n                --k;\n            }\n\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n",
        "begin_line": 3784,
        "end_line": 3821,
        "comment": "\n         * @param xa Argument.\n         * @param xb Argument.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getK#3826",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getK()",
        "snippet": "        int getK() {\n            return finalK;\n        }\n",
        "begin_line": 3826,
        "end_line": 3828,
        "comment": "\n         * @return k\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getRemA#3832",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemA()",
        "snippet": "        double getRemA() {\n            return finalRemA;\n        }\n",
        "begin_line": 3832,
        "end_line": 3834,
        "comment": "\n         * @return remA\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.getRemB#3838",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemB()",
        "snippet": "        double getRemB() {\n            return finalRemB;\n        }\n",
        "begin_line": 3838,
        "end_line": 3840,
        "comment": "\n         * @return remB\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1095",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double)",
        "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }\n",
        "begin_line": 1095,
        "end_line": 1097,
        "comment": "\n     * Natural logarithm.\n     *\n     * @param x   a double\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1105,
        "end_line": 1329,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polySine#1651",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
        "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }\n",
        "begin_line": 1651,
        "end_line": 1664,
        "comment": "\n     *  Computes sin(x) - x, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return sin(x) - x\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.polyCosine#1672",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
        "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n",
        "begin_line": 1672,
        "end_line": 1682,
        "comment": "\n     *  Computes cos(x) - 1, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return cos(x) - 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sinQ#1691",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
        "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n",
        "begin_line": 1691,
        "end_line": 1806,
        "comment": "\n     *  Compute sine over the first quadrant (0 < x < pi/2).\n     *  Use combination of table lookup and rational polynomial expansion.\n     *  @param xa number from which sine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return sin(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cosQ#1815",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
        "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n",
        "begin_line": 1815,
        "end_line": 1824,
        "comment": "\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n     *  @param xa number from which cosine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return cos(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sin#2200",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
        "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2200,
        "end_line": 2259,
        "comment": "\n     * Sine function.\n     *\n     * @param x Argument.\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.cos#2267",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
        "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2267,
        "end_line": 2313,
        "comment": "\n     * Cosine function.\n     *\n     * @param x Argument.\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#2991",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 2991,
        "end_line": 2993,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3395",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
        "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n",
        "begin_line": 3395,
        "end_line": 3397,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3506",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3506,
        "end_line": 3524,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
        "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance()} with the only customizing that the\n     * maximum number of fraction digits is set to 10.\n     * @return the default number format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(java.util.Locale)",
        "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }\n",
        "begin_line": 53,
        "end_line": 57,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing that the maximum number of fraction digits is set to 10.\n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.next#228",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.next(int)",
        "snippet": "    @Override\n    protected int next(int bits) {\n\n        int y;\n\n        if (mti >= N) { // generate N words at one time\n            int mtNext = mt[0];\n            for (int k = 0; k < N - M; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            for (int k = N - M; k < N - 1; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            y = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\n            mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\n\n            mti = 0;\n        }\n\n        y = mt[mti++];\n\n        // tempering\n        y ^=  y >>> 11;\n        y ^= (y <<   7) & 0x9d2c5680;\n        y ^= (y <<  15) & 0xefc60000;\n        y ^=  y >>> 18;\n\n        return y >>> (32 - bits);\n\n    }\n",
        "begin_line": 228,
        "end_line": 263,
        "comment": " Generate next pseudorandom number.\n     * <p>This method is the core generation algorithm. It is used by all the\n     * public generation methods for the various primitive types {@link\n     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n     * {@link #next(int)} and {@link #nextLong()}.</p>\n     * @param bits number of random bits to produce\n     * @return random bits generated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.nextDouble#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextDouble()",
        "snippet": "    public double nextDouble() {\n        final long high = ((long) next(26)) << 26;\n        final int  low  = next(26);\n        return (high | low) * 0x1.0p-52d;\n    }\n",
        "begin_line": 84,
        "end_line": 88,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.random.RandomGenerator": "\n     * Returns the next pseudorandom, uniformly distributed\n     * <code>double</code> value between <code>0.0</code> and\n     * <code>1.0</code> from this random number generator's sequence.\n     *\n     * @return  the next pseudorandom, uniformly distributed\n     *  <code>double</code> value between <code>0.0</code> and\n     *  <code>1.0</code> from this random number generator's sequence\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.nextGaussian#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextGaussian()",
        "snippet": "    public double nextGaussian() {\n\n        final double random;\n        if (Double.isNaN(nextGaussian)) {\n            // generate a new pair of gaussian numbers\n            final double x = nextDouble();\n            final double y = nextDouble();\n            final double alpha = 2 * FastMath.PI * x;\n            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n            random       = r * FastMath.cos(alpha);\n            nextGaussian = r * FastMath.sin(alpha);\n        } else {\n            // use the second element of the pair already generated\n            random = nextGaussian;\n            nextGaussian = Double.NaN;\n        }\n\n        return random;\n\n    }\n",
        "begin_line": 96,
        "end_line": 115,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.random.RandomGenerator": "\n     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n     * <code>double</code> value with mean <code>0.0</code> and standard\n     * deviation <code>1.0</code> from this random number generator's sequence.\n     *\n     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n     * <code>double</code> value with mean <code>0.0</code> and\n     * standard deviation <code>1.0</code> from this random number\n     *  generator's sequence\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.FitnessFunction#895",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.FitnessFunction()",
        "snippet": "        public FitnessFunction() {\n            valueRange = 1.0;\n            isRepairMode = true;\n        }\n",
        "begin_line": 895,
        "end_line": 898,
        "comment": " Simple constructor.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.repairAndDecode#920",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.repairAndDecode(double[])",
        "snippet": "        public double[] repairAndDecode(final double[] x) {\n            return\n                decode(x);\n        }\n",
        "begin_line": 920,
        "end_line": 923,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the original objective variables, possibly repaired.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.setValueRange#981",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.setValueRange(double)",
        "snippet": "        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n",
        "begin_line": 981,
        "end_line": 983,
        "comment": "\n         * @param valueRange Adjusts the penalty computation.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.DoubleIndex#844",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.DoubleIndex.DoubleIndex(double, int)",
        "snippet": "        DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n",
        "begin_line": 844,
        "end_line": 847,
        "comment": "\n         * @param value Value to compare.\n         * @param index Index into sorted array.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.compareTo#850",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.DoubleIndex.compareTo(org.apache.commons.math3.optimization.direct.CMAESOptimizer.DoubleIndex)",
        "snippet": "        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n",
        "begin_line": 850,
        "end_line": 852,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.MultivariateOptimizer": null,
            "java.lang.Comparable": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseMultivariateSimpleBoundsOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.updateEvolutionPaths#637",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateEvolutionPaths(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);\n        pc = pc.scalarMultiply(1. - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }\n",
        "begin_line": 637,
        "end_line": 651,
        "comment": "\n     * Update of the evolution paths ps and pc.\n     *\n     * @param zmean Weighted row matrix of the gaussian random numbers generating\n     * the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     * @return hsig flag indicating a small correction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.push#804",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.push(double[], double)",
        "snippet": "    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n",
        "begin_line": 804,
        "end_line": 809,
        "comment": "\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.sortedIndices#817",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sortedIndices(double[])",
        "snippet": "    private int[] sortedIndices(final double[] doubles) {\n        DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n",
        "begin_line": 817,
        "end_line": 828,
        "comment": "\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.log#1024",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.log(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1024,
        "end_line": 1032,
        "comment": "\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.sqrt#1039",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sqrt(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix sqrt(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1039,
        "end_line": 1047,
        "comment": "\n     * @param m\n     *            Input matrix\n     * @return Matrix representing the element-wise square root of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.square#1053",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.square(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1053,
        "end_line": 1062,
        "comment": "\n     * @param m Input matrix\n     * @return Matrix representing the element-wise square (^2) of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.times#1069",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.times(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1069,
        "end_line": 1077,
        "comment": "\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.selectColumns#1099",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.selectColumns(org.apache.commons.math3.linear.RealMatrix, int[])",
        "snippet": "    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1099,
        "end_line": 1107,
        "comment": "\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.diag#1145",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.diag(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n",
        "begin_line": 1145,
        "end_line": 1159,
        "comment": "\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.copyColumn#1169",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.copyColumn(org.apache.commons.math3.linear.RealMatrix, int, org.apache.commons.math3.linear.RealMatrix, int)",
        "snippet": "    private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n",
        "begin_line": 1169,
        "end_line": 1173,
        "comment": "\n     * Copies a column from m1 to m2.\n     *\n     * @param m1 Source matrix 1.\n     * @param col1 Source column.\n     * @param m2 Target matrix.\n     * @param col2 Target column.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.ones#1180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.ones(int, int)",
        "snippet": "    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1180,
        "end_line": 1186,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix filled with 1.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.eye#1193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.eye(int, int)",
        "snippet": "    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1193,
        "end_line": 1201,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0.0-values, diagonal has values 1.0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.zeros#1208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.zeros(int, int)",
        "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n",
        "begin_line": 1208,
        "end_line": 1210,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0.0-values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.repmat#1218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.repmat(org.apache.commons.math3.linear.RealMatrix, int, int)",
        "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1218,
        "end_line": 1228,
        "comment": "\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.sequence#1236",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sequence(double, double, double)",
        "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1236,
        "end_line": 1245,
        "comment": "\n     * @param start Start value.\n     * @param end End value.\n     * @param step Step size.\n     * @return a sequence as column matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.max#1251",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }\n",
        "begin_line": 1251,
        "end_line": 1262,
        "comment": "\n     * @param m Input matrix.\n     * @return the maximum of the matrix element values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.min#1268",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.min(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }\n",
        "begin_line": 1268,
        "end_line": 1279,
        "comment": "\n     * @param m Input matrix.\n     * @return the minimum of the matrix element values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.max#1285",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(double[])",
        "snippet": "    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }\n",
        "begin_line": 1285,
        "end_line": 1293,
        "comment": "\n     * @param m Input array.\n     * @return the maximum of the array values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.min#1299",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.min(double[])",
        "snippet": "    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }\n",
        "begin_line": 1299,
        "end_line": 1307,
        "comment": "\n     * @param m Input array.\n     * @return the minimum of the array values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.randn1#1350",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.randn1(int, int)",
        "snippet": "    private RealMatrix randn1(int size, int popSize) {\n        double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1350,
        "end_line": 1358,
        "comment": "\n     * @param size Number of rows.\n     * @param popSize Population size.\n     * @return a 2-dimensional matrix of Gaussian random numbers.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getMaxEvaluations#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getMaxEvaluations()",
        "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": "\n     * Get the maximal number of function evaluations.\n     *\n     * @return the maximal number of function evaluations.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getConvergenceChecker#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getConvergenceChecker()",
        "snippet": "    public ConvergenceChecker<PointValuePair> getConvergenceChecker() {\n        return checker;\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optimization.BaseOptimizer": "\n     * Get the convergence checker.\n     *\n     * @return the object used to check for convergence.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.computeObjectiveValue#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.computeObjectiveValue(double[])",
        "snippet": "    protected double computeObjectiveValue(double[] point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }\n",
        "begin_line": 93,
        "end_line": 100,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at the specified point.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getGoalType#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 154,
        "end_line": 156,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "SimpleValueChecker.converged#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java",
        "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
        "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.converged(int, org.apache.commons.math3.optimization.PointValuePair, org.apache.commons.math3.optimization.PointValuePair)",
        "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointValuePair previous,\n                             final PointValuePair current) {\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }\n",
        "begin_line": 73,
        "end_line": 83,
        "comment": "\n     * Check if the optimization algorithm has converged considering the\n     * last two points.\n     * This method may be called several time from the same algorithm\n     * iteration with different points. This can be detected by checking the\n     * iteration number at each call if needed. Each time this method is\n     * called, the previous and current point correspond to points with the\n     * same role at each iteration, so they can be compared. As an example,\n     * simplex-based algorithms call this method for all points of the simplex,\n     * not only for the best or worst ones.\n     *\n     * @param iteration Index of current iteration\n     * @param previous Best point in the previous iteration.\n     * @param current Best point in the current iteration.\n     * @return {@code true} if the algorithm has converged.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "PointValuePair.getPoint#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optimization.PointValuePair",
        "signature": "org.apache.commons.math3.optimization.PointValuePair.getPoint()",
        "snippet": "    public double[] getPoint() {\n        final double[] p = getKey();\n        return p == null ? null : p.clone();\n    }\n",
        "begin_line": 72,
        "end_line": 75,
        "comment": "\n     * Gets the point.\n     *\n     * @return a copy of the stored point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractConvergenceChecker.getRelativeThreshold#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.getRelativeThreshold()",
        "snippet": "    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }\n",
        "begin_line": 84,
        "end_line": 86,
        "comment": "\n     * @return the relative threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractConvergenceChecker.getAbsoluteThreshold#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.getAbsoluteThreshold()",
        "snippet": "    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n     * @return the absolute threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#98",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }\n",
        "begin_line": 112,
        "end_line": 117,
        "comment": "\n     * Create an instance with custom prefix, suffix and separator.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#130",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }\n",
        "begin_line": 130,
        "end_line": 143,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getFormat#206",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
        "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }\n",
        "begin_line": 206,
        "end_line": 208,
        "comment": "\n     * Get the components format.\n     * @return components format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getInstance#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
        "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "RealMatrixFormat.getInstance#223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createRealMatrix#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int, int)",
        "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }\n",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n     * Returns a {@link RealMatrix} with specified dimensions.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The matrix elements are all set to 0.0.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @return  RealMatrix with specified dimensions\n     * @see #createRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.createColumnRealMatrix#337",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createColumnRealMatrix(double[])",
        "snippet": "    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }\n",
        "begin_line": 337,
        "end_line": 348,
        "comment": "\n     * Creates a column {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param columnData  the input column data\n     * @return a columnData x 1 RealMatrix\n     * @throws NoDataException if {@code columnData} is empty.\n     * @throws NullArgumentException if {@code columnData} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMatrixIndex#386",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix, int, int)",
        "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }\n",
        "begin_line": 386,
        "end_line": 391,
        "comment": "\n     * Check if matrix indices are valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code row} or {@code column} is not\n     * a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkRowIndex#400",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }\n",
        "begin_line": 400,
        "end_line": 407,
        "comment": "\n     * Check if a row index is valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @throws OutOfRangeException if {@code row} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkColumnIndex#416",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }\n",
        "begin_line": 416,
        "end_line": 422,
        "comment": "\n     * Check if a column index is valid.\n     *\n     * @param m Matrix.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code column} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkAdditionCompatible#504",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkAdditionCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 504,
        "end_line": 511,
        "comment": "\n     * Check if matrices are addition compatible.\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws MatrixDimensionMismatchException if the matrices are not addition\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkSubtractionCompatible#521",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkSubtractionCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 521,
        "end_line": 528,
        "comment": "\n     * Check if matrices are subtraction compatible\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws MatrixDimensionMismatchException if the matrices are not addition\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#538",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }\n",
        "begin_line": 538,
        "end_line": 545,
        "comment": "\n     * Check if matrices are multiplication compatible\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws DimensionMismatchException if matrices are not multiplication\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.start#32",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int, int, int, int, int, int)",
        "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }\n",
        "begin_line": 32,
        "end_line": 34,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.end#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
        "snippet": "    public double end() {\n        return 0;\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
        "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }\n",
        "begin_line": 58,
        "end_line": 63,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows in the new matrix.\n     * @param columnDimension Number of columns in the new matrix.\n     * @throws NotStrictlyPositiveException if the row or column dimension is\n     * not positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#99",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws DimensionMismatchException, NoDataException,\n        NullArgumentException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullArgumentException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 99,
        "end_line": 123,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the {@code copyArray} may be\n     * set to {@code false}. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.\n     *\n     * @param d Data for new matrix.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     * @throws DimensionMismatchException if {@code d} is not rectangular.\n     * @throws NoDataException if {@code d} row or colum dimension is zero.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #Array2DRowRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.createMatrix#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int, int)",
        "snippet": "    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }\n",
        "begin_line": 141,
        "end_line": 145,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": null,
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Create a new RealMatrix of the same type as the instance with the\n     * supplied\n     * row and column dimensions.\n     *\n     * @param rowDimension the number of rows in the new matrix\n     * @param columnDimension the number of columns in the new matrix\n     * @return a new matrix of the same type as the instance\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getEntry#301",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int, int)",
        "snippet": "    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }\n",
        "begin_line": 301,
        "end_line": 305,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": null,
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be fetched.\n     * @param column Column index of entry to be fetched.\n     * @return the matrix entry at {@code (row, column)}.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.setEntry#308",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
        "snippet": "    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }\n",
        "begin_line": 308,
        "end_line": 312,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": null,
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Set the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be set.\n     * @param column Column index of entry to be set.\n     * @param value the new value of the entry.\n     * @throws OutOfRangeException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#333",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 333,
        "end_line": 336,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of rows of this matrix.\n     *\n     * @return the number of rows.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#339",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 339,
        "end_line": 342,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of columns of this matrix.\n     *\n     * @return the number of columns.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.walkInRowOrder#404",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 404,
        "end_line": 416,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.transpose#597",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
        "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }\n",
        "begin_line": 597,
        "end_line": 612,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.visit#604",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-1f58d070-dc42-44ba-b6a5-df9fc17724e8.visit(int, int, double)",
        "snippet": "            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n",
        "begin_line": 604,
        "end_line": 607,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.getFrobeniusNorm#279",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getFrobeniusNorm()",
        "snippet": "    public double getFrobeniusNorm() {\n        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n            /** Sum of squared entries. */\n            private double sum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return FastMath.sqrt(sum);\n            }\n        });\n    }\n",
        "begin_line": 279,
        "end_line": 302,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the <a href=\"http://mathworld.wolfram.com/FrobeniusNorm.html\">\n     * Frobenius norm</a> of the matrix.\n     *\n     * @return norm\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.start#286",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-51c15b1c-77ec-46b5-b768-0b62e58b8fce.start(int, int, int, int, int, int)",
        "snippet": "            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n",
        "begin_line": 286,
        "end_line": 290,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.visit#293",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-e26b9679-4e37-40be-99c8-693d3ccdef4a.visit(int, int, double)",
        "snippet": "            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n",
        "begin_line": 293,
        "end_line": 295,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.end#298",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-312e0243-314d-40c3-a4c9-e9188c24c82d.end()",
        "snippet": "            public double end() {\n                return FastMath.sqrt(sum);\n            }\n",
        "begin_line": 298,
        "end_line": 300,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {}\n",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }\n",
        "begin_line": 65,
        "end_line": 74,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws NotStrictlyPositiveException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.add#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.add(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix add(RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 77,
        "end_line": 91,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.subtract#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.subtract(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix subtract(final RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 94,
        "end_line": 108,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.scalarAdd#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarAdd(double)",
        "snippet": "    public RealMatrix scalarAdd(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + d);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 111,
        "end_line": 122,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of adding {@code d} to each entry of {@code this}.\n     *\n     * @param d value to be added to each entry\n     * @return {@code d + this}\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.scalarMultiply#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarMultiply(double)",
        "snippet": "    public RealMatrix scalarMultiply(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) * d);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 125,
        "end_line": 136,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of multiplying each entry of {@code this} by\n     * {@code d}.\n     *\n     * @param d value to multiply all entries by\n     * @return {@code d * this}\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.multiply#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 139,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.getColumnMatrix#464",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumnMatrix(int)",
        "snippet": "    public RealMatrix getColumnMatrix(final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final RealMatrix out = createMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, 0, getEntry(i, column));\n        }\n\n        return out;\n    }\n",
        "begin_line": 464,
        "end_line": 474,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given column index as a column matrix. Column\n     * indices start at 0.\n     *\n     * @param column Column to be fetched.\n     * @return column Matrix.\n     * @throws OutOfRangeException if the specified column index is invalid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.getColumn#558",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumn(int)",
        "snippet": "    public double[] getColumn(final int column) throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final double[] out = new double[nRows];\n        for (int i = 0; i < nRows; ++i) {\n            out[i] = getEntry(i, column);\n        }\n\n        return out;\n    }\n",
        "begin_line": 558,
        "end_line": 567,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given column index as an array. Column indices\n     * start at 0.\n     *\n     * @param column Column to be fetched.\n     * @return the array of entries in the column.\n     * @throws OutOfRangeException if the specified column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.walkInOptimizedOrder#872",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 872,
        "end_line": 874,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound()",
        "snippet": "    public double[] getLowerBound() {\n        return lowerBound.clone();\n    }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": "\n     * @return the lower bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound()",
        "snippet": "    public double[] getUpperBound() {\n        return upperBound.clone();\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * @return the upper bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.optimize#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(int, FUNC, org.apache.commons.math3.optimization.GoalType, double[])",
        "snippet": "    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                       double[] startPoint) {\n        return optimizeInternal(maxEval, f, goalType, startPoint);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optimization.BaseMultivariateOptimizer": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.optimizeInternal#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimizeInternal(int, org.apache.commons.math3.analysis.MultivariateFunction, org.apache.commons.math3.optimization.GoalType, double[])",
        "snippet": "    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f, GoalType goalType,\n                                              double[] startPoint) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n        if (startPoint == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Store optimization problem characteristics.\n        function = f;\n        goal = goalType;\n        start = startPoint.clone();\n\n        // Perform computation.\n        return doOptimize();\n    }\n",
        "begin_line": 125,
        "end_line": 149,
        "comment": "\n     * Optimize an objective function.\n     *\n     * @param f Objective function.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param startPoint Start point for optimization.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.getStartPoint#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getStartPoint()",
        "snippet": "    public double[] getStartPoint() {\n        return start.clone();\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2182
        },
        "num_failing_tests": 1
    },
    {
        "name": "Pair.Pair#45",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.Pair(K, V)",
        "snippet": "    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n     * Create an entry representing a mapping from the specified key to the\n     * specified value.\n     *\n     * @param k Key (first element of the pair).\n     * @param v Value (second element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 61,
        "end_line": 69,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int, org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 79,
        "end_line": 86,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     * @throws NullArgumentException if {@code cb} is {@code null}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3463",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
        "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n",
        "begin_line": 3463,
        "end_line": 3465,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.MersenneTwister#106",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
        "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": " Creates a new random number generator.\n     * <p>The instance is initialized using the current time plus the\n     * system identity hash code of this instance as the seed.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
        "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }\n",
        "begin_line": 141,
        "end_line": 155,
        "comment": " Reinitialize the generator as if just built with the given int seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
        "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }\n",
        "begin_line": 164,
        "end_line": 207,
        "comment": " Reinitialize the generator as if just built with the given int array seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integers array), if null\n     * the seed of the generator will be the current system time plus the\n     * system identity hash code of this instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "MersenneTwister.setSeed#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
        "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }\n",
        "begin_line": 214,
        "end_line": 217,
        "comment": " Reinitialize the generator as if just built with the given long seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (64 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.BitsStreamGenerator#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
        "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": " Creates a new random number generator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "BitsStreamGenerator.clear#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
        "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 164,
        "end_line": 166,
        "comment": "\n     * Clears the cache used by the default implementation of\n     * {@link #nextGaussian}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#277",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int, double[], int, double, boolean, int, int, org.apache.commons.math3.random.RandomGenerator, boolean)",
        "snippet": "    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }\n",
        "begin_line": 277,
        "end_line": 285,
        "comment": "\n     * @param lambda Population size.\n     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n     * @param maxIterations Maximal number of iterations.\n     * @param stopFitness Whether to stop if objective function value is smaller than\n     * {@code stopFitness}.\n     * @param isActiveCMA Chooses the covariance matrix update method.\n     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n     * remains diagonal.\n     * @param checkFeasableCount Determines how often new random objective variables are\n     * generated in case they are out of bounds.\n     * @param random Random generator.\n     * @param generateStatistics Whether statistic data is collected.\n     * @deprecated See {@link SimpleValueChecker#SimpleValueChecker()}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#302",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int, double[], int, double, boolean, int, int, org.apache.commons.math3.random.RandomGenerator, boolean, org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }\n",
        "begin_line": 302,
        "end_line": 317,
        "comment": "\n     * @param lambda Population size.\n     * @param inputSigma Initial search volume; sigma of offspring objective variables.\n     * @param maxIterations Maximal number of iterations.\n     * @param stopFitness Whether to stop if objective function value is smaller than\n     * {@code stopFitness}.\n     * @param isActiveCMA Chooses the covariance matrix update method.\n     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n     * remains diagonal.\n     * @param checkFeasableCount Determines how often new random objective variables are\n     * generated in case they are out of bounds.\n     * @param random Random generator.\n     * @param generateStatistics Whether statistic data is collected.\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer(org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer(org.apache.commons.math3.optimization.ConvergenceChecker<org.apache.commons.math3.optimization.PointValuePair>)",
        "snippet": "    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        this.checker = checker;\n    }\n",
        "begin_line": 66,
        "end_line": 68,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "SimpleValueChecker.SimpleValueChecker#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java",
        "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
        "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.SimpleValueChecker()",
        "snippet": "    @Deprecated\n    public SimpleValueChecker() {}\n",
        "begin_line": 40,
        "end_line": 41,
        "comment": "\n     * Build an instance with default thresholds.\n     * @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PointValuePair.PointValuePair#45",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optimization.PointValuePair",
        "signature": "org.apache.commons.math3.optimization.PointValuePair.PointValuePair(double[], double)",
        "snippet": "    public PointValuePair(final double[] point,\n                          final double value) {\n        this(point, value, true);\n    }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n     * Builds a point/objective function value pair.\n     *\n     * @param point Point coordinates. This instance will store\n     * a copy of the array, not the array passed as argument.\n     * @param value Value of the objective function at the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PointValuePair.PointValuePair#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optimization.PointValuePair",
        "signature": "org.apache.commons.math3.optimization.PointValuePair.PointValuePair(double[], double, boolean)",
        "snippet": "    public PointValuePair(final double[] point,\n                          final double value,\n                          final boolean copyArray) {\n        super(copyArray ? ((point == null) ? null :\n                           point.clone()) :\n              point,\n              value);\n    }\n",
        "begin_line": 58,
        "end_line": 65,
        "comment": "\n     * Builds a point/objective function value pair.\n     *\n     * @param point Point coordinates.\n     * @param value Value of the objective function at the point.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractConvergenceChecker.AbstractConvergenceChecker#63",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optimization/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.AbstractConvergenceChecker()",
        "snippet": "    @Deprecated\n    public AbstractConvergenceChecker() {\n        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n    }\n",
        "begin_line": 63,
        "end_line": 67,
        "comment": "\n     * Build an instance with default thresholds.\n     * @deprecated in 3.1 (to be removed in 4.0). Convergence thresholds are\n     * problem-dependent. As this class is intended for users who want to set\n     * their own convergence criterion instead of relying on an algorithm's\n     * default procedure, they should also set the thresholds appropriately\n     * (cf. MATH-798).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    }
]