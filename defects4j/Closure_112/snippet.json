[
    {
        "name": "JSType.checkEquivalenceHelper#570",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.checkEquivalenceHelper(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n      if (eqMethod == EquivalenceMethod.INVARIANT) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n        return true;\n      } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return toMaybeUnionType().checkUnionEquivalenceHelper(\n          that.toMaybeUnionType(), eqMethod);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), eqMethod);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), eqMethod);\n    }\n\n    if (!getTemplateTypeMap().checkEquivalenceHelper(\n        that.getTemplateTypeMap(), eqMethod)) {\n      return false;\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    if (isTemplateType() && that.isTemplateType()) {\n      return this == that;\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n              that, eqMethod);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          eqMethod);\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }\n",
        "begin_line": 570,
        "end_line": 642,
        "comment": "\n   * An equivalence visitor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMapReplacer.caseTemplateType#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer.caseTemplateType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  @Override\n  public JSType caseTemplateType(TemplateType type) {\n    if (replacements.hasTemplateKey(type)) {\n      if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {\n        // If we have already encountered this TemplateType during replacement\n        // (i.e. there is a reference loop), or there is no JSType substitution\n        // for the TemplateType, return the TemplateType type itself.\n        return type;\n      } else {\n        JSType replacement = replacements.getTemplateType(type);\n\n        visitedTypes.push(type);\n        JSType visitedReplacement = replacement.visit(this);\n        visitedTypes.pop();\n\n        return visitedReplacement;\n      }\n    } else {\n      return type;\n    }\n  }\n",
        "begin_line": 67,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.343
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.inferTemplateTypesFromParameters#1031",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.inferTemplateTypesFromParameters(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.Node)",
        "snippet": "  private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n      FunctionType fnType, Node call) {\n    if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n      return Collections.emptyMap();\n    }\n\n    Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap();\n\n    Node callTarget = call.getFirstChild();\n    if (NodeUtil.isGet(callTarget)) {\n      Node obj = callTarget.getFirstChild();\n      maybeResolveTemplatedType(\n          fnType.getTypeOfThis(),\n          getJSType(obj),\n          resolvedTypes);\n    }\n\n    if (call.hasMoreThanOneChild()) {\n      maybeResolveTemplateTypeFromNodes(\n          fnType.getParameters(),\n          call.getChildAtIndex(1).siblings(),\n          resolvedTypes);\n    }\n    return resolvedTypes;\n  }\n",
        "begin_line": 1031,
        "end_line": 1055,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.getPropertyType#1320",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.getPropertyType(com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if (propertyType != null && objType != null) {\n      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n      if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n          && propertyType.hasAnyTemplateTypes()) {\n        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n            registry, typeMap);\n        propertyType = propertyType.visit(replacer);\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return unknownType;\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }\n",
        "begin_line": 1320,
        "end_line": 1381,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.resolvedTemplateType#1144",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.resolvedTemplateType(java.util.Map<com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType>, com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private static void resolvedTemplateType(\n      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n    JSType previous = map.get(template);\n    if (!resolved.isUnknownType()) {\n      if (previous == null) {\n        map.put(template, resolved);\n      } else {\n        JSType join = previous.getLeastSupertype(resolved);\n        map.put(template, join);\n      }\n    }\n  }\n",
        "begin_line": 1144,
        "end_line": 1155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.caseFunctionType#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.caseFunctionType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  @Override\n  public JSType caseFunctionType(FunctionType type) {\n    if (isNativeFunctionType(type)) {\n      return type;\n    }\n\n    // TODO(johnlenz): remove this simplifying assumption...\n    if (!type.isOrdinaryFunction()) {\n      return type;\n    }\n\n    boolean changed = false;\n\n    JSType beforeThis = type.getTypeOfThis();\n    JSType afterThis = coerseToThisType(beforeThis.visit(this));\n    if (beforeThis != afterThis) {\n      changed = true;\n    }\n\n    JSType beforeReturn = type.getReturnType();\n    JSType afterReturn = beforeReturn.visit(this);\n    if (beforeReturn != afterReturn) {\n      changed = true;\n    }\n\n    FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n    for (Node paramNode : type.getParameters()) {\n      JSType beforeParamType = paramNode.getJSType();\n      JSType afterParamType = beforeParamType.visit(this);\n      if (beforeParamType != afterParamType) {\n        changed = true;\n      }\n      if (paramNode.isOptionalArg()) {\n        paramBuilder.addOptionalParams(afterParamType);\n      } else if (paramNode.isVarArgs()) {\n        paramBuilder.addVarArgs(afterParamType);\n      } else {\n        paramBuilder.addRequiredParams(afterParamType);\n      }\n    }\n\n    if (changed) {\n      FunctionBuilder builder = new FunctionBuilder(registry);\n      builder.withParams(paramBuilder);\n      builder.withReturnType(afterReturn);\n      builder.withTypeOfThis(afterThis);\n      builder.withTemplateKeys(type.getTemplateTypeMap().getUnfilledTemplateKeys());\n      return builder.build();\n    }\n\n    return type;\n  }\n",
        "begin_line": 87,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3086
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.registerMismatch#671",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.registerMismatch(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.JSError)",
        "snippet": "  private void registerMismatch(JSType found, JSType required, JSError error) {\n    // Don't register a mismatch for differences in null or undefined or if the\n    // code didn't downcast.\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (found.isSubtype(required) || required.isSubtype(found)) {\n      return;\n    }\n\n    mismatches.add(new TypeMismatch(found, required, error));\n    if (found.isFunctionType() &&\n        required.isFunctionType()) {\n      FunctionType fnTypeA = found.toMaybeFunctionType();\n      FunctionType fnTypeB = required.toMaybeFunctionType();\n      Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n      Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n      while (paramItA.hasNext() && paramItB.hasNext()) {\n        registerIfMismatch(paramItA.next().getJSType(),\n            paramItB.next().getJSType(), error);\n      }\n\n      registerIfMismatch(\n          fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n    }\n  }\n",
        "begin_line": 671,
        "end_line": 695,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMapReplacer.hasVisitedType#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer.hasVisitedType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  private boolean hasVisitedType(TemplateType type) {\n    for (TemplateType visitedType : visitedTypes) {\n      if (visitedType == type) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 93,
        "end_line": 100,
        "comment": "\n   * Checks if the specified type has already been visited during the Visitor's\n   * traversal of a JSType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.maybeResolveTemplatedType#1057",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.maybeResolveTemplatedType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, java.util.Map<com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private void maybeResolveTemplatedType(\n      JSType paramType,\n      JSType argType,\n      Map<TemplateType, JSType> resolvedTypes) {\n    if (paramType.isTemplateType()) {\n      // @param {T}\n      resolvedTemplateType(\n          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n    } else if (paramType.isUnionType()) {\n      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n      UnionType unionType = paramType.toMaybeUnionType();\n      for (JSType alernative : unionType.getAlternates()) {\n        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n      }\n    } else if (paramType.isFunctionType()) {\n      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n      FunctionType argFunctionType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion()\n          .toMaybeFunctionType();\n      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getTypeOfThis(),\n            argFunctionType.getTypeOfThis(), resolvedTypes);\n        // infer from return type of the function type\n        maybeResolveTemplatedType(\n            paramFunctionType.getReturnType(),\n            argFunctionType.getReturnType(), resolvedTypes);\n        // infer from parameter types of the function type\n        maybeResolveTemplateTypeFromNodes(\n            paramFunctionType.getParameters(),\n            argFunctionType.getParameters(), resolvedTypes);\n      }\n    } else if (paramType.isTemplatizedType()) {\n      // @param {Array.<T>}\n      ObjectType referencedParamType = paramType\n          .toMaybeTemplatizedType()\n          .getReferencedType();\n      JSType argObjectType = argType\n          .restrictByNotNullOrUndefined()\n          .collapseUnion();\n\n      if (argObjectType.isSubtype(referencedParamType)) {\n        // If the argument type is a subtype of the parameter type, resolve any\n        // template types amongst their templatized types.\n        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n          maybeResolveTemplatedType(\n              paramTypeMap.getTemplateType(key),\n              argTypeMap.getTemplateType(key),\n              resolvedTypes);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1057,
        "end_line": 1113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2265
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferInheritance#335",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferInheritance(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\n      if (makesStructs && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", formatFnName());\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", formatFnName());\n      }\n\n      // Class template types, which can be used in the scope of a constructor\n      // definition.\n      ImmutableList<String> typeParameters = info.getTemplateTypeNames();\n      if (!typeParameters.isEmpty()) {\n        if (isConstructor || isInterface) {\n          ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n          for (String typeParameter : typeParameters) {\n            builder.add(typeRegistry.createTemplateType(typeParameter));\n          }\n          classTemplateTypeNames = builder.build();\n          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n        }\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, formatFnName());\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          Set<JSType> baseInterfaces = new HashSet<JSType>();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              // Disallow implementing the same base (not templatized) interface\n              // type more than once.\n              JSType baseInterface = maybeInterType;\n              if (baseInterface.toMaybeTemplatizedType() != null) {\n                baseInterface =\n                    baseInterface.toMaybeTemplatizedType().getReferencedType();\n              }\n              if (baseInterfaces.contains(baseInterface)) {\n                reportWarning(SAME_INTERFACE_MULTIPLE_IMPLEMENTS,\n                              baseInterface.toString());\n              } else {\n                baseInterfaces.add(baseInterface);\n              }\n\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, formatFnName());\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", formatFnName());\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n",
        "begin_line": 335,
        "end_line": 426,
        "comment": "\n   * Infer the role of the function (whether it's a constructor or interface)\n   * and what it inherits from in JSDocInfo.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2209
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.hasTemplateKey#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.hasTemplateKey(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  public boolean hasTemplateKey(TemplateType templateKey) {\n    // Note: match by identity, not equality\n    for (TemplateType entry : templateKeys) {\n      if (entry == templateKey) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 111,
        "end_line": 119,
        "comment": "\n   * Returns true if this map contains the specified template key, false\n   * otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.caseObjectType#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.caseObjectType(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  @Override\n  public JSType caseObjectType(ObjectType objType) {\n    return objType;\n  }\n",
        "begin_line": 145,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.maybeResolveTemplateTypeFromNodes#1115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.maybeResolveTemplateTypeFromNodes(java.lang.Iterable<com.google.javascript.rhino.Node>, java.lang.Iterable<com.google.javascript.rhino.Node>, java.util.Map<com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private void maybeResolveTemplateTypeFromNodes(\n      Iterable<Node> declParams,\n      Iterable<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes) {\n    maybeResolveTemplateTypeFromNodes(\n        declParams.iterator(), callParams.iterator(), resolvedTypes);\n  }\n",
        "begin_line": 1115,
        "end_line": 1121,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.maybeResolveTemplateTypeFromNodes#1123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.maybeResolveTemplateTypeFromNodes(java.util.Iterator<com.google.javascript.rhino.Node>, java.util.Iterator<com.google.javascript.rhino.Node>, java.util.Map<com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private void maybeResolveTemplateTypeFromNodes(\n      Iterator<Node> declParams,\n      Iterator<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes) {\n    while (declParams.hasNext() && callParams.hasNext()) {\n      Node declParam = declParams.next();\n      maybeResolveTemplatedType(\n          getJSType(declParam),\n          getJSType(callParams.next()),\n          resolvedTypes);\n      if (declParam.isVarArgs()) {\n        while (callParams.hasNext()) {\n          maybeResolveTemplatedType(\n              getJSType(declParam),\n              getJSType(callParams.next()),\n              resolvedTypes);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1123,
        "end_line": 1142,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.caseTemplateType#1169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.TemplateTypeReplacer.caseTemplateType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "    @Override\n    public JSType caseTemplateType(TemplateType type) {\n      madeChanges = true;\n      JSType replacement = replacements.get(type);\n      return replacement != null ?\n          replacement : registry.getNativeType(UNKNOWN_TYPE);\n    }\n",
        "begin_line": 1169,
        "end_line": 1175,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.backwardsInferenceFromCallSite#964",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.backwardsInferenceFromCallSite(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n    boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n    if (updatedFnType) {\n      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n    }\n    updateTypeOfParameters(n, fnType);\n    updateBind(n);\n  }\n",
        "begin_line": 964,
        "end_line": 971,
        "comment": "\n   * We only do forward type inference. We do not do full backwards\n   * type inference.\n   *\n   * In other words, if we have,\n   * <code>\n   * var x = f();\n   * g(x);\n   * </code>\n   * a forward type-inference engine would try to figure out the type\n   * of \"x\" from the return type of \"f\". A backwards type-inference engine\n   * would try to figure out the type of \"x\" from the parameter type of \"g\".\n   *\n   * However, there are a few special syntactic forms where we do some\n   * some half-assed backwards type-inference, because programmers\n   * expect it in this day and age. To take an example from Java,\n   * <code>\n   * List<String> x = Lists.newArrayList();\n   * </code>\n   * The Java compiler will be able to infer the generic type of the List\n   * returned by newArrayList().\n   *\n   * In much the same way, we do some special-case backwards inference for\n   * JS. Those cases are enumerated here.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.isSubtype#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n\n    ArrowType that = (ArrowType) other;\n\n    // This is described in Draft 2 of the ES4 spec,\n    // Section 3.4.7: Subtyping Function Types.\n\n    // this.returnType <: that.returnType (covariant)\n    if (!this.returnType.isSubtype(that.returnType)) {\n      return false;\n    }\n\n    // that.paramType[i] <: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don't have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g < f, but f !< g\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n      if (thisParamType != null) {\n        if (thatParamType == null ||\n            !thatParamType.isSubtype(thisParamType)) {\n          return false;\n        }\n      }\n\n      boolean thisIsVarArgs = thisParam.isVarArgs();\n      boolean thatIsVarArgs = thatParam.isVarArgs();\n      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n\n      // \"that\" can't be a supertype, because it's missing a required argument.\n      if (!thisIsOptional && thatIsOptional) {\n        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n        // {function(...NoType)} to to indicate that arity should not be\n        // checked. Strictly speaking, this is not a correct formulation,\n        // because now a sub-function can required arguments that are var_args\n        // in the super-function. So we special-case this.\n        boolean isTopFunction =\n            thatIsVarArgs &&\n            (thatParamType == null ||\n             thatParamType.isUnknownType() ||\n             thatParamType.isNoType());\n        if (!isTopFunction) {\n          return false;\n        }\n      }\n\n      // don't advance if we have variable arguments\n      if (!thisIsVarArgs) {\n        thisParam = thisParam.getNext();\n      }\n      if (!thatIsVarArgs) {\n        thatParam = thatParam.getNext();\n      }\n\n      // both var_args indicates the end\n      if (thisIsVarArgs && thatIsVarArgs) {\n        thisParam = null;\n        thatParam = null;\n      }\n    }\n\n    // \"that\" can't be a supertype, because it's missing a required argument.\n    if (thisParam != null\n        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n        && thatParam == null) {\n      return false;\n    }\n\n    return true;\n  }\n",
        "begin_line": 79,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.registerIfMismatch#697",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.registerIfMismatch(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.JSError)",
        "snippet": "  private void registerIfMismatch(\n      JSType found, JSType required, JSError error) {\n    if (found != null && required != null &&\n        !found.isSubtype(required)) {\n      registerMismatch(found, required, error);\n    }\n  }\n",
        "begin_line": 697,
        "end_line": 703,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "ModificationVisitor.caseUnionType#199",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.caseUnionType(com.google.javascript.rhino.jstype.UnionType)",
        "snippet": "  @Override\n  public JSType caseUnionType(UnionType type) {\n    boolean changed = false;\n    List<JSType> results = Lists.newArrayList();\n    for (JSType alternative : type.getAlternates()) {\n      JSType replacement = alternative.visit(this);\n      if (replacement != alternative) {\n        changed = true;\n      }\n      results.add(replacement);\n    }\n\n    if (changed) {\n      UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n      for (JSType alternate : results) {\n        builder.addAlternate(alternate);\n      }\n      return builder.build();  // maybe not a union\n    }\n\n    return type;\n  }\n",
        "begin_line": 199,
        "end_line": 220,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1826
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.visit#510",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseObjectType(this);\n  }\n",
        "begin_line": 510,
        "end_line": 513,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSError.toString#200",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.toString()",
        "snippet": "  @Override\n  public String toString() {\n    // TODO(user): remove custom toString.\n    return type.key + \". \" + description + \" at \" +\n      (sourceName != null && sourceName.length() > 0 ?\n       sourceName : \"(unknown source)\") + \" line \" +\n      (lineNumber != -1 ? String.valueOf(lineNumber) : \"(unknown line)\") +\n      \" : \" + (charno != -1 ? String.valueOf(charno) : \"(unknown column)\");\n  }\n",
        "begin_line": 200,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.collapseUnion#899",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.collapseUnion()",
        "snippet": "  public JSType collapseUnion() {\n    return this;\n  }\n",
        "begin_line": 899,
        "end_line": 901,
        "comment": "\n   * Gets the least supertype of this that's not a union.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.TemplateTypeReplacer#1162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.TemplateTypeReplacer.TemplateTypeReplacer(com.google.javascript.rhino.jstype.JSTypeRegistry, java.util.Map<com.google.javascript.rhino.jstype.TemplateType, com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "    TemplateTypeReplacer(\n        JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n      super(registry);\n      this.registry = registry;\n      this.replacements = replacements;\n    }\n",
        "begin_line": 1162,
        "end_line": 1167,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.inferTemplatedTypesForCall#1183",
        "is_bug": true,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.inferTemplatedTypesForCall(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = \n        inferTemplateTypesFromParameters(fnType, n);\n\n\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }\n",
        "begin_line": 1183,
        "end_line": 1210,
        "comment": "\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.getReadableJSTypeName#724",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.getReadableJSTypeName(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  String getReadableJSTypeName(Node n, boolean dereference) {\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // The best type name is the actual type name.\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n",
        "begin_line": 724,
        "end_line": 777,
        "comment": "\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.updateTypeOfParameters#1000",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.updateTypeOfParameters(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void updateTypeOfParameters(Node n, FunctionType fnType) {\n    int i = 0;\n    int childCount = n.getChildCount();\n    for (Node iParameter : fnType.getParameters()) {\n      if (i + 1 >= childCount) {\n        // TypeCheck#visitParametersList will warn so we bail.\n        return;\n      }\n\n      JSType iParameterType = getJSType(iParameter);\n      Node iArgument = n.getChildAtIndex(i + 1);\n      JSType iArgumentType = getJSType(iArgument);\n      inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n\n      // TODO(johnlenz): Filter out non-function types\n      // (such as null and undefined) as\n      // we only care about FUNCTION subtypes here.\n      JSType restrictedParameter = iParameterType\n          .restrictByNotNullOrUndefined()\n          .toMaybeFunctionType();\n      if (restrictedParameter != null) {\n        if (iArgument.isFunction() &&\n            iArgumentType.isFunctionType() &&\n            iArgument.getJSDocInfo() == null) {\n          iArgument.setJSType(restrictedParameter);\n        }\n      }\n      i++;\n    }\n  }\n",
        "begin_line": 1000,
        "end_line": 1029,
        "comment": "\n   * For functions with function parameters, type inference will set the type of\n   * a function literal argument from the function parameter type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.hasTemplateType#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.hasTemplateType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  public boolean hasTemplateType(TemplateType key) {\n    return getTemplateTypeIndex(key) != -1;\n  }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": "\n   * Returns true if there is a JSType value associated with the specified\n   * template key; false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1191
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoObjectType.getReferenceName#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    return null;\n  }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.isNominalType#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isNominalType()",
        "snippet": "  @Override\n  public boolean isNominalType() {\n    return referencedType.isNominalType();\n  }\n",
        "begin_line": 167,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withParams#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParams(com.google.javascript.rhino.jstype.FunctionParamBuilder)",
        "snippet": "  public FunctionBuilder withParams(FunctionParamBuilder params) {\n    this.parametersNode = params.build();\n    return this;\n  }\n",
        "begin_line": 82,
        "end_line": 85,
        "comment": " Set the parameters of the function type from a FunctionParamBuilder. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getQualifiedName#1575",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getQualifiedName()",
        "snippet": "  public String getQualifiedName() {\n    if (type == Token.NAME) {\n      String name = getString();\n      return name.isEmpty() ? null : name;\n    } else if (type == Token.GETPROP) {\n      String left = getFirstChild().getQualifiedName();\n      if (left == null) {\n        return null;\n      }\n      return left + \".\" + getLastChild().getString();\n    } else if (type == Token.THIS) {\n      return \"this\";\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 1575,
        "end_line": 1590,
        "comment": "\n   * This function takes a set of GETPROP nodes and produces a string that is\n   * each property separated by dots. If the node ultimately under the left\n   * sub-tree is not a simple name, this is not a valid qualified name.\n   *\n   * @return a null if this is not a qualified name, or a dot-separated string\n   *         of the name and properties.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0915
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.checkArrowEquivalenceHelper#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.checkArrowEquivalenceHelper(com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean checkArrowEquivalenceHelper(\n      ArrowType that, EquivalenceMethod eqMethod) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {\n      return false;\n    }\n    return hasEqualParameters(that, eqMethod);\n  }\n",
        "begin_line": 213,
        "end_line": 220,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseResultType#2130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseResultType(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseResultType(JsDocToken token) {\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return newNode(Token.EMPTY);\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {\n      next();\n      return newNode(Token.VOID);\n    } else {\n      return parseTypeExpression(next());\n    }\n  }\n",
        "begin_line": 2130,
        "end_line": 2144,
        "comment": "\n   * ResultType := <empty> | ':' void | ':' TypeExpression\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnionType.visit#547",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnionType(this);\n  }\n",
        "begin_line": 547,
        "end_line": 550,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0729
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.isSubtype#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return referencedType.isSubtype(that);\n  }\n",
        "begin_line": 233,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "NoType.isSubtype#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoType",
        "signature": "com.google.javascript.rhino.jstype.NoType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return true;\n  }\n",
        "begin_line": 83,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createFromTypeNodesInternal#1597",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodesInternal(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private JSType createFromTypeNodesInternal(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    switch (n.getType()) {\n      case Token.LC: // Record type.\n        return createRecordTypeFromNodes(\n            n.getFirstChild(), sourceName, scope);\n\n      case Token.BANG: // Not nullable\n        return createFromTypeNodesInternal(\n            n.getFirstChild(), sourceName, scope)\n            .restrictByNotNullOrUndefined();\n\n      case Token.QMARK: // Nullable or unknown\n        Node firstChild = n.getFirstChild();\n        if (firstChild == null) {\n          return getNativeType(UNKNOWN_TYPE);\n        }\n        return createDefaultObjectUnion(\n            createFromTypeNodesInternal(\n                firstChild, sourceName, scope));\n\n      case Token.EQUALS: // Optional\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.ELLIPSIS: // Var args\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.STAR: // The AllType\n        return getNativeType(ALL_TYPE);\n\n      case Token.LB: // Array type\n        // TODO(nicksantos): Enforce membership restrictions on the Array.\n        return getNativeType(ARRAY_TYPE);\n\n      case Token.PIPE: // Union type\n        UnionTypeBuilder builder = new UnionTypeBuilder(this);\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          builder.addAlternate(\n              createFromTypeNodesInternal(child, sourceName, scope));\n        }\n        return builder.build();\n\n      case Token.EMPTY: // When the return value of a function is not specified\n        return getNativeType(UNKNOWN_TYPE);\n\n      case Token.VOID: // Only allowed in the return value of a function.\n        return getNativeType(VOID_TYPE);\n\n      case Token.STRING:\n        JSType namedType = getType(scope, n.getString(), sourceName,\n            n.getLineno(), n.getCharno());\n        if ((namedType instanceof ObjectType) &&\n            !(namedType instanceof NamespaceType) &&\n            !(nonNullableTypeNames.contains(n.getString()))) {\n          Node typeList = n.getFirstChild();\n          int nAllowedTypes =\n              namedType.getTemplateTypeMap().numUnfilledTemplateKeys();\n          if (typeList != null && nAllowedTypes > 0) {\n            // Templatized types.\n            ImmutableList.Builder<JSType> templateTypes =\n                ImmutableList.builder();\n\n            // Special case for Object, where Object.<X> implies Object.<?,X>.\n            if (n.getString().equals(\"Object\") &&\n                typeList.getFirstChild() == typeList.getLastChild()) {\n              templateTypes.add(getNativeType(UNKNOWN_TYPE));\n            }\n\n            int templateNodeIndex = 0;\n            for (Node templateNode : typeList.getFirstChild().siblings()) {\n              // Don't parse more templatized type nodes than the type can\n              // accommodate. This is because some existing clients have\n              // template annotations on non-templatized classes, for instance:\n              //   goog.structs.Set.<SomeType>\n              // The problem in these cases is that the previously-unparsed\n              // SomeType is not actually a valid type. To prevent these clients\n              // from seeing unknown type errors, we explicitly don't parse\n              // these types.\n              // TODO(user): Address this issue by removing bad template\n              // annotations on non-templatized classes.\n              if (++templateNodeIndex > nAllowedTypes) {\n                break;\n              }\n              templateTypes.add(createFromTypeNodesInternal(\n                  templateNode, sourceName, scope));\n            }\n            namedType = createTemplatizedType(\n                (ObjectType) namedType, templateTypes.build());\n            Preconditions.checkNotNull(namedType);\n          }\n          return createDefaultObjectUnion(namedType);\n        } else {\n          return namedType;\n        }\n\n      case Token.FUNCTION:\n        ObjectType thisType = null;\n        boolean isConstructor = false;\n        Node current = n.getFirstChild();\n        if (current.getType() == Token.THIS ||\n            current.getType() == Token.NEW) {\n          Node contextNode = current.getFirstChild();\n          thisType =\n              ObjectType.cast(\n                  createFromTypeNodesInternal(\n                      contextNode, sourceName, scope)\n                  .restrictByNotNullOrUndefined());\n          if (thisType == null) {\n            reporter.warning(\n                SimpleErrorReporter.getMessage0(\n                    current.getType() == Token.THIS ?\n                    \"msg.jsdoc.function.thisnotobject\" :\n                    \"msg.jsdoc.function.newnotobject\"),\n                sourceName,\n                contextNode.getLineno(), contextNode.getCharno());\n          }\n\n          isConstructor = current.getType() == Token.NEW;\n          current = current.getNext();\n        }\n\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n\n        if (current.getType() == Token.PARAM_LIST) {\n          for (Node arg = current.getFirstChild(); arg != null;\n               arg = arg.getNext()) {\n            if (arg.getType() == Token.ELLIPSIS) {\n              if (arg.getChildCount() == 0) {\n                paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n              } else {\n                paramBuilder.addVarArgs(\n                    createFromTypeNodesInternal(\n                        arg.getFirstChild(), sourceName, scope));\n              }\n            } else {\n              JSType type = createFromTypeNodesInternal(\n                  arg, sourceName, scope);\n              if (arg.getType() == Token.EQUALS) {\n                boolean addSuccess = paramBuilder.addOptionalParams(type);\n                if (!addSuccess) {\n                  reporter.warning(\n                      SimpleErrorReporter.getMessage0(\n                          \"msg.jsdoc.function.varargs\"),\n                      sourceName, arg.getLineno(), arg.getCharno());\n                }\n              } else {\n                paramBuilder.addRequiredParams(type);\n              }\n            }\n          }\n          current = current.getNext();\n        }\n\n        JSType returnType =\n            createFromTypeNodesInternal(current, sourceName, scope);\n\n        return new FunctionBuilder(this)\n            .withParams(paramBuilder)\n            .withReturnType(returnType)\n            .withTypeOfThis(thisType)\n            .setIsConstructor(isConstructor)\n            .build();\n    }\n\n    throw new IllegalStateException(\n        \"Unexpected node in type expression: \" + n.toString());\n  }\n",
        "begin_line": 1597,
        "end_line": 1768,
        "comment": " @see #createFromTypeNodes(Node, String, StaticScope) ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0714
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseParametersType#2061",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParametersType(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseParametersType(JsDocToken token) {\n    Node paramsType = newNode(Token.PARAM_LIST);\n    boolean isVarArgs = false;\n    Node paramType = null;\n    if (token != JsDocToken.RP) {\n      do {\n        if (paramType != null) {\n          // skip past the comma\n          next();\n          skipEOLs();\n          token = next();\n        }\n\n        if (token == JsDocToken.ELLIPSIS) {\n          // In the latest ES4 proposal, there are no type constraints allowed\n          // on variable arguments. We support the old syntax for backwards\n          // compatibility, but we should gradually tear it out.\n          skipEOLs();\n          if (match(JsDocToken.RP)) {\n            paramType = newNode(Token.ELLIPSIS);\n          } else {\n            skipEOLs();\n            if (!match(JsDocToken.LB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n            }\n\n            next();\n            skipEOLs();\n            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            skipEOLs();\n            next();\n          }\n\n          isVarArgs = true;\n        } else {\n          paramType = parseTypeExpression(token);\n          if (match(JsDocToken.EQUALS)) {\n            skipEOLs();\n            next();\n            paramType = wrapNode(Token.EQUALS, paramType);\n          }\n        }\n\n        if (paramType == null) {\n          return null;\n        }\n        paramsType.addChildToBack(paramType);\n        if (isVarArgs) {\n          break;\n        }\n      } while (match(JsDocToken.COMMA));\n    }\n\n    if (isVarArgs && match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n    }\n\n    // The right paren will be checked by parseFunctionType\n\n    return paramsType;\n  }\n",
        "begin_line": 2061,
        "end_line": 2125,
        "comment": " order-checking in two places, we just do all of it in type resolution.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0654
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getMinArguments#292",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getMinArguments()",
        "snippet": "  public int getMinArguments() {\n    // NOTE(nicksantos): There are some native functions that have optional\n    // parameters before required parameters. This algorithm finds the position\n    // of the last required parameter.\n    int i = 0;\n    int min = 0;\n    for (Node n : getParameters()) {\n      i++;\n      if (!n.isOptionalArg() && !n.isVarArgs()) {\n        min = i;\n      }\n    }\n    return min;\n  }\n",
        "begin_line": 292,
        "end_line": 305,
        "comment": " Gets the minimum number of arguments that this function requires. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.064
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseFunctionType#1967",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseFunctionType(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
        "begin_line": 1967,
        "end_line": 2037,
        "comment": "\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0635
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.typeofClassDefiningName#162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.typeofClassDefiningName(com.google.javascript.rhino.Node)",
        "snippet": "  private SubclassType typeofClassDefiningName(Node callName) {\n    // Check if the method name matches one of the class-defining methods.\n    String methodName = null;\n    if (callName.isGetProp()) {\n      methodName = callName.getLastChild().getString();\n    } else if (callName.isName()) {\n      String name = callName.getString();\n      int dollarIndex = name.lastIndexOf('$');\n      if (dollarIndex != -1) {\n        methodName = name.substring(dollarIndex + 1);\n      }\n    }\n\n    if (methodName != null) {\n      if (methodName.equals(\"inherits\")) {\n        return SubclassType.INHERITS;\n      } else if (methodName.equals(\"mixin\")) {\n        return SubclassType.MIXIN;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 162,
        "end_line": 183,
        "comment": "\n   * Determines whether the given node is a class-defining name, like\n   * \"inherits\" or \"mixin.\"\n   * @return The type of class-defining name, or null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0629
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitNew#1625",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitNew(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n",
        "begin_line": 1625,
        "end_line": 1640,
        "comment": "\n   * Visits a NEW node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0611
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.toStringHelper#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n\n        ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }\n",
        "begin_line": 225,
        "end_line": 269,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.getSlot#125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getSlot(java.lang.String)",
        "snippet": "  Property getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    PropertyMap primaryParent = getPrimaryParent();\n    if (primaryParent != null) {\n      Property prop = primaryParent.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (PropertyMap p : getSecondaryParents()) {\n      if (p != null) {\n        Property prop = p.getSlot(name);\n        if (prop != null) {\n          return prop;\n        }\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 125,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0591
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visit#495",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.CAST:\n        Node expr = n.getFirstChild();\n        JSType exprType = getJSType(expr);\n        JSType castType = getJSType(n);\n\n        // TODO(johnlenz): determine if we can limit object literals in some\n        // way.\n        if (!expr.isObjectLit()) {\n          validator.expectCanCast(t, n, castType, exprType);\n        }\n        ensureTyped(t, n, castType);\n\n        if (castType.isSubtype(exprType) || expr.isObjectLit()) {\n          expr.setJSType(castType);\n        }\n        break;\n\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        typeable = false;\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.STRING_KEY:\n        typeable = false;\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        checkPropCreation(t, left);\n        validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE: {\n        left = n.getFirstChild();\n        right = n.getLastChild();\n\n        if (left.isTypeOf()) {\n          if (right.isString()) {\n            checkTypeofString(t, right, right.getString());\n          }\n        } else if (right.isTypeOf() && left.isString()) {\n          checkTypeofString(t, left, left.getString());\n        }\n\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n\n        // We do not want to warn about explicit comparisons to VOID. People\n        // often do this if they think their type annotations screwed up.\n        //\n        // We do want to warn about cases where people compare things like\n        // (Array|null) == (Function|null)\n        // because it probably means they screwed up.\n        //\n        // This heuristic here is not perfect, but should catch cases we\n        // care about without too many false negatives.\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n\n        TernaryValue result = TernaryValue.UNKNOWN;\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n          if (n.isNE()) {\n            result = result.not();\n          }\n        } else {\n          // SHEQ or SHNE\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                  rightTypeRestricted)) {\n            result = n.getType() == Token.SHEQ ?\n                TernaryValue.FALSE : TernaryValue.TRUE;\n          }\n        }\n\n        if (result != TernaryValue.UNKNOWN) {\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right);\n        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        if (rightType.isStruct()) {\n          report(t, right, IN_USED_WITH_STRUCT);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, getJSType(left), \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n        checkPropCreation(t, n.getFirstChild());\n        // fall through\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          Node obj = n.getChildAtIndex(1);\n          if (getJSType(obj).isStruct()) {\n            report(t, obj, IN_USED_WITH_STRUCT);\n          }\n        }\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          JSType typ = getJSType(n);\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n, typ);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n",
        "begin_line": 495,
        "end_line": 876,
        "comment": "\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0589
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseNew#1212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseNew(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = unknownType;\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          backwardsInferenceFromCallSite(n, ct);\n\n          // If necessary, create a TemplatizedType wrapper around the instance\n          // type, based on the types of the constructor parameters.\n          ObjectType instanceType = ct.getInstanceType();\n          Map<TemplateType, JSType> inferredTypes =\n              inferTemplateTypesFromParameters(ct, n);\n          if (inferredTypes.isEmpty()) {\n            type = instanceType;\n          } else {\n            type = registry.createTemplatizedType(instanceType, inferredTypes);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n",
        "begin_line": 1212,
        "end_line": 1248,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0586
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectArgumentMatchesParameter#423",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectArgumentMatchesParameter(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node, int)",
        "snippet": "  void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType,\n      JSType paramType, Node callNode, int ordinal) {\n    if (!argType.isSubtype(paramType)) {\n      mismatch(t, n,\n          String.format(\"actual parameter %d of %s does not match \" +\n              \"formal parameter\", ordinal,\n              getReadableJSTypeName(callNode.getFirstChild(), false)),\n          argType, paramType);\n    }\n  }\n",
        "begin_line": 423,
        "end_line": 432,
        "comment": "\n   * Expect that the type of an argument matches the type of the parameter\n   * that it's fulfilling.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param argType The type of the argument.\n   * @param paramType The type of the parameter.\n   * @param callNode The call node, to help with the warning message.\n   * @param ordinal The argument ordinal, to help with the warning message.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitParameterList#1828",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitParameterList(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n",
        "begin_line": 1828,
        "end_line": 1862,
        "comment": "\n   * Visits the parameters of a CALL or a NEW node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.appendArgString#983",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.appendArgString(java.lang.StringBuilder, com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private void appendArgString(\n      StringBuilder b, Node p, boolean forAnnotations) {\n    if (p.isVarArgs()) {\n      appendVarArgsString(b, p.getJSType(), forAnnotations);\n    } else if (p.isOptionalArg()) {\n      appendOptionalArgString(b, p.getJSType(), forAnnotations);\n    } else {\n      b.append(p.getJSType().toStringHelper(forAnnotations));\n    }\n  }\n",
        "begin_line": 983,
        "end_line": 992,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0575
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.setIsConstructor#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.setIsConstructor(boolean)",
        "snippet": "  public FunctionBuilder setIsConstructor(boolean isConstructor) {\n    this.isConstructor = isConstructor;\n    return this;\n  }\n",
        "begin_line": 135,
        "end_line": 138,
        "comment": " Set whether this is a constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0572
        },
        "num_failing_tests": 1
    },
    {
        "name": "JsDocInfoParser.parseBasicTypeExpression#1893",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n",
        "begin_line": 1893,
        "end_line": 1919,
        "comment": "\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverse#307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverse(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.hasType()) {\n          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n        }\n        break;\n    }\n\n    return scope;\n  }\n",
        "begin_line": 307,
        "end_line": 462,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.describeFunctionBind#423",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "    @Override\n    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n      if (!n.isCall()) {\n        return null;\n      }\n\n      Node callTarget = n.getFirstChild();\n      String name = callTarget.getQualifiedName();\n      if (name != null) {\n        if (name.equals(\"Function.prototype.bind.call\")) {\n          // goog.bind(fn, self, args...);\n          Node fn = callTarget.getNext();\n          if (fn == null) {\n            return null;\n          }\n          Node thisValue = safeNext(fn);\n          Node parameters = safeNext(thisValue);\n          return new Bind(fn, thisValue, parameters);\n        }\n      }\n\n      if (callTarget.isGetProp()\n          && callTarget.getLastChild().getString().equals(\"bind\")) {\n        Node maybeFn = callTarget.getFirstChild();\n        JSType maybeFnType = maybeFn.getJSType();\n        FunctionType fnType = null;\n        if (useTypeInfo && maybeFnType != null) {\n          fnType = maybeFnType.restrictByNotNullOrUndefined()\n              .toMaybeFunctionType();\n        }\n\n        if (fnType != null || maybeFn.isFunction()) {\n          // (function(){}).bind(self, args...);\n          Node thisValue = callTarget.getNext();\n          Node parameters = safeNext(thisValue);\n          return new Bind(maybeFn, thisValue, parameters);\n        }\n      }\n\n      return null;\n    }\n",
        "begin_line": 423,
        "end_line": 463,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0556
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.describeFunctionBind#388",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  @Override\n  public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n    Bind result = super.describeFunctionBind(n, useTypeInfo);\n    if (result != null) {\n      return result;\n    }\n\n    if (!n.isCall()) {\n      return null;\n    }\n\n    Node callTarget = n.getFirstChild();\n    String name = callTarget.getQualifiedName();\n    if (name != null) {\n      if (name.equals(\"goog.bind\")\n          || name.equals(\"goog$bind\")) {\n        // goog.bind(fn, self, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = safeNext(fn);\n        Node parameters = safeNext(thisValue);\n        return new Bind(fn, thisValue, parameters);\n      }\n\n      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n        // goog.partial(fn, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = null;\n        Node parameters = safeNext(fn);\n        return new Bind(fn, thisValue, parameters);\n      }\n    }\n\n    return null;\n  }\n",
        "begin_line": 388,
        "end_line": 427,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0556
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeSafeDispatcher.process#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java",
        "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
        "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return (node instanceof EmptyExpression) ?\n            processEmptyExpression((EmptyExpression) node) :\n            processEmptyStatement((EmptyStatement) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }\n",
        "begin_line": 120,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0536
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processNewExpression#942",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processNewExpression(com.google.javascript.rhino.head.ast.NewExpression)",
        "snippet": "    @Override\n    Node processNewExpression(NewExpression exprNode) {\n      Node node = newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getTarget()));\n      for (AstNode child : exprNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n      node.setLineno(exprNode.getLineno());\n      node.setCharno(position2charno(exprNode.getAbsolutePosition()));\n      maybeSetLengthFrom(node, exprNode);\n      return node;\n    }\n",
        "begin_line": 942,
        "end_line": 954,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0536
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transformTokenType#1325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
        "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.rhino.head.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.rhino.head.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.rhino.head.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.rhino.head.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.rhino.head.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.rhino.head.Token.NE:\n        return Token.NE;\n      case com.google.javascript.rhino.head.Token.LT:\n        return Token.LT;\n      case com.google.javascript.rhino.head.Token.LE:\n        return Token.LE;\n      case com.google.javascript.rhino.head.Token.GT:\n        return Token.GT;\n      case com.google.javascript.rhino.head.Token.GE:\n        return Token.GE;\n      case com.google.javascript.rhino.head.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.rhino.head.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.rhino.head.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.rhino.head.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.rhino.head.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.rhino.head.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.rhino.head.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.rhino.head.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.rhino.head.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.rhino.head.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.rhino.head.Token.POS:\n        return Token.POS;\n      case com.google.javascript.rhino.head.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.rhino.head.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.rhino.head.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.rhino.head.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.rhino.head.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.rhino.head.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.rhino.head.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.rhino.head.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.rhino.head.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.rhino.head.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.rhino.head.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.rhino.head.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.rhino.head.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.rhino.head.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.rhino.head.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.rhino.head.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.rhino.head.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.rhino.head.Token.IN:\n        return Token.IN;\n      case com.google.javascript.rhino.head.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.rhino.head.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.rhino.head.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.rhino.head.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.rhino.head.Token.LP:\n        return Token.PARAM_LIST;\n      case com.google.javascript.rhino.head.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.rhino.head.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.rhino.head.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.rhino.head.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.rhino.head.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.rhino.head.Token.OR:\n        return Token.OR;\n      case com.google.javascript.rhino.head.Token.AND:\n        return Token.AND;\n      case com.google.javascript.rhino.head.Token.INC:\n        return Token.INC;\n      case com.google.javascript.rhino.head.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.rhino.head.Token.IF:\n        return Token.IF;\n      case com.google.javascript.rhino.head.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.rhino.head.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.rhino.head.Token.DEFAULT:\n        return Token.DEFAULT_CASE;\n      case com.google.javascript.rhino.head.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.rhino.head.Token.DO:\n        return Token.DO;\n      case com.google.javascript.rhino.head.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.rhino.head.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.rhino.head.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.rhino.head.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.rhino.head.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.rhino.head.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.rhino.head.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.rhino.head.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.rhino.head.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.rhino.head.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.rhino.head.Token.EXPR_VOID:\n      case com.google.javascript.rhino.head.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.rhino.head.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.rhino.head.Token.GET:\n        return Token.GETTER_DEF;\n      case com.google.javascript.rhino.head.Token.SET:\n        return Token.SETTER_DEF;\n      case com.google.javascript.rhino.head.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.rhino.head.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }\n",
        "begin_line": 1325,
        "end_line": 1505,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0536
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.mismatch#654",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.mismatch(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void mismatch(NodeTraversal t, Node n,\n                        String msg, JSType found, JSType required) {\n    mismatch(t.getSourceName(), n, msg, found, required);\n  }\n",
        "begin_line": 654,
        "end_line": 657,
        "comment": "\n   * Report a type mismatch\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0534
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.mismatch#664",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.mismatch(java.lang.String, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void mismatch(String sourceName, Node n,\n                        String msg, JSType found, JSType required) {\n    registerMismatch(found, required, report(\n        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n                     formatFoundRequired(msg, found, required))));\n  }\n",
        "begin_line": 664,
        "end_line": 669,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0534
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.formatFoundRequired#708",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.formatFoundRequired(java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private String formatFoundRequired(String description, JSType found,\n      JSType required) {\n    return MessageFormat.format(FOUND_REQUIRED, description, found, required);\n  }\n",
        "begin_line": 708,
        "end_line": 711,
        "comment": "\n   * Formats a found/required error message.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0534
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.findOverriddenFunction#1014",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.findOverriddenFunction(com.google.javascript.rhino.jstype.ObjectType, java.lang.String, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName, TemplateTypeMap typeMap) {\n      FunctionType result = null;\n\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType != null && propType.isFunctionType()) {\n        result =  propType.toMaybeFunctionType();\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType != null && propType.isFunctionType()) {\n            result = propType.toMaybeFunctionType();\n            break;\n          }\n        }\n      }\n\n      if (result != null && typeMap != null && !typeMap.isEmpty()) {\n        result = result.visit(\n            new TemplateTypeMapReplacer(typeRegistry, typeMap))\n            .toMaybeFunctionType();\n      }\n\n      return result;\n    }\n",
        "begin_line": 1014,
        "end_line": 1043,
        "comment": "\n     * Find the function that's being overridden on this type, if any.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.isSubtype#452",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    // unknown\n    if (that.isUnknownType()) {\n      return true;\n    }\n    // all type\n    if (that.isAllType()) {\n      return true;\n    }\n    for (JSType element : alternates) {\n      if (!element.isSubtype(that)) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 452,
        "end_line": 468,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0518
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.getSourceName#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
        "snippet": "  public String getSourceName() {\n    return sourceName;\n  }\n",
        "begin_line": 431,
        "end_line": 433,
        "comment": "\n   * Gets the current input source name.\n   *\n   * @return A string that may be empty, but not null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getCtorImplementedInterfaces#398",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorImplementedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getImplementedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n",
        "begin_line": 398,
        "end_line": 403,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0512
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isCheckedUnknownType#260",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isCheckedUnknownType()",
        "snippet": "  public boolean isCheckedUnknownType() {\n    return false;\n  }\n",
        "begin_line": 260,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0511
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.report#800",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.report(com.google.javascript.jscomp.JSError)",
        "snippet": "  private JSError report(JSError error) {\n    if (shouldReport) {\n      compiler.report(error);\n    }\n    return error;\n  }\n",
        "begin_line": 800,
        "end_line": 805,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processFunctionCall#752",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processFunctionCall(com.google.javascript.rhino.head.ast.FunctionCall)",
        "snippet": "    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      node.setLineno(node.getFirstChild().getLineno());\n      node.setCharno(node.getFirstChild().getCharno());\n      maybeSetLengthFrom(node, callNode);\n      return node;\n    }\n",
        "begin_line": 752,
        "end_line": 764,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0491
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.toStringHelper#941",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (!isPrettyPrint() ||\n        this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n      return \"Function\";\n    }\n\n    setPrettyPrint(false);\n\n    StringBuilder b = new StringBuilder(32);\n    b.append(\"function (\");\n    int paramNum = call.parameters.getChildCount();\n    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);\n    if (hasKnownTypeOfThis) {\n      if (isConstructor()) {\n        b.append(\"new:\");\n      } else {\n        b.append(\"this:\");\n      }\n      b.append(typeOfThis.toStringHelper(forAnnotations));\n    }\n    if (paramNum > 0) {\n      if (hasKnownTypeOfThis) {\n        b.append(\", \");\n      }\n      Node p = call.parameters.getFirstChild();\n      appendArgString(b, p, forAnnotations);\n\n      p = p.getNext();\n      while (p != null) {\n        b.append(\", \");\n        appendArgString(b, p, forAnnotations);\n        p = p.getNext();\n      }\n    }\n    b.append(\"): \");\n    b.append(call.returnType.toStringHelper(forAnnotations));\n\n    setPrettyPrint(true);\n    return b.toString();\n  }\n",
        "begin_line": 941,
        "end_line": 981,
        "comment": "\n   * Informally, a function is represented by\n   * {@code function (params): returnType} where the {@code params} is a comma\n   * separated list of types, the first one being a special\n   * {@code this:T} if the function expects a known type for {@code this}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0486
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getPropertyType#421",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getPropertyType(java.lang.String)",
        "snippet": "  public JSType getPropertyType(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    if (slot == null) {\n      if (isNoResolvedType() || isCheckedUnknownType()) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n      } else if (isEmptyType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }\n",
        "begin_line": 421,
        "end_line": 432,
        "comment": "\n   * Gets the property type of the property whose name is given. If the\n   * underlying object does not have this property, the Unknown type is\n   * returned to indicate that no information is available on this property.\n   *\n   * This gets overridden by FunctionType for lazily-resolved call() and\n   * bind() functions.\n   *\n   * @return the property's type or {@link UnknownType}. This method never\n   *         returns {@code null}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0483
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getRValueOfLValue#3142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getRValueOfLValue(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getRValueOfLValue(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.ASSIGN:\n        return n.getNext();\n      case Token.VAR:\n        return n.getFirstChild();\n      case Token.FUNCTION:\n        return parent;\n    }\n    return null;\n  }\n",
        "begin_line": 3142,
        "end_line": 3153,
        "comment": " Gets the r-value of a node returned by getBestLValue. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0475
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitCall#1771",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitCall(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    // A couple of types can be called as if they were functions.\n    // If it is a function type, then validate parameters.\n    if (childType.isFunctionType()) {\n      FunctionType functionType = childType.toMaybeFunctionType();\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if (functionJSDocInfo != null  &&\n          functionJSDocInfo.getAssociatedNode() != null) {\n        isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns();\n      }\n\n      // Non-native constructors should not be called directly\n      // unless they specify a return type and are defined\n      // in an extern.\n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType())) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      // Functions with explicit 'this' types must be called in a GETPROP\n      // or GETELEM.\n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !(functionType.getTypeOfThis().toObjectType() != null &&\n          functionType.getTypeOfThis().toObjectType().isNativeObjectType()) &&\n          !(child.isGetElem() ||\n            child.isGetProp())) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    // TODO(nicksantos): Add something to check for calls of RegExp objects,\n    // which is not supported by IE. Either say something about the return type\n    // or warn about the non-portability of the call or both.\n  }\n",
        "begin_line": 1771,
        "end_line": 1823,
        "comment": "\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0467
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.canBeCalled#260",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.canBeCalled()",
        "snippet": "  @Override\n  public boolean canBeCalled() {\n    return true;\n  }\n",
        "begin_line": 260,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0466
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseCall#867",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseCall(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseCall(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node left = n.getFirstChild();\n    JSType functionType = getJSType(left).restrictByNotNullOrUndefined();\n    if (functionType.isFunctionType()) {\n      FunctionType fnType = functionType.toMaybeFunctionType();\n      n.setJSType(fnType.getReturnType());\n      backwardsInferenceFromCallSite(n, fnType);\n    } else if (functionType.isEquivalentTo(\n        getNativeType(CHECKED_UNKNOWN_TYPE))) {\n      n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    }\n\n    scope = tightenTypesAfterAssertions(scope, n);\n    return scope;\n  }\n",
        "begin_line": 867,
        "end_line": 883,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0459
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.toStringHelper#434",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.toStringHelper(boolean)",
        "snippet": "  @Override String toStringHelper(boolean forAnnotations) {\n    StringBuilder result = new StringBuilder();\n    boolean firstAlternate = true;\n\n    result.append(\"(\");\n    SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA);\n    sorted.addAll(alternates);\n    for (JSType t : sorted) {\n      if (!firstAlternate) {\n        result.append(\"|\");\n      }\n      result.append(t.toStringHelper(forAnnotations));\n      firstAlternate = false;\n    }\n    result.append(\")\");\n    return result.toString();\n  }\n",
        "begin_line": 434,
        "end_line": 450,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0446
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.compare#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.Anonymous-56f2b532-d29a-4739-afa0-186cd5ff0d25.compare(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    @Override\n    public int compare(JSType t1, JSType t2) {\n      return t1.toString().compareTo(t2.toString());\n    }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0446
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitVar#1591",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitVar(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n",
        "begin_line": 1591,
        "end_line": 1620,
        "comment": "\n   * Visits a VAR node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0446
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.matchConstraint#1444",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.matchConstraint(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public void matchConstraint(JSType constraint) {}\n",
        "begin_line": 1444,
        "end_line": 1444,
        "comment": "\n   * Modify this type so that it matches the specified type.\n   *\n   * This is useful for reverse type-inference, where we want to\n   * infer that an object literal matches its constraint (much like\n   * how the java compiler does reverse-inference to figure out generics).\n   * @param constraint\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.tightenTypesAfterAssertions#885",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.tightenTypesAfterAssertions(com.google.javascript.jscomp.type.FlowScope, com.google.javascript.rhino.Node)",
        "snippet": "  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n      Node callNode) {\n    Node left = callNode.getFirstChild();\n    Node firstParam = left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec =\n        assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec == null || firstParam == null) {\n      return scope;\n    }\n    Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode == null) {\n      return scope;\n    }\n    JSType assertedType = assertionFunctionSpec.getAssertedType(\n        callNode, registry);\n    String assertedNodeName = assertedNode.getQualifiedName();\n\n    JSType narrowed;\n    // Handle assertions that enforce expressions evaluate to true.\n    if (assertedType == null) {\n      // Handle arbitrary expressions within the assert.\n      scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n          assertedNode, scope, true);\n      // Build the result of the assertExpression\n      narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined();\n    } else {\n      // Handle assertions that enforce expressions are of a certain type.\n      JSType type = getJSType(assertedNode);\n      narrowed = type.getGreatestSubtype(assertedType);\n      if (assertedNodeName != null && type.differsFrom(narrowed)) {\n        scope = narrowScope(scope, assertedNode, narrowed);\n      }\n    }\n\n    callNode.setJSType(narrowed);\n    return scope;\n  }\n",
        "begin_line": 885,
        "end_line": 921,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0436
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoObjectType.getImplicitPrototype#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0434
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.getObjectLiteralCast#326",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getObjectLiteralCast(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n    Preconditions.checkArgument(callNode.isCall());\n    ObjectLiteralCast proxyCast = super.getObjectLiteralCast(callNode);\n    if (proxyCast != null) {\n      return proxyCast;\n    }\n\n    Node callName = callNode.getFirstChild();\n    if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n        callNode.getChildCount() != 3) {\n      return null;\n    }\n\n    Node typeNode = callName.getNext();\n    if (!typeNode.isQualifiedName()) {\n      return null;\n    }\n\n    Node objectNode = typeNode.getNext();\n    if (!objectNode.isObjectLit()) {\n      return new ObjectLiteralCast(null, null, OBJECTLIT_EXPECTED);\n    }\n\n    return new ObjectLiteralCast(\n        typeNode.getQualifiedName(), typeNode.getNext(), null);\n  }\n",
        "begin_line": 326,
        "end_line": 352,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0431
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getDelegateRelationship#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getDelegateRelationship(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public DelegateRelationship getDelegateRelationship(Node callNode) {\n      return nextConvention.getDelegateRelationship(callNode);\n    }\n",
        "begin_line": 167,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.checkForCallingConventionDefiningCalls#187",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.checkForCallingConventionDefiningCalls(com.google.javascript.rhino.Node, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void checkForCallingConventionDefiningCalls(\n        Node n, Map<String, String> delegateCallingConventions) {\n      nextConvention.checkForCallingConventionDefiningCalls(\n          n, delegateCallingConventions);\n    }\n",
        "begin_line": 187,
        "end_line": 192,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getObjectLiteralCast#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getObjectLiteralCast(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n      return nextConvention.getObjectLiteralCast(callNode);\n    }\n",
        "begin_line": 233,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#514",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      attachLiteralTypes(n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n);\n          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // Hoisted functions are handled during pre-traversal.\n          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n            defineFunctionLiteral(n);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.isGetProp() &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n);\n          break;\n\n        case Token.VAR:\n          defineVar(n);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.isExprResult() &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n\n      // Analyze any @lends object literals in this statement.\n      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n          lentObjectLiterals != null) {\n        for (Node objLit : lentObjectLiterals) {\n          defineObjectLiteral(objLit);\n        }\n        lentObjectLiterals.clear();\n      }\n    }\n",
        "begin_line": 514,
        "end_line": 571,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.checkForCallingConventionDefiningCalls#1402",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.checkForCallingConventionDefiningCalls(com.google.javascript.rhino.Node, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    private void checkForCallingConventionDefiningCalls(\n        Node n, Map<String, String> delegateCallingConventions) {\n      codingConvention.checkForCallingConventionDefiningCalls(n,\n          delegateCallingConventions);\n    }\n",
        "begin_line": 1402,
        "end_line": 1406,
        "comment": "\n     * Look for calls that set a delegate method's calling convention.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.checkForClassDefiningCalls#1413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.checkForClassDefiningCalls(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "    private void checkForClassDefiningCalls(NodeTraversal t, Node n) {\n      SubclassRelationship relationship =\n          codingConvention.getClassesDefinedByCall(n);\n      if (relationship != null) {\n        FunctionType superCtor = getFunctionType(\n            scope.getVar(relationship.superclassName));\n        FunctionType subCtor = getFunctionType(\n            scope.getVar(relationship.subclassName));\n        if (superCtor != null && superCtor.isConstructor() &&\n            subCtor != null && subCtor.isConstructor()) {\n          ObjectType superClass = superCtor.getInstanceType();\n          ObjectType subClass = subCtor.getInstanceType();\n\n          // superCtor and subCtor might be structural constructors\n          // (like {function(new:Object)}) so we need to resolve them back\n          // to the original ctor objects.\n          superCtor = superClass.getConstructor();\n          subCtor = subClass.getConstructor();\n\n          if (relationship.type == SubclassType.INHERITS &&\n              !superClass.isEmptyType() && !subClass.isEmptyType()) {\n            validator.expectSuperType(t, n, superClass, subClass);\n          }\n\n          if (superCtor != null && subCtor != null) {\n            codingConvention.applySubclassRelationship(\n                superCtor, subCtor, relationship.type);\n          }\n        }\n      }\n\n      String singletonGetterClassName =\n          codingConvention.getSingletonGetterClassName(n);\n      if (singletonGetterClassName != null) {\n        ObjectType objectType = ObjectType.cast(\n            typeRegistry.getType(singletonGetterClassName));\n        if (objectType != null) {\n          FunctionType functionType = objectType.getConstructor();\n\n          if (functionType != null) {\n            FunctionType getterType =\n                typeRegistry.createFunctionType(objectType);\n            codingConvention.applySingletonGetter(functionType, getterType,\n                objectType);\n          }\n        }\n      }\n\n      DelegateRelationship delegateRelationship =\n          codingConvention.getDelegateRelationship(n);\n      if (delegateRelationship != null) {\n        applyDelegateRelationship(delegateRelationship);\n      }\n\n      ObjectLiteralCast objectLiteralCast =\n          codingConvention.getObjectLiteralCast(n);\n      if (objectLiteralCast != null) {\n        if (objectLiteralCast.diagnosticType == null) {\n          ObjectType type = ObjectType.cast(\n              typeRegistry.getType(objectLiteralCast.typeName));\n          if (type != null && type.getConstructor() != null) {\n            setDeferredType(objectLiteralCast.objectNode, type);\n            objectLiteralCast.objectNode.putBooleanProp(\n                Node.REFLECTED_OBJECT, true);\n          } else {\n            compiler.report(JSError.make(t.getSourceName(), n,\n                    CONSTRUCTOR_EXPECTED));\n          }\n        } else {\n          compiler.report(JSError.make(t.getSourceName(), n,\n                  objectLiteralCast.diagnosticType));\n        }\n      }\n    }\n",
        "begin_line": 1413,
        "end_line": 1486,
        "comment": "\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getDelegateRelationship#361",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getDelegateRelationship(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public DelegateRelationship getDelegateRelationship(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 361,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.checkForCallingConventionDefiningCalls#379",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.checkForCallingConventionDefiningCalls(com.google.javascript.rhino.Node, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void checkForCallingConventionDefiningCalls(Node n,\n        Map<String, String> delegateCallingConventions) {\n      // do nothing.\n    }\n",
        "begin_line": 379,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getObjectLiteralCast#408",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getObjectLiteralCast(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public ObjectLiteralCast getObjectLiteralCast(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 408,
        "end_line": 411,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.043
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.getClassesDefinedByCall#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n    SubclassRelationship relationship =\n        super.getClassesDefinedByCall(callNode);\n    if (relationship != null) {\n      return relationship;\n    }\n\n    Node callName = callNode.getFirstChild();\n    SubclassType type = typeofClassDefiningName(callName);\n    if (type != null) {\n      Node subclass = null;\n      Node superclass = callNode.getLastChild();\n\n      // There are six possible syntaxes for a class-defining method:\n      // SubClass.inherits(SuperClass)\n      // goog.inherits(SubClass, SuperClass)\n      // goog$inherits(SubClass, SuperClass)\n      // SubClass.mixin(SuperClass.prototype)\n      // goog.mixin(SubClass.prototype, SuperClass.prototype)\n      // goog$mixin(SubClass.prototype, SuperClass.prototype)\n      boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n          callName.isGetProp();\n      if (isDeprecatedCall) {\n        // SubClass.inherits(SuperClass)\n        subclass = callName.getFirstChild();\n      } else if (callNode.getChildCount() == 3) {\n        // goog.inherits(SubClass, SuperClass)\n        subclass = callName.getNext();\n      } else {\n        return null;\n      }\n\n      if (type == SubclassType.MIXIN) {\n        // Only consider mixins that mix two prototypes as related to\n        // inheritance.\n        if (!endsWithPrototype(superclass)) {\n          return null;\n        }\n        if (!isDeprecatedCall) {\n          if (!endsWithPrototype(subclass)) {\n            return null;\n          }\n          // Strip off the prototype from the name.\n          subclass = subclass.getFirstChild();\n        }\n        superclass = superclass.getFirstChild();\n      }\n\n      // bail out if either of the side of the \"inherits\"\n      // isn't a real class name. This prevents us from\n      // doing something weird in cases like:\n      // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)\n      if (subclass != null &&\n          subclass.isUnscopedQualifiedName() &&\n          superclass.isUnscopedQualifiedName()) {\n        return new SubclassRelationship(type, subclass, superclass);\n      }\n    }\n\n    return null;\n  }\n",
        "begin_line": 94,
        "end_line": 155,
        "comment": "\n   * {@inheritDoc}\n   *\n   * <p>Understands several different inheritance patterns that occur in\n   * Google code (various uses of {@code inherits} and {@code mixin}).\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.CodingConventions.Proxy": null
        },
        "susp": {
            "ochiai_susp": 0.0425
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.getSingletonGetterClassName#283",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public String getSingletonGetterClassName(Node callNode) {\n    Node callArg = callNode.getFirstChild();\n    String callName = callArg.getQualifiedName();\n\n    // Use both the original name and the post-CollapseProperties name.\n    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n          \"goog$addSingletonGetter\".equals(callName)) ||\n        callNode.getChildCount() != 2) {\n      return super.getSingletonGetterClassName(callNode);\n    }\n\n    return callArg.getNext().getQualifiedName();\n  }\n",
        "begin_line": 283,
        "end_line": 296,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0421
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getSingletonGetterClassName#344",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public String getSingletonGetterClassName(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 344,
        "end_line": 347,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.042
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getSingletonGetterClassName#150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public String getSingletonGetterClassName(Node callNode) {\n      return nextConvention.getSingletonGetterClassName(callNode);\n    }\n",
        "begin_line": 150,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.042
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getClassesDefinedByCall#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n      return nextConvention.getClassesDefinedByCall(callNode);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.042
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getClassesDefinedByCall#296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 296,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0419
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.CollectProperties#1804",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.CollectProperties.CollectProperties(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "      CollectProperties(JSType thisType) {\n        this.thisType = thisType;\n      }\n",
        "begin_line": 1804,
        "end_line": 1806,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#1808",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.CollectProperties.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isExprResult()) {\n          Node child = n.getFirstChild();\n          switch (child.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(child.getFirstChild(), child,\n                  child.getLastChild());\n              break;\n            case Token.GETPROP:\n              maybeCollectMember(child, child, null);\n              break;\n          }\n        }\n      }\n",
        "begin_line": 1808,
        "end_line": 1822,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.createScope#200",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      JSType globalThis =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n\n      // Mark the main root, the externs root, and the src root\n      // with the global this type.\n      root.setJSType(globalThis);\n      root.getFirstChild().setJSType(globalThis);\n      root.getLastChild().setJSType(globalThis);\n\n      // Run a first-order analysis over the syntax tree.\n      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n          .process(root.getFirstChild(), root.getLastChild());\n\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type.isFunctionType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        JSType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes,\n          delegateCallingConventions);\n    }\n\n    newScope.setTypeResolver(scopeBuilder);\n    return newScope;\n  }\n",
        "begin_line": 200,
        "end_line": 259,
        "comment": "\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getJsDocToken#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a JsDoc string but discard last . if it is followed by\n          // a non-JsDoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 57,
        "end_line": 193,
        "comment": "\n   * Tokenizes JSDoc comments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getMaxArguments#311",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getMaxArguments()",
        "snippet": "  public int getMaxArguments() {\n    Node params = getParametersNode();\n    if (params != null) {\n      Node lastParam = params.getLastChild();\n      if (lastParam == null || !lastParam.isVarArgs()) {\n        return params.getChildCount();\n      }\n    }\n\n    return Integer.MAX_VALUE;\n  }\n",
        "begin_line": 311,
        "end_line": 321,
        "comment": "\n   * Gets the maximum number of arguments that this function requires,\n   * or Integer.MAX_VALUE if this is a variable argument function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0413
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.report#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.report(com.google.javascript.jscomp.CheckLevel, com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public void report(CheckLevel level, JSError error) {\n    if (messages.add(new ErrorWithLevel(error, level))) {\n      if (level == CheckLevel.ERROR) {\n        errorCount++;\n      } else if (level == CheckLevel.WARNING) {\n        warningCount++;\n      }\n    }\n  }\n",
        "begin_line": 43,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0412
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isSubtype#1022",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      FunctionType other = that.toMaybeFunctionType();\n      if (other.isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      boolean treatThisTypesAsCovariant =\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.toObjectType() != null &&\n             other.typeOfThis.toObjectType().getConstructor() != null &&\n             other.typeOfThis.toObjectType().getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n",
        "begin_line": 1022,
        "end_line": 1062,
        "comment": "\n   * A function is a subtype of another if their call methods are related via\n   * subtyping and {@code this} is a subtype of {@code that} with regard to\n   * the prototype chain.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.041
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSError.make#113",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.make(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  public static JSError make(String sourceName, Node n,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, n, type, arguments);\n  }\n",
        "begin_line": 113,
        "end_line": 116,
        "comment": "\n   * Creates a JSError from a file and Node position.\n   *\n   * @param sourceName The source file name\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0402
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSError.JSError#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.JSError(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  private JSError(String sourceName, @Nullable Node node,\n                  DiagnosticType type, String... arguments) {\n    this(sourceName,\n         node,\n         (node != null) ? node.getLineno() : -1,\n         (node != null) ? node.getCharno() : -1,\n         type, null, arguments);\n  }\n",
        "begin_line": 169,
        "end_line": 176,
        "comment": "\n   * Creates a JSError for a source file location.  Private to avoid\n   * any entanglement with code outside of the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0402
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.inferPropertyTypesToMatchConstraint#1296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.inferPropertyTypesToMatchConstraint(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private static void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    type.matchConstraint(constraint);\n  }\n",
        "begin_line": 1296,
        "end_line": 1303,
        "comment": "\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0402
        },
        "num_failing_tests": 2
    },
    {
        "name": "SuppressDocWarningsGuard.level#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    Node node = error.node;\n    if (node != null) {\n      boolean visitedFunction = false;\n      for (Node current = node;\n           current != null;\n           current = current.getParent()) {\n        int type = current.getType();\n        JSDocInfo info = null;\n\n        if (type == Token.FUNCTION) {\n          info = NodeUtil.getBestJSDocInfo(current);\n          visitedFunction = true;\n        } else if (type == Token.SCRIPT) {\n          info = current.getJSDocInfo();\n        } else if (current.isVar() || current.isAssign()) {\n          // There's one edge case we're worried about:\n          // if the warning points to an assigment to a function, we\n          // want the suppressions on that function to apply.\n          // It's OK if we double-count some cases.\n          Node rhs = NodeUtil.getRValueOfLValue(current.getFirstChild());\n          if (rhs != null) {\n            if (rhs.isCast()) {\n              rhs = rhs.getFirstChild();\n            }\n\n            if (rhs.isFunction() && !visitedFunction) {\n              info = NodeUtil.getBestJSDocInfo(current);\n            }\n          }\n        }\n\n        if (info != null) {\n          for (String suppressor : info.getSuppressions()) {\n            WarningsGuard guard = suppressors.get(suppressor);\n\n            // Some @suppress tags are for other tools, and\n            // may not have a warnings guard.\n            if (guard != null) {\n              CheckLevel newLevel = guard.level(error);\n              if (newLevel != null) {\n                return newLevel;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 51,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.toArray#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }\n",
        "begin_line": 103,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0397
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.compare#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.LeveledJSErrorComparator.compare(com.google.javascript.jscomp.BasicErrorManager.ErrorWithLevel, com.google.javascript.jscomp.BasicErrorManager.ErrorWithLevel)",
        "snippet": "    @Override\n    public int compare(ErrorWithLevel p1, ErrorWithLevel p2) {\n      // null is the smallest value\n      if (p2 == null) {\n        if (p1 == null) {\n          return 0;\n        } else {\n          return P1_GT_P2;\n        }\n      }\n\n      // check level\n      if (p1.level != p2.level) {\n        return p2.level.compareTo(p1.level);\n      }\n\n      // sourceName comparison\n      String source1 = p1.error.sourceName;\n      String source2 = p2.error.sourceName;\n      if (source1 != null && source2 != null) {\n        int sourceCompare = source1.compareTo(source2);\n        if (sourceCompare != 0) {\n          return sourceCompare;\n        }\n      } else if (source1 == null && source2 != null) {\n        return P1_LT_P2;\n      } else if (source1 != null && source2 == null) {\n        return P1_GT_P2;\n      }\n      // lineno comparison\n      int lineno1 = p1.error.lineNumber;\n      int lineno2 = p2.error.lineNumber;\n      if (lineno1 != lineno2) {\n        return lineno1 - lineno2;\n      } else if (lineno1 < 0 && 0 <= lineno2) {\n        return P1_LT_P2;\n      } else if (0 <= lineno1 && lineno2 < 0) {\n        return P1_GT_P2;\n      }\n      // charno comparison\n      int charno1 = p1.error.getCharno();\n      int charno2 = p2.error.getCharno();\n      if (charno1 != charno2) {\n        return charno1 - charno2;\n      } else if (charno1 < 0 && 0 <= charno2) {\n        return P1_LT_P2;\n      } else if (0 <= charno1 && charno2 < 0) {\n        return P1_GT_P2;\n      }\n      // description\n      return p1.error.description.compareTo(p2.error.description);\n    }\n",
        "begin_line": 127,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0396
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSError.getCharno#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.getCharno()",
        "snippet": "  public int getCharno() {\n    return charno;\n  }\n",
        "begin_line": 213,
        "end_line": 215,
        "comment": "\n   * Get the character number.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0395
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.report#2133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.report(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n",
        "begin_line": 2133,
        "end_line": 2149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0395
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.ErrorWithLevel#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.ErrorWithLevel.ErrorWithLevel(com.google.javascript.jscomp.JSError, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "    ErrorWithLevel(JSError error, CheckLevel level) {\n      this.error = error;\n      this.level = level;\n    }\n",
        "begin_line": 185,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0395
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.updateBind#977",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.updateBind(com.google.javascript.rhino.Node)",
        "snippet": "  private void updateBind(Node n) {\n    CodingConvention.Bind bind =\n        compiler.getCodingConvention().describeFunctionBind(n, true);\n    if (bind == null) {\n      return;\n    }\n\n    FunctionType callTargetFn = getJSType(bind.target)\n        .restrictByNotNullOrUndefined().toMaybeFunctionType();\n    if (callTargetFn == null) {\n      return;\n    }\n\n    n.setJSType(\n        callTargetFn.getBindReturnType(\n            // getBindReturnType expects the 'this' argument to be included.\n            bind.getBoundParameterCount() + 1));\n  }\n",
        "begin_line": 977,
        "end_line": 994,
        "comment": "\n   * When \"bind\" is called on a function, we infer the type of the returned\n   * \"bound\" function by looking at the number of parameters in the call site.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0393
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.visit#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }\n",
        "begin_line": 131,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0392
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.annotateCalls#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.annotateCalls(com.google.javascript.rhino.Node)",
        "snippet": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n",
        "begin_line": 157,
        "end_line": 179,
        "comment": "\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0392
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSError.getDefaultLevel#241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.getDefaultLevel()",
        "snippet": "  public CheckLevel getDefaultLevel() {\n    return defaultLevel;\n  }\n",
        "begin_line": 241,
        "end_line": 243,
        "comment": " The default level, before any of the WarningsGuards are applied. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0386
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.describeFunctionBind#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "    @Override\n    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n      return nextConvention.describeFunctionBind(n, useTypeInfo);\n    }\n",
        "begin_line": 218,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0385
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getChildAtIndex#563",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getChildAtIndex(int)",
        "snippet": "  public Node getChildAtIndex(int i) {\n    Node n = first;\n    while (i > 0) {\n      n = n.next;\n      i--;\n    }\n    return n;\n  }\n",
        "begin_line": 563,
        "end_line": 570,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0382
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.getJSType#783",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.getJSType(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(user): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n",
        "begin_line": 783,
        "end_line": 794,
        "comment": "\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0375
        },
        "num_failing_tests": 1
    },
    {
        "name": "ComposeWarningsGuard.level#109",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    for (WarningsGuard guard : guards) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        if (demoteErrors && newLevel == CheckLevel.ERROR) {\n          return CheckLevel.WARNING;\n        }\n        return newLevel;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 109,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0374
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.matchConstraint#427",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.matchConstraint(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraint {{prop: (number|undefined)}}\n    // function f(constraint) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraint.isRecordType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    } else if (constraint.isUnionType()) {\n      for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {\n        if (alt.isRecordType()) {\n          matchRecordTypeConstraint(alt.toObjectType());\n        }\n      }\n    }\n  }\n",
        "begin_line": 427,
        "end_line": 452,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0374
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSError.getType#178",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.getType()",
        "snippet": "  public DiagnosticType getType() {\n    return type;\n  }\n",
        "begin_line": 178,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0364
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroupWarningsGuard.level#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    return group.matches(error) ? level : null;\n  }\n",
        "begin_line": 35,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0364
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.matches#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(com.google.javascript.jscomp.JSError)",
        "snippet": "  public boolean matches(JSError error) {\n    return matches(error.getType());\n  }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n   * Returns whether the given error's type matches a type\n   * in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0364
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.isPrettyPrint#275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPrettyPrint()",
        "snippet": "  boolean isPrettyPrint() {\n    return prettyPrint;\n  }\n",
        "begin_line": 275,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.036
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSError.JSError#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.JSError(java.lang.String, com.google.javascript.rhino.Node, int, int, com.google.javascript.jscomp.DiagnosticType, com.google.javascript.jscomp.CheckLevel, java.lang.String...)",
        "snippet": "  private JSError(\n      String sourceName, @Nullable Node node, int lineno, int charno,\n      DiagnosticType type, CheckLevel level, String... arguments) {\n    this.type = type;\n    this.node = node;\n    this.description = type.format.format(arguments);\n    this.lineNumber = lineno;\n    this.charno = charno;\n    this.sourceName = sourceName;\n    this.defaultLevel = level == null ? type.level : level;\n    this.level = level == null ? type.level : level;\n  }\n",
        "begin_line": 152,
        "end_line": 163,
        "comment": "\n   * Creates a JSError at a CheckLevel for a source file location.\n   * Private to avoid any entanglement with code outside of the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.036
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.TypeCheck#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      CheckLevel reportMissingOverride) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n        reportMissingOverride);\n  }\n",
        "begin_line": 352,
        "end_line": 358,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0351
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectCanAssignTo#403",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignTo(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, java.lang.String)",
        "snippet": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.isSubtype(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 403,
        "end_line": 410,
        "comment": "\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0346
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseName#679",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseName(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped and assigned in an inner scope, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable. That variable is assigned more than once,\n        // and we can't know which type we're getting.\n        //\n        // var t = null; function f() { (t); } doStuff(); t = {};\n        //\n        // Notice that this heuristic isn't perfect. For example, you might\n        // have:\n        //\n        // function f() { (t); } f(); var t = 3;\n        //\n        // In this case, we would infer the first reference to t as\n        // type {number}, even though it's undefined.\n        boolean nonLocalInferredSlot = false;\n        if (isInferred && syntacticScope.isLocal()) {\n          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n          if (var == maybeOuterVar &&\n              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n            nonLocalInferredSlot = true;\n          }\n        }\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n",
        "begin_line": 679,
        "end_line": 732,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0343
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.updateScopeForTypeChange#521",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.updateScopeForTypeChange(com.google.javascript.jscomp.type.FlowScope, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n",
        "begin_line": 521,
        "end_line": 564,
        "comment": "\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0334
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.newNode#1512",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int, com.google.javascript.rhino.Node)",
        "snippet": "  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1512,
        "end_line": 1514,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0328
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.buildAndRegister#662",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister()",
        "snippet": "  FunctionType buildAndRegister() {\n    if (returnType == null) {\n      // Infer return types.\n      // We need to be extremely conservative about this, because of two\n      // competing needs.\n      // 1) If we infer the return type of f too widely, then we won't be able\n      //    to assign f to other functions.\n      // 2) If we infer the return type of f too narrowly, then we won't be\n      //    able to override f in subclasses.\n      // So we only infer in cases where the user doesn't expect to write\n      // @return annotations--when it's very obvious that the function returns\n      // nothing.\n      if (!contents.mayHaveNonEmptyReturns() &&\n          !contents.mayHaveSingleThrow() &&\n          !contents.mayBeFromExterns()) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred = true;\n      }\n    }\n\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(\n          fnName, contents.getSourceNode(), classTemplateTypeNames);\n      if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(contents.getSourceNode())\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType, returnTypeInferred)\n          .withTypeOfThis(thisType)\n          .withTemplateKeys(templateTypeNames)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    if (extendedInterfaces != null) {\n      fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeNames();\n\n    return fnType;\n  }\n",
        "begin_line": 662,
        "end_line": 724,
        "comment": "\n   * Builds the function type, and puts it in the registry.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0325
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processVariableInitializer#1244",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processVariableInitializer(com.google.javascript.rhino.head.ast.VariableInitializer)",
        "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node;\n      Comment comment = initializerNode.getTarget().getJsDocNode();\n      // TODO(user): At some point, consider allowing only inline jsdocs for\n      // variable initializers\n      if (comment != null && !comment.getValue().contains(\"@\")) {\n        node = transformNodeWithInlineJsDoc(initializerNode.getTarget());\n      } else {\n        node = transform(initializerNode.getTarget());\n      }\n      if (initializerNode.getInitializer() != null) {\n        Node initalizer = transform(initializerNode.getInitializer());\n        node.addChildToBack(initalizer);\n      }\n      return node;\n    }\n",
        "begin_line": 1244,
        "end_line": 1260,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0318
        },
        "num_failing_tests": 2
    },
    {
        "name": "InputId.equals#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass() != obj.getClass()) return false;\n    return id.equals(((InputId) obj).id);\n  }\n",
        "begin_line": 64,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0318
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.getPropertiesCount#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getPropertiesCount()",
        "snippet": "  int getPropertiesCount() {\n    PropertyMap primaryParent = getPrimaryParent();\n    if (primaryParent == null) {\n      return this.properties.size();\n    }\n    Set<String> props = Sets.newHashSet();\n    collectPropertyNames(props);\n    return props.size();\n  }\n",
        "begin_line": 151,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0317
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getPropertiesCount#489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getPropertiesCount()",
        "snippet": "  public int getPropertiesCount() {\n    return getPropertyMap().getPropertiesCount();\n  }\n",
        "begin_line": 489,
        "end_line": 491,
        "comment": "\n   * Gets the number of properties of this object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0317
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferFromOverriddenFunction#249",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferFromOverriddenFunction(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.Node)",
        "snippet": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    // Propagate the template types, if they exist.\n    templateTypeNames = oldType.getTemplateTypeMap().getTemplateKeys();\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal,\n      // but make them optional.\n      while (oldParams.hasNext()) {\n        paramBuilder.newOptionalParameterFromNode(oldParams.next());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
        "begin_line": 249,
        "end_line": 310,
        "comment": "\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferParameterTypes#483",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferParameterTypes(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (arg.getJSDocInfo() != null && arg.getJSDocInfo().hasType()) {\n        parameterType =\n            arg.getJSDocInfo().getType().evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, formatFnName());\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
        "begin_line": 483,
        "end_line": 553,
        "comment": "\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.filterNoResolvedType#1016",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.filterNoResolvedType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  static JSType filterNoResolvedType(JSType type) {\n    if (type.isNoResolvedType()) {\n      // inf(UnresolvedType1, UnresolvedType2) needs to resolve\n      // to the base unresolved type, so that the relation is symmetric.\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      boolean needsFiltering = false;\n      for (JSType alt : unionType.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          needsFiltering = true;\n          break;\n        }\n      }\n\n      if (needsFiltering) {\n        UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);\n        builder.addAlternate(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));\n        for (JSType alt : unionType.getAlternates()) {\n          if (!alt.isNoResolvedType()) {\n            builder.addAlternate(alt);\n          }\n        }\n        return builder.build();\n      }\n    }\n    return type;\n  }\n",
        "begin_line": 1016,
        "end_line": 1043,
        "comment": "\n   * When computing infima, we may get a situation like\n   * inf(Type1, Type2)\n   * where both types are unresolved, so they're technically\n   * subtypes of one another.\n   *\n   * If this happens, filter them down to NoResolvedType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionParamBuilder.newParameterFromNode#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameterFromNode(com.google.javascript.rhino.Node)",
        "snippet": "  public Node newParameterFromNode(Node n) {\n    Node newParam = newParameter(n.getJSType());\n    newParam.setVarArgs(n.isVarArgs());\n    newParam.setOptionalArg(n.isOptionalArg());\n    return newParam;\n  }\n",
        "begin_line": 114,
        "end_line": 119,
        "comment": "\n   * Copies the parameter specification from the given node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.collectPropertyNames#173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.collectPropertyNames(java.util.Set<java.lang.String>)",
        "snippet": "  void collectPropertyNames(Set<String> props) {\n    for (String prop : properties.keySet()) {\n      props.add(prop);\n    }\n    PropertyMap primaryParent = getPrimaryParent();\n    if (primaryParent != null) {\n      primaryParent.collectPropertyNames(props);\n    }\n    for (PropertyMap p : getSecondaryParents()) {\n      if (p != null) {\n        p.collectPropertyNames(props);\n      }\n    }\n  }\n",
        "begin_line": 173,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.isSubGroup#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 116,
        "end_line": 123,
        "comment": "\n   * Returns whether all of the types in the given group are in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.enables#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 147,
        "end_line": 158,
        "comment": "\n   * Determines whether this guard will \"elevate\" the status of any disabled\n   * diagnostic type in the group to a warning or an error.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0316
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.caseNumberType#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.caseNumberType()",
        "snippet": "  @Override\n  public JSType caseNumberType() {\n    return getNativeType(JSTypeNative.NUMBER_TYPE);\n  }\n",
        "begin_line": 184,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0315
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.caseUnknownType#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.caseUnknownType()",
        "snippet": "  @Override\n  public JSType caseUnknownType() {\n    return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0315
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isReturnTypeInferred#327",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isReturnTypeInferred()",
        "snippet": "  public boolean isReturnTypeInferred() {\n    return call.returnTypeInferred;\n  }\n",
        "begin_line": 327,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0315
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.visit#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseUnknownType();\n  }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0314
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.coerseToThisType#140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.coerseToThisType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private JSType coerseToThisType(JSType type) {\n    return type != null ? type : registry.getNativeObjectType(\n        JSTypeNative.UNKNOWN_TYPE);\n  }\n",
        "begin_line": 140,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0314
        },
        "num_failing_tests": 2
    },
    {
        "name": "NumberType.visit#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNumberType();\n  }\n",
        "begin_line": 110,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0314
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.getNativeType#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return registry.getNativeType(nativeType);\n  }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0314
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseAnnotation#288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAnnotation(com.google.javascript.jscomp.parsing.JsDocToken, java.util.List<com.google.javascript.jscomp.parsing.JsDocInfoParser.ExtendedTypeInfo>)",
        "snippet": "  private JsDocToken parseAnnotation(JsDocToken token,\n      List<ExtendedTypeInfo> extendedTypes) {\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    String annotationName = stream.getString();\n    Annotation annotation = annotationNames.get(annotationName);\n    if (annotation == null) {\n      parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n          stream.getLineno(), stream.getCharno());\n    } else {\n      // Mark the beginning of the annotation.\n      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n      switch (annotation) {\n        case NG_INJECT:\n          if (jsdocBuilder.isNgInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordNgInject(true);\n          }\n          return eatTokensUntilEOL();\n\n        case JAGGER_INJECT:\n          if (jsdocBuilder.isJaggerInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerInject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerInject(true);\n          }\n          return eatTokensUntilEOL();\n\n        case JAGGER_MODULE:\n          if (jsdocBuilder.isJaggerModuleRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerModule.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerModule(true);\n          }\n          return eatTokensUntilEOL();\n\n        case JAGGER_PROVIDE:\n          if (jsdocBuilder.isJaggerProvideRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerProvide.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerProvide(true);\n          }\n          return eatTokensUntilEOL();\n\n        case AUTHOR:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo authorInfo = extractSingleLineBlock();\n            String author = authorInfo.string;\n\n            if (author.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addAuthor(author);\n            }\n            token = authorInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n          return token;\n\n        case CONSISTENTIDGENERATOR:\n          if (!jsdocBuilder.recordConsistentIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case STRUCT:\n          if (!jsdocBuilder.recordStruct()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case DICT:\n          if (!jsdocBuilder.recordDict()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case CONSTRUCTOR:\n          if (!jsdocBuilder.recordConstructor()) {\n            if (jsdocBuilder.isInterfaceRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatTokensUntilEOL();\n\n        case DEPRECATED:\n          if (!jsdocBuilder.recordDeprecated()) {\n            parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          // Find the reason/description, if any.\n          ExtractionInfo reasonInfo =\n              extractMultilineTextualBlock(token);\n\n          String reason = reasonInfo.string;\n\n          if (reason.length() > 0) {\n            jsdocBuilder.recordDeprecationReason(reason);\n          }\n\n          token = reasonInfo.token;\n          return token;\n\n        case INTERFACE:\n          if (!jsdocBuilder.recordInterface()) {\n            if (jsdocBuilder.isConstructorRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatTokensUntilEOL();\n\n        case DESC:\n          if (jsdocBuilder.isDescriptionRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                stream.getLineno(), stream.getCharno());\n            return eatTokensUntilEOL();\n          } else {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            jsdocBuilder.recordDescription(description);\n            token = descriptionInfo.token;\n            return token;\n          }\n\n        case FILE_OVERVIEW:\n          String fileOverview = \"\";\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo fileOverviewInfo =\n                extractMultilineTextualBlock(token,\n                    WhitespaceOption.TRIM);\n\n            fileOverview = fileOverviewInfo.string;\n\n            token = fileOverviewInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n\n          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n            parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case LICENSE:\n        case PRESERVE:\n          ExtractionInfo preserveInfo =\n              extractMultilineTextualBlock(token,\n                                           WhitespaceOption.PRESERVE);\n\n          String preserve = preserveInfo.string;\n\n          if (preserve.length() > 0) {\n            if (fileLevelJsDocBuilder != null) {\n              fileLevelJsDocBuilder.append(preserve);\n            }\n          }\n\n          token = preserveInfo.token;\n          return token;\n\n        case ENUM:\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          type = null;\n          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n          }\n\n          if (type == null) {\n            type = createJSTypeExpression(newStringNode(\"number\"));\n          }\n          if (!jsdocBuilder.recordEnumParameterType(type)) {\n            parser.addTypeWarning(\n                \"msg.jsdoc.incompat.type\", lineno, charno);\n          }\n          token = eatTokensUntilEOL(token);\n          return token;\n\n        case EXPORT:\n          if (!jsdocBuilder.recordExport()) {\n            parser.addParserWarning(\"msg.jsdoc.export\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case EXPOSE:\n          if (!jsdocBuilder.recordExpose()) {\n            parser.addParserWarning(\"msg.jsdoc.expose\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case EXTERNS:\n          if (!jsdocBuilder.recordExterns()) {\n            parser.addParserWarning(\"msg.jsdoc.externs\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case JAVA_DISPATCH:\n          if (!jsdocBuilder.recordJavaDispatch()) {\n            parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case EXTENDS:\n        case IMPLEMENTS:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          boolean matchingRc = false;\n\n          if (token == JsDocToken.LC) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (token == JsDocToken.STRING) {\n            Node typeNode = parseAndRecordTypeNameNode(\n                token, lineno, charno, matchingRc);\n\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            typeNode = wrapNode(Token.BANG, typeNode);\n            type = createJSTypeExpression(typeNode);\n\n            if (annotation == Annotation.EXTENDS) {\n              // record the extended type, check later\n              extendedTypes.add(new ExtendedTypeInfo(\n                  type, stream.getLineno(), stream.getCharno()));\n            } else {\n              Preconditions.checkState(\n                  annotation == Annotation.IMPLEMENTS);\n              if (!jsdocBuilder.recordImplementedInterface(type)) {\n                parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                    lineno, charno);\n              }\n            }\n            token = next();\n            if (matchingRc) {\n              if (token != JsDocToken.RC) {\n                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                    stream.getLineno(), stream.getCharno());\n              }\n            } else if (token != JsDocToken.EOL &&\n                token != JsDocToken.EOF && token != JsDocToken.EOC) {\n              parser.addTypeWarning(\"msg.end.annotation.expected\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n          }\n          token = eatTokensUntilEOL(token);\n          return token;\n\n        case HIDDEN:\n          if (!jsdocBuilder.recordHiddenness()) {\n            parser.addParserWarning(\"msg.jsdoc.hidden\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case LENDS:\n          skipEOLs();\n\n          matchingRc = false;\n          if (match(JsDocToken.LC)) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (match(JsDocToken.STRING)) {\n            token = next();\n            if (!jsdocBuilder.recordLends(stream.getString())) {\n              parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          if (matchingRc && !match(JsDocToken.RC)) {\n            parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case MEANING:\n          ExtractionInfo meaningInfo =\n              extractMultilineTextualBlock(token);\n          String meaning = meaningInfo.string;\n          token = meaningInfo.token;\n          if (!jsdocBuilder.recordMeaning(meaning)) {\n            parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case NO_ALIAS:\n          if (!jsdocBuilder.recordNoAlias()) {\n            parser.addParserWarning(\"msg.jsdoc.noalias\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case NO_COMPILE:\n          if (!jsdocBuilder.recordNoCompile()) {\n            parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case NO_TYPE_CHECK:\n          if (!jsdocBuilder.recordNoTypeCheck()) {\n            parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case NOT_IMPLEMENTED:\n          return eatTokensUntilEOL();\n\n        case INHERIT_DOC:\n        case OVERRIDE:\n          if (!jsdocBuilder.recordOverride()) {\n            parser.addTypeWarning(\"msg.jsdoc.override\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case THROWS:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatTokensUntilEOL();\n            }\n          }\n\n          // *Update* the token to that after the type annotation.\n          token = current();\n\n          // Save the throw type.\n          jsdocBuilder.recordThrowType(type);\n\n          // Find the throw's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            if (description.length() > 0) {\n              jsdocBuilder.recordThrowDescription(type, description);\n            }\n\n            token = descriptionInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n          return token;\n\n        case PARAM:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordParamTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatTokensUntilEOL();\n            }\n            skipEOLs();\n            token = next();\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n          }\n\n          String name = null;\n          boolean isBracketedParam = JsDocToken.LB == token;\n          if (isBracketedParam) {\n            token = next();\n          }\n\n          if (JsDocToken.STRING != token) {\n            parser.addTypeWarning(\"msg.missing.variable.name\",\n                lineno, charno);\n          } else {\n            name = stream.getString();\n\n            if (isBracketedParam) {\n              token = next();\n\n              // Throw out JsDocToolkit's \"default\" parameter\n              // annotation.  It makes no sense under our type\n              // system.\n              if (JsDocToken.EQUALS == token) {\n                token = next();\n                if (JsDocToken.STRING == token) {\n                  token = next();\n                }\n              }\n\n              if (JsDocToken.RB != token) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n              } else if (type != null) {\n                // Make the type expression optional, if it isn't\n                // already.\n                type = JSTypeExpression.makeOptionalArg(type);\n              }\n            }\n\n            // If the param name has a DOT in it, just throw it out\n            // quietly. We do not handle the JsDocToolkit method\n            // for handling properties of params.\n            if (name.indexOf('.') > -1) {\n              name = null;\n            } else if (!jsdocBuilder.recordParameter(name, type)) {\n              if (jsdocBuilder.hasParameter(name)) {\n                parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                    lineno, charno);\n              } else {\n                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                    lineno, charno);\n              }\n            }\n          }\n\n          if (name == null) {\n            token = eatTokensUntilEOL(token);\n            return token;\n          }\n\n          jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n          // Find the parameter's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo paramDescriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String paramDescription = paramDescriptionInfo.string;\n\n            if (paramDescription.length() > 0) {\n              jsdocBuilder.recordParameterDescription(name,\n                  paramDescription);\n            }\n\n            token = paramDescriptionInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n          return token;\n\n        case PRESERVE_TRY:\n          if (!jsdocBuilder.recordPreserveTry()) {\n            parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case NO_SHADOW:\n          if (!jsdocBuilder.recordNoShadow()) {\n            parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case NO_SIDE_EFFECTS:\n          if (!jsdocBuilder.recordNoSideEffects()) {\n            parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case MODIFIES:\n          token = parseModifiesTag(next());\n          return token;\n\n        case IMPLICIT_CAST:\n          if (!jsdocBuilder.recordImplicitCast()) {\n            parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case SEE:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo referenceInfo = extractSingleLineBlock();\n            String reference = referenceInfo.string;\n\n            if (reference.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addReference(reference);\n            }\n\n            token = referenceInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n          return token;\n\n        case STABLEIDGENERATOR:\n          if (!jsdocBuilder.recordStableIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case SUPPRESS:\n          token = parseSuppressTag(next());\n          return token;\n\n        case TEMPLATE: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case IDGENERATOR:\n          token = parseIdGeneratorTag(next());\n          return token;\n\n        case WIZACTION:\n          if (!jsdocBuilder.recordWizaction()) {\n            parser.addParserWarning(\"msg.jsdoc.wizaction\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatTokensUntilEOL();\n\n        case DISPOSES: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case VERSION:\n          ExtractionInfo versionInfo = extractSingleLineBlock();\n          String version = versionInfo.string;\n\n          if (version.length() == 0) {\n            parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else {\n            if (!jsdocBuilder.recordVersion(version)) {\n               parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n\n          token = versionInfo.token;\n          return token;\n\n        case CONSTANT:\n        case DEFINE:\n        case RETURN:\n        case PRIVATE:\n        case PROTECTED:\n        case PUBLIC:\n        case THIS:\n        case TYPE:\n        case TYPEDEF:\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          Node typeNode = null;\n          boolean hasType = lookAheadForTypeAnnotation();\n          boolean isAlternateTypeAnnotation =\n              (annotation == Annotation.PRIVATE ||\n               annotation == Annotation.PROTECTED ||\n               annotation == Annotation.PUBLIC ||\n               annotation == Annotation.CONSTANT);\n          boolean canSkipTypeAnnotation =\n              (isAlternateTypeAnnotation ||\n               annotation == Annotation.RETURN);\n          type = null;\n          if (hasType || !canSkipTypeAnnotation) {\n            skipEOLs();\n            token = next();\n            typeNode = parseAndRecordTypeNode(token);\n\n            if (annotation == Annotation.THIS) {\n              typeNode = wrapNode(Token.BANG, typeNode);\n            }\n            type = createJSTypeExpression(typeNode);\n          }\n\n          // The error was reported during recursive descent\n          // recovering parsing\n          boolean hasError = type == null && !canSkipTypeAnnotation;\n          if (!hasError) {\n            // Record types for @type.\n            // If the @private, @protected, or @public annotations\n            // have a type attached, pretend that they actually wrote:\n            // @type {type}\\n@private\n            // This will have some weird behavior in some cases\n            // (for example, @private can now be used as a type-cast),\n            // but should be mostly OK.\n            if ((type != null && isAlternateTypeAnnotation)\n                || annotation == Annotation.TYPE) {\n              if (!jsdocBuilder.recordType(type)) {\n                parser.addTypeWarning(\n                    \"msg.jsdoc.incompat.type\", lineno, charno);\n              }\n            }\n\n            switch (annotation) {\n              case CONSTANT:\n                if (!jsdocBuilder.recordConstancy()) {\n                  parser.addParserWarning(\"msg.jsdoc.const\",\n                      stream.getLineno(), stream.getCharno());\n                }\n                break;\n\n              case DEFINE:\n                if (!jsdocBuilder.recordDefineType(type)) {\n                  parser.addParserWarning(\"msg.jsdoc.define\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PRIVATE:\n                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.private\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PROTECTED:\n                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.protected\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PUBLIC:\n                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.public\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case RETURN:\n                if (type == null) {\n                  type = createJSTypeExpression(newNode(Token.QMARK));\n                }\n\n                if (!jsdocBuilder.recordReturnType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                  break;\n                }\n\n                // Find the return's description (if applicable).\n                if (jsdocBuilder.shouldParseDocumentation()) {\n                  ExtractionInfo returnDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String returnDescription =\n                      returnDescriptionInfo.string;\n\n                  if (returnDescription.length() > 0) {\n                    jsdocBuilder.recordReturnDescription(\n                        returnDescription);\n                  }\n\n                  token = returnDescriptionInfo.token;\n                } else {\n                  token = eatTokensUntilEOL(token);\n                }\n                return token;\n\n              case THIS:\n                if (!jsdocBuilder.recordThisType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n\n              case TYPEDEF:\n                if (!jsdocBuilder.recordTypedef(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n            }\n          }\n\n          return eatTokensUntilEOL();\n      }\n    }\n\n    return next();\n  }\n",
        "begin_line": 288,
        "end_line": 1062,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0314
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.isNativeFunctionType#231",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.isNativeFunctionType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private boolean isNativeFunctionType(FunctionType type) {\n    return type.isNativeObjectType();\n  }\n",
        "begin_line": 231,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0313
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.visit#1064",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseFunctionType(this);\n  }\n",
        "begin_line": 1064,
        "end_line": 1067,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0312
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.checkFunctionEquivalenceHelper#903",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.checkFunctionEquivalenceHelper(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean checkFunctionEquivalenceHelper(\n      FunctionType that, EquivalenceMethod eqMethod) {\n    if (isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (isInterface()) {\n      if (that.isInterface()) {\n        return getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n\n    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod) &&\n        call.checkArrowEquivalenceHelper(that.call, eqMethod);\n  }\n",
        "begin_line": 903,
        "end_line": 923,
        "comment": "\n   * Two function types are equal if their signatures match. Since they don't\n   * have signatures, two interfaces are equal if their names match.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0311
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getDeclaredTypeInAnnotation#708",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getDeclaredTypeInAnnotation(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private JSType getDeclaredTypeInAnnotation(Node node, JSDocInfo info) {\n      JSType jsType = null;\n      if (info != null) {\n        if (info.hasType()) {\n\n          ImmutableList<TemplateType> ownerTypeKeys = ImmutableList.of();\n          Node ownerNode = NodeUtil.getBestLValueOwner(node);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            Var ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = getPrototypeOwnerType(\n                  ObjectType.cast(ownerVar.getType()));\n              if (ownerType != null) {\n                ownerTypeKeys =\n                    ownerType.getTemplateTypeMap().getTemplateKeys();\n              }\n            }\n          }\n\n          if (!ownerTypeKeys.isEmpty()) {\n            typeRegistry.setTemplateTypeNames(ownerTypeKeys);\n          }\n\n          jsType = info.getType().evaluate(scope, typeRegistry);\n\n          if (!ownerTypeKeys.isEmpty()) {\n            typeRegistry.clearTemplateTypeNames();\n          }\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }\n",
        "begin_line": 708,
        "end_line": 745,
        "comment": "\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.031
        },
        "num_failing_tests": 2
    },
    {
        "name": "NumberType.autoboxesTo#115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.autoboxesTo()",
        "snippet": "  @Override\n  public JSType autoboxesTo() {\n    return getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE);\n  }\n",
        "begin_line": 115,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0309
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.isVarArgsParameter#573",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isVarArgsParameter(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private boolean isVarArgsParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isVarArgsParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isVarArgs();\n  }\n",
        "begin_line": 573,
        "end_line": 582,
        "comment": "\n   * Determine whether this is a var args parameter.\n   * @return Whether the given param is a var args param.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0309
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getThisType#1176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getThisType()",
        "snippet": "  public JSTypeExpression getThisType() {\n    return thisType;\n  }\n",
        "begin_line": 1176,
        "end_line": 1178,
        "comment": "\n   * Gets the type specified by the {@code @this} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0308
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferThisType#450",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info) {\n    JSType maybeThisType = null;\n    if (info != null && info.hasThisType()) {\n      // TODO(johnlenz): In ES5 strict mode a function can have a null or\n      // undefined \"this\" value, but all the existing \"@this\" annotations\n      // don't declare restricted types.\n      maybeThisType = info.getThisType().evaluate(scope, typeRegistry)\n          .restrictByNotNullOrUndefined();\n    }\n    if (maybeThisType != null) {\n      thisType = maybeThisType;\n    }\n\n    return this;\n  }\n",
        "begin_line": 450,
        "end_line": 464,
        "comment": "\n   * Infers the type of {@code this}.\n   * @param info The JSDocInfo for this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0308
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferTemplateTypeName#587",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferTemplateTypeName(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  FunctionTypeBuilder inferTemplateTypeName(\n      @Nullable JSDocInfo info, JSType ownerType) {\n    // NOTE: these template type names may override a list\n    // of inherited ones from an overridden function.\n    if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n      ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n      for (String key : info.getTemplateTypeNames()) {\n        builder.add(typeRegistry.createTemplateType(key));\n      }\n      templateTypeNames = builder.build();\n    }\n\n    ImmutableList<TemplateType> keys = templateTypeNames;\n    if (ownerType != null) {\n      ImmutableList<TemplateType> ownerTypeKeys =\n          ownerType.getTemplateTypeMap().getTemplateKeys();\n      if (!ownerTypeKeys.isEmpty()) {\n        ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n        builder.addAll(templateTypeNames);\n        builder.addAll(ownerTypeKeys);\n        keys = builder.build();\n      }\n    }\n\n    if (!keys.isEmpty()) {\n      typeRegistry.setTemplateTypeNames(keys);\n    }\n    return this;\n  }\n",
        "begin_line": 587,
        "end_line": 615,
        "comment": "\n   * Infer the template type from the doc info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0308
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.hasEqualParameters#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.hasEqualParameters(com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n                otherParamType, eqMethod)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n\n      // Check var_args/optionality\n      if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {\n        return false;\n      }\n\n      if (thisParam.isVarArgs() != otherParam.isVarArgs()) {\n        return false;\n      }\n\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }\n",
        "begin_line": 177,
        "end_line": 211,
        "comment": "\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.isSubtype#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.isSubtype(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.jstype.RecordType)",
        "snippet": "  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.getOwnPropertyNames()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (typeA.isPropertyTypeDeclared(property)) {\n        // If one declared property isn't invariant,\n        // then the whole record isn't covariant.\n        if (!propA.isInvariant(propB)) {\n          return false;\n        }\n      } else {\n        // If one inferred property isn't a subtype,\n        // then the whole record isn't covariant.\n        if (!propA.isSubtype(propB)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n",
        "begin_line": 233,
        "end_line": 274,
        "comment": " Determines if typeA is a subtype of typeB ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isInvariant#550",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isInvariant(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public final boolean isInvariant(JSType that) {\n    return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);\n  }\n",
        "begin_line": 550,
        "end_line": 552,
        "comment": "\n   * Checks if two types are invariant.\n   * @see EquivalenceMethod\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.finishConstructorDefinition#1262",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.finishConstructorDefinition(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.CompilerInput, com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n      if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }\n",
        "begin_line": 1262,
        "end_line": 1306,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.isSubtype#210",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Top of the record types is the empty record, or OBJECT_TYPE.\n    if (registry.getNativeObjectType(\n            JSTypeNative.OBJECT_TYPE).isSubtype(that)) {\n      return true;\n    }\n\n    // A type is a subtype of a record type if it itself is a record\n    // type and it has at least the same members as the parent record type\n    // with the same types.\n    if (!that.isRecordType()) {\n      return false;\n    }\n\n    return RecordType.isSubtype(this, that.toMaybeRecordType());\n  }\n",
        "begin_line": 210,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getName#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getName()",
        "snippet": "  @Override\n      public String getName() {\n    return name;\n  }\n",
        "begin_line": 87,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.hasEqualCallType#930",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasEqualCallType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(\n        otherType.call, EquivalenceMethod.IDENTITY);\n  }\n",
        "begin_line": 930,
        "end_line": 933,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setSource#1117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setSource(com.google.javascript.rhino.Node)",
        "snippet": "  public void setSource(Node source) {\n    if (prototypeSlot != null) {\n      // NOTE(bashir): On one hand when source is null we want to drop any\n      // references to old nodes retained in prototypeSlot. On the other hand\n      // we cannot simply drop prototypeSlot, so we retain all information\n      // except the propertyNode for which we use an approximation! These\n      // details mostly matter in hot-swap passes.\n      if (source == null || prototypeSlot.getNode() == null) {\n        prototypeSlot = new Property(prototypeSlot.getName(),\n            prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source);\n      }\n    }\n    this.source = source;\n  }\n",
        "begin_line": 1117,
        "end_line": 1130,
        "comment": "\n   * Sets the source node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.isOptionalParameter#558",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isOptionalParameter(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private boolean isOptionalParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isOptionalParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isOptionalArg();\n  }\n",
        "begin_line": 558,
        "end_line": 567,
        "comment": "\n   * @return Whether the given param is an optional param.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.getOrCreateConstructor#746",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getOrCreateConstructor()",
        "snippet": "  private FunctionType getOrCreateConstructor() {\n    FunctionType fnType = typeRegistry.createConstructorType(\n        fnName, contents.getSourceNode(), parametersNode, returnType,\n        classTemplateTypeNames);\n    JSType existingType = typeRegistry.getType(fnName);\n\n    if (makesStructs) {\n      fnType.setStruct();\n    } else if (makesDicts) {\n      fnType.setDict();\n    }\n    if (existingType != null) {\n      boolean isInstanceObject = existingType.isInstanceType();\n      if (isInstanceObject || fnName.equals(\"Function\")) {\n        FunctionType existingFn =\n            isInstanceObject ?\n            existingType.toObjectType().getConstructor() :\n            typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n\n        if (existingFn.getSource() == null) {\n          existingFn.setSource(contents.getSourceNode());\n        }\n\n        if (!existingFn.hasEqualCallType(fnType)) {\n          reportWarning(TYPE_REDEFINITION, formatFnName(),\n              fnType.toString(), existingFn.toString());\n        }\n\n        return existingFn;\n      } else {\n        // We fall through and return the created type, even though it will fail\n        // to register. We have no choice as we have to return a function. We\n        // issue an error elsewhere though, so the user should fix it.\n      }\n    }\n\n    maybeSetBaseType(fnType);\n\n    if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n      typeRegistry.declareType(fnName, fnType.getInstanceType());\n    }\n    return fnType;\n  }\n",
        "begin_line": 746,
        "end_line": 788,
        "comment": "\n   * Returns a constructor function either by returning it from the\n   * registry if it exists or creating and registering a new type. If\n   * there is already a type, then warn if the existing type is\n   * different than the one we are creating, though still return the\n   * existing function if possible.  The primary purpose of this is\n   * that registering a constructor will fail for all built-in types\n   * that are initialized in {@link JSTypeRegistry}.  We a) want to\n   * make sure that the type information specified in the externs file\n   * matches what is in the registry and b) annotate the externs with\n   * the {@link JSType} from the registry so that there are not two\n   * separate JSType objects for one type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0307
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.toMaybeRecordType#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.toMaybeRecordType()",
        "snippet": "  @Override\n  RecordType toMaybeRecordType() {\n    return this;\n  }\n",
        "begin_line": 205,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.isSubtype#316",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    } else if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return thatObj != null && isImplicitPrototype(thatObj);\n  }\n",
        "begin_line": 316,
        "end_line": 363,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.hasAnyTemplateTypesInternal#321",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.hasAnyTemplateTypesInternal()",
        "snippet": "  boolean hasAnyTemplateTypesInternal() {\n    for (JSType templateValue : templateValues) {\n      if (templateValue.hasAnyTemplateTypes()) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 321,
        "end_line": 328,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.addAlternate#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate.isUnionType()) {\n        UnionType union = alternate.toMaybeUnionType();\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Function types are special, because they have their\n        // own bizarre sub-lattice. See the comments on\n        // FunctionType#supAndInf helper and above at functionTypePosition.\n        if (alternate.isFunctionType() && functionTypePosition != -1) {\n          // See the comments on functionTypePosition above.\n          FunctionType other =\n              alternates.get(functionTypePosition).toMaybeFunctionType();\n          FunctionType supremum =\n              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n          alternates.set(functionTypePosition, supremum);\n          result = null;\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        int currentIndex = 0;\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          boolean removeCurrent = false;\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType() ||\n              alternate.hasAnyTemplateTypes() ||\n              current.hasAnyTemplateTypes()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n\n            // Because \"Foo\" and \"Foo.<?>\" are roughly equivalent\n            // templatized types, special care is needed when building the\n            // union. For example:\n            //   Object is consider a subtype of Object.<string>\n            // but we want to leave \"Object\" not \"Object.<string>\" when\n            // building the subtype.\n            //\n\n            if (alternate.isTemplatizedType() || current.isTemplatizedType()) {\n              // Cases:\n              // 1) alternate:Array.<string> and current:Object ==> Object\n              // 2) alternate:Array.<string> and current:Array ==> Array\n              // 3) alternate:Object.<string> and\n              //    current:Array ==> Array|Object.<string>\n              // 4) alternate:Object and current:Array.<string> ==> Object\n              // 5) alternate:Array and current:Array.<string> ==> Array\n              // 6) alternate:Array and\n              //    current:Object.<string> ==> Array|Object.<string>\n              // 7) alternate:Array.<string> and\n              //    current:Array.<number> ==> Array.<?>\n              // 8) alternate:Array.<string> and\n              //    current:Array.<string> ==> Array.<string>\n              // 9) alternate:Array.<string> and\n              //    current:Object.<string> ==> Object.<string>|Array.<string>\n\n              if (!current.isTemplatizedType()) {\n                if (alternate.isSubtype(current)) {\n                  // case 1, 2\n                  return this;\n                }\n                // case 3: leave current, add alternate\n              } else if (!alternate.isTemplatizedType()) {\n                if (current.isSubtype(alternate)) {\n                  // case 4, 5\n                  removeCurrent = true;\n                }\n                // case 6: leave current, add alternate\n              } else {\n                Preconditions.checkState(current.isTemplatizedType()\n                    && alternate.isTemplatizedType());\n                TemplatizedType templatizedAlternate = alternate.toMaybeTemplatizedType();\n                TemplatizedType templatizedCurrent = current.toMaybeTemplatizedType();\n\n                if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n                  if (alternate.getTemplateTypeMap().checkEquivalenceHelper(\n                      current.getTemplateTypeMap(),\n                      EquivalenceMethod.IDENTITY)) {\n                    // case 8\n                    return this;\n                  } else {\n                    // TODO(johnlenz): should we leave both types?\n                    // case 7: add a merged alternate\n                    // We currently merge to the templatized types to \"unknown\"\n                    // which is equivalent to the raw type.\n                    JSType merged = templatizedCurrent\n                        .getReferencedObjTypeInternal();\n                    return addAlternate(merged);\n                  }\n                }\n                // case 9: leave current, add alternate\n              }\n              // Otherwise leave both templatized types.\n            } else if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              removeCurrent = true;\n            }\n          }\n\n          if (removeCurrent) {\n            it.remove();\n\n            if (currentIndex == functionTypePosition) {\n              functionTypePosition = -1;\n            } else if (currentIndex < functionTypePosition) {\n              functionTypePosition--;\n              currentIndex--;\n            }\n          }\n          currentIndex++;\n        }\n\n        if (alternate.isFunctionType()) {\n          // See the comments on functionTypePosition above.\n          Preconditions.checkState(functionTypePosition == -1);\n          functionTypePosition = alternates.size();\n        }\n\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }\n",
        "begin_line": 120,
        "end_line": 281,
        "comment": "\n   * Adds an alternate to the union type under construction. Returns this\n   * for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.RecordProperty#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty.RecordProperty(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "    RecordProperty(JSType type, Node propertyNode) {\n      this.type = type;\n      this.propertyNode = propertyNode;\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.getType#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty.getType()",
        "snippet": "    public JSType getType() {\n      return type;\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.getPropertyNode#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty.getPropertyNode()",
        "snippet": "    public Node getPropertyNode() {\n      return propertyNode;\n    }\n",
        "begin_line": 112,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.RecordTypeBuilder#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordTypeBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public RecordTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.addProperty#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.addProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public RecordTypeBuilder addProperty(String name, JSType type, Node\n      propertyNode) {\n    isEmpty = false;\n    if (properties.containsKey(name)) {\n      return null;\n    }\n    properties.put(name, new RecordProperty(type, propertyNode));\n    return this;\n  }\n",
        "begin_line": 75,
        "end_line": 83,
        "comment": "\n   * Adds a property with the given name and type to the record type.\n   * @param name the name of the new property\n   * @param type the JSType of the new property\n   * @param propertyNode the node that holds this property definition\n   * @return The builder itself for chaining purposes, or null if there's\n   *          a duplicate.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordTypeBuilder.build#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.build()",
        "snippet": "  public JSType build() {\n     // If we have an empty record, simply return the object type.\n    if (isEmpty) {\n       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    }\n\n    return new RecordType(\n        registry, Collections.unmodifiableMap(properties), isDeclared);\n  }\n",
        "begin_line": 89,
        "end_line": 97,
        "comment": "\n   * Creates a record.\n   * @return The record type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.RecordType#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.RecordType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.util.Map<java.lang.String, com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty>, boolean)",
        "snippet": "  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties,\n      boolean declared) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n    this.declared = declared;\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n      if (declared) {\n        defineDeclaredProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      } else {\n        defineSynthesizedProperty(\n            property, prop.getType(), prop.getPropertyNode());\n      }\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }\n",
        "begin_line": 83,
        "end_line": 106,
        "comment": "\n   * Creates a record type.\n   *\n   * @param registry The type registry under which this type lives.\n   * @param properties A map of all the properties of this record type.\n   * @param declared Whether this is a declared or synthesized type.\n   *     A synthesized record type is just used for bookkeeping\n   *     in the type system. A declared record type was actually used in the\n   *     user's program.\n   * @throws IllegalStateException if the {@code RecordProperty} associated\n   *         with a property is null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.getImplicitPrototype#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n  }\n",
        "begin_line": 129,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "RecordType.defineProperty#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/RecordType.java",
        "class_name": "com.google.javascript.rhino.jstype.RecordType",
        "signature": "com.google.javascript.rhino.jstype.RecordType.defineProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (isFrozen) {\n      return false;\n    }\n\n    return super.defineProperty(propertyName, type, inferred,\n        propertyNode);\n  }\n",
        "begin_line": 134,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createRecordTypeFromNodes#1776",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createRecordTypeFromNodes(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private JSType createRecordTypeFromNodes(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n\n    RecordTypeBuilder builder = new RecordTypeBuilder(this);\n\n    // For each of the fields in the record type.\n    for (Node fieldTypeNode = n.getFirstChild();\n         fieldTypeNode != null;\n         fieldTypeNode = fieldTypeNode.getNext()) {\n\n      // Get the property's name.\n      Node fieldNameNode = fieldTypeNode;\n      boolean hasType = false;\n\n      if (fieldTypeNode.getType() == Token.COLON) {\n        fieldNameNode = fieldTypeNode.getFirstChild();\n        hasType = true;\n      }\n\n      String fieldName = fieldNameNode.getString();\n\n      // TODO(user): Move this into the lexer/parser.\n      // Remove the string literal characters around a field name,\n      // if any.\n      if (fieldName.startsWith(\"'\") || fieldName.startsWith(\"\\\"\")) {\n        fieldName = fieldName.substring(1, fieldName.length() - 1);\n      }\n\n      // Get the property's type.\n      JSType fieldType = null;\n\n      if (hasType) {\n        // We have a declared type.\n        fieldType = createFromTypeNodesInternal(\n            fieldTypeNode.getLastChild(), sourceName, scope);\n      } else {\n        // Otherwise, the type is UNKNOWN.\n        fieldType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n\n      // Add the property to the record.\n      if (builder.addProperty(fieldName, fieldType, fieldNameNode) == null) {\n        // Duplicate field name, warning and skip\n        reporter.warning(\n            \"Duplicate record field \" + fieldName,\n            sourceName,\n            n.getLineno(), fieldNameNode.getCharno());\n      }\n    }\n\n    return builder.build();\n  }\n",
        "begin_line": 1776,
        "end_line": 1827,
        "comment": "\n   * Creates a RecordType from the nodes representing said record type.\n   * @param n The node with type info.\n   * @param sourceName The source file name.\n   * @param scope A scope for doing type name lookups.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseRecordType#2245",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseRecordType(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseRecordType(JsDocToken token) {\n    Node recordType = newNode(Token.LC);\n    Node fieldTypeList = parseFieldTypeList(token);\n\n    if (fieldTypeList == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n\n    next();\n\n    recordType.addChildToBack(fieldTypeList);\n    return recordType;\n  }\n",
        "begin_line": 2245,
        "end_line": 2262,
        "comment": "\n   * RecordType := '{' FieldTypeList '}'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseFieldTypeList#2267",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseFieldTypeList(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseFieldTypeList(JsDocToken token) {\n    Node fieldTypeList = newNode(Token.LB);\n\n    do {\n      Node fieldType = parseFieldType(token);\n\n      if (fieldType == null) {\n        return null;\n      }\n\n      fieldTypeList.addChildToBack(fieldType);\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n\n    return fieldTypeList;\n  }\n",
        "begin_line": 2267,
        "end_line": 2293,
        "comment": "\n   * FieldTypeList := FieldType | FieldType ',' FieldTypeList\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseFieldType#2298",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseFieldType(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseFieldType(JsDocToken token) {\n    Node fieldName = parseFieldName(token);\n\n    if (fieldName == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return fieldName;\n    }\n\n    // Move to the colon.\n    next();\n\n    // Move to the token after the colon and parse\n    // the type expression.\n    skipEOLs();\n    Node typeExpression = parseTypeExpression(next());\n\n    if (typeExpression == null) {\n      return null;\n    }\n\n    Node fieldType = newNode(Token.COLON);\n    fieldType.addChildToBack(fieldName);\n    fieldType.addChildToBack(typeExpression);\n    return fieldType;\n  }\n",
        "begin_line": 2298,
        "end_line": 2326,
        "comment": "\n   * FieldType := FieldName | FieldName ':' TypeExpression\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseFieldName#2332",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseFieldName(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseFieldName(JsDocToken token) {\n    switch (token) {\n      case STRING:\n        String string = stream.getString();\n        return newStringNode(string);\n\n      default:\n        return null;\n    }\n  }\n",
        "begin_line": 2332,
        "end_line": 2341,
        "comment": "\n   * FieldName := NameExpression | StringLiteral | NumberLiteral |\n   * ReservedIdentifier\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateType.hasAnyTemplateTypesInternal#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateType",
        "signature": "com.google.javascript.rhino.jstype.TemplateType.hasAnyTemplateTypesInternal()",
        "snippet": "  @Override\n  public boolean hasAnyTemplateTypesInternal() {\n    return true;\n  }\n",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0306
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplatizedType.hasAnyTemplateTypesInternal#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplatizedType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplatizedType",
        "signature": "com.google.javascript.rhino.jstype.TemplatizedType.hasAnyTemplateTypesInternal()",
        "snippet": "  @Override\n  public boolean hasAnyTemplateTypesInternal() {\n    return templateTypeMap.hasAnyTemplateTypesInternal();\n  }\n",
        "begin_line": 167,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplatizedType.TemplatizedType#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplatizedType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplatizedType",
        "signature": "com.google.javascript.rhino.jstype.TemplatizedType.TemplatizedType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.ObjectType, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  TemplatizedType(\n      JSTypeRegistry registry, ObjectType objectType,\n      ImmutableList<JSType> templateTypes) {\n    super(registry, objectType, objectType.getTemplateTypeMap().addValues(\n        templateTypes));\n\n    // Cache which template keys were filled, and what JSTypes they were filled\n    // with.\n    ImmutableList<TemplateType> filledTemplateKeys =\n        objectType.getTemplateTypeMap().getUnfilledTemplateKeys();\n    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n    for (TemplateType filledTemplateKey : filledTemplateKeys) {\n      builder.add(getTemplateTypeMap().getTemplateType(filledTemplateKey));\n    }\n    this.templateTypes = builder.build();\n\n    replacer = new TemplateTypeMapReplacer(registry, getTemplateTypeMap());\n  }\n",
        "begin_line": 57,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplatizedType.getTemplateTypeMap#162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplatizedType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplatizedType",
        "signature": "com.google.javascript.rhino.jstype.TemplatizedType.getTemplateTypeMap()",
        "snippet": "  @Override\n  public TemplateTypeMap getTemplateTypeMap() {\n    return templateTypeMap;\n  }\n",
        "begin_line": 162,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.TemplateTypeMap#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.TemplateTypeMap(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.TemplateType>, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  TemplateTypeMap(JSTypeRegistry registry,\n                  ImmutableList<TemplateType> templateKeys,\n                  ImmutableList<JSType> templateValues) {\n    Preconditions.checkNotNull(templateKeys);\n    Preconditions.checkNotNull(templateValues);\n\n    this.registry = registry;\n    this.templateKeys = templateKeys;\n\n    int nKeys = templateKeys.size();\n    this.templateValues = templateValues.size() > nKeys ?\n        templateValues.subList(0, nKeys) : templateValues;\n\n    // Iteratively resolve any JSType values that refer to the TemplateType keys\n    // of this TemplateTypeMap.\n    TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n        registry, this);\n    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n    for (JSType templateValue : this.templateValues) {\n      builder.add(templateValue.visit(replacer));\n    }\n    this.resolvedTemplateValues = builder.build();\n  }\n",
        "begin_line": 69,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getTemplateTypeIndex#168",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getTemplateTypeIndex(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  private int getTemplateTypeIndex(TemplateType key) {\n    int maxIndex = Math.min(templateKeys.size(), templateValues.size());\n    for (int i = maxIndex - 1; i >= 0; i--) {\n      if (templateKeys.get(i) == key) {\n        return i;\n      }\n    }\n    return -1;\n  }\n",
        "begin_line": 168,
        "end_line": 176,
        "comment": "\n   * Returns the index of the JSType value associated with the specified\n   * template key. If no JSType value is associated, returns -1.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.addValues#273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.addValues(com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  TemplateTypeMap addValues(ImmutableList<JSType> newValues) {\n    // Ignore any new template values that will not align with an existing\n    // template key.\n    int numUnfilledKeys = numUnfilledTemplateKeys();\n    if (numUnfilledKeys < newValues.size()) {\n      newValues = newValues.subList(0, numUnfilledKeys);\n    }\n\n    return registry.createTemplateTypeMap(\n        templateKeys, concatImmutableLists(templateValues, newValues));\n  }\n",
        "begin_line": 273,
        "end_line": 283,
        "comment": "\n   * Returns a new TemplateTypeMap whose values have been extended with the\n   * specified list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createTemplatizedType#1507",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createTemplatizedType(com.google.javascript.rhino.jstype.ObjectType, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public TemplatizedType createTemplatizedType(\n      ObjectType baseType, ImmutableList<JSType> templatizedTypes) {\n    // Only ObjectTypes can currently be templatized; extend this logic when\n    // more types can be templatized.\n    return new TemplatizedType(this, baseType, templatizedTypes);\n  }\n",
        "begin_line": 1507,
        "end_line": 1512,
        "comment": "\n   * Creates a templatized instance of the specified type.  Only ObjectTypes\n   * can currently be templatized; extend the logic in this function when\n   * more types can be templatized.\n   * @param baseType the type to be templatized.\n   * @param templatizedTypes a list of the template JSTypes. Will be matched by\n   *     list order to the template keys on the base type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.hashCode#250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return referencedType.hashCode();\n  }\n",
        "begin_line": 250,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createOptionalType#997",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }\n",
        "begin_line": 997,
        "end_line": 1003,
        "comment": "\n   * Creates a type representing optional values of the given type.\n   * @return the union of the type and the void type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.toMaybeRecordType#208",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeRecordType()",
        "snippet": "  @Override\n  RecordType toMaybeRecordType() {\n    return referencedType.toMaybeRecordType();\n  }\n",
        "begin_line": 208,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitFunction#1693",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitFunction(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          baseConstructor != null &&\n          baseConstructor.isInterface()) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                        \"constructor\", functionPrivateName));\n      } else {\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n          ObjectType proto = functionType.getPrototype();\n          if (functionType.makesStructs() && !proto.isStruct()) {\n            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,\n                                        \"struct\", functionPrivateName));\n          } else if (functionType.makesDicts() && !proto.isDict()) {\n            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,\n                                        \"dict\", functionPrivateName));\n          }\n        }\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                          \"interface\", functionPrivateName));\n        }\n      }\n\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1693,
        "end_line": 1762,
        "comment": "\n   * Visits a {@link Token#FUNCTION} node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateType.visit#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateType",
        "signature": "com.google.javascript.rhino.jstype.TemplateType.visit(com.google.javascript.rhino.jstype.Visitor<T>)",
        "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseTemplateType(this);\n  }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.siblings#1256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.siblings()",
        "snippet": "  public Iterable<Node> siblings() {\n    return new SiblingNodeIterable(this);\n  }\n",
        "begin_line": 1256,
        "end_line": 1258,
        "comment": "\n   * <p>Return an iterable object that iterates over this node's siblings.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's siblings, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node sibling : n.siblings()) { ...</pre>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isInstanceType#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isInstanceType()",
        "snippet": "  @Override\n  public boolean isInstanceType() {\n    // The universal constructor is its own instance, bizarrely. It overrides\n    // getConstructor() appropriately when it's declared.\n    return this == registry.getNativeType(U2U_CONSTRUCTOR_TYPE);\n  }\n",
        "begin_line": 185,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getUnfilledTemplateKeys#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getUnfilledTemplateKeys()",
        "snippet": "  ImmutableList<TemplateType> getUnfilledTemplateKeys() {\n    return templateKeys.subList(templateValues.size(), templateKeys.size());\n  }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n   * Returns a list of template keys in this map that do not have corresponding\n   * JSType values.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getType#893",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(java.lang.String)",
        "snippet": "  public JSType getType(String jsTypeName) {\n    // TODO(user): Push every local type name out of namesToTypes so that\n    // NamedType#resolve is correct.\n    TemplateType templateType = templateTypes.get(jsTypeName);\n    if (templateType != null) {\n      return templateType;\n    }\n    return namesToTypes.get(jsTypeName);\n  }\n",
        "begin_line": 893,
        "end_line": 901,
        "comment": "\n   * Looks up a type by name.\n   *\n   * @param jsTypeName The name string.\n   * @return the corresponding JSType object or {@code null} it cannot be found\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectUndeclaredVariable#524",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectUndeclaredVariable(java.lang.String, com.google.javascript.jscomp.CompilerInput, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope.Var, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type. We should redeclare it at the new input site.\n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }\n",
        "begin_line": 524,
        "end_line": 584,
        "comment": "\n   * Expect that the given variable has not been declared with a type.\n   *\n   * @param sourceName The name of the source file we're in.\n   * @param n The node where warnings should point to.\n   * @param parent The parent of {@code n}.\n   * @param var The variable that we're checking.\n   * @param variableName The name of the variable.\n   * @param newType The type being applied to the variable. Mostly just here\n   *     for the benefit of the warning.\n   * @return The variable we end up with. Most of the time, this will just\n   *     be {@code var}, but in some rare cases we will need to declare\n   *     a new var with new source info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateType.toMaybeTemplateType#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateType",
        "signature": "com.google.javascript.rhino.jstype.TemplateType.toMaybeTemplateType()",
        "snippet": "  @Override\n  public TemplateType toMaybeTemplateType() {\n    return this;\n  }\n",
        "begin_line": 68,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createDefaultObjectUnion#1009",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createDefaultObjectUnion(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createDefaultObjectUnion(JSType type) {\n    if (type.isTemplateType()) {\n      // Template types represent the substituted type exactly and should\n      // not be wrapped.\n      return type;\n    } else {\n      return shouldTolerateUndefinedValues()\n        ? createOptionalNullableType(type)\n        : createNullableType(type);\n    }\n  }\n",
        "begin_line": 1009,
        "end_line": 1019,
        "comment": "\n   * Creates a type representing nullable values of the given type.\n   * @return the union of the type and the Null type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createTemplateType#1478",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createTemplateType(java.lang.String)",
        "snippet": "  public TemplateType createTemplateType(String name) {\n    return new TemplateType(this, name);\n  }\n",
        "begin_line": 1478,
        "end_line": 1480,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getTemplateTypeNames#1581",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getTemplateTypeNames()",
        "snippet": "  public ImmutableList<String> getTemplateTypeNames() {\n    if (info == null || info.templateTypeNames == null) {\n      return ImmutableList.of();\n    }\n    return info.templateTypeNames;\n  }\n",
        "begin_line": 1581,
        "end_line": 1586,
        "comment": " Gets the template type name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getNode#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getNode()",
        "snippet": "  @Override\n      public Node getNode() {\n    return propertyNode;\n  }\n",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0305
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordTemplateTypeNames#307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordTemplateTypeNames(java.util.List<java.lang.String>)",
        "snippet": "  public boolean recordTemplateTypeNames(List<String> names) {\n    if (currentInfo.declareTemplateTypeNames(names)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 307,
        "end_line": 314,
        "comment": "\n   * Records a template type name.\n   *\n   * @return {@code true} if the template type name was recorded and\n   *     {@code false} if a template type name was already defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.declareTemplateTypeNames#972",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.declareTemplateTypeNames(java.util.List<java.lang.String>)",
        "snippet": "  boolean declareTemplateTypeNames(List<String> templateTypeNames) {\n    lazyInitInfo();\n\n    if (info.templateTypeNames != null) {\n      return false;\n    }\n\n    info.templateTypeNames = ImmutableList.copyOf(templateTypeNames);\n    return true;\n  }\n",
        "begin_line": 972,
        "end_line": 981,
        "comment": "\n   * Declares a template type name. Template type names are described using the\n   * {@code @template} annotation.\n   *\n   * @param templateTypeNames the template type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseHelperLoop#241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseHelperLoop(com.google.javascript.jscomp.parsing.JsDocToken, java.util.List<com.google.javascript.jscomp.parsing.JsDocInfoParser.ExtendedTypeInfo>)",
        "snippet": "  private boolean parseHelperLoop(JsDocToken token,\n                                  List<ExtendedTypeInfo> extendedTypes) {\n    while (true) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            token = parseAnnotation(token, extendedTypes);\n          } else {\n            token = next();\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          break;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n          }\n          break;\n      }\n    }\n  }\n",
        "begin_line": 241,
        "end_line": 286,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.extractSingleLineBlock#1437",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractSingleLineBlock()",
        "snippet": "  private ExtractionInfo extractSingleLineBlock() {\n\n    // Get the current starting point.\n    stream.update();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno() + 1;\n\n    String line = getRemainingJSDocLine().trim();\n\n    // Record the textual description.\n    if (line.length() > 0) {\n      jsdocBuilder.markText(line, lineno, charno, lineno,\n                            charno + line.length());\n    }\n\n    return new ExtractionInfo(line, next());\n  }\n",
        "begin_line": 1437,
        "end_line": 1453,
        "comment": "\n   * Extracts the text found on the current line starting at token. Note that\n   * token = token.info; should be called after this method is used to update\n   * the token properly in the parser.\n   *\n   * @return The extraction information.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getSource#1110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSource()",
        "snippet": "  public Node getSource() {\n    return source;\n  }\n",
        "begin_line": 1110,
        "end_line": 1112,
        "comment": "\n   * Gets the source node or null if this is an unknown function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseTypeExpressionList#1815",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionList(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeExpressionList(JsDocToken token) {\n    Node typeExpr = parseTopLevelTypeExpression(token);\n    if (typeExpr == null) {\n      return null;\n    }\n    Node typeList = IR.block();\n    typeList.addChildToBack(typeExpr);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      typeExpr = parseTopLevelTypeExpression(next());\n      if (typeExpr == null) {\n        return null;\n      }\n      typeList.addChildToBack(typeExpr);\n    }\n    return typeList;\n  }\n",
        "begin_line": 1815,
        "end_line": 1832,
        "comment": "\n   * TypeExpressionList := TopLevelTypeExpression\n   *     | TopLevelTypeExpression ',' TypeExpressionList\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseTypeName#1925",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }\n",
        "begin_line": 1925,
        "end_line": 1960,
        "comment": "\n   * TypeName := NameExpression | NameExpression TypeApplication\n   * TypeApplication := '.<' TypeExpressionList '>'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.markText#176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markText(java.lang.String, int, int, int, int)",
        "snippet": "  public void markText(String text, int startLineno, int startCharno,\n      int endLineno, int endCharno) {\n    if (currentMarker != null) {\n      JSDocInfo.StringPosition position = new JSDocInfo.StringPosition();\n      position.setItem(text);\n      position.setPositionInformation(startLineno, startCharno,\n          endLineno, endCharno);\n      currentMarker.setDescription(position);\n    }\n  }\n",
        "begin_line": 176,
        "end_line": 185,
        "comment": "\n   * Adds a textual block to the current marker.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseTopLevelTypeExpression#1793",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }\n",
        "begin_line": 1793,
        "end_line": 1809,
        "comment": "\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseUnionTypeWithAlternate#2160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseUnionTypeWithAlternate(com.google.javascript.jscomp.parsing.JsDocToken, com.google.javascript.rhino.Node)",
        "snippet": "  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n    Node union = newNode(Token.PIPE);\n    if (alternate != null) {\n      union.addChildToBack(alternate);\n    }\n\n    Node expr = null;\n    do {\n      if (expr != null) {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n            token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n        boolean isPipe = token == JsDocToken.PIPE;\n        if (isPipe && match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n      }\n      expr = parseTypeExpression(token);\n      if (expr == null) {\n        return null;\n      }\n\n      union.addChildToBack(expr);\n      // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (alternate == null) {\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n    }\n    return union;\n  }\n",
        "begin_line": 2160,
        "end_line": 2199,
        "comment": "\n   * Create a new union type, with an alternate that has already been\n   * parsed. The alternate may be null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0304
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.newStringNode#2354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(java.lang.String)",
        "snippet": "  private Node newStringNode(String s) {\n    return newStringNode(s, stream.getLineno(), stream.getCharno());\n  }\n",
        "begin_line": 2354,
        "end_line": 2356,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.isNoResolvedType#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isNoResolvedType()",
        "snippet": "  @Override\n  public boolean isNoResolvedType() {\n    return referencedType.isNoResolvedType();\n  }\n",
        "begin_line": 137,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.addParameter#627",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.addParameter(com.google.javascript.rhino.jstype.FunctionParamBuilder, com.google.javascript.rhino.jstype.JSType, boolean, boolean, boolean)",
        "snippet": "  private boolean addParameter(FunctionParamBuilder builder,\n      JSType paramType, boolean warnedAboutArgList,\n      boolean isOptional, boolean isVarArgs) {\n    boolean emittedWarning = false;\n    if (isOptional) {\n      // Remembering that an optional parameter has been encountered\n      // so that if a non optional param is encountered later, an\n      // error can be reported.\n      if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else if (isVarArgs) {\n      if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else {\n      if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {\n        // An optional parameter was seen and this argument is not an optional\n        // or var arg so it is an error.\n        if (builder.hasVarArgs()) {\n          reportWarning(VAR_ARGS_MUST_BE_LAST);\n        } else {\n          reportWarning(OPTIONAL_ARG_AT_END);\n        }\n        emittedWarning = true;\n      }\n    }\n    return emittedWarning;\n  }\n",
        "begin_line": 627,
        "end_line": 657,
        "comment": "\n   * Add a parameter to the param list.\n   * @param builder A builder.\n   * @param paramType The parameter type.\n   * @param warnedAboutArgList Whether we've already warned about arg ordering\n   *     issues (like if optional args appeared before required ones).\n   * @param isOptional Is this an optional parameter?\n   * @param isVarArgs Is this a var args parameter?\n   * @return Whether a warning was emitted.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateType.getReferenceName#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateType",
        "signature": "com.google.javascript.rhino.jstype.TemplateType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    return name;\n  }\n",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.setTemplateTypeNames#1832",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.setTemplateTypeNames(java.util.List<com.google.javascript.rhino.jstype.TemplateType>)",
        "snippet": "  public void setTemplateTypeNames(List<TemplateType> keys) {\n    Preconditions.checkNotNull(keys);\n    for (TemplateType key : keys) {\n      templateTypes.put(key.getReferenceName(), key);\n    }\n  }\n",
        "begin_line": 1832,
        "end_line": 1837,
        "comment": "\n   * Sets the template type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.hasTemplatedParameterType#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.hasTemplatedParameterType()",
        "snippet": "  private boolean hasTemplatedParameterType() {\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        JSType type = paramNode.getJSType();\n        if (type != null && type.hasAnyTemplateTypes()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 309,
        "end_line": 320,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.undeclare#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.undeclare(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  void undeclare(Var var) {\n    Preconditions.checkState(var.scope == this);\n    Preconditions.checkState(vars.get(var.name) == var);\n    vars.remove(var.name);\n  }\n",
        "begin_line": 509,
        "end_line": 513,
        "comment": "\n   * Undeclares a variable, to be used when the compiler optimizes out\n   * a variable and removes it from the scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.update#325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.update()",
        "snippet": "  void update() {\n    charno = getOffset();\n  }\n",
        "begin_line": 325,
        "end_line": 327,
        "comment": "\n   * Allows the JSDocParser to update the character offset\n   * so that getCharno() returns a valid character position.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getRemainingJSDocLine#199",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getRemainingJSDocLine()",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  String getRemainingJSDocLine() {\n    int c;\n    for (;;) {\n      c = getChar();\n      switch (c) {\n        case '*':\n          if (peekChar() != '/') {\n            addToString(c);\n            break;\n          }\n          // fall through\n        case EOF_CHAR:\n        case '\\n':\n          ungetChar(c);\n          this.string = getStringFromBuffer();\n          stringBufferTop = 0;\n          return this.string;\n\n        default:\n          addToString(c);\n          break;\n      }\n    }\n  }\n",
        "begin_line": 199,
        "end_line": 223,
        "comment": "\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.getRemainingJSDocLine#2478",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getRemainingJSDocLine()",
        "snippet": "  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n    return result;\n  }\n",
        "begin_line": 2478,
        "end_line": 2482,
        "comment": "\n   * Returns the remainder of the line.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.ExtractionInfo#1409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.ExtractionInfo.ExtractionInfo(java.lang.String, com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "    public ExtractionInfo(String string, JsDocToken token) {\n      this.string = string;\n      this.token = token;\n    }\n",
        "begin_line": 1409,
        "end_line": 1412,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "InferJSDocInfo.visit#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSDocInfo docInfo;\n\n    switch (n.getType()) {\n      // Infer JSDocInfo on types of all type declarations on variables.\n      case Token.NAME:\n        if (parent == null) {\n          return;\n        }\n\n        // Only allow JSDoc on VARs, function declarations, and assigns.\n        if (!parent.isVar() &&\n            !NodeUtil.isFunctionDeclaration(parent) &&\n            !(parent.isAssign() &&\n              n == parent.getFirstChild())) {\n          return;\n        }\n\n        // There are four places the doc info could live.\n        // 1) A FUNCTION node.\n        // /** ... */ function f() { ... }\n        // 2) An ASSIGN parent.\n        // /** ... */ x = function () { ... }\n        // 3) A NAME parent.\n        // var x, /** ... */ y = function() { ... }\n        // 4) A VAR gramps.\n        // /** ... */ var x = function() { ... }\n        docInfo = n.getJSDocInfo();\n        if (docInfo == null &&\n            !(parent.isVar() &&\n                !parent.hasOneChild())) {\n          docInfo = parent.getJSDocInfo();\n        }\n\n        // Try to find the type of the NAME.\n        JSType varType = n.getJSType();\n        if (varType == null && parent.isFunction()) {\n          varType = parent.getJSType();\n        }\n\n        // If we have no type to attach JSDocInfo to, then there's nothing\n        // we can do.\n        if (varType == null || docInfo == null) {\n          return;\n        }\n\n        // Dereference the type. If the result is not an object, or already\n        // has docs attached, then do nothing.\n        ObjectType objType = dereferenceToObject(varType);\n        if (objType == null || objType.getJSDocInfo() != null) {\n          return;\n        }\n\n        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n        break;\n\n      case Token.GETPROP:\n        // Infer JSDocInfo on properties.\n        // There are two ways to write doc comments on a property.\n        //\n        // 1)\n        // /** @deprecated */\n        // obj.prop = ...\n        //\n        // 2)\n        // /** @deprecated */\n        // obj.prop;\n        if (parent.isExprResult() ||\n            (parent.isAssign() &&\n             parent.getFirstChild() == n)) {\n          docInfo = n.getJSDocInfo();\n          if (docInfo == null) {\n            docInfo = parent.getJSDocInfo();\n          }\n          if (docInfo != null) {\n            ObjectType lhsType =\n                dereferenceToObject(n.getFirstChild().getJSType());\n            if (lhsType != null) {\n              // Put the JSDoc in the property slot, if there is one.\n              String propName = n.getLastChild().getString();\n              if (lhsType.hasOwnProperty(propName)) {\n                lhsType.setPropertyJSDocInfo(propName, docInfo);\n              }\n\n              // Put the JSDoc in any constructors or function shapes as well.\n              ObjectType propType =\n                  dereferenceToObject(lhsType.getPropertyType(propName));\n              if (propType != null) {\n                attachJSDocInfoToNominalTypeOrShape(\n                    propType, docInfo, n.getQualifiedName());\n              }\n            }\n          }\n        }\n        break;\n    }\n  }\n",
        "begin_line": 92,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.match#2436",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(com.google.javascript.jscomp.parsing.JsDocToken, com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private boolean match(JsDocToken token1, JsDocToken token2) {\n    unreadToken = next();\n    return unreadToken == token1 || unreadToken == token2;\n  }\n",
        "begin_line": 2436,
        "end_line": 2439,
        "comment": "\n   * Tests that the next symbol of the token stream matches one of the specified\n   * tokens.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.getConstructor#132",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.getConstructor()",
        "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }\n",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0303
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.getReferencedTypeInternal#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getReferencedTypeInternal()",
        "snippet": "  JSType getReferencedTypeInternal() {\n    return referencedType;\n  }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.hasAnyTemplateTypesInternal#303",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.hasAnyTemplateTypesInternal()",
        "snippet": "  @Override\n  public boolean hasAnyTemplateTypesInternal() {\n    return returnType.hasAnyTemplateTypes()\n        || hasTemplatedParameterType();\n  }\n",
        "begin_line": 303,
        "end_line": 307,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineSlot#1163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.isName() && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.isVar() ||\n           parent.isFunction());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.isGetProp() && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // The input may be null if we are working with a AST snippet. So read\n      // the extern info from the node.\n      Var newVar = null;\n\n      // declared in closest scope?\n      CompilerInput input = compiler.getInput(inputId);\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        newVar = validator.expectUndeclaredVariable(\n            sourceName, input, n, parent, oldVar, variableName, type);\n      } else {\n        if (type != null) {\n          setDeferredType(n, type);\n        }\n\n        newVar =\n          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.isObjectLit() ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n      }\n\n      // We need to do some additional work for constructors and interfaces.\n      FunctionType fnType = JSType.toMaybeFunctionType(type);\n      if (fnType != null &&\n          // We don't want to look at empty function types.\n          !type.isEmptyType()) {\n\n        // We want to make sure that when we declare a new instance type\n        // (with @constructor) that there's actually a ctor for it.\n        // This doesn't apply to structural constructors (like\n        // function(new:Array). Checking the constructed type against\n        // the variable name is a sufficient check for this.\n        if ((fnType.isConstructor() || fnType.isInterface()) &&\n            variableName.equals(fnType.getReferenceName())) {\n          finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn,\n                                      input, newVar);\n        }\n      }\n\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS);\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n              getNativeType(JSTypeNative.NO_TYPE) :\n              type,\n              n);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, n);\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type != null\n          && type.isFunctionType()\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n      }\n    }\n",
        "begin_line": 1163,
        "end_line": 1260,
        "comment": "\n     * Defines a symbol in the current scope.\n     *\n     * @param n the defining NAME or GETPROP or object literal key node.\n     * @param parent the {@code n}'s parent.\n     * @param variableName The name that this should be known by.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred or declared.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.hasAnyTemplateTypesInternal#1277",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasAnyTemplateTypesInternal()",
        "snippet": "  @Override\n  public boolean hasAnyTemplateTypesInternal() {\n    return getTemplateTypeMap().numUnfilledTemplateKeys() > 0\n        || typeOfThis.hasAnyTemplateTypes()\n        || call.hasAnyTemplateTypes();\n  }\n",
        "begin_line": 1277,
        "end_line": 1282,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.toMaybeTemplateType#362",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeTemplateType()",
        "snippet": "  @Override\n  public TemplateType toMaybeTemplateType() {\n    return referencedType.toMaybeTemplateType();\n  }\n",
        "begin_line": 362,
        "end_line": 365,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.isAllType#187",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isAllType()",
        "snippet": "  @Override\n  public boolean isAllType() {\n    return referencedType.isAllType();\n  }\n",
        "begin_line": 187,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0302
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.toMaybeUnionType#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeUnionType()",
        "snippet": "  @Override\n  public UnionType toMaybeUnionType() {\n    return referencedType.toMaybeUnionType();\n  }\n",
        "begin_line": 213,
        "end_line": 216,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordThisType#593",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordThisType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordThisType(JSTypeExpression type) {\n    if (type != null && !hasAnySingletonTypeTags() &&\n        !currentInfo.hasThisType()) {\n      currentInfo.setThisType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 593,
        "end_line": 602,
        "comment": "\n   * Records a type for {@code @this} annotation.\n   *\n   * @return {@code true} if the type was recorded and\n   *     {@code false} if it is invalid or if it collided with {@code @enum} or\n   *     {@code @type} annotations\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setThisType#1183",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setThisType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setThisType(JSTypeExpression type) {\n    this.thisType = type;\n  }\n",
        "begin_line": 1183,
        "end_line": 1185,
        "comment": "\n   * Sets the type specified by the {@code @this} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isOverride#554",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isOverride()",
        "snippet": "  public boolean isOverride() {\n    return getFlag(MASK_OVERRIDE);\n  }\n",
        "begin_line": 554,
        "end_line": 556,
        "comment": "\n   * Returns whether the {@code @override} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.isNoType#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isNoType()",
        "snippet": "  @Override\n  public boolean isNoType() {\n    return referencedType.isNoType();\n  }\n",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.isUnknownType#142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    return referencedType.isUnknownType();\n  }\n",
        "begin_line": 142,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.toMaybeFunctionType#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeFunctionType()",
        "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return referencedType.toMaybeFunctionType();\n  }\n",
        "begin_line": 218,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.resolveInternal#325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setReferencedType(referencedType.resolve(t, scope));\n    return this;\n  }\n",
        "begin_line": 325,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.getTemplateTypeMap#372",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getTemplateTypeMap()",
        "snippet": "  @Override\n  public TemplateTypeMap getTemplateTypeMap() {\n    return referencedType.getTemplateTypeMap();\n  }\n",
        "begin_line": 372,
        "end_line": 375,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation#1728",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }\n",
        "begin_line": 1728,
        "end_line": 1763,
        "comment": "\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.setReferencedType#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.setReferencedType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setReferencedType(JSType referencedType) {\n    this.referencedType = referencedType;\n    if (referencedType instanceof ObjectType) {\n      this.referencedObjType = (ObjectType) referencedType;\n    } else {\n      this.referencedObjType = null;\n    }\n  }\n",
        "begin_line": 86,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0301
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getParameterCount#1058",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
        "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }\n",
        "begin_line": 1058,
        "end_line": 1063,
        "comment": "\n   * Gets the number of parameters defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.03
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isConstructor#479",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isConstructor()",
        "snippet": "  public boolean isConstructor() {\n    return false;\n  }\n",
        "begin_line": 479,
        "end_line": 481,
        "comment": "\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.03
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isCast#2253",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCast()",
        "snippet": "  public boolean isCast() {\n    return this.getType() == Token.CAST;\n  }\n",
        "begin_line": 2253,
        "end_line": 2255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0299
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.concatImmutableLists#307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.concatImmutableLists(com.google.common.collect.ImmutableList<T>, com.google.common.collect.ImmutableList<T>)",
        "snippet": "  private <T> ImmutableList<T> concatImmutableLists(\n    ImmutableList<T> first, ImmutableList<T> second) {\n    if (first.isEmpty()) {\n      return second;\n    }\n    if (second.isEmpty()) {\n      return first;\n    }\n    ImmutableList.Builder<T> builder = ImmutableList.builder();\n    builder.addAll(first);\n    builder.addAll(second);\n    return builder.build();\n  }\n",
        "begin_line": 307,
        "end_line": 319,
        "comment": "\n   * Concatenates two ImmutableList instances. If either input is empty, the\n   * other is returned; otherwise, a new ImmutableList instance is created that\n   * contains the contents of both arguments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0299
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.isInstanceType#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isInstanceType()",
        "snippet": "  @Override\n  public boolean isInstanceType() {\n    return true;\n  }\n",
        "begin_line": 110,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0298
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.getOwnPropertyNames#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getOwnPropertyNames()",
        "snippet": "  Set<String> getOwnPropertyNames() {\n    return properties.keySet();\n  }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getOwnPropertyNames#453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyNames()",
        "snippet": "  public Set<String> getOwnPropertyNames() {\n    return getPropertyMap().getOwnPropertyNames();\n  }\n",
        "begin_line": 453,
        "end_line": 455,
        "comment": "\n   * Returns the names of all the properties directly on this type.\n   *\n   * Overridden by FunctionType to add \"prototype\".\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordModifies#461",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordModifies(java.util.Set<java.lang.String>)",
        "snippet": "  public boolean recordModifies(Set<String> modifies) {\n    if (!hasAnySingletonSideEffectTags()\n        && currentInfo.setModifies(modifies)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 461,
        "end_line": 469,
        "comment": "\n   * Records the list of modifies warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isImplicitCast#618",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isImplicitCast()",
        "snippet": "  public boolean isImplicitCast() {\n    return getFlag(MASK_IMPLICITCAST);\n  }\n",
        "begin_line": 618,
        "end_line": 620,
        "comment": "\n   * Returns whether the {@code @implicitCast} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setModifies#784",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setModifies(java.util.Set<java.lang.String>)",
        "snippet": "  boolean setModifies(Set<String> modifies) {\n    lazyInitInfo();\n\n    if (info.modifies != null) {\n      return false;\n    }\n\n    info.modifies = modifies;\n    return true;\n  }\n",
        "begin_line": 784,
        "end_line": 793,
        "comment": "\n   * Sets modifies values.\n   * @param modifies A list of modifies types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseModifiesTag#1148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseModifiesTag(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private JsDocToken parseModifiesTag(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      Set<String> modifies = new HashSet<String>();\n      while (true) {\n        if (match(JsDocToken.STRING)) {\n          String name = stream.getString();\n          if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name)) {\n              parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());\n          }\n\n          modifies.add(stream.getString());\n          token = next();\n        } else {\n          parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());\n          return token;\n        }\n\n        if (match(JsDocToken.PIPE)) {\n          token = next();\n        } else {\n          break;\n        }\n      }\n\n      if (!match(JsDocToken.RC)) {\n        parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());\n      } else {\n        token = next();\n        if (!jsdocBuilder.recordModifies(modifies)) {\n          parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());\n        }\n      }\n    }\n    return token;\n  }\n",
        "begin_line": 1148,
        "end_line": 1187,
        "comment": "\n   * Parse a {@code @modifies} tag of the form\n   * {@code @modifies&#123;this|arguments|param&#125;}.\n   *\n   * @param token The current token.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.ensureTyped#2054",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(!n.isFunction() ||\n            type.isFunctionType() ||\n            type.isUnknownType());\n    // TODO(johnlenz): this seems like a strange place to check \"@implicitCast\"\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.isGetProp() ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n",
        "begin_line": 2054,
        "end_line": 2073,
        "comment": "\n   * Enforces type casts, and ensures the node is typed.\n   *\n   * A cast in the way that we use it in JSDoc annotations never\n   * alters the generated code and therefore never can induce any runtime\n   * operation. What this means is that a 'cast' is really just a compile\n   * time constraint on the underlying value. In the future, we may add\n   * support for run-time casts for compiled tests.\n   *\n   * To ensure some shred of sanity, we enforce the notion that the\n   * type you are casting to may only meaningfully be a narrower type\n   * than the underlying declared type. We also invalidate optimizations\n   * on bad type casts.\n   *\n   * @param t The traversal object needed to report errors.\n   * @param n The node getting a type assigned to it.\n   * @param type The type to be assigned.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isInterface#527",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isInterface()",
        "snippet": "  public boolean isInterface() {\n    return false;\n  }\n",
        "begin_line": 527,
        "end_line": 529,
        "comment": "\n   * Whether this type is a {@link FunctionType} that is an interface or a named\n   * type that points to such a type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getReferenceName#300",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 300,
        "end_line": 309,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.setPropertyJSDocInfo#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPropertyJSDocInfo(java.lang.String, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  @Override\n  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (properties.getOwnProperty(propertyName) == null) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.getOwnProperty(propertyName);\n      if (property != null) {\n        property.setJSDocInfo(info);\n      }\n    }\n  }\n",
        "begin_line": 151,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.computeFollowNode#692",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowAnalysis)",
        "snippet": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "begin_line": 692,
        "end_line": 789,
        "comment": "\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkDeclaredPropertyInheritance#1164",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkDeclaredPropertyInheritance(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getInstanceType().hasProperty(propertyName);\n    boolean superClassHasDeclaredProperty = superClass != null &&\n        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n\n    // For interface\n    boolean superInterfaceHasProperty = false;\n    boolean superInterfaceHasDeclaredProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfaceHasProperty =\n            superInterfaceHasProperty ||\n            interfaceType.hasProperty(propertyName);\n        superInterfaceHasDeclaredProperty =\n            superInterfaceHasDeclaredProperty ||\n            interfaceType.isPropertyTypeDeclared(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty ||\n            interfaceHasProperty;\n        if (reportMissingOverride.isOn()\n            && !declaredOverride\n            && interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    boolean declaredLocally =\n        ctorType.isConstructor() &&\n        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n         ctorType.getInstanceType().hasOwnProperty(propertyName));\n    if (reportMissingOverride.isOn()\n        && !declaredOverride\n        && superClassHasDeclaredProperty\n        && declaredLocally) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n\n    // @override is present and we have to check that it is ok\n    if (superClassHasDeclaredProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getInstanceType().getPropertyType(propertyName);\n      TemplateTypeMap ctorTypeMap =\n          ctorType.getTypeOfThis().getTemplateTypeMap();\n      if (!ctorTypeMap.isEmpty()) {\n        superClassPropType = superClassPropType.visit(\n            new TemplateTypeMapReplacer(typeRegistry, ctorTypeMap));\n      }\n\n      if (!propertyType.isSubtype(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfaceHasDeclaredProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n              interfaceType.getPropertyType(propertyName);\n          if (!propertyType.isSubtype(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n",
        "begin_line": 1164,
        "end_line": 1289,
        "comment": "\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "GoogleCodingConvention.isOptionalParameter#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isOptionalParameter(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return parameter.getString().startsWith(OPTIONAL_ARG_PREFIX);\n  }\n",
        "begin_line": 123,
        "end_line": 126,
        "comment": "\n   * {@inheritDoc}\n   *\n   * <p>In Google code, parameter names beginning with {@code opt_} are\n   * treated as optional arguments.\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.CodingConventions.Proxy": null
        },
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "GoogleCodingConvention.isVarArgsParameter#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isVarArgsParameter(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return VAR_ARGS_NAME.equals(parameter.getString());\n  }\n",
        "begin_line": 128,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.hasUnknownOrEmptySupertype#1295",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.hasUnknownOrEmptySupertype(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    // The type system should notice inheritance cycles on its own\n    // and break the cycle.\n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }\n",
        "begin_line": 1295,
        "end_line": 1317,
        "comment": "\n   * Given a constructor or an interface type, find out whether the unknown\n   * type is a supertype of the current type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.hashCode#222",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (returnTypeInferred) {\n      hashCode += 1;\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }\n",
        "begin_line": 222,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferThisType#432",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {\n    // Look at the @this annotation first.\n    inferThisType(info);\n\n    if (thisType == null) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null && (info == null || !info.hasType())) {\n        thisType = objType;\n      }\n    }\n\n    return this;\n  }\n",
        "begin_line": 432,
        "end_line": 444,
        "comment": "\n   * Infers the type of {@code this}.\n   * @param type The type of this if the info is missing.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0295
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.createFunctionTypeFromNodes#873",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.createFunctionTypeFromNodes(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() != null &&\n            var.getType().isFunctionType()) {\n          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.isFunction();\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = type.toMaybeFunctionType();\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          Var ownerVar = null;\n          String propName = null;\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = ObjectType.cast(ownerVar.getType());\n            }\n            if (name != null) {\n              propName = name.substring(ownerName.length() + 1);\n            }\n          }\n\n          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n          TemplateTypeMap prototypeOwnerTypeMap = null;\n          if (prototypeOwner != null &&\n              prototypeOwner.getTypeOfThis() != null) {\n            prototypeOwnerTypeMap =\n                prototypeOwner.getTypeOfThis().getTemplateTypeMap();\n          }\n\n          FunctionType overriddenType = null;\n          if (ownerType != null && propName != null) {\n            overriddenType = findOverriddenFunction(\n                ownerType, propName, prototypeOwnerTypeMap);\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setContents(getFunctionAnalysisResults(fnRoot))\n              .inferFromOverriddenFunction(overriddenType, parametersNode)\n              .inferTemplateTypeName(info, prototypeOwner)\n              .inferInheritance(info);\n\n          if (info == null || !info.hasReturnType()) {\n            /**\n             * when there is no {@code @return} annotation, look for inline\n             * return type declaration\n             */\n            if (rValue != null && rValue.isFunction() &&\n                rValue.getFirstChild() != null) {\n              JSDocInfo nameDocInfo = rValue.getFirstChild().getJSDocInfo();\n              builder.inferReturnType(nameDocInfo, true);\n            }\n          } else {\n            builder.inferReturnType(info, false);\n          }\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (ownerType != null && ownerType.isFunctionPrototypeType() &&\n              ownerType.getOwnerFunction().hasInstanceType()) {\n            builder.inferThisType(\n                info, ownerType.getOwnerFunction().getInstanceType());\n            searchedForThisType = true;\n          } else if (ownerNode != null && ownerNode.isThis()) {\n            // If 'this' has a type, use that instead.\n            // This is a hack, necessary because CollectProperties (below)\n            // doesn't run with the scope that it's building,\n            // so scope.getTypeOfThis() will be wrong.\n            JSType injectedThisType = ownerNode.getJSType();\n            builder.inferThisType(\n                info,\n                injectedThisType == null ?\n                scope.getTypeOfThis() : injectedThisType);\n            searchedForThisType = true;\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }\n",
        "begin_line": 873,
        "end_line": 1002,
        "comment": "\n     * Creates a new function type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - A function literal that needs a type attached to it.\n     * - An assignment expression with function-type info in the JsDoc.\n     *\n     * All parameters are optional, and we will do the best we can to create\n     * a function type.\n     *\n     * This function will always create a function type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The function node.\n     * @param name the function's name\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkPropertyInheritanceOnGetpropAssign#1033",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyInheritanceOnGetpropAssign(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void checkPropertyInheritanceOnGetpropAssign(\n      NodeTraversal t, Node assign, Node object, String property,\n      JSDocInfo info, JSType propertyType) {\n    // Inheritance checks for prototype properties.\n    //\n    // TODO(nicksantos): This isn't the right place to do this check. We\n    // really want to do this when we're looking at the constructor.\n    // We'd find all its properties and make sure they followed inheritance\n    // rules, like we currently do for @implements to make sure\n    // all the methods are implemented.\n    //\n    // As-is, this misses many other ways to override a property.\n    //\n    // object.prototype.property = ...;\n    if (object.isGetProp()) {\n      Node object2 = object.getFirstChild();\n      String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n      if (\"prototype\".equals(property2)) {\n        JSType jsType = getJSType(object2);\n        if (jsType.isFunctionType()) {\n          FunctionType functionType = jsType.toMaybeFunctionType();\n          if (functionType.isConstructor() || functionType.isInterface()) {\n            checkDeclaredPropertyInheritance(\n                t, assign, functionType, property, info, propertyType);\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 1033,
        "end_line": 1062,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.setJSDocInfo#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  void setJSDocInfo(JSDocInfo info) {\n    this.docInfo = info;\n  }\n",
        "begin_line": 134,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.inferArguments#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.inferArguments(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void inferArguments(Scope functionScope) {\n    Node functionNode = functionScope.getRootNode();\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType != null) {\n      Node parameterTypes = functionType.getParametersNode();\n      if (parameterTypes != null) {\n        Node parameterTypeNode = parameterTypes.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          Var var = functionScope.getVar(astParameter.getString());\n          Preconditions.checkNotNull(var);\n          if (var.isTypeInferred() &&\n              var.getType() == unknownType) {\n            JSType newType = null;\n\n            if (iifeArgumentNode != null) {\n              newType = iifeArgumentNode.getJSType();\n            } else if (parameterTypeNode != null) {\n              newType = parameterTypeNode.getJSType();\n            }\n\n            if (newType != null) {\n              var.setType(newType);\n              astParameter.setJSType(newType);\n            }\n          }\n\n          if (parameterTypeNode != null) {\n            parameterTypeNode = parameterTypeNode.getNext();\n          }\n          if (iifeArgumentNode != null) {\n            iifeArgumentNode = iifeArgumentNode.getNext();\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 124,
        "end_line": 167,
        "comment": "\n   * Infers all of a function's arguments if their types aren't declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.inferReturnType#317",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType(com.google.javascript.rhino.JSDocInfo, boolean)",
        "snippet": "  FunctionTypeBuilder inferReturnType(\n      @Nullable JSDocInfo info, boolean fromInlineDoc) {\n    if (info != null) {\n      JSTypeExpression returnTypeExpr =\n          fromInlineDoc ? info.getType() : info.getReturnType();\n      if (returnTypeExpr != null) {\n        returnType = returnTypeExpr.evaluate(scope, typeRegistry);\n        returnTypeInferred = false;\n      }\n    }\n\n    return this;\n  }\n",
        "begin_line": 317,
        "end_line": 329,
        "comment": "\n   * Infer the return type from JSDocInfo.\n   * @param fromInlineDoc Indicates whether return type is inferred from inline\n   * doc attached to function name\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isOrdinaryFunction#202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isOrdinaryFunction()",
        "snippet": "  @Override\n  public boolean isOrdinaryFunction() {\n    return kind == Kind.ORDINARY;\n  }\n",
        "begin_line": 202,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getDeclaredType#1338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getDeclaredType(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private JSType getDeclaredType(JSDocInfo info, Node lValue,\n        @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        }\n      }\n\n      // Check if this is constant, and if it has a known type.\n      if (isConstantSymbol(info, lValue)) {\n        if (rValue != null) {\n          JSDocInfo rValueInfo = rValue.getJSDocInfo();\n          if (rValueInfo != null && rValueInfo.hasType()) {\n            // If rValue has a type-cast, we use the type in the type-cast.\n            return rValueInfo.getType().evaluate(scope, typeRegistry);\n          } else if (rValue.getJSType() != null\n              && !rValue.getJSType().isUnknownType()) {\n            // If rValue's type was already computed during scope creation,\n            // then we can safely use that.\n            return rValue.getJSType();\n          } else if (rValue.isOr()) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node firstClause = rValue.getFirstChild();\n            Node secondClause = firstClause.getNext();\n            boolean namesMatch = firstClause.isName()\n                && lValue.isName()\n                && firstClause.getString().equals(lValue.getString());\n            if (namesMatch && secondClause.getJSType() != null\n                && !secondClause.getJSType().isUnknownType()) {\n              return secondClause.getJSType();\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(lValue, info);\n    }\n",
        "begin_line": 1338,
        "end_line": 1391,
        "comment": "\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.ensurePropertyDeclared#646",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclared(com.google.javascript.rhino.Node)",
        "snippet": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }\n",
        "begin_line": 646,
        "end_line": 652,
        "comment": "\n   * Defines a declared property if it has not been defined yet.\n   *\n   * This handles the case where a property is declared on an object where\n   * the object type is inferred, and so the object type will not\n   * be known in {@code TypedScopeCreator}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0294
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getPrototypeOwnerType#1004",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getPrototypeOwnerType(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "    private ObjectType getPrototypeOwnerType(ObjectType ownerType) {\n      if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n        return ownerType.getOwnerFunction();\n      }\n      return null;\n    }\n",
        "begin_line": 1004,
        "end_line": 1009,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0293
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.isFunctionTypeDeclaration#801",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isFunctionTypeDeclaration(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n    return info.getParameterCount() > 0 ||\n        info.hasReturnType() ||\n        info.hasThisType() ||\n        info.isConstructor() ||\n        info.isInterface();\n  }\n",
        "begin_line": 801,
        "end_line": 807,
        "comment": "\n   * Determines whether the given JsDoc info declares a function type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0293
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeExpression.isOptionalArg#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
        "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }\n",
        "begin_line": 89,
        "end_line": 91,
        "comment": "\n   * @return Whether this expression denotes an optional {@code @param}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.TypeMismatch#824",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.TypeMismatch.TypeMismatch(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.JSError)",
        "snippet": "    TypeMismatch(JSType a, JSType b, JSError src) {\n      this.typeA = a;\n      this.typeB = b;\n      this.src = src;\n    }\n",
        "begin_line": 824,
        "end_line": 828,
        "comment": "\n     * It's the responsibility of the class that creates the\n     * {@code TypeMismatch} to ensure that {@code a} and {@code b} are\n     * non-matching types.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeExpression.isVarArgs#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
        "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n   * @return Whether this expression denotes a rest args {@code @param}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getParameterType#1014",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(java.lang.String)",
        "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }\n",
        "begin_line": 1014,
        "end_line": 1019,
        "comment": "\n   * Gets the parameter type.\n   * @param parameter the parameter's name\n   * @return the parameter's type or {@code null} if this parameter is not\n   *     defined or has a {@code null} type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getParameterNames#1048",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterNames()",
        "snippet": "  public Set<String> getParameterNames() {\n    if (info == null || info.parameters == null) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(info.parameters.keySet());\n  }\n",
        "begin_line": 1048,
        "end_line": 1053,
        "comment": "\n   * Returns the set of names of the defined parameters. The iteration order\n   * of the returned set is not the order in which parameters are defined.\n   *\n   * @return the set of names of the defined parameters. The returned set is\n   *     immutable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.hashCode#925",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n  }\n",
        "begin_line": 925,
        "end_line": 928,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.shouldUseFunctionLiteralType#839",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.shouldUseFunctionLiteralType(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue)) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }\n",
        "begin_line": 839,
        "end_line": 849,
        "comment": "\n     * If a variable is assigned a function literal in the global scope,\n     * make that a declared type (even if there's no doc info).\n     * There's only one exception to this rule:\n     * if the return type is inferred, and we're in a local\n     * scope, we should assume the whole function is inferred.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.JSDocInfo, java.lang.String)",
        "snippet": "  private void attachJSDocInfoToNominalTypeOrShape(\n      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n    if (objType.isConstructor() ||\n        objType.isEnumType() ||\n        objType.isInterface()) {\n      // Named types.\n      if (objType.hasReferenceName() &&\n          objType.getReferenceName().equals(qName)) {\n        objType.setJSDocInfo(docInfo);\n\n        if (objType.isConstructor() || objType.isInterface()) {\n          JSType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(\n              docInfo);\n        } else if (objType instanceof EnumType) {\n          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n        }\n      }\n    } else if (!objType.isNativeObjectType() &&\n        objType.isFunctionType()) {\n      // Structural functions.\n      objType.setJSDocInfo(docInfo);\n    }\n  }\n",
        "begin_line": 201,
        "end_line": 223,
        "comment": "\n   * Handle cases #1 and #3 in the class doc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getConstructor#532",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.Anonymous-9a442c83-8ebe-41a1-a062-a0fa41a0e241.getConstructor()",
        "snippet": "          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n",
        "begin_line": 532,
        "end_line": 535,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.maybeDeclareQualifiedName#1539",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.maybeDeclareQualifiedName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n\n          qVar.getScope().undeclare(qVar);\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n        if (ownerFnType != null) {\n          JSType ownerTypeOfThis = ownerFnType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "begin_line": 1539,
        "end_line": 1645,
        "comment": "\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0292
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasParameterType#1037",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasParameterType(java.lang.String)",
        "snippet": "  public boolean hasParameterType(String parameter) {\n    return getParameterType(parameter) != null;\n  }\n",
        "begin_line": 1037,
        "end_line": 1039,
        "comment": "\n   * Returns whether the parameter has an attached type.\n   *\n   * @return {@code true} if the parameter has an attached type, {@code false}\n   *     if the parameter has no attached type or does not exist.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitAssign#912",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitAssign(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    // Check property sets to 'object.property' when 'object' is known.\n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      Node property = lvalue.getLastChild();\n      String pname = property.getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\n        }\n      }\n\n      checkEnumAlias(t, info, rvalue);\n      checkPropCreation(t, lvalue);\n\n      // Prototype assignments are special, because they actually affect\n      // the definition of a class. These are mostly validated\n      // during TypedScopeCreator, and we only look for the \"dumb\" cases here.\n      // object.prototype = ...;\n      if (pname.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n            // Only assign structs to the prototype of a @struct constructor\n            if (functionType.makesStructs() && !rvalueType.isStruct()) {\n              String funName = functionType.getTypeOfThis().toString();\n              compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE,\n                                          \"struct\", funName));\n            }\n            return;\n          }\n        }\n      }\n\n      // The generic checks for 'object.property' when 'object' is known,\n      // and 'property' is declared on it.\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(pname) &&\n            !type.isPropertyTypeInferred(pname) &&\n            !propertyIsImplicitCast(type, pname)) {\n          JSType expectedType = type.getPropertyType(pname);\n          if (!expectedType.isUnknownType()) {\n            validator.expectCanAssignToPropertyOf(\n                t, assign, getJSType(rvalue),\n                expectedType, object, pname);\n            checkPropertyInheritanceOnGetpropAssign(\n                t, assign, object, pname, info, expectedType);\n            return;\n          }\n        }\n      }\n\n      // If we couldn't get the property type with normal object property\n      // lookups, then check inheritance anyway with the unknown type.\n      checkPropertyInheritanceOnGetpropAssign(\n          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\n    }\n\n    // Check qualified name sets to 'object' and 'object.property'.\n    // This can sometimes handle cases when the type of 'object' is not known.\n    // e.g.,\n    // var obj = createUnknownType();\n    // /** @type {number} */ obj.foo = true;\n    JSType leftType = getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n      // variable with inferred type case\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n            t.getScope() != var.getScope()) {\n          // Don't look at \"this.foo\" variables from other scopes.\n          return;\n        }\n\n        if (var.getType() != null) {\n          leftType = var.getType();\n        }\n      }\n    }\n\n    // Fall through case for arbitrary LHS and arbitrary RHS.\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n",
        "begin_line": 912,
        "end_line": 1021,
        "comment": "\n   * Visits an assignment <code>lvalue = rvalue</code>. If the\n   * <code>lvalue</code> is a prototype modification, we change the schema\n   * of the object type it is referring to.\n   * @param t the traversal\n   * @param assign the assign node\n   * (<code>assign.isAssign()</code> is an implicit invariant)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseTypeExpression#1842",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }\n",
        "begin_line": 1842,
        "end_line": 1887,
        "comment": "\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getType#1140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getType()",
        "snippet": "  public JSTypeExpression getType() {\n    return getType(TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1140,
        "end_line": 1142,
        "comment": "\n   * Gets the type specified by the {@code @type} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.isQualifiedNameInferred#1674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.isQualifiedNameInferred(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        String className = qName.substring(0, qName.lastIndexOf(\".prototype\"));\n        Var slot = scope.getSlot(className);\n        JSType classType = slot == null ? null : slot.getType();\n        if (classType != null\n            && (classType.isConstructor() || classType.isInterface())) {\n          return false;\n        }\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }\n",
        "begin_line": 1674,
        "end_line": 1728,
        "comment": "\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.newNode#2349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newNode(int)",
        "snippet": "  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 2349,
        "end_line": 2352,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getPropertyType#601",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getPropertyType(java.lang.String)",
        "snippet": "  @Override\n  public JSType getPropertyType(String name) {\n    if (!hasOwnProperty(name)) {\n      // Define the \"call\", \"apply\", and \"bind\" functions lazily.\n      boolean isCall = \"call\".equals(name);\n      boolean isBind = \"bind\".equals(name);\n      if (isCall || isBind) {\n        defineDeclaredProperty(name, getCallOrBindSignature(isCall), source);\n      } else if (\"apply\".equals(name)) {\n        // Define the \"apply\" function lazily.\n        FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n\n        // ECMA-262 says that apply's second argument must be an Array\n        // or an arguments object. We don't model the arguments object,\n        // so let's just be forgiving for now.\n        // TODO(nicksantos): Model the Arguments object.\n        builder.addOptionalParams(\n            registry.createNullableType(getTypeOfThis()),\n            registry.createNullableType(\n                registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n\n        defineDeclaredProperty(name,\n            new FunctionBuilder(registry)\n            .withParams(builder)\n            .withReturnType(getReturnType())\n            .withTemplateKeys(getTemplateTypeMap().getTemplateKeys())\n            .build(),\n            source);\n      }\n    }\n\n    return super.getPropertyType(name);\n  }\n",
        "begin_line": 601,
        "end_line": 633,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0291
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectCanAssignToPropertyOf#367",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignToPropertyOf(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 367,
        "end_line": 390,
        "comment": "\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getStringValue#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getStringValue(com.google.javascript.rhino.Node)",
        "snippet": "  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.STRING_KEY:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n        return \"false\";\n\n      case Token.TRUE:\n        return \"true\";\n\n      case Token.NULL:\n        return \"null\";\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }\n",
        "begin_line": 177,
        "end_line": 222,
        "comment": "\n   * Gets the value of a node as a String, or null if it cannot be converted.\n   * When it returns a non-null String, this method effectively emulates the\n   * <code>String()</code> JavaScript cast function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.mayThrowException#910",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 910,
        "end_line": 931,
        "comment": "\n   * Determines if the subtree might throw an exception.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.hasAnySingletonSideEffectTags#1193",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonSideEffectTags()",
        "snippet": "  private boolean hasAnySingletonSideEffectTags() {\n    return currentInfo.isNoSideEffects() ||\n        currentInfo.hasModifies();\n  }\n",
        "begin_line": 1193,
        "end_line": 1196,
        "comment": "\n   * Whether the current doc info has any of the singleton type\n   * tags that may not appear with other type tags, like\n   * {@code @type} or {@code @typedef}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isNoSideEffects#626",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoSideEffects()",
        "snippet": "  public boolean isNoSideEffects() {\n    return getFlag(MASK_NOSIDEEFFECTS);\n  }\n",
        "begin_line": 626,
        "end_line": 628,
        "comment": "\n   * Returns whether the {@code @nosideeffects} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasModifies#1643",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasModifies()",
        "snippet": "  public boolean hasModifies() {\n    return info != null && info.modifies != null;\n  }\n",
        "begin_line": 1643,
        "end_line": 1645,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.skipEOLs#2466",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
        "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }\n",
        "begin_line": 2466,
        "end_line": 2473,
        "comment": "\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.propertyIsImplicitCast#1148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.propertyIsImplicitCast(com.google.javascript.rhino.jstype.ObjectType, java.lang.String)",
        "snippet": "  private static boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 1148,
        "end_line": 1156,
        "comment": "\n   * Returns true if any type in the chain has an implicitCast annotation for\n   * the given property.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getJSDocInfo#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getJSDocInfo()",
        "snippet": "  @Override public JSDocInfo getJSDocInfo() {\n    return this.docInfo;\n  }\n",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.029
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty#644",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }\n",
        "begin_line": 644,
        "end_line": 663,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getReturnType#323",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getReturnType()",
        "snippet": "  public JSType getReturnType() {\n    return call.returnType;\n  }\n",
        "begin_line": 323,
        "end_line": 325,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getOwnPropertyJSDocInfo#389",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyJSDocInfo(java.lang.String)",
        "snippet": "  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    Property p = getOwnSlot(propertyName);\n    return p == null ? null : p.getJSDocInfo();\n  }\n",
        "begin_line": 389,
        "end_line": 392,
        "comment": "\n   * Gets the docInfo on the specified property on this type.  This should not\n   * be implemented recursively, as you generally need to know exactly on\n   * which type in the prototype chain the JSDocInfo exists.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.addChildToFront#594",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.addChildToFront(com.google.javascript.rhino.Node)",
        "snippet": "  public void addChildToFront(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = first;\n    first = child;\n    if (last == null) {\n      last = child;\n    }\n  }\n",
        "begin_line": 594,
        "end_line": 603,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isOptionalArg#1933",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isOptionalArg()",
        "snippet": "  public boolean isOptionalArg() {\n    return getBooleanProp(OPT_ARG_NAME);\n  }\n",
        "begin_line": 1933,
        "end_line": 1935,
        "comment": "\n   * Returns whether this node is an optional argument node. This\n   * method's return value is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isVarArgs#1915",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isVarArgs()",
        "snippet": "  public boolean isVarArgs() {\n    return getBooleanProp(VAR_ARGS_NAME);\n  }\n",
        "begin_line": 1915,
        "end_line": 1917,
        "comment": "\n   * Returns whether this node is a variable length argument node. This\n   * method's return value is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0289
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.restrictByNotNullOrUndefined#223",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.restrictByNotNullOrUndefined()",
        "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    UnionTypeBuilder restricted = new UnionTypeBuilder(registry);\n    for (JSType t : alternates) {\n      restricted.addAlternate(t.restrictByNotNullOrUndefined());\n    }\n    return restricted.build();\n  }\n",
        "begin_line": 223,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0288
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isSubtypeHelper#1240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isSubtypeHelper(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  static boolean isSubtypeHelper(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // unions\n    if (thatType.isUnionType()) {\n      UnionType union = thatType.toMaybeUnionType();\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // TemplateTypeMaps. This check only returns false if the TemplateTypeMaps\n    // are not equivalent.\n    TemplateTypeMap thisTypeParams = thisType.getTemplateTypeMap();\n    TemplateTypeMap thatTypeParams = thatType.getTemplateTypeMap();\n    boolean templateMatch = true;\n    if (isExemptFromTemplateTypeInvariance(thatType)) {\n      // Array and Object are exempt from template type invariance; their\n      // template types maps are considered a match only if the ObjectElementKey\n      // values are subtypes/supertypes of one another.\n      TemplateType key = thisType.registry.getObjectElementKey();\n      JSType thisElement = thisTypeParams.getTemplateType(key);\n      JSType thatElement = thatTypeParams.getTemplateType(key);\n\n      templateMatch = thisElement.isSubtype(thatElement)\n          || thatElement.isSubtype(thisElement);\n    } else {\n      templateMatch = thisTypeParams.checkEquivalenceHelper(\n          thatTypeParams, EquivalenceMethod.INVARIANT);\n    }\n    if (!templateMatch) {\n      return false;\n    }\n\n    // Templatized types. The above check guarantees TemplateTypeMap\n    // equivalence; check if the base type is a subtype.\n    if (thisType.isTemplatizedType()) {\n      return thisType.toMaybeTemplatizedType().getReferencedType().isSubtype(\n              thatType);\n    }\n\n    // proxy types\n    if (thatType instanceof ProxyObjectType) {\n      return thisType.isSubtype(\n          ((ProxyObjectType) thatType).getReferencedTypeInternal());\n    }\n    return false;\n  }\n",
        "begin_line": 1240,
        "end_line": 1300,
        "comment": "\n   * A generic implementation meant to be used as a helper for common subtyping\n   * cases.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0288
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.validateTypeAnnotations#295",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.validateTypeAnnotations(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private void validateTypeAnnotations(JSDocInfo info, AstNode node) {\n    if (info.hasType()) {\n      boolean valid = false;\n      switch (node.getType()) {\n        // Casts are valid\n        case com.google.javascript.rhino.head.Token.LP:\n          valid = node instanceof ParenthesizedExpression;\n          break;\n        // Variable declarations are valid\n        case com.google.javascript.rhino.head.Token.VAR:\n          valid = true;\n          break;\n        // Function declarations are valid\n        case com.google.javascript.rhino.head.Token.FUNCTION:\n          FunctionNode fnNode = (FunctionNode) node;\n          valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n          break;\n        // Object literal properties, catch declarations and variable\n        // initializers are valid.\n        case com.google.javascript.rhino.head.Token.NAME:\n          AstNode parent = node.getParent();\n          valid = parent instanceof ObjectProperty\n              || parent instanceof CatchClause\n              || parent instanceof FunctionNode\n              || (parent instanceof VariableInitializer &&\n                  node == ((VariableInitializer) parent).getTarget());\n          break;\n        // Object literal properties are valid\n        case com.google.javascript.rhino.head.Token.GET:\n        case com.google.javascript.rhino.head.Token.SET:\n        case com.google.javascript.rhino.head.Token.NUMBER:\n        case com.google.javascript.rhino.head.Token.STRING:\n          valid = node.getParent() instanceof ObjectProperty;\n          break;\n\n        // Property assignments are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.ASSIGN:\n          if (node instanceof Assignment) {\n            valid = isExprStmt(node.getParent())\n                && isPropAccess(((Assignment) node).getLeft());\n          }\n          break;\n\n        // Property definitions are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.GETPROP:\n        case com.google.javascript.rhino.head.Token.GETELEM:\n          valid = isExprStmt(node.getParent());\n          break;\n\n        case com.google.javascript.rhino.head.Token.CALL:\n          valid = info.isDefine();\n          break;\n      }\n      if (!valid) {\n        errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n            sourceName,\n            node.getLineno(), \"\", 0);\n      }\n    }\n  }\n",
        "begin_line": 295,
        "end_line": 354,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0288
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.handleStmtList#484",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n",
        "begin_line": 484,
        "end_line": 523,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0288
        },
        "num_failing_tests": 2
    },
    {
        "name": "NullType.restrictByNotNullOrUndefined#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.restrictByNotNullOrUndefined()",
        "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    return registry.getNativeType(JSTypeNative.NO_TYPE);\n  }\n",
        "begin_line": 82,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.declareArguments#2042",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.declareArguments(com.google.javascript.rhino.Node)",
        "snippet": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node iifeArgumentNode = null;\n\n      if (NodeUtil.isCallOrNewTarget(functionNode)) {\n        iifeArgumentNode = functionNode.getNext();\n      }\n\n      FunctionType functionType =\n          JSType.toMaybeFunctionType(functionNode.getJSType());\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            JSType paramType = jsDocParameter == null ?\n                unknownType : jsDocParameter.getJSType();\n            boolean inferred = paramType == null || paramType == unknownType;\n\n            if (iifeArgumentNode != null && inferred) {\n              String argumentName = iifeArgumentNode.getQualifiedName();\n              Var argumentVar =\n                  argumentName == null || scope.getParent() == null\n                  ? null : scope.getParent().getVar(argumentName);\n              if (argumentVar != null && !argumentVar.isTypeInferred()) {\n                paramType = argumentVar.getType();\n              }\n            }\n\n            if (paramType == null) {\n              paramType = unknownType;\n            }\n\n            defineSlot(astParameter, functionNode, paramType, inferred);\n\n            if (jsDocParameter != null) {\n              jsDocParameter = jsDocParameter.getNext();\n            }\n            if (iifeArgumentNode != null) {\n              iifeArgumentNode = iifeArgumentNode.getNext();\n            }\n          }\n        }\n      }\n    } // end declareArguments\n",
        "begin_line": 2042,
        "end_line": 2086,
        "comment": "\n     * Declares all of a function's arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.shouldTolerateUndefinedValues#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.shouldTolerateUndefinedValues()",
        "snippet": "  public boolean shouldTolerateUndefinedValues() {\n    return tolerateUndefinedValues;\n  }\n",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.getScopeDeclaredIn#814",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getScopeDeclaredIn()",
        "snippet": "  private Scope getScopeDeclaredIn() {\n    int dotIndex = fnName.indexOf(\".\");\n    if (dotIndex != -1) {\n      String rootVarName = fnName.substring(0, dotIndex);\n      Var rootVar = scope.getVar(rootVarName);\n      if (rootVar != null) {\n        return rootVar.getScope();\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 814,
        "end_line": 824,
        "comment": "\n   * The scope that we should declare this function in, if it needs\n   * to be declared in a scope. Notice that TypedScopeCreator takes\n   * care of most scope-declaring.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectAllInterfaceProperties#590",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectAllInterfaceProperties(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }\n",
        "begin_line": 590,
        "end_line": 601,
        "comment": "\n   * Expect that all properties on interfaces that this type implements are\n   * implemented and correctly typed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkPropCreation#1023",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropCreation(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n    if (lvalue.isGetProp()) {\n      JSType objType = getJSType(lvalue.getFirstChild());\n      Node prop = lvalue.getLastChild();\n      if (objType.isStruct() && !objType.hasProperty(prop.getString())) {\n        report(t, prop, ILLEGAL_PROPERTY_CREATION);\n      }\n    }\n  }\n",
        "begin_line": 1023,
        "end_line": 1031,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0287
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getAllImplementedInterfaces#494",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getAllImplementedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getAllImplementedInterfaces() {\n    // Store them in a linked hash set, so that the compile job is\n    // deterministic.\n    Set<ObjectType> interfaces = Sets.newLinkedHashSet();\n\n    for (ObjectType type : getImplementedInterfaces()) {\n      addRelatedInterfaces(type, interfaces);\n    }\n    return interfaces;\n  }\n",
        "begin_line": 494,
        "end_line": 503,
        "comment": "\n   * Returns all interfaces implemented by a class or its superclass and any\n   * superclasses for any of those interfaces. If this is called before all\n   * types are resolved, it may return an incomplete set.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.process#380",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }\n",
        "begin_line": 380,
        "end_line": 394,
        "comment": "\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.check#417",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.check(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }\n",
        "begin_line": 417,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.markName#214",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(java.lang.String, com.google.javascript.rhino.jstype.StaticSourceFile, int, int)",
        "snippet": "  public void markName(String name, StaticSourceFile file,\n      int lineno, int charno) {\n    if (currentMarker != null) {\n      // Record the name as both a SourcePosition<String> and a\n      // SourcePosition<Node>. The <String> form is deprecated,\n      // because <Node> is more consistent with how other name\n      // references are handled (see #markTypeNode)\n      //\n      // TODO(nicksantos): Remove all uses of the Name position\n      // and replace them with the NameNode position.\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(name);\n      position.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setName(position);\n\n      SourcePosition<Node> nodePos =\n          new JSDocInfo.NamePosition();\n      Node node = Node.newString(Token.NAME, name, lineno, charno);\n      node.setLength(name.length());\n      node.setStaticSourceFile(file);\n      nodePos.setItem(node);\n      nodePos.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setNameNode(nodePos);\n    }\n  }\n",
        "begin_line": 214,
        "end_line": 241,
        "comment": "\n   * Adds a name declaration to the current marker.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordParameter#275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(java.lang.String, com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 275,
        "end_line": 283,
        "comment": "\n   * Records a typed parameter.\n   *\n   * @return {@code true} if the typed parameter was recorded and\n   *     {@code false} if a parameter with the same name was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.declareParam#953",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(com.google.javascript.rhino.JSTypeExpression, java.lang.String)",
        "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 953,
        "end_line": 964,
        "comment": "\n   * Declares a parameter. Parameters are described using the {@code @param}\n   * annotation.\n   *\n   * @param jsType the parameter's type, it may be {@code null} when the\n   *     {@code @param} annotation did not specify a type.\n   * @param parameter the parameter's name\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseAndRecordParamTypeNode#1288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    recordTypeNode(lineno, startCharno, typeNode, true);\n    return typeNode;\n  }\n",
        "begin_line": 1288,
        "end_line": 1296,
        "comment": "\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * Parameter type expressions are special for two reasons:\n   * <ol>\n   *   <li>They must begin with '{', to distinguish type names from param names.\n   *   <li>They may end in '=', to denote optionality.\n   * </ol>\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getBestLValue#3118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValue(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parent.isName()) {\n      return parent;\n    } else if (parent.isAssign()) {\n      return parent.getFirstChild();\n    } else if (isObjectLitKey(parent)) {\n      return parent;\n    } else if (\n        (parent.isHook() && parent.getFirstChild() != n) ||\n        parent.isOr() ||\n        parent.isAnd() ||\n        (parent.isComma() && parent.getFirstChild() != n)) {\n      return getBestLValue(parent);\n    } else if (parent.isCast()) {\n      return getBestLValue(parent);\n    }\n    return null;\n  }\n",
        "begin_line": 3118,
        "end_line": 3139,
        "comment": " Find the l-value that the given r-value is being assigned to. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isInstanceType#519",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isInstanceType()",
        "snippet": "  public boolean isInstanceType() {\n    return false;\n  }\n",
        "begin_line": 519,
        "end_line": 521,
        "comment": "\n   * Whether this type is an Instance object of some constructor.\n   * Does not necessarily mean this is an {@link InstanceObjectType}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isDict#297",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isDict()",
        "snippet": "  public boolean isDict() {\n    if (isObject()) {\n      ObjectType objType = toObjectType();\n      ObjectType iproto = objType.getImplicitPrototype();\n      // For the case when a @dict constructor is assigned to a function's\n      // prototype property\n      if (iproto != null && iproto.isDict()) {\n        return true;\n      }\n      FunctionType ctor = objType.getConstructor();\n      // This test is true for object literals\n      if (ctor == null) {\n        JSDocInfo info = objType.getJSDocInfo();\n        return info != null && info.makesDicts();\n      } else {\n        return ctor.makesDicts();\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 297,
        "end_line": 316,
        "comment": "\n   * Returns true iff {@code this} can be a {@code dict}.\n   * UnionType overrides the method, assume {@code this} is not a union here.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.ensurePropertyDefined#569",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDefined(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = obj.isThis() &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        // In general, we don't want to define a property on a struct object,\n        // b/c TypeCheck will later check for improper property creation on\n        // structs. There are two exceptions.\n        // 1) If it's a property created inside the constructor, on the newly\n        //    created instance, allow it.\n        // 2) If it's a prototype property, allow it. For example:\n        //    Foo.prototype.bar = baz;\n        //    where Foo.prototype is a struct and the assignment happens at the\n        //    top level and the constructor Foo is defined in the same file.\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return; // Early return to avoid creating the property below.\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (propCreationInConstructor) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }\n",
        "begin_line": 569,
        "end_line": 637,
        "comment": "\n   * Defines a property if the property has not been defined yet.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getBestLValueOwner#3156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueOwner(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue)) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }\n",
        "begin_line": 3156,
        "end_line": 3167,
        "comment": " Get the owner of the given l-value node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "InferJSDocInfo.process#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      inExterns = false;\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }\n",
        "begin_line": 72,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.makesDicts#232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.makesDicts()",
        "snippet": "  public boolean makesDicts() {\n    if (!isConstructor()) {\n      return false;\n    }\n    if (propAccess == PropAccess.DICT) {\n      return true;\n    }\n    FunctionType superc = getSuperClassConstructor();\n    if (superc != null && superc.makesDicts()) {\n      setDict();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 232,
        "end_line": 245,
        "comment": "\n   * When a class B inherits from A and A is annotated as a dict, then B\n   * automatically gets the annotation, even if B's constructor is not\n   * explicitly annotated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getParameters#277",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getParameters()",
        "snippet": "  public Iterable<Node> getParameters() {\n    Node n = getParametersNode();\n    if (n != null) {\n      return n.children();\n    } else {\n      return Collections.emptySet();\n    }\n  }\n",
        "begin_line": 277,
        "end_line": 284,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isPropertyTypeInferred#460",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isPropertyTypeInferred(java.lang.String)",
        "snippet": "  public boolean isPropertyTypeInferred(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : slot.isTypeInferred();\n  }\n",
        "begin_line": 460,
        "end_line": 463,
        "comment": "\n   * Checks whether the property's type is inferred.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.isConstantSymbol#1730",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.isConstantSymbol(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isConstantSymbol(JSDocInfo info, Node node) {\n      if (info != null && info.isConstant()) {\n        return true;\n      }\n\n      switch (node.getType()) {\n        case Token.NAME:\n          return NodeUtil.isConstantByConvention(\n              compiler.getCodingConvention(), node, node.getParent());\n        case Token.GETPROP:\n          return node.isQualifiedName() && NodeUtil.isConstantByConvention(\n              compiler.getCodingConvention(), node.getLastChild(), node);\n      }\n      return false;\n    }\n",
        "begin_line": 1730,
        "end_line": 1744,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.numUnfilledTemplateKeys#125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.numUnfilledTemplateKeys()",
        "snippet": "  int numUnfilledTemplateKeys() {\n    return templateKeys.size() - templateValues.size();\n  }\n",
        "begin_line": 125,
        "end_line": 127,
        "comment": "\n   * Returns the number of template keys in this map that do not have a\n   * corresponding JSType value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.getAlternates#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.getAlternates()",
        "snippet": "  public Collection<JSType> getAlternates() {\n    for (JSType t : alternates) {\n      if (t.isUnionType()) {\n        rebuildAlternates();\n        break;\n      }\n    }\n    return alternates;\n  }\n",
        "begin_line": 90,
        "end_line": 98,
        "comment": "\n   * Gets the alternate types of this union type.\n   * @return The alternate types of this union type. The returned set is\n   *     immutable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.expectNotNullOrUndefined#257",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectNotNullOrUndefined(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 257,
        "end_line": 283,
        "comment": "\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitGetProp#1404",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitGetProp(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n",
        "begin_line": 1404,
        "end_line": 1420,
        "comment": "\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkPropertyAccess#1429",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyAccess(com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    // If the property type is unknown, check the object type to see if it\n    // can ever be defined. We explicitly exclude CHECKED_UNKNOWN (for\n    // properties where we've checked that it exists, or for properties on\n    // objects that aren't in this binary).\n    JSType propType = getJSType(n);\n    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n      childType = childType.autobox();\n      ObjectType objectType = ObjectType.cast(childType);\n      if (objectType != null) {\n        // We special-case object types so that checks on enums can be\n        // much stricter, and so that we can use hasProperty (which is much\n        // faster in most cases).\n        if (!objectType.hasProperty(propName) ||\n            objectType.isEquivalentTo(\n                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n          if (objectType instanceof EnumType) {\n            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n          } else {\n            checkPropertyAccessHelper(objectType, propName, t, n);\n          }\n        }\n\n      } else {\n        checkPropertyAccessHelper(childType, propName, t, n);\n      }\n    }\n  }\n",
        "begin_line": 1429,
        "end_line": 1457,
        "comment": "\n   * Emit a warning if we can prove that a property cannot possibly be\n   * defined on an object. Note the difference between JS and a strictly\n   * statically typed language: we're checking if the property\n   * *cannot be defined*, whereas a java compiler would check if the\n   * property *can be undefined*.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.Node#448",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node, int, int)",
        "snippet": "  public Node(int nodeType, Node child, int lineno, int charno) {\n    this(nodeType, child);\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 448,
        "end_line": 451,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.wrapNode#2343",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int, com.google.javascript.rhino.Node)",
        "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 2343,
        "end_line": 2347,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion#288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
        "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }\n",
        "begin_line": 288,
        "end_line": 309,
        "comment": "\n   * Reduce the alternates into a non-union type.\n   * If the alternates can't be accurately represented with a non-union\n   * type, return null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getImplementedInterfaces#521",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getImplementedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getImplementedInterfaces() {\n    FunctionType superCtor = isConstructor() ?\n        getSuperClassConstructor() : null;\n    if (superCtor == null) {\n      return implementedInterfaces;\n    } else {\n      return Iterables.concat(\n          implementedInterfaces, superCtor.getImplementedInterfaces());\n    }\n  }\n",
        "begin_line": 521,
        "end_line": 530,
        "comment": " Returns interfaces implemented directly by a class or its superclass. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.processForTesting#397",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.processForTesting(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }\n",
        "begin_line": 397,
        "end_line": 414,
        "comment": " Main entry point of this phase for testing code. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getType#1165",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getType(int)",
        "snippet": "  private JSTypeExpression getType(int typefield) {\n    if ((MASK_TYPEFIELD & bitset) == typefield) {\n      return type;\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 1165,
        "end_line": 1171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0285
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.build#1974",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.build()",
        "snippet": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents != null) {\n        for (String varName : contents.getEscapedVarNames()) {\n          Var v = scope.getVar(varName);\n          Preconditions.checkState(v.getScope() == scope);\n          v.markEscaped();\n        }\n\n        for (Multiset.Entry<String> entry :\n                 contents.getAssignedNameCounts().entrySet()) {\n          Var v = scope.getVar(entry.getElement());\n          Preconditions.checkState(v.getScope() == scope);\n          if (entry.getCount() == 1) {\n            v.markAssignedExactlyOnce();\n          }\n        }\n      }\n    }\n",
        "begin_line": 1974,
        "end_line": 1995,
        "comment": "\n     * Traverse the scope root and build it.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.markAssignedExactlyOnce#335",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.markAssignedExactlyOnce()",
        "snippet": "    void markAssignedExactlyOnce() {\n      markedAssignedExactlyOnce = true;\n    }\n",
        "begin_line": 335,
        "end_line": 337,
        "comment": "\n     * Record that this is assigned exactly once..\n     *\n     * In other words, it's assigned in an inner scope so that it's much harder\n     * to make assertions about its value at a given point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getBestJSDocInfo#3087",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestJSDocInfo(com.google.javascript.rhino.Node)",
        "snippet": "  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return getBestJSDocInfo(parent);\n      } else if (isObjectLitKey(parent)) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isCast()) {\n        return parent.getJSDocInfo();\n      }\n    }\n    return info;\n  }\n",
        "begin_line": 3087,
        "end_line": 3115,
        "comment": " Find the best JSDoc for the given node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createConstructorType#1448",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createConstructorType(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.TemplateType>)",
        "snippet": "  public FunctionType createConstructorType(String name, Node source,\n      Node parameters, JSType returnType, ImmutableList<TemplateType> templateKeys) {\n    return new FunctionType(this, name, source,\n        createArrowType(parameters, returnType), null,\n        createTemplateTypeMap(templateKeys, null), true, false);\n  }\n",
        "begin_line": 1448,
        "end_line": 1453,
        "comment": "\n   * Creates a constructor function type.\n   * @param name the function's name or {@code null} to indicate that the\n   *     function is anonymous.\n   * @param source the node defining this function. Its type\n   *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n   * @param parameters the function's parameters or {@code null}\n   *     to indicate that the parameter types are unknown.\n   * @param returnType the function's return type or {@code null} to indicate\n   *     that the return type is unknown.\n   * @param templateKeys the templatized types for the class.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.ensurePropertyDeclaredHelper#658",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclaredHelper(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 658,
        "end_line": 677,
        "comment": "\n   * Declares a property on its owner, if necessary.\n   * @return True if a property was declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.ensureTyped#2028",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }\n",
        "begin_line": 2028,
        "end_line": 2030,
        "comment": "\n   * Ensure that the given node has a type. If it does not have one,\n   * attach the UNKNOWN_TYPE.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getObjectSlot#1751",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getObjectSlot(java.lang.String)",
        "snippet": "    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }\n",
        "begin_line": 1751,
        "end_line": 1759,
        "comment": "\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkEnumAlias#1982",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkEnumAlias(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkEnumAlias(\n      NodeTraversal t, JSDocInfo declInfo, Node value) {\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n      return;\n    }\n\n    JSType valueType = getJSType(value);\n    if (!valueType.isEnumType()) {\n      return;\n    }\n\n    EnumType valueEnumType = valueType.toMaybeEnumType();\n    JSType valueEnumPrimitiveType =\n        valueEnumType.getElementsType().getPrimitiveType();\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n        \"incompatible enum element types\");\n  }\n",
        "begin_line": 1982,
        "end_line": 1999,
        "comment": "\n   * <p>Checks enum aliases.\n   *\n   * <p>We verify that the enum element type of the enum used\n   * for initialization is a subtype of the enum element type of\n   * the enum the value is being copied in.</p>\n   *\n   * <p>Example:</p>\n   * <pre>var myEnum = myOtherEnum;</pre>\n   *\n   * <p>Enum aliases are irregular, so we need special code for this :(</p>\n   *\n   * @param value the value used for initialization of the enum\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isPropertyTypeDeclared#468",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isPropertyTypeDeclared(java.lang.String)",
        "snippet": "  public boolean isPropertyTypeDeclared(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : !slot.isTypeInferred();\n  }\n",
        "begin_line": 468,
        "end_line": 471,
        "comment": "\n   * Checks whether the property's type is declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.handleFunctionInputs#2018",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.handleFunctionInputs(com.google.javascript.rhino.Node)",
        "snippet": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n",
        "begin_line": 2018,
        "end_line": 2037,
        "comment": " Handle bleeding functions and function parameters. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0284
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#369",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, NodeUtil.getBestJSDocInfo(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.isAssign()) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 369,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.identifyNameNode#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.identifyNameNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void identifyNameNode(\n        Node nameNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }\n",
        "begin_line": 392,
        "end_line": 403,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.setNode#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setNode(com.google.javascript.rhino.Node)",
        "snippet": "  public void setNode(Node n) {\n    this.propertyNode = n;\n  }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.shouldTraverse#483",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      if (n.isFunction() ||\n          n.isScript()) {\n        Preconditions.checkNotNull(inputId);\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }\n",
        "begin_line": 483,
        "end_line": 512,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineFunctionLiteral#790",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineFunctionLiteral(com.google.javascript.rhino.Node)",
        "snippet": "    void defineFunctionLiteral(Node n) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and l-value for the function.\n      // Any of these may be null.\n      Node lValue = NodeUtil.getBestLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      String functionName = NodeUtil.getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }\n",
        "begin_line": 790,
        "end_line": 810,
        "comment": "\n     * Defines a function literal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getNameNode#242",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getNameNode()",
        "snippet": "    public Node getNameNode() {\n      return nameNode;\n    }\n",
        "begin_line": 242,
        "end_line": 244,
        "comment": "\n     * Returns the name node that produced this variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getSlot#336",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getSlot(String name) {\n    if (\"prototype\".equals(name)) {\n      // Lazy initialization of the prototype field.\n      getPrototype();\n      return prototypeSlot;\n    } else {\n      return super.getSlot(name);\n    }\n  }\n",
        "begin_line": 336,
        "end_line": 345,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineSlot#1132",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() ||\n            parent.isCatch());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() &&\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }\n",
        "begin_line": 1132,
        "end_line": 1150,
        "comment": "\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.isDeclared#552",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isDeclared(java.lang.String, boolean)",
        "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name)) {\n      return true;\n    }\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }\n",
        "begin_line": 552,
        "end_line": 561,
        "comment": "\n   * Returns true if a variable is declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isStruct#272",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isStruct()",
        "snippet": "  public boolean isStruct() {\n    if (isObject()) {\n      ObjectType objType = toObjectType();\n      ObjectType iproto = objType.getImplicitPrototype();\n      // For the case when a @struct constructor is assigned to a function's\n      // prototype property\n      if (iproto != null && iproto.isStruct()) {\n        return true;\n      }\n      FunctionType ctor = objType.getConstructor();\n      // This test is true for object literals\n      if (ctor == null) {\n        JSDocInfo info = objType.getJSDocInfo();\n        return info != null && info.makesStructs();\n      } else {\n        return ctor.makesStructs();\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 272,
        "end_line": 291,
        "comment": "\n   * Returns true iff {@code this} can be a {@code struct}.\n   * UnionType overrides the method, assume {@code this} is not a union here.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0283
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.isExprStmt#361",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.isExprStmt(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private static boolean isExprStmt(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT\n        || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID;\n  }\n",
        "begin_line": 361,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.findPropertyType#404",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.findPropertyType(java.lang.String)",
        "snippet": "  @Override\n  public JSType findPropertyType(String propertyName) {\n    return hasProperty(propertyName) ?\n        getPropertyType(propertyName) : null;\n  }\n",
        "begin_line": 404,
        "end_line": 408,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.makesStructs#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.makesStructs()",
        "snippet": "  public boolean makesStructs() {\n    if (!isConstructor()) {\n      return false;\n    }\n    if (propAccess == PropAccess.STRUCT) {\n      return true;\n    }\n    FunctionType superc = getSuperClassConstructor();\n    if (superc != null && superc.makesStructs()) {\n      setStruct();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 212,
        "end_line": 225,
        "comment": "\n   * When a class B inherits from A and A is annotated as a struct, then B\n   * automatically gets the annotation, even if B's constructor is not\n   * explicitly annotated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isNoTypeCheck#538",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoTypeCheck()",
        "snippet": "  public boolean isNoTypeCheck() {\n    return getFlag(MASK_NOCHECK);\n  }\n",
        "begin_line": 538,
        "end_line": 540,
        "comment": "\n   * Returns whether the {@code @nocheck} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#2120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }\n",
        "begin_line": 2120,
        "end_line": 2171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "GoogleCodingConvention.isConstantKey#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstantKey(java.lang.String)",
        "snippet": "  @Override\n  public boolean isConstantKey(String name) {\n    if (name.isEmpty() || !Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }\n",
        "begin_line": 89,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.recordAssignedName#991",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.recordAssignedName(java.lang.String)",
        "snippet": "    void recordAssignedName(String name) {\n      assignedVarNames.add(name);\n    }\n",
        "begin_line": 991,
        "end_line": 993,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.inferQualifiedSlot#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferQualifiedSlot(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n      JSType inferredType) {\n    Scope functionScope = getFunctionScope();\n    if (functionScope.isLocal()) {\n      if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {\n        functionScope.declare(symbol, node, bottomType, null);\n      }\n\n      inferSlotType(symbol, inferredType);\n    }\n  }\n",
        "begin_line": 111,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.maybeDeclareQualifiedName#1914",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.maybeDeclareQualifiedName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }\n",
        "begin_line": 1914,
        "end_line": 1920,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.isTypeInferred#117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.isTypeInferred()",
        "snippet": "  @Override\n      public boolean isTypeInferred() {\n    return inferred;\n  }\n",
        "begin_line": 117,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.declareType#850",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.declareType(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean declareType(String name, JSType t) {\n    if (namesToTypes.containsKey(name)) {\n      return false;\n    }\n    register(t, name);\n    return true;\n  }\n",
        "begin_line": 850,
        "end_line": 856,
        "comment": "\n   * Records declared global type names. This makes resolution faster\n   * and more robust in the common case.\n   *\n   * @param name The name of the type to be recorded.\n   * @param t The actual type being associated with the name.\n   * @return True if this name is not already defined, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.shouldTraverse#217",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 217,
        "end_line": 292,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.ensureTyped#2032",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }\n",
        "begin_line": 2032,
        "end_line": 2034,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "InferJSDocInfo.dereferenceToObject#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.dereferenceToObject(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private ObjectType dereferenceToObject(JSType type) {\n    return ObjectType.cast(type == null ? null : type.dereference());\n  }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": "\n   * Dereferences the given type to an object, or returns null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.dereference#797",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.dereference()",
        "snippet": "  public final ObjectType dereference() {\n    return autobox().toObjectType();\n  }\n",
        "begin_line": 797,
        "end_line": 799,
        "comment": "\n   * Dereference a type for property access.\n   *\n   * Filters null/undefined, autoboxes the resulting type, and returns it\n   * iff it's an object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0281
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.autoboxesTo#756",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.autoboxesTo()",
        "snippet": "  public JSType autoboxesTo() {\n    return null;\n  }\n",
        "begin_line": 756,
        "end_line": 758,
        "comment": "\n   * Turn a scalar type to the corresponding object type.\n   *\n   * @return the auto-boxed type or {@code null} if this type is not a scalar.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getTypeOfThis#456",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getTypeOfThis()",
        "snippet": "  @Override\n  public JSType getTypeOfThis() {\n    if (isGlobal()) {\n      return ObjectType.cast(rootNode.getJSType());\n    }\n\n    Preconditions.checkState(rootNode.isFunction());\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType.isFunctionType()) {\n      return nodeType.toMaybeFunctionType().getTypeOfThis();\n    } else {\n      return parent.getTypeOfThis();\n    }\n  }\n",
        "begin_line": 456,
        "end_line": 469,
        "comment": "\n   * Gets the type of {@code this} in the current scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isUnknownType#552",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }\n",
        "begin_line": 552,
        "end_line": 572,
        "comment": "\n   * We treat this as the unknown type if any of its implicit prototype\n   * properties is unknown.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.autobox#785",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.autobox()",
        "snippet": "  public JSType autobox() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return autobox == null ? restricted : autobox;\n  }\n",
        "begin_line": 785,
        "end_line": 789,
        "comment": "\n   * Dereference a type for property access.\n   *\n   * Filters null/undefined and autoboxes the resulting type.\n   * Never returns null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitName#1365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.PARAM_LIST ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n",
        "begin_line": 1365,
        "end_line": 1394,
        "comment": "\n   * Visits a NAME node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   * @return whether the node is typeable or not\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.shouldTraverse#458",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // normal type checking\n        final Scope outerScope = t.getScope();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            // Ideally, we would want to check whether the type in the scope\n            // differs from the type being defined, but then the extern\n            // redeclarations of built-in types generates spurious warnings.\n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        // TODO(user): Only traverse the function's body. The function's\n        // name and arguments are traversed by the scope creator, and ideally\n        // should not be traversed by the type checker.\n        break;\n    }\n    return true;\n  }\n",
        "begin_line": 458,
        "end_line": 483,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.getJSType#2005",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.getJSType(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n",
        "begin_line": 2005,
        "end_line": 2016,
        "comment": "\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getAssertionFunctions#208",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getAssertionFunctions()",
        "snippet": "    @Override\n    public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n      return nextConvention.getAssertionFunctions();\n    }\n",
        "begin_line": 208,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getTemplateTypeKeyByName#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getTemplateTypeKeyByName(java.lang.String)",
        "snippet": "  public TemplateType getTemplateTypeKeyByName(String keyName) {\n    for (TemplateType key : templateKeys) {\n      if (key.getReferenceName().equals(keyName)) {\n        return key;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 155,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getType#927",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.lang.String, java.lang.String, int, int)",
        "snippet": "  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno) {\n    // Resolve template type names\n    JSType type = null;\n    JSType thisType = null;\n    if (scope != null && scope.getTypeOfThis() != null) {\n      thisType = scope.getTypeOfThis().toObjectType();\n    }\n    if (thisType != null) {\n      type = thisType.getTemplateTypeMap().getTemplateTypeKeyByName(jsTypeName);\n      if (type != null) {\n        Preconditions.checkState(type.isTemplateType(), \"expected:\" + type);\n        return type;\n      }\n    }\n\n    type = getType(jsTypeName);\n    if (type == null) {\n      // TODO(user): Each instance should support named type creation using\n      // interning.\n      NamedType namedType = createNamedType(jsTypeName, sourceName, lineno, charno);\n      unresolvedNamedTypes.put(scope, namedType);\n      type = namedType;\n    }\n    return type;\n  }\n",
        "begin_line": 927,
        "end_line": 952,
        "comment": "\n   * Looks up a type by name. To allow for forward references to types, an\n   * unrecognized string has to be bound to a NamedType object that will be\n   * resolved later.\n   *\n   * @param scope A scope for doing type name resolution.\n   * @param jsTypeName The name string.\n   * @param sourceName The name of the source file where this reference appears.\n   * @param lineno The line number of the reference.\n   * @return a NamedType if the string argument is not one of the known types,\n   *     otherwise the corresponding JSType object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.doPercentTypedAccounting#890",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.doPercentTypedAccounting(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes) {\n        compiler.report(t.makeError(n, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n",
        "begin_line": 890,
        "end_line": 902,
        "comment": "\n   * Counts the given node in the typed statistics.\n   * @param n a node that should be typed\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.reconcileOptionsWithGuards#313",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.reconcileOptionsWithGuards()",
        "snippet": "  protected void reconcileOptionsWithGuards() {\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !options.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      options.setWarningLevel(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF);\n    }\n  }\n",
        "begin_line": 313,
        "end_line": 352,
        "comment": "\n   * When the CompilerOptions and its WarningsGuard overlap, reconcile\n   * any discrepencies.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.getNativeType#2084",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n",
        "begin_line": 2084,
        "end_line": 2086,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.028
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.isUnknownType#264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    for (JSType t : alternates) {\n      if (t.isUnknownType()) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 264,
        "end_line": 272,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0279
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isObject#574",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isObject()",
        "snippet": "  @Override\n  public boolean isObject() {\n    return true;\n  }\n",
        "begin_line": 574,
        "end_line": 577,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0279
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeEnumType#378",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeEnumType()",
        "snippet": "  public EnumType toMaybeEnumType() {\n    return null;\n  }\n",
        "begin_line": 378,
        "end_line": 380,
        "comment": "\n   * Downcasts this to an EnumType, or returns null if this is not an EnumType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0279
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.isEmpty#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.isEmpty()",
        "snippet": "  public boolean isEmpty() {\n    return templateKeys.isEmpty();\n  }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n   * Returns true if the map is empty; false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isJavaDispatch#642",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
        "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }\n",
        "begin_line": 642,
        "end_line": 644,
        "comment": "\n   * Returns whether the {@code @javadispatch} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.setShouldReport#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.setShouldReport(boolean)",
        "snippet": "  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.checkNoTypeCheckSection#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkNoTypeCheckSection(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }\n",
        "begin_line": 431,
        "end_line": 449,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isEnumType#371",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEnumType()",
        "snippet": "  public boolean isEnumType() {\n    return toMaybeEnumType() != null;\n  }\n",
        "begin_line": 371,
        "end_line": 373,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasChildren#533",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasChildren()",
        "snippet": "  public boolean hasChildren() {\n    return first != null;\n  }\n",
        "begin_line": 533,
        "end_line": 535,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordReturnType#524",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordReturnType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordReturnType(JSTypeExpression jsType) {\n    if (jsType != null && currentInfo.getReturnType() == null &&\n        !hasAnySingletonTypeTags()) {\n      currentInfo.setReturnType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 524,
        "end_line": 533,
        "comment": "\n   * Records a return type.\n   *\n   * @return {@code true} if the return type was recorded and {@code false} if\n   *     it is invalid or was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setReturnType#1069",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setReturnType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setReturnType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1069,
        "end_line": 1071,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getReturnType#1147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getReturnType()",
        "snippet": "  public JSTypeExpression getReturnType() {\n    return getType(TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1147,
        "end_line": 1149,
        "comment": "\n   * Gets the return type specified by the {@code @return} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createFromTypeNodes#1576",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodes(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public JSType createFromTypeNodes(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    return createFromTypeNodesInternal(n, sourceName, scope);\n  }\n",
        "begin_line": 1576,
        "end_line": 1579,
        "comment": "\n   * Creates a JSType from the nodes representing a type.\n   * @param n The node with type info.\n   * @param sourceName The source file name.\n   * @param scope A scope for doing type name lookups.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeExpression.evaluate#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.evaluate(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n    root.setJSType(type);\n    return type;\n  }\n",
        "begin_line": 103,
        "end_line": 107,
        "comment": "\n   * Evaluates the type expression into a {@code JSType} object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.TypeCheck#324",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.MemoizedScopeCreator, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      MemoizedScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = ((Compiler) compiler).getOptions().enables(\n        DiagnosticGroups.REPORT_UNKNOWN_TYPES);\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n\n    ClassLoader classLoader = TypeCheck.class.getClassLoader();\n    try {\n      Class<?> c = classLoader.loadClass(\n          \"com.google.common.string.EditDistance\");\n      editDistance = c.getDeclaredMethod(\n          \"getEditDistance\", String.class, String.class, boolean.class);\n    } catch (Exception ignored) {\n      editDistance = null;\n    }\n  }\n",
        "begin_line": 324,
        "end_line": 350,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#1900",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 1900,
        "end_line": 1912,
        "comment": "\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getScope#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getScope()",
        "snippet": "    Scope getScope() {\n      return scope;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Gets the scope where this variable is declared.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0278
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasChild#1414",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasChild(com.google.javascript.rhino.Node)",
        "snippet": "  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 1414,
        "end_line": 1421,
        "comment": " Intended for testing and verification only.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "InferJSDocInfo.InferJSDocInfo#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.InferJSDocInfo(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  InferJSDocInfo(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseGetProp#1271",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseGetProp(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n",
        "begin_line": 1271,
        "end_line": 1280,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.dereferencePointer#1309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.dereferencePointer(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 1309,
        "end_line": 1318,
        "comment": "\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseAssign#504",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseAssign(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }\n",
        "begin_line": 504,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.setType#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.setType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    void setType(JSType type) {\n      Preconditions.checkState(isTypeInferred());\n      this.type = type;\n    }\n",
        "begin_line": 258,
        "end_line": 261,
        "comment": "\n     * Sets this variable's type.\n     * @throws IllegalStateException if the variable's type is not inferred\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordType#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordType(JSTypeExpression type) {\n    if (type != null && !hasAnyTypeRelatedTags()) {\n      currentInfo.setType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 477,
        "end_line": 485,
        "comment": "\n   * Records a type.\n   *\n   * @return {@code true} if the type was recorded and {@code false} if\n   *     it is invalid or was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setType#1065",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1065,
        "end_line": 1067,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.checkEquivalenceHelper#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.checkEquivalenceHelper(com.google.javascript.rhino.jstype.TemplateTypeMap, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  public boolean checkEquivalenceHelper(\n      TemplateTypeMap that, EquivalenceMethod eqMethod) {\n    ImmutableList<TemplateType> thisKeys = getTemplateKeys();\n    ImmutableList<TemplateType> thatKeys = that.getTemplateKeys();\n\n    EquivalenceMatch[] thatMatches = new EquivalenceMatch[thatKeys.size()];\n    Arrays.fill(thatMatches, EquivalenceMatch.NO_KEY_MATCH);\n\n    for (int i = 0; i < thisKeys.size(); i++) {\n      TemplateType thisKey = thisKeys.get(i);\n      JSType thisType = getResolvedTemplateType(thisKey);\n      EquivalenceMatch thisMatch = EquivalenceMatch.NO_KEY_MATCH;\n\n      for (int j = 0; j < thatKeys.size(); j++) {\n        TemplateType thatKey = thatKeys.get(j);\n        JSType thatType = that.getResolvedTemplateType(thatKey);\n\n        // Cross-compare every key-value pair in this TemplateTypeMap with\n        // those in that TemplateTypeMap. Update the Equivalence match for both\n        // key-value pairs involved.\n        if (thisKey == thatKey) {\n          EquivalenceMatch newMatchType = EquivalenceMatch.VALUE_MISMATCH;\n          if (thisType.checkEquivalenceHelper(thatType, eqMethod)) {\n            newMatchType = EquivalenceMatch.VALUE_MATCH;\n          }\n\n          if (thisMatch != EquivalenceMatch.VALUE_MATCH) {\n            thisMatch = newMatchType;\n          }\n          if (thatMatches[j] != EquivalenceMatch.VALUE_MATCH) {\n            thatMatches[j] = newMatchType;\n          }\n        }\n      }\n\n      if (failedEquivalenceCheck(thisMatch, eqMethod)) {\n        return false;\n      }\n    }\n\n    for (int i = 0; i < thatMatches.length; i++) {\n      if (failedEquivalenceCheck(thatMatches[i], eqMethod)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n",
        "begin_line": 196,
        "end_line": 243,
        "comment": "\n   * Determines if this map and the specified map have equivalent template\n   * types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0277
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isDec#2273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isDec()",
        "snippet": "  public boolean isDec() {\n    return this.getType() == Token.DEC;\n  }\n",
        "begin_line": 2273,
        "end_line": 2275,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isInc#2333",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isInc()",
        "snippet": "  public boolean isInc() {\n    return this.getType() == Token.INC;\n  }\n",
        "begin_line": 2333,
        "end_line": 2335,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isThis#2413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isThis()",
        "snippet": "  public boolean isThis() {\n    return this.getType() == Token.THIS;\n  }\n",
        "begin_line": 2413,
        "end_line": 2415,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getJSDocInfo#140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getJSDocInfo()",
        "snippet": "  @Override\n  public JSDocInfo getJSDocInfo() {\n    return docInfo;\n  }\n",
        "begin_line": 140,
        "end_line": 143,
        "comment": "\n   * Gets the docInfo for this type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getImplementedInterfaceCount#1410",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaceCount()",
        "snippet": "  public int getImplementedInterfaceCount() {\n    if (info == null || info.implementedInterfaces == null) {\n      return 0;\n    }\n    return info.implementedInterfaces.size();\n  }\n",
        "begin_line": 1410,
        "end_line": 1415,
        "comment": "\n   * Gets the number of interfaces specified by the {@code @implements}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.hasAnyTypeRelatedTags#1165",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnyTypeRelatedTags()",
        "snippet": "  private boolean hasAnyTypeRelatedTags() {\n    return currentInfo.isConstructor() ||\n        currentInfo.isInterface() ||\n        currentInfo.getParameterCount() > 0 ||\n        currentInfo.hasReturnType() ||\n        currentInfo.hasBaseType() ||\n        currentInfo.getExtendedInterfacesCount() > 0 ||\n        currentInfo.getLendsName() != null ||\n        currentInfo.hasThisType() ||\n        hasAnySingletonTypeTags();\n  }\n",
        "begin_line": 1165,
        "end_line": 1175,
        "comment": "\n   * Whether the current doc info has other type tags, like\n   * {@code @param} or {@code @return} or {@code @type} or etc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getLendsName#1247",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getLendsName()",
        "snippet": "  public String getLendsName() {\n    return (info == null) ? null : info.lendsName;\n  }\n",
        "begin_line": 1247,
        "end_line": 1249,
        "comment": "\n   * Gets the name we're lending to in a {@code @lends} annotation.\n   *\n   * In many reflection APIs, you pass an anonymous object to a function,\n   * and that function mixes the anonymous object into another object.\n   * The {@code @lends} annotation allows the type system to track\n   * those property assignments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getExtendedInterfacesCount#1450",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getExtendedInterfacesCount()",
        "snippet": "  public int getExtendedInterfacesCount() {\n    if (info == null || info.extendedInterfaces == null) {\n      return 0;\n    }\n    return info.extendedInterfaces.size();\n  }\n",
        "begin_line": 1450,
        "end_line": 1455,
        "comment": "\n   * Gets the number of extended interfaces specified\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0276
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.makesDicts#513",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.makesDicts()",
        "snippet": "  public boolean makesDicts() {\n    return getFlag(MASK_DICT);\n  }\n",
        "begin_line": 513,
        "end_line": 515,
        "comment": "\n   * Returns whether the {@code @dict} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.makesStructs#505",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.makesStructs()",
        "snippet": "  public boolean makesStructs() {\n    return getFlag(MASK_STRUCT);\n  }\n",
        "begin_line": 505,
        "end_line": 507,
        "comment": "\n   * Returns whether the {@code @struct} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.attachLiteralTypes#573",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.attachLiteralTypes(com.google.javascript.rhino.Node)",
        "snippet": "    private void attachLiteralTypes(Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }\n",
        "begin_line": 573,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isImplicitPrototype#529",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isTemplatizedType()) {\n        current = current.toMaybeTemplatizedType().getReferencedType();\n      }\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 529,
        "end_line": 541,
        "comment": "\n   * Checks that the prototype is an implicit prototype of this object. Since\n   * each object has an implicit prototype, an implicit prototype's\n   * implicit prototype is also this implicit prototype's.\n   *\n   * @param prototype any prototype based object\n   *\n   * @return {@code true} if {@code prototype} is {@code equal} to any\n   *         object in this object's implicit prototype chain.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.checkForTypedef#1928",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.checkForTypedef(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recursive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, unknownType);\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.isGetProp()) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }\n",
        "begin_line": 1928,
        "end_line": 1956,
        "comment": "\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getInitialValue#226",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getInitialValue()",
        "snippet": "    public Node getInitialValue() {\n      return NodeUtil.getRValueOfLValue(nameNode);\n    }\n",
        "begin_line": 226,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.getSecondaryParents#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getSecondaryParents()",
        "snippet": "  Iterable<PropertyMap> getSecondaryParents() {\n    if (parentSource == null) {\n      return ImmutableList.of();\n    }\n    Iterable<ObjectType> extendedInterfaces =\n        parentSource.getCtorExtendedInterfaces();\n\n    // Most of the time, this will be empty.\n    if (Iterables.isEmpty(extendedInterfaces)) {\n      return ImmutableList.of();\n    }\n\n    return Iterables.transform(extendedInterfaces, PROP_MAP_FROM_TYPE);\n  }\n",
        "begin_line": 110,
        "end_line": 123,
        "comment": "\n   * Returns the secondary parents of this property map, for interfaces that\n   * need multiple inheritance.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.hasProperty#434",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasProperty(java.lang.String)",
        "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isEmptyType() || isUnknownType() || getSlot(propertyName) != null;\n  }\n",
        "begin_line": 434,
        "end_line": 438,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getOptions#2284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getOptions()",
        "snippet": "  CompilerOptions getOptions() {\n    return options;\n  }\n",
        "begin_line": 2284,
        "end_line": 2286,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.getPrimaryParent#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getPrimaryParent()",
        "snippet": "  PropertyMap getPrimaryParent() {\n    if (parentSource == null) {\n      return null;\n    }\n    ObjectType iProto = parentSource.getImplicitPrototype();\n    return iProto == null ? null : iProto.getPropertyMap();\n  }\n",
        "begin_line": 98,
        "end_line": 104,
        "comment": " Returns the direct parent of this property map. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.setJSDocInfo#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n    docInfo = info;\n  }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n   * Sets the docInfo for this type from the given\n   * {@link JSDocInfo}. The {@code JSDocInfo} may be {@code null}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.matchChar#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
        "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }\n",
        "begin_line": 258,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.ungetCharIgnoreLineEnd#437",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetCharIgnoreLineEnd(int)",
        "snippet": "  private void ungetCharIgnoreLineEnd(int c) {\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }\n",
        "begin_line": 437,
        "end_line": 440,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getSlot#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getSlot(String name) {\n    return getPropertyMap().getSlot(name);\n  }\n",
        "begin_line": 114,
        "end_line": 117,
        "comment": "\n   * Default getSlot implementation. This gets overridden by FunctionType\n   * for lazily-resolved prototypes.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.eatTokensUntilEOL#2397",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }\n",
        "begin_line": 2397,
        "end_line": 2406,
        "comment": "\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getChar#335",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
        "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for (;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }\n",
        "begin_line": 335,
        "end_line": 389,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.toMaybeUnionType#377",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.toMaybeUnionType()",
        "snippet": "  @Override\n  public UnionType toMaybeUnionType() {\n    return this;\n  }\n",
        "begin_line": 377,
        "end_line": 380,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withName#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withName(java.lang.String)",
        "snippet": "  public FunctionBuilder withName(String name) {\n    this.name = name;\n    return this;\n  }\n",
        "begin_line": 70,
        "end_line": 73,
        "comment": " Set the name of the function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withSourceNode#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withSourceNode(com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionBuilder withSourceNode(Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }\n",
        "begin_line": 76,
        "end_line": 79,
        "comment": " Set the source node of the function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withReturnType#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n    this.returnType = returnType;\n    this.inferredReturnType = inferred;\n    return this;\n  }\n",
        "begin_line": 102,
        "end_line": 106,
        "comment": " Set the return type and whether it's inferred. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.isAllowedProp#928",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.isAllowedProp(java.lang.String)",
        "snippet": "    private boolean isAllowedProp(String identifier) {\n      if (config.languageMode == LanguageMode.ECMASCRIPT3) {\n        return !TokenStream.isKeyword(identifier);\n      }\n      return true;\n    }\n",
        "begin_line": 928,
        "end_line": 933,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withTypeOfThis#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTypeOfThis(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public FunctionBuilder withTypeOfThis(JSType typeOfThis) {\n    this.typeOfThis = typeOfThis;\n    return this;\n  }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": " Set the \"this\" type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withTemplateKeys#122",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTemplateKeys(com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.TemplateType>)",
        "snippet": "  public FunctionBuilder withTemplateKeys(\n      ImmutableList<TemplateType> templateKeys) {\n    this.templateTypeMap = registry.createTemplateTypeMap(templateKeys, null);\n    return this;\n  }\n",
        "begin_line": 122,
        "end_line": 126,
        "comment": " Set the template name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0274
        },
        "num_failing_tests": 2
    },
    {
        "name": "SyntacticScopeCreator.scanRoot#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(com.google.javascript.rhino.Node)",
        "snippet": "  private void scanRoot(Node n) {\n    if (n.isFunction()) {\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n        // TODO(johnlenz): inputId maybe null if the FUNCTION node is detached\n        // from the AST.\n        // Is it meaningful to build a scope for detached FUNCTION node?\n      }\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.isParamList());\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.isName());\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n);\n    }\n  }\n",
        "begin_line": 72,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isBleedingFunctionName#1982",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isBleedingFunctionName(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }\n",
        "begin_line": 1982,
        "end_line": 1985,
        "comment": "\n   * Returns whether this is a bleeding function (an anonymous named function\n   * that bleeds into the inner scope).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroupWarningsGuard.enables#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 45,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineVar#770",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineVar(com.google.javascript.rhino.Node)",
        "snippet": "    void defineVar(Node n) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, (info != null) ? info : name.getJSDocInfo());\n      }\n    }\n",
        "begin_line": 770,
        "end_line": 785,
        "comment": "\n     * Defines a VAR initialization.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.lookAheadForTypeAnnotation#2515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.lookAheadForTypeAnnotation()",
        "snippet": "  private boolean lookAheadForTypeAnnotation() {\n    boolean matchedLc = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == '{') {\n        matchedLc = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matchedLc;\n  }\n",
        "begin_line": 2515,
        "end_line": 2531,
        "comment": "\n   * Look ahead for a type annotation by advancing the character stream.\n   * Does not modify the token stream.\n   * This is kind of a hack, and is only necessary because we use the token\n   * stream to parse types, but need the underlying character stream to get\n   * JsDoc descriptions.\n   * @return Whether we found a type annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineName#820",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineName(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void defineName(Node name, Node var, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        type = name.isFromExterns() ? unknownType : null;\n      }\n      defineSlot(name, var, type);\n    }\n",
        "begin_line": 820,
        "end_line": 830,
        "comment": "\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "SyntacticScopeCreator.scanVars#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(com.google.javascript.rhino.Node)",
        "snippet": "  private void scanVars(Node n) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().isName());\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        inputId = n.getInputId();\n        Preconditions.checkNotNull(inputId);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child);\n        child = next;\n      }\n    }\n  }\n",
        "begin_line": 112,
        "end_line": 166,
        "comment": "\n   * Scans and gather variables declarations under a Node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isLValue#2075",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isLValue(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean isLValue(Node n) {\n    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n        n.isGetElem());\n    Node parent = n.getParent();\n    if (parent == null) {\n      return false;\n    }\n    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n        || parent.isVar()\n        || (parent.isFunction() && parent.getFirstChild() == n)\n        || parent.isDec()\n        || parent.isInc()\n        || parent.isParamList()\n        || parent.isCatch();\n  }\n",
        "begin_line": 2075,
        "end_line": 2090,
        "comment": "\n   * Determines whether this node is used as an L-value. Notice that sometimes\n   * names are used as both L-values and R-values.\n   *\n   * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n   * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n   * we're honest with ourselves, it doesn't make sense, and we only do this\n   * because it makes sense to treat this as syntactically similar to\n   * \"var x = 0;\".\n   *\n   * @param n The node\n   * @return True if n is an L-value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processStringLiteral#1078",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processStringLiteral(com.google.javascript.rhino.head.ast.StringLiteral)",
        "snippet": "    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n      String value = literalNode.getValue();\n      Node n = newStringNode(value);\n      if (value.indexOf('\\u000B') != -1) {\n        // NOTE(nicksantos): In JavaScript, there are 3 ways to\n        // represent a vertical tab: \\v, \\x0B, \\u000B.\n        // The \\v notation was added later, and is not understood\n        // on IE. So we need to preserve it as-is. This is really\n        // obnoxious, because we do not have a good way to represent\n        // how the original string was encoded without making the\n        // representation of strings much more complicated.\n        //\n        // To handle this, we look at the original source test, and\n        // mark the string as \\v-encoded or not. If a string is\n        // \\v encoded, then all the vertical tabs in that string\n        // will be encoded with a \\v.\n        int start = literalNode.getAbsolutePosition();\n        int end = start + literalNode.getLength();\n        if (start < sourceString.length() &&\n            (sourceString.substring(\n                 start, Math.min(sourceString.length(), end))\n             .indexOf(\"\\\\v\") != -1)) {\n          n.putBooleanProp(Node.SLASH_V, true);\n        }\n      }\n      return n;\n    }\n",
        "begin_line": 1078,
        "end_line": 1105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0273
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isQualifiedName#1596",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
        "snippet": "  public boolean isQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n        return getString().isEmpty() ? false : true;\n      case Token.THIS:\n        return true;\n      case Token.GETPROP:\n        return getFirstChild().isQualifiedName();\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1596,
        "end_line": 1607,
        "comment": "\n   * Returns whether a node corresponds to a simple or a qualified name, such as\n   * <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseTypeExpressionAnnotation#1700",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }\n",
        "begin_line": 1700,
        "end_line": 1717,
        "comment": "\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.lazyInitInfo#685",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
        "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }\n",
        "begin_line": 685,
        "end_line": 689,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isConstant#489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isConstant()",
        "snippet": "  public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }\n",
        "begin_line": 489,
        "end_line": 491,
        "comment": "\n   * Returns whether the {@code @const} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isDefine#522",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
        "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }\n",
        "begin_line": 522,
        "end_line": 524,
        "comment": "\n   * Returns whether the {@code @define} annotation is present on this\n   * {@link JSDocInfo}. If this annotation is present, then the\n   * {@link #getType()} method will retrieve the define type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "MemoizedScopeCreator.createScope#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MemoizedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
        "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }\n",
        "begin_line": 78,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.getAlternates#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternates()",
        "snippet": "  Collection<JSType> getAlternates() {\n    JSType specialCaseType = reduceAlternatesWithoutUnion();\n    if (specialCaseType != null) {\n      return ImmutableList.of(specialCaseType);\n    }\n    return Collections.unmodifiableList(alternates);\n  }\n",
        "begin_line": 108,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.rebuildAlternates#104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.rebuildAlternates()",
        "snippet": "  private void rebuildAlternates() {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      builder.addAlternate(alternate);\n    }\n    alternates = builder.getAlternates();\n    hashcode = alternates.hashCode();\n  }\n",
        "begin_line": 104,
        "end_line": 111,
        "comment": "\n   * Use UnionTypeBuilder to rebuild the list of alternates and hashcode\n   * of the current UnionType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.resolveInternal#556",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this); // for circularly defined types.\n\n    // Just resolve the alternates, but do not update as that breaks some error\n    // reporting cases.\n    for (JSType alternate : alternates) {\n      alternate.resolve(t, scope);\n    }\n    // Ensure the union is in a normalized state.\n    rebuildAlternates();\n    return this;\n  }\n",
        "begin_line": 556,
        "end_line": 568,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0272
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processFunctionNode#766",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processFunctionNode(com.google.javascript.rhino.head.ast.FunctionNode)",
        "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      // if the function has an inline return annotation, attach it\n      Node newName = transformNodeWithInlineJsDoc(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        Node paramNode = transformNodeWithInlineJsDoc(param);\n        // When in ideMode Rhino can generate a param list with only a single\n        // ErrorNode. This is transformed into an EMPTY node. Drop this node in\n        // ideMode to keep the AST in a valid state.\n        if (paramNode.isName()) {\n          lp.addChildToBack(paramNode);\n        } else {\n          // We expect this in ideMode or when there is an error handling\n          // destructuring parameter assignments which aren't supported\n          // (an error has already been reported).\n          Preconditions.checkState(\n              config.isIdeMode\n              || paramNode.isObjectLit()\n              || paramNode.isArrayLit());\n        }\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n",
        "begin_line": 766,
        "end_line": 849,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.newStringNode#1524",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(java.lang.String)",
        "snippet": "  private Node newStringNode(String value) {\n    return IR.string(value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1524,
        "end_line": 1526,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.resolve#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DeferredSetType.resolve(com.google.javascript.jscomp.Scope)",
        "snippet": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }\n",
        "begin_line": 177,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.resolveTypes#465",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.resolveTypes()",
        "snippet": "    @Override\n    public void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n",
        "begin_line": 465,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.SiblingNodeIterable#1269",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.SiblingNodeIterable(com.google.javascript.rhino.Node)",
        "snippet": "    SiblingNodeIterable(Node start) {\n      this.start = start;\n      this.current = start;\n      this.used = false;\n    }\n",
        "begin_line": 1269,
        "end_line": 1273,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.iterator#1275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.iterator()",
        "snippet": "    @Override\n    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }\n",
        "begin_line": 1275,
        "end_line": 1289,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasNext#1291",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.hasNext()",
        "snippet": "    @Override\n    public boolean hasNext() {\n      return current != null;\n    }\n",
        "begin_line": 1291,
        "end_line": 1294,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.next#1296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.next()",
        "snippet": "    @Override\n    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }\n",
        "begin_line": 1296,
        "end_line": 1306,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.children#1239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.children()",
        "snippet": "  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }\n",
        "begin_line": 1239,
        "end_line": 1245,
        "comment": "\n   * <p>Return an iterable object that iterates over this node's children.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's children, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node child : n.children()) { ...</pre>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseAndRecordTypeNode#1255",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LC, false);\n  }\n",
        "begin_line": 1255,
        "end_line": 1258,
        "comment": "\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parseAndRecordTypeNode#1311",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(com.google.javascript.jscomp.parsing.JsDocToken, int, int, boolean, boolean)",
        "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    recordTypeNode(lineno, startCharno, typeNode, matchingLC);\n    return typeNode;\n  }\n",
        "begin_line": 1311,
        "end_line": 1325,
        "comment": "\n   * Looks for a parameter type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\n   *     (via a call to parseTypeNameAnnotation instead of\n   *     parseTypeExpressionAnnotation).\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setType#1081",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setType(com.google.javascript.rhino.JSTypeExpression, int)",
        "snippet": "  private void setType(JSTypeExpression type, int mask) {\n    if ((bitset & MASK_TYPEFIELD) != 0) {\n      throw new IllegalStateException(\n          \"API tried to add two incompatible type tags. \" +\n          \"This should have been blocked and emitted a warning.\");\n    }\n    this.bitset = (bitset & MASK_FLAGS) | mask;\n    this.type = type;\n  }\n",
        "begin_line": 1081,
        "end_line": 1089,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getBestLValueName#3170",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueName(com.google.javascript.rhino.Node)",
        "snippet": "  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue)) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }\n",
        "begin_line": 3170,
        "end_line": 3185,
        "comment": " Get the name of the given l-value node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0271
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordConstructor#744",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
        "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 744,
        "end_line": 753,
        "comment": "\n   * Records that the {@link JSDocInfo} being built should have its\n   * {@link JSDocInfo#isConstructor()} flag set to {@code true}.\n   *\n   * @return {@code true} if the constructor was recorded and {@code false}\n   *     if it was already defined or it was incompatible with the existing\n   *     flags\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setConstructor#374",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
        "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isConstantByConvention#2869",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isConstantByConvention(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    if (parent.isGetProp() && node == parent.getLastChild()) {\n      return convention.isConstantKey(node.getString());\n    } else if (isObjectLitKey(node)) {\n      return convention.isConstantKey(node.getString());\n    } else if (node.isName()) {\n      return convention.isConstant(node.getString());\n    }\n    return false;\n  }\n",
        "begin_line": 2869,
        "end_line": 2879,
        "comment": " Whether the given name is constant by coding convention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.resolveInternal#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 157,
        "end_line": 160,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.mayBeFromExterns#940",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayBeFromExterns()",
        "snippet": "    @Override\n    public boolean mayBeFromExterns() {\n      return n.isFromExterns();\n    }\n",
        "begin_line": 940,
        "end_line": 943,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.TypeInferencePass#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.TypeInferencePass(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.MemoizedScopeCreator)",
        "snippet": "  TypeInferencePass(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      Scope topScope, MemoizedScopeCreator scopeCreator) {\n    this.compiler = compiler;\n    this.reverseInterpreter = reverseInterpreter;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n\n    assertionFunctionsMap = Maps.newHashMap();\n    for (AssertionFunctionSpec assertionFunction :\n        compiler.getCodingConvention().getAssertionFunctions()) {\n      assertionFunctionsMap.put(assertionFunction.getFunctionName(),\n          assertionFunction);\n    }\n  }\n",
        "begin_line": 44,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.mayHaveSingleThrow#954",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayHaveSingleThrow()",
        "snippet": "    @Override\n    public boolean mayHaveSingleThrow() {\n      Node block = n.getLastChild();\n      return block.hasOneChild() && block.getFirstChild().isThrow();\n    }\n",
        "begin_line": 954,
        "end_line": 958,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "ValueType.resolveInternal#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ValueType.java",
        "class_name": "com.google.javascript.rhino.jstype.ValueType",
        "signature": "com.google.javascript.rhino.jstype.ValueType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.resolveInternal#412",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }\n",
        "begin_line": 412,
        "end_line": 425,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.values#202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.values()",
        "snippet": "  Iterable<Property> values() {\n    return properties.values();\n  }\n",
        "begin_line": 202,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.setType#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setType(JSType type) {\n    this.type = type;\n  }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.resolveTypesInScope#967",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resolveTypesInScope(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public void resolveTypesInScope(StaticScope<JSType> scope) {\n    for (NamedType type : unresolvedNamedTypes.get(scope)) {\n      type.resolve(reporter, scope);\n    }\n\n    resolvedNamedTypes.putAll(scope, unresolvedNamedTypes.removeAll(scope));\n\n    if (scope != null && scope.getParentScope() == null) {\n      // By default, the global \"this\" type is just an anonymous object.\n      // If the user has defined a Window type, make the Window the\n      // implicit prototype of \"this\".\n      PrototypeObjectType globalThis = (PrototypeObjectType) getNativeType(\n          JSTypeNative.GLOBAL_THIS);\n      JSType windowType = getType(\"Window\");\n      if (globalThis.isUnknownType()) {\n        ObjectType windowObjType = ObjectType.cast(windowType);\n        if (windowObjType != null) {\n          globalThis.setImplicitPrototype(windowObjType);\n        } else {\n          globalThis.setImplicitPrototype(\n              getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n        }\n      }\n    }\n  }\n",
        "begin_line": 967,
        "end_line": 991,
        "comment": "\n   * Resolve all the unresolved types in the given scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.resolve#1340",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.resolve(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }\n",
        "begin_line": 1340,
        "end_line": 1353,
        "comment": "\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.setResolvedTypeInternal#1360",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.setResolvedTypeInternal(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }\n",
        "begin_line": 1360,
        "end_line": 1363,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.safeResolve#1380",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.safeResolve(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }\n",
        "begin_line": 1380,
        "end_line": 1383,
        "comment": "\n   * A null-safe resolve.\n   * @see #resolve\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.resolveInternal#1175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    if (prototypeSlot != null) {\n      prototypeSlot.setType(\n          safeResolve(prototypeSlot.getType(), t, scope));\n    }\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the run-time coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(\n            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
        "begin_line": 1175,
        "end_line": 1224,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.resolveInternal#273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    returnType = safeResolve(returnType, t, scope);\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n      }\n    }\n    return this;\n  }\n",
        "begin_line": 273,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "AllType.resolveInternal#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.enterScope#143",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.SecondScopeBuildingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Only infer the entry root, rather than the scope root.\n      // This ensures that incremental compilation only touches the root\n      // that's been swapped out.\n      inferScope(t.getCurrentNode(), t.getScope());\n    }\n",
        "begin_line": 143,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.visit#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.SecondScopeBuildingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }\n",
        "begin_line": 151,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.enterScope#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.FirstScopeBuildingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      t.getScope();\n    }\n",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.visit#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.FirstScopeBuildingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }\n",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.process#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    inferAllScopes(externsAndJs);\n  }\n",
        "begin_line": 66,
        "end_line": 74,
        "comment": "\n   * Main entry point for type inference when running over the whole tree.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.inferAllScopes#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.inferAllScopes(com.google.javascript.rhino.Node)",
        "snippet": "  void inferAllScopes(Node node) {\n    // Type analysis happens in two major phases.\n    // 1) Finding all the symbols.\n    // 2) Propagating all the inferred types.\n    //\n    // The order of this analysis is non-obvious. In a complete inference\n    // system, we may need to backtrack arbitrarily far. But the compile-time\n    // costs would be unacceptable.\n    //\n    // We do one pass where we do typed scope creation for all scopes\n    // in pre-order.\n    //\n    // Then we do a second pass where we do all type inference\n    // (type propagation) in pre-order.\n    //\n    // We use a memoized scope creator so that we never create a scope\n    // more than once.\n    //\n    // This will allow us to handle cases like:\n    // var ns = {};\n    // (function() { /** JSDoc */ ns.method = function() {}; })();\n    // ns.method();\n    // In this code, we need to build the symbol table for the inner scope in\n    // order to propagate the type of ns.method in the outer scope.\n    (new NodeTraversal(\n        compiler, new FirstScopeBuildingCallback(), scopeCreator))\n        .traverseWithScope(node, topScope);\n\n    for (Scope s : scopeCreator.getAllMemoizedScopes()) {\n      s.resolveTypes();\n    }\n\n    (new NodeTraversal(\n        compiler, new SecondScopeBuildingCallback(), scopeCreator))\n        .traverseWithScope(node, topScope);\n  }\n",
        "begin_line": 77,
        "end_line": 112,
        "comment": " Entry point for type inference when running over part of the tree. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.inferScope#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.inferScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  void inferScope(Node n, Scope scope) {\n    TypeInference typeInference =\n        new TypeInference(\n            compiler, computeCfg(n), reverseInterpreter, scope,\n            assertionFunctionsMap);\n    try {\n      typeInference.analyze();\n\n      // Resolve any new type names found during the inference.\n      compiler.getTypeRegistry().resolveTypesInScope(scope);\n\n    } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n      compiler.report(JSError.make(n.getSourceFileName(), n, DATAFLOW_ERROR));\n    }\n  }\n",
        "begin_line": 114,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInferencePass.computeCfg#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.computeCfg(com.google.javascript.rhino.Node)",
        "snippet": "  private ControlFlowGraph<Node> computeCfg(Node n) {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    return cfa.getCfg();\n  }\n",
        "begin_line": 157,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.resolveType#266",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.resolveType(com.google.javascript.rhino.ErrorReporter)",
        "snippet": "    void resolveType(ErrorReporter errorReporter) {\n      if (type != null) {\n        type = type.resolve(errorReporter, scope);\n      }\n    }\n",
        "begin_line": 266,
        "end_line": 270,
        "comment": "\n     * Resolve this variable's type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.resolveTypes#628",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.resolveTypes()",
        "snippet": "  void resolveTypes() {\n    if (typeResolver != null) {\n      typeResolver.resolveTypes();\n      typeResolver = null;\n    }\n  }\n",
        "begin_line": 628,
        "end_line": 633,
        "comment": " Resolve all type references. Only used on typed scopes. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverseWithScope#346",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseWithScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    inputId = null;\n    sourceName = \"\";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }\n",
        "begin_line": 346,
        "end_line": 355,
        "comment": "\n   * Traverses a parse tree recursively with a scope, starting with the given\n   * root. This should only be used in the global scope. Otherwise, use\n   * {@link #traverseAtScope}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.pushScope#605",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    compiler.setScope(s.getRootNode());\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n",
        "begin_line": 605,
        "end_line": 613,
        "comment": " Creates a new scope (e.g. when entering a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "MemoizedScopeCreator.MemoizedScopeCreator#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MemoizedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
        "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.MemoizedScopeCreator(com.google.javascript.jscomp.ScopeCreator)",
        "snippet": "  MemoizedScopeCreator(ScopeCreator delegate) {\n    this.delegate = delegate;\n  }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n   * @param delegate The real source of Scope objects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "MemoizedScopeCreator.getAllMemoizedScopes#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MemoizedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
        "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.getAllMemoizedScopes()",
        "snippet": "  Collection<Scope> getAllMemoizedScopes() {\n    return Collections.unmodifiableCollection(scopes.values());\n  }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "GoogleCodingConvention.GoogleCodingConvention#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention()",
        "snippet": "  public GoogleCodingConvention() {\n    this(new ClosureCodingConvention());\n  }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": " By default, decorate the ClosureCodingConvention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "GoogleCodingConvention.GoogleCodingConvention#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public GoogleCodingConvention(CodingConvention convention) {\n    super(convention);\n  }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": " Decorates a wrapped CodingConvention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getParentScope#448",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getParentScope()",
        "snippet": "  @Override\n  public StaticScope<JSType> getParentScope() {\n    return parent;\n  }\n",
        "begin_line": 448,
        "end_line": 451,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.cast#604",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }\n",
        "begin_line": 604,
        "end_line": 606,
        "comment": "\n   * A null-safe version of JSType#toObjectType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.027
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.mayHaveNonEmptyReturns#945",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayHaveNonEmptyReturns()",
        "snippet": "    @Override\n    public boolean mayHaveNonEmptyReturns() {\n      return hasNonEmptyReturns;\n    }\n",
        "begin_line": 945,
        "end_line": 948,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0269
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setFlag#455",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean, int)",
        "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }\n",
        "begin_line": 455,
        "end_line": 461,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0269
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getTypeOfThis#1101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getTypeOfThis()",
        "snippet": "  @Override\n  public JSType getTypeOfThis() {\n    return typeOfThis.isEmptyType() ?\n        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;\n  }\n",
        "begin_line": 1101,
        "end_line": 1105,
        "comment": "\n   * Gets the type of {@code this} in this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0269
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.isJSDocString#278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
        "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }\n",
        "begin_line": 278,
        "end_line": 302,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.visit#294",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n",
        "begin_line": 294,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.handleExpr#534",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleExpr(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n",
        "begin_line": 534,
        "end_line": 537,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.getSourceNode#935",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getSourceNode()",
        "snippet": "    @Override\n    public Node getSourceNode() {\n      return n;\n    }\n",
        "begin_line": 935,
        "end_line": 938,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.setContents#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.setContents(com.google.javascript.jscomp.FunctionTypeBuilder.FunctionContents)",
        "snippet": "  FunctionTypeBuilder setContents(@Nullable FunctionContents contents) {\n    if (contents != null) {\n      this.contents = contents;\n    }\n    return this;\n  }\n",
        "begin_line": 233,
        "end_line": 238,
        "comment": "\n   * Sets the contents of this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.getJSType#1590",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.getJSType(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return unknownType;\n    } else {\n      return jsType;\n    }\n  }\n",
        "begin_line": 1590,
        "end_line": 1601,
        "comment": "\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.LocalScopeBuilder#1967",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.LocalScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private LocalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n",
        "begin_line": 1967,
        "end_line": 1969,
        "comment": "\n     * @param scope The scope that we're building.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#2005",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) {\n        return;\n      }\n      if (n.isParamList() && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }\n",
        "begin_line": 2005,
        "end_line": 2015,
        "comment": "\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.enterScope#2113",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }\n",
        "begin_line": 2113,
        "end_line": 2118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getFunctionAnalysisResults#2174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.getFunctionAnalysisResults(com.google.javascript.rhino.Node)",
        "snippet": "  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n    if (n == null) {\n      return null;\n    }\n\n    // Sometimes this will return null in things like\n    // NameReferenceGraphConstruction that build partial scopes.\n    return functionAnalysisResults.get(n);\n  }\n",
        "begin_line": 2174,
        "end_line": 2182,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.AstFunctionContents#931",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.AstFunctionContents(com.google.javascript.rhino.Node)",
        "snippet": "    AstFunctionContents(Node n) {\n      this.n = n;\n    }\n",
        "begin_line": 931,
        "end_line": 933,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.getEscapedVarNames#960",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getEscapedVarNames()",
        "snippet": "    @Override\n    public Iterable<String> getEscapedVarNames() {\n      return escapedVarNames == null\n          ? ImmutableList.<String>of() : escapedVarNames;\n    }\n",
        "begin_line": 960,
        "end_line": 964,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.getAssignedNameCounts#986",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getAssignedNameCounts()",
        "snippet": "    @Override\n    public Multiset<String> getAssignedNameCounts() {\n      return assignedVarNames;\n    }\n",
        "begin_line": 986,
        "end_line": 989,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.maybeSetBaseType#726",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.maybeSetBaseType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void maybeSetBaseType(FunctionType fnType) {\n    if (!fnType.isInterface() && baseType != null) {\n      fnType.setPrototypeBasedOn(baseType);\n      fnType.extendTemplateTypeMapBasedOn(baseType);\n    }\n  }\n",
        "begin_line": 726,
        "end_line": 731,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.defineSlot#1116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n",
        "begin_line": 1116,
        "end_line": 1118,
        "comment": "\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.defineProperty#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }\n",
        "begin_line": 85,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getParametersNode#287",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getParametersNode()",
        "snippet": "  public Node getParametersNode() {\n    return call.parameters;\n  }\n",
        "begin_line": 287,
        "end_line": 289,
        "comment": " Gets an LP node that contains all params. May be null. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.isUnknownType#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    return true;\n  }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.clearTemplateTypeNames#1842",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.clearTemplateTypeNames()",
        "snippet": "  public void clearTemplateTypeNames() {\n    templateTypes.clear();\n  }\n",
        "begin_line": 1842,
        "end_line": 1844,
        "comment": "\n   * Clears the template type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.getNativeType#406",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }\n",
        "begin_line": 406,
        "end_line": 408,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.getSlot#492",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache.getSlot(java.lang.String)",
        "snippet": "    public StaticSlot<JSType> getSlot(String name) {\n      if (symbols.containsKey(name)) {\n        return symbols.get(name);\n      } else {\n        return functionScope.getSlot(name);\n      }\n    }\n",
        "begin_line": 492,
        "end_line": 498,
        "comment": "\n     * Get the slot for the given symbol.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.get#884",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.UnknownFunctionContents.get()",
        "snippet": "    static FunctionContents get() {\n      return singleton;\n    }\n",
        "begin_line": 884,
        "end_line": 886,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionTypeBuilder.FunctionTypeBuilder#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.FunctionTypeBuilder(java.lang.String, com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.jscomp.Scope)",
        "snippet": "  FunctionTypeBuilder(String fnName, AbstractCompiler compiler,\n      Node errorRoot, String sourceName, Scope scope) {\n    Preconditions.checkNotNull(errorRoot);\n\n    this.fnName = fnName == null ? \"\" : fnName;\n    this.codingConvention = compiler.getCodingConvention();\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.errorRoot = errorRoot;\n    this.sourceName = sourceName;\n    this.compiler = compiler;\n    this.scope = scope;\n  }\n",
        "begin_line": 212,
        "end_line": 223,
        "comment": "\n   * @param fnName The function name.\n   * @param compiler The compiler.\n   * @param errorRoot The node to associate with any warning generated by\n   *     this builder.\n   * @param sourceName A source name for associating any warnings that\n   *     we have to emit.\n   * @param scope The syntactic scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.defineDeclaredProperty#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, propertyNode);\n    // All property definitions go through this method\n    // or defineInferredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n    return result;\n  }\n",
        "begin_line": 284,
        "end_line": 293,
        "comment": "\n   * Defines a property whose type is explicitly declared by the programmer.\n   * @param propertyName the property's name\n   * @param type the type\n   * @param propertyNode the node corresponding to the declaration of property\n   *        which might later be accessed using {@code getPropertyNode}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.getSlot#142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public StaticSlot<JSType> getSlot(String name) {\n    if (cache.dirtySymbols.contains(name)) {\n      for (LinkedFlowSlot slot = lastSlot;\n           slot != null; slot = slot.parent) {\n        if (slot.getName().equals(name)) {\n          return slot;\n        }\n      }\n    }\n    return cache.getSlot(name);\n  }\n",
        "begin_line": 142,
        "end_line": 153,
        "comment": "\n   * Get the slot for the given symbol.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.defineProperty#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    properties.putProperty(name, newProp);\n    return true;\n  }\n",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getConstructor#279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
        "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }\n",
        "begin_line": 279,
        "end_line": 282,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.putProperty#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.putProperty(java.lang.String, com.google.javascript.rhino.jstype.Property)",
        "snippet": "  void putProperty(String name, Property newProp) {\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred JsDoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n  }\n",
        "begin_line": 192,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.hasOwnDeclaredProperty#476",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(java.lang.String)",
        "snippet": "  final boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }\n",
        "begin_line": 476,
        "end_line": 478,
        "comment": "\n   * Whether the given property is declared on this object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.getOwnProperty#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getOwnProperty(java.lang.String)",
        "snippet": "  Property getOwnProperty(String propertyName) {\n    return properties.get(propertyName);\n  }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.getOwnSlot#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getOwnSlot(String name) {\n    return getPropertyMap().getOwnProperty(name);\n  }\n",
        "begin_line": 119,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.hasOwnProperty#444",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnProperty(java.lang.String)",
        "snippet": "  public boolean hasOwnProperty(String propertyName) {\n    return getOwnSlot(propertyName) != null;\n  }\n",
        "begin_line": 444,
        "end_line": 446,
        "comment": "\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getSlot#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Var getSlot(String name) {\n    return getVar(name);\n  }\n",
        "begin_line": 515,
        "end_line": 518,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isCallOrNew#1919",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isCallOrNew(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isCallOrNew(Node node) {\n    return node.isCall() || node.isNew();\n  }\n",
        "begin_line": 1919,
        "end_line": 1921,
        "comment": "\n   * @param node A node\n   * @return Whether the call is a NEW or CALL node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isFromExterns#1125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFromExterns()",
        "snippet": "  public boolean isFromExterns() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? false : file.isExtern();\n  }\n",
        "begin_line": 1125,
        "end_line": 1128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getPropertyMap#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyMap()",
        "snippet": "  @Override\n  PropertyMap getPropertyMap() {\n    return properties;\n  }\n",
        "begin_line": 129,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.restrictByNotNullOrUndefined#1202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.restrictByNotNullOrUndefined()",
        "snippet": "  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }\n",
        "begin_line": 1202,
        "end_line": 1204,
        "comment": "\n   * If this is a union type, returns a union type that does not include\n   * the null or undefined type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.handleStmt#668",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n",
        "begin_line": 668,
        "end_line": 672,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.position2charno#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
        "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }\n",
        "begin_line": 515,
        "end_line": 523,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.newString#517",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(java.lang.String, int, int)",
        "snippet": "  public static Node newString(String str, int lineno, int charno) {\n    return new StringNode(Token.STRING, str, lineno, charno);\n  }\n",
        "begin_line": 517,
        "end_line": 519,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.newStringNode#2358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(java.lang.String, int, int)",
        "snippet": "  private Node newStringNode(String s, int lineno, int charno) {\n    Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n    n.setLength(s.length());\n    return n;\n  }\n",
        "begin_line": 2358,
        "end_line": 2362,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.StringNode#200",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.StringNode(int, java.lang.String, int, int)",
        "snippet": "    StringNode(int type, String str, int lineno, int charno) {\n      super(type, lineno, charno);\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }\n",
        "begin_line": 200,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setLength#1134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setLength(int)",
        "snippet": "  public void setLength(int length) {\n    putIntProp(LENGTH, length);\n  }\n",
        "begin_line": 1134,
        "end_line": 1136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.markTypeNode#190",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(com.google.javascript.rhino.Node, int, int, int, int, boolean)",
        "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n      int endLineno, int endCharno, boolean hasLC) {\n    if (currentMarker != null) {\n      JSDocInfo.TypePosition position = new JSDocInfo.TypePosition();\n      position.setItem(typeNode);\n      position.setHasBrackets(hasLC);\n      position.setPositionInformation(lineno, startCharno,\n          endLineno, endCharno);\n      currentMarker.setType(position);\n    }\n  }\n",
        "begin_line": 190,
        "end_line": 200,
        "comment": "\n   * Adds a type declaration to the current marker.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.recordTypeNode#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.recordTypeNode(int, int, com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private void recordTypeNode(int lineno, int startCharno, Node typeAst,\n      boolean matchingLC) {\n    if (typeAst != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n      jsdocBuilder.markTypeNode(\n          typeAst, lineno, startCharno, endLineno, endCharno, matchingLC);\n    }\n  }\n",
        "begin_line": 177,
        "end_line": 185,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0267
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createNullableType#1025",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }\n",
        "begin_line": 1025,
        "end_line": 1027,
        "comment": "\n   * Creates a type representing nullable values of the given type.\n   * @return the union of the type and the Null type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.Node#442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, int, int)",
        "snippet": "  public Node(int nodeType, int lineno, int charno) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 442,
        "end_line": 446,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeExpression.JSTypeExpression#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  public JSTypeExpression(Node root, String sourceName) {\n    this.root = root;\n    this.sourceName = sourceName;\n  }\n",
        "begin_line": 64,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.createJSTypeExpression#1395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(com.google.javascript.rhino.Node)",
        "snippet": "  JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, getSourceName());\n  }\n",
        "begin_line": 1395,
        "end_line": 1398,
        "comment": "\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.getSourceName#153",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getSourceName()",
        "snippet": "  private String getSourceName() {\n    return sourceFile == null ? null : sourceFile.getName();\n  }\n",
        "begin_line": 153,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseChildren#1254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseChildren(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }\n",
        "begin_line": 1254,
        "end_line": 1259,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isForIn#1640",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isForIn(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }\n",
        "begin_line": 1640,
        "end_line": 1643,
        "comment": "\n   * @return Whether the node represents a FOR-IN loop.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isFor#2301",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFor()",
        "snippet": "  public boolean isFor() {\n    return this.getType() == Token.FOR;\n  }\n",
        "begin_line": 2301,
        "end_line": 2303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "IR.string#446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.string(java.lang.String)",
        "snippet": "  public static Node string(String s) {\n    return Node.newString(s);\n  }\n",
        "begin_line": 446,
        "end_line": 448,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isReturn#2389",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isReturn()",
        "snippet": "  public boolean isReturn() {\n    return this.getType() == Token.RETURN;\n  }\n",
        "begin_line": 2389,
        "end_line": 2391,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.DeferredSetType#166",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DeferredSetType.DeferredSetType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    DeferredSetType(Node node, JSType type) {\n      Preconditions.checkNotNull(node);\n      Preconditions.checkNotNull(type);\n      this.node = node;\n      this.type = type;\n\n      // Other parts of this pass may read off the node.\n      // (like when we set the LHS of an assign with a typed RHS function.)\n      node.setJSType(type);\n    }\n",
        "begin_line": 166,
        "end_line": 175,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.setDeferredType#461",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.setDeferredType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }\n",
        "begin_line": 461,
        "end_line": 463,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isGetElem#2313",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isGetElem()",
        "snippet": "  public boolean isGetElem() {\n    return this.getType() == Token.GETELEM;\n  }\n",
        "begin_line": 2313,
        "end_line": 2315,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.isTypeInferred#276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isTypeInferred()",
        "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return typeInferred;\n    }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": "\n     * Returns whether this variable's type is inferred. To get the variable's\n     * type, see {@link #getType()}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.handleFunction#525",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n",
        "begin_line": 525,
        "end_line": 532,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.assertDefinitionNode#751",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.assertDefinitionNode(com.google.javascript.rhino.Node, int)",
        "snippet": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }\n",
        "begin_line": 751,
        "end_line": 754,
        "comment": "\n     * Asserts that it's OK to define this node's name.\n     * The node should have a source name and be of the specified type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0266
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.newString#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(java.lang.String)",
        "snippet": "  public static Node newString(String str) {\n    return new StringNode(Token.STRING, str);\n  }\n",
        "begin_line": 509,
        "end_line": 511,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0265
        },
        "num_failing_tests": 1
    },
    {
        "name": "JsDocInfoParser.eatTokensUntilEOL#2389",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
        "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }\n",
        "begin_line": 2389,
        "end_line": 2391,
        "comment": "\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0265
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getType#234",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getType()",
        "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }\n",
        "begin_line": 234,
        "end_line": 237,
        "comment": "\n     * Gets this variable's type. To know whether this type has been inferred,\n     * see {@code #isTypeInferred()}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0265
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.init#368",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.init(java.util.List<T1>, java.util.List<T2>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n",
        "begin_line": 368,
        "end_line": 378,
        "comment": "\n   * Initializes the instance state needed for a compile job.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0265
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getSourceName#2905",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getSourceName(com.google.javascript.rhino.Node)",
        "snippet": "  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }\n",
        "begin_line": 2905,
        "end_line": 2912,
        "comment": "\n   * @param n The node.\n   * @return The source name property on the node or its ancestors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0265
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.defineDelegateProxyPrototypeProperties#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.defineDelegateProxyPrototypeProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.util.List<com.google.javascript.rhino.jstype.ObjectType>, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      nextConvention.defineDelegateProxyPrototypeProperties(\n          registry, scope, delegateProxyPrototypes, delegateCallingConventions);\n    }\n",
        "begin_line": 194,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter#118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public SemanticReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n  }\n",
        "begin_line": 118,
        "end_line": 121,
        "comment": "\n   * Creates a semantic reverse abstract interpreter.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }\n",
        "begin_line": 63,
        "end_line": 70,
        "comment": "\n   * Constructs an interpreter, which is the only link in a chain. Interpreters\n   * can be appended using {@link #append}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.GlobalScopeBuilder#1888",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.GlobalScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private GlobalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n",
        "begin_line": 1888,
        "end_line": 1890,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.FirstOrderFunctionAnalyzer#2098",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.FirstOrderFunctionAnalyzer(com.google.javascript.jscomp.AbstractCompiler, java.util.Map<com.google.javascript.rhino.Node, com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents>)",
        "snippet": "    FirstOrderFunctionAnalyzer(\n        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {\n      this.compiler = compiler;\n      this.data = outParam;\n    }\n",
        "begin_line": 2098,
        "end_line": 2102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.process#2104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void process(Node externs, Node root) {\n      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }\n",
        "begin_line": 2104,
        "end_line": 2111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.AbstractScopeBuilder#457",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.AbstractScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private AbstractScopeBuilder(Scope scope) {\n      this.scope = scope;\n    }\n",
        "begin_line": 457,
        "end_line": 459,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.resolveStubDeclarations#1765",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.resolveStubDeclarations()",
        "snippet": "    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }\n",
        "begin_line": 1765,
        "end_line": 1794,
        "comment": "\n     * Resolve any stub declarations to unknown types if we could not\n     * find types for them during traversal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.TypedScopeCreator#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }\n",
        "begin_line": 182,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.branchedFlowThrough#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.branchedFlowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  @Override\n  @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"})\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably too expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getTemplateTypeMap().getTemplateType(\n                      registry.getObjectIndexKey());\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }\n",
        "begin_line": 192,
        "end_line": 305,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.TypeInference#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.TypeInference(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.jscomp.Scope, java.util.Map<java.lang.String, com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec>)",
        "snippet": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);\n\n    this.syntacticScope = functionScope;\n    inferArguments(functionScope);\n\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (isUnflowable(var)) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        Scope.createLatticeBottom(functionScope.getRootNode()));\n  }\n",
        "begin_line": 87,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.createInitialEstimateLattice#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.createInitialEstimateLattice()",
        "snippet": "  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }\n",
        "begin_line": 169,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.createEntryLattice#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.createEntryLattice()",
        "snippet": "  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }\n",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.flowThrough#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.flowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }\n",
        "begin_line": 179,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.apply#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Anonymous-1627f465-9735-448d-b710-7447be435e65.apply(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    @Override public boolean apply(Var var) {\n      return var.getParentNode() != null &&\n          var.getType() == null && // no declared type\n          var.getParentNode().isVar() &&\n          !var.isExtern();\n    }\n",
        "begin_line": 68,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.createLatticeBottom#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.createLatticeBottom(com.google.javascript.rhino.Node)",
        "snippet": "  static Scope createLatticeBottom(Node rootNode) {\n    return new Scope(rootNode, true);\n  }\n",
        "begin_line": 413,
        "end_line": 415,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getDeclarativelyUnboundVarsWithoutTypes#616",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getDeclarativelyUnboundVarsWithoutTypes()",
        "snippet": "  public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() {\n    return Iterators.filter(\n        getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n  }\n",
        "begin_line": 616,
        "end_line": 619,
        "comment": "\n   * Gets all variables declared with \"var\" but without declared types attached.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.setTypeResolver#635",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.setTypeResolver(com.google.javascript.jscomp.Scope.TypeResolver)",
        "snippet": "  void setTypeResolver(TypeResolver resolver) {\n    this.typeResolver = resolver;\n  }\n",
        "begin_line": 635,
        "end_line": 637,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isCallOrNewTarget#3070",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isCallOrNewTarget(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n  }\n",
        "begin_line": 3070,
        "end_line": 3075,
        "comment": "\n   * Returns whether this is a target of a call or new.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getInputId#696",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getInputId()",
        "snippet": "  InputId getInputId() {\n    return inputId;\n  }\n",
        "begin_line": 696,
        "end_line": 698,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.FlatFlowScopeCache#407",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache.FlatFlowScopeCache(com.google.javascript.jscomp.Scope)",
        "snippet": "    FlatFlowScopeCache(Scope functionScope) {\n      this.functionScope = functionScope;\n      symbols = ImmutableMap.of();\n      linkedEquivalent = null;\n    }\n",
        "begin_line": 407,
        "end_line": 411,
        "comment": " The cache at the bottom of the lattice.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache, com.google.javascript.jscomp.LinkedFlowScope)",
        "snippet": "  private LinkedFlowScope(FlatFlowScopeCache cache,\n      LinkedFlowScope directParent) {\n    this.cache = cache;\n    if (directParent == null) {\n      this.lastSlot = null;\n      this.depth = 0;\n      this.parent = cache.linkedEquivalent;\n    } else {\n      this.lastSlot = directParent.lastSlot;\n      this.depth = directParent.depth + 1;\n      this.parent = directParent;\n    }\n  }\n",
        "begin_line": 64,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache)",
        "snippet": "  LinkedFlowScope(FlatFlowScopeCache cache) {\n    this(cache, null);\n  }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope)",
        "snippet": "  LinkedFlowScope(LinkedFlowScope directParent) {\n    this(directParent.cache, directParent);\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.getFunctionScope#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.getFunctionScope()",
        "snippet": "  private Scope getFunctionScope() {\n    return cache.functionScope;\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": " Gets the function scope for this flow scope. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.createEntryLattice#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.createEntryLattice(com.google.javascript.jscomp.Scope)",
        "snippet": "  public static LinkedFlowScope createEntryLattice(Scope scope) {\n    return new LinkedFlowScope(new FlatFlowScopeCache(scope));\n  }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n   * Creates an entry lattice for the flow.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.createChildFlowScope#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.createChildFlowScope()",
        "snippet": "  @Override\n  public FlowScope createChildFlowScope() {\n    frozen = true;\n\n    if (depth > MAX_DEPTH) {\n      if (flattened == null) {\n        flattened = new FlatFlowScopeCache(this);\n      }\n      return new LinkedFlowScope(flattened);\n    }\n\n    return new LinkedFlowScope(this);\n  }\n",
        "begin_line": 160,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.optimize#231",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.optimize()",
        "snippet": "  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }\n",
        "begin_line": 231,
        "end_line": 239,
        "comment": " a findUniqueRefinedSlot on it.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedFlowScope.equals#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate through all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 258,
        "end_line": 308,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JoinOp.apply#36",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JoinOp.java",
        "class_name": "com.google.javascript.jscomp.JoinOp",
        "signature": "com.google.javascript.jscomp.JoinOp.BinaryJoinOp.apply(java.util.List<L>)",
        "snippet": "    @Override\n    public final L apply(List<L> values) {\n      Preconditions.checkArgument(!values.isEmpty());\n      int size = values.size();\n      if (size == 1) {\n        return values.get(0);\n      } else if (size == 2) {\n        return apply(values.get(0), values.get(1));\n      } else {\n        int mid = computeMidPoint(size);\n        return apply(\n            apply(values.subList(0, mid)),\n            apply(values.subList(mid, size)));\n      }\n    }\n",
        "begin_line": 36,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.initialize#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.initialize()",
        "snippet": "    @Override\n    protected void initialize() {\n      orderedWorkSet.clear();\n      for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n        int outEdgeCount = getCfg().getOutEdges(node.getValue()).size();\n        List<L> outLattices = Lists.newArrayList();\n        for (int i = 0; i < outEdgeCount; i++) {\n          outLattices.add(createInitialEstimateLattice());\n        }\n        node.setAnnotation(new BranchedFlowState<L>(\n            createInitialEstimateLattice(), outLattices));\n        if (node != getCfg().getImplicitReturn()) {\n          orderedWorkSet.add(node);\n        }\n      }\n    }\n",
        "begin_line": 392,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.BranchedForwardDataFlowAnalysis#409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.BranchedForwardDataFlowAnalysis(com.google.javascript.jscomp.ControlFlowGraph<N>, com.google.javascript.jscomp.JoinOp<L>)",
        "snippet": "    BranchedForwardDataFlowAnalysis(ControlFlowGraph<N> targetCfg,\n                                    JoinOp<L> joinOp) {\n      super(targetCfg, joinOp);\n    }\n",
        "begin_line": 409,
        "end_line": 412,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.isForward#425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.isForward()",
        "snippet": "    @Override\n    final boolean isForward() {\n      return true;\n    }\n",
        "begin_line": 425,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.flow#443",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.flow(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    protected final boolean flow(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<L> outBefore = state.out;\n      state.out = branchedFlowThrough(node.getValue(), state.in);\n      Preconditions.checkState(outBefore.size() == state.out.size());\n      for (int i = 0; i < outBefore.size(); i++) {\n        if (!outBefore.get(i).equals(state.out.get(i))) {\n          return true;\n        }\n      }\n      return false;\n    }\n",
        "begin_line": 443,
        "end_line": 455,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.joinInputs#457",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.joinInputs(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    protected void joinInputs(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<DiGraphNode<N, Branch>> predNodes =\n          getCfg().getDirectedPredNodes(node);\n      List<L> values = new ArrayList<L>(predNodes.size());\n\n      for (DiGraphNode<N, Branch> predNode : predNodes) {\n        BranchedFlowState<L> predNodeState = predNode.getAnnotation();\n\n        L in = predNodeState.out.get(\n            getCfg().getDirectedSuccNodes(predNode).indexOf(node));\n\n        values.add(in);\n      }\n      if (getCfg().getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else if (!values.isEmpty()) {\n        state.setIn(joinOp.apply(values));\n      }\n    }\n",
        "begin_line": 457,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.BranchedFlowState#496",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState.BranchedFlowState(L, java.util.List<L>)",
        "snippet": "    private BranchedFlowState(L inState, List<L> outState) {\n      Preconditions.checkNotNull(inState);\n      Preconditions.checkNotNull(outState);\n      this.in = inState;\n      this.out = outState;\n    }\n",
        "begin_line": 496,
        "end_line": 501,
        "comment": "\n     * Private constructor. No other classes should create new states.\n     *\n     * @param inState Input.\n     * @param outState Output.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.setIn#507",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState.setIn(L)",
        "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }\n",
        "begin_line": 507,
        "end_line": 510,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.defineDelegateProxyPrototypeProperties#385",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.defineDelegateProxyPrototypeProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.util.List<com.google.javascript.rhino.jstype.ObjectType>, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      // do nothing.\n    }\n",
        "begin_line": 385,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.shouldTraverse#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.exitScope#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}\n",
        "begin_line": 160,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getErrorReporter#221",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getErrorReporter()",
        "snippet": "  public ErrorReporter getErrorReporter() {\n    return reporter;\n  }\n",
        "begin_line": 221,
        "end_line": 223,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createUnionType#1053",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(com.google.javascript.rhino.jstype.JSTypeNative...)",
        "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1053,
        "end_line": 1059,
        "comment": "\n   * Creates a union type whose variants are the built-in types specified\n   * by the arguments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.DiscoverEnumsAndTypedefs#365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.DiscoverEnumsAndTypedefs(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n      this.registry = registry;\n    }\n",
        "begin_line": 365,
        "end_line": 367,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.TypedScopeCreator#186",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n    this.unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n  }\n",
        "begin_line": 186,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.createInitialScope#313",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.createInitialScope(com.google.javascript.rhino.Node)",
        "snippet": "  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = Scope.createGlobalScope(root);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // There is no longer a need to special case ActiveXObject\n    // but this remains here until we can get the extern forks\n    // cleaned up.\n    declareNativeValueType(s, \"ActiveXObject\", FUNCTION_INSTANCE_TYPE);\n\n    return s;\n  }\n",
        "begin_line": 313,
        "end_line": 343,
        "comment": "\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.declareNativeFunctionType#345",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeFunctionType(com.google.javascript.jscomp.Scope, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }\n",
        "begin_line": 345,
        "end_line": 350,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.declareNativeValueType#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeValueType(com.google.javascript.jscomp.Scope, java.lang.String, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }\n",
        "begin_line": 352,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.declareNativeType#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeType(com.google.javascript.jscomp.Scope, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private static void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }\n",
        "begin_line": 357,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeValidator.TypeValidator#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }\n",
        "begin_line": 138,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getTypeValidator#1282",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getTypeValidator()",
        "snippet": "  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n",
        "begin_line": 1282,
        "end_line": 1288,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.shouldTraverse#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }\n",
        "begin_line": 185,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.addMarker#711",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
        "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }\n",
        "begin_line": 711,
        "end_line": 723,
        "comment": "\n   * Adds a marker to the documentation (if it exists) and\n   * returns the marker. Returns null otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.lazyInitDocumentation#695",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
        "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }\n",
        "begin_line": 695,
        "end_line": 705,
        "comment": "\n   * Lazily initializes the documentation information object, but only\n   * if the JSDocInfo was told to keep such information around.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.parse#216",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
        "snippet": "  boolean parse() {\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\n  }\n",
        "begin_line": 216,
        "end_line": 239,
        "comment": "\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isNew#2357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isNew()",
        "snippet": "  public boolean isNew() {\n    return this.getType() == Token.NEW;\n  }\n",
        "begin_line": 2357,
        "end_line": 2359,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getCurrentNode#451",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getCurrentNode()",
        "snippet": "  public Node getCurrentNode() {\n    return curNode;\n  }\n",
        "begin_line": 451,
        "end_line": 453,
        "comment": " Returns the node currently being traversed. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.initModules#396",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initModules(java.util.List<T>, java.util.List<com.google.javascript.jscomp.JSModule>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n",
        "begin_line": 396,
        "end_line": 426,
        "comment": "\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSModule.JSModule#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.JSModule(java.lang.String)",
        "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }\n",
        "begin_line": 62,
        "end_line": 65,
        "comment": "\n   * Creates an instance.\n   *\n   * @param name A unique name for the module\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSModule.add#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.add(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public void add(SourceFile file) {\n    add(new CompilerInput(file));\n  }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": " Adds a source file input to this module. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSModule.add#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.add(com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": " Adds a source code input to this module. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSModule.getInputs#204",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
        "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }\n",
        "begin_line": 204,
        "end_line": 206,
        "comment": "\n   * Gets this module's list of source code inputs.\n   *\n   * @return A list that may be empty but not null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.setModule#325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.setModule(com.google.javascript.jscomp.JSModule)",
        "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }\n",
        "begin_line": 325,
        "end_line": 330,
        "comment": " Sets the module to which the input belongs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.initBasedOnOptions#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
        "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n",
        "begin_line": 431,
        "end_line": 437,
        "comment": "\n   * Do any initialization that is dependent on the compiler options.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.makeCompilerInput#439",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(java.util.List<T>, boolean)",
        "snippet": "  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n",
        "begin_line": 439,
        "end_line": 446,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.checkFirstModule#460",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n",
        "begin_line": 460,
        "end_line": 468,
        "comment": "\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.fillEmptyModules#482",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n",
        "begin_line": 482,
        "end_line": 489,
        "comment": "\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getAllInputsFromModules#505",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n",
        "begin_line": 505,
        "end_line": 521,
        "comment": "\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.initInputsByIdMap#533",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initInputsByIdMap()",
        "snippet": "  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n",
        "begin_line": 533,
        "end_line": 549,
        "comment": "\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0264
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.analyze#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
        "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }\n",
        "begin_line": 201,
        "end_line": 229,
        "comment": "\n   * Finds a fixed-point solution. The function has the side effect of replacing\n   * the existing node annotations with the computed solutions using {@link\n   * com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.\n   *\n   * <p>Initially, each node's input and output flow state contains the value\n   * given by {@link #createInitialEstimateLattice()} (with the exception of the\n   * entry node of the graph which takes on the {@link #createEntryLattice()}\n   * value. Each node will use the output state of its predecessor and compute a\n   * output state according to the instruction. At that time, any nodes that\n   * depends on the node's newly modified output value will need to recompute\n   * their output state again. Each step will perform a computation at one node\n   * until no extra computation will modify any existing output state anymore.\n   *\n   * @param maxSteps Max number of iterations before the method stops and throw\n   *        a {@link MaxIterationsExceededException}. This will prevent the\n   *        analysis from going into a infinite loop.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.isReservedKeyword#935",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.isReservedKeyword(java.lang.String)",
        "snippet": "    private boolean isReservedKeyword(String identifier) {\n      if (config.languageMode == LanguageMode.ECMASCRIPT3) {\n        return TokenStream.isKeyword(identifier);\n      }\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }\n",
        "begin_line": 935,
        "end_line": 940,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConvention.AssertionFunctionSpec#386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.AssertionFunctionSpec(java.lang.String)",
        "snippet": "    public AssertionFunctionSpec(String functionName) {\n      this(functionName, null);\n    }\n",
        "begin_line": 386,
        "end_line": 388,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConvention.AssertionFunctionSpec#390",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.AssertionFunctionSpec(java.lang.String, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "    public AssertionFunctionSpec(String functionName,\n        JSTypeNative assertedType) {\n      this.functionName = functionName;\n      this.assertedType = assertedType;\n    }\n",
        "begin_line": 390,
        "end_line": 394,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConvention.getFunctionName#397",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.getFunctionName()",
        "snippet": "    public String getFunctionName() {\n      return functionName;\n    }\n",
        "begin_line": 397,
        "end_line": 399,
        "comment": " Returns the name of the function. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.AssertInstanceofSpec#446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.AssertInstanceofSpec.AssertInstanceofSpec(java.lang.String)",
        "snippet": "    public AssertInstanceofSpec(String functionName) {\n      super(functionName, JSTypeNative.OBJECT_TYPE);\n    }\n",
        "begin_line": 446,
        "end_line": 448,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.AssertFunctionByTypeName#479",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.AssertFunctionByTypeName.AssertFunctionByTypeName(java.lang.String, java.lang.String)",
        "snippet": "    public AssertFunctionByTypeName(String functionName, String typeName) {\n      super(functionName);\n      this.typeName = typeName;\n    }\n",
        "begin_line": 479,
        "end_line": 482,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.getAssertionFunctions#369",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getAssertionFunctions()",
        "snippet": "  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        new AssertFunctionByTypeName(\"goog.asserts.assertElement\", \"Element\"),\n        new AssertInstanceofSpec(\"goog.asserts.assertInstanceof\")\n    );\n  }\n",
        "begin_line": 369,
        "end_line": 386,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "InputId.getIdName#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.getIdName()",
        "snippet": "  public String getIdName() {\n    return id;\n  }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.getName#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
        "snippet": "  @Override\n  public String getName() {\n    return id.getIdName();\n  }\n",
        "begin_line": 99,
        "end_line": 102,
        "comment": " Returns a name for this input. Must be unique across all inputs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.IRFactory#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.IRFactory(java.lang.String, com.google.javascript.rhino.jstype.StaticSourceFile, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  private IRFactory(String sourceString,\n                    StaticSourceFile sourceFile,\n                    Config config,\n                    ErrorReporter errorReporter) {\n    this.sourceString = sourceString;\n    this.sourceFile = sourceFile;\n\n    // Sometimes this will be null in tests.\n    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n\n    this.config = config;\n    this.errorReporter = errorReporter;\n    this.transformDispatcher = new TransformDispatcher();\n    // The template node properties are applied to all nodes in this transform.\n    this.templateNode = createTemplateNode();\n\n    switch (config.languageMode) {\n      case ECMASCRIPT3:\n        reservedKeywords = null; // use TokenStream.isKeyword instead\n        break;\n      case ECMASCRIPT5:\n        reservedKeywords = ES5_RESERVED_KEYWORDS;\n        break;\n      case ECMASCRIPT5_STRICT:\n        reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS;\n        break;\n      default:\n        throw new IllegalStateException(\"unknown language mode\");\n    }\n  }\n",
        "begin_line": 145,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getParserConfig#2088",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
        "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n",
        "begin_line": 2088,
        "end_line": 2113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.mergeLineCharNo#1193",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int, int)",
        "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }\n",
        "begin_line": 1193,
        "end_line": 1201,
        "comment": "\n   * Merges the line number and character number in one integer. The Character\n   * number takes the first 12 bits and the line number takes the rest. If\n   * the character number is greater than <code>2<sup>12</sup>-1</code> it is\n   * adjusted to <code>2<sup>12</sup>-1</code>.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverseFunction#544",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }\n",
        "begin_line": 544,
        "end_line": 577,
        "comment": " Traverses a function. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler#830",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n",
        "begin_line": 830,
        "end_line": 857,
        "comment": "\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0263
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getIntValue#337",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.getIntValue()",
        "snippet": "    @Override\n    public int getIntValue() {\n      return intValue;\n    }\n",
        "begin_line": 337,
        "end_line": 340,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getIntProp#827",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
        "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.getIntValue();\n  }\n",
        "begin_line": 827,
        "end_line": 833,
        "comment": "\n   * Returns the integer value for the property, or 0 if the property\n   * is not defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "IR.block#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.block()",
        "snippet": "  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.setCodingConvention#1460",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }\n",
        "begin_line": 1460,
        "end_line": 1462,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getVar#528",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getVar(java.lang.String)",
        "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 528,
        "end_line": 537,
        "comment": "\n   * Returns the variable, may be null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getEnclosingFunction#580",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getEnclosingFunction()",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  public Node getEnclosingFunction() {\n    if (scopes.size() + scopeRoots.size() < 2) {\n      return null;\n    } else {\n      if (scopeRoots.isEmpty()) {\n        return scopes.peek().getRootNode();\n      } else {\n        return scopeRoots.peek();\n      }\n    }\n  }\n",
        "begin_line": 580,
        "end_line": 591,
        "comment": " Examines the functions stack for the last instance of a function node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.toMaybeFunctionType#356",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public static FunctionType toMaybeFunctionType(JSType type) {\n    return type == null ? null : type.toMaybeFunctionType();\n  }\n",
        "begin_line": 356,
        "end_line": 358,
        "comment": "\n   * Null-safe version of toMaybeFunctionType().\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transform#366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
        "begin_line": 366,
        "end_line": 375,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.maybeInjectCastNode#377",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeInjectCastNode(com.google.javascript.rhino.head.ast.AstNode, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n        && node instanceof ParenthesizedExpression\n        && info.hasType()) {\n      irNode = newNode(Token.CAST, irNode);\n    }\n    return irNode;\n  }\n",
        "begin_line": 377,
        "end_line": 384,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowGraph.isEnteringNewCfgNode#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // bleeds into the local scope and parameters are assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body, represented by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // These control structures are represented by a node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n\n      case Token.FOR:\n        // The FOR(;;) node differs from other control structures in that\n        // it has an initialization and an increment statement. Those\n        // two statements have corresponding CFG nodes to represent them.\n        // The FOR node only represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          // TODO(user): Investigate how we should handle the case where\n          // we have a very complex expression inside the FOR-IN header.\n          return n != parent.getFirstChild();\n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 159,
        "end_line": 205,
        "comment": "\n   * @return True if n should be represented by a new CFG node in the control\n   * flow graph.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getBaseType#1203",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
        "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }\n",
        "begin_line": 1203,
        "end_line": 1205,
        "comment": "\n   * Gets the base type specified by the {@code @extends} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasBaseType#1373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
        "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }\n",
        "begin_line": 1373,
        "end_line": 1375,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @extends}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.hasAnySingletonTypeTags#1182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
        "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }\n",
        "begin_line": 1182,
        "end_line": 1186,
        "comment": "\n   * Whether the current doc info has any of the singleton type\n   * tags that may not appear with other type tags, like\n   * {@code @type} or {@code @typedef}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasReturnType#1129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
        "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1129,
        "end_line": 1131,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @return}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasThisType#1191",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
        "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }\n",
        "begin_line": 1191,
        "end_line": 1193,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @this}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0262
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.markAnnotation#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(java.lang.String, int, int)",
        "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(annotation);\n      position.setPositionInformation(lineno, charno, lineno,\n          charno + annotation.length());\n      marker.setAnnotation(position);\n      populated = true;\n    }\n\n    currentMarker = marker;\n  }\n",
        "begin_line": 157,
        "end_line": 171,
        "comment": "\n   * Adds a marker to the current JSDocInfo and populates the marker with the\n   * annotation information.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasEnumParameterType#1113",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
        "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }\n",
        "begin_line": 1113,
        "end_line": 1115,
        "comment": "\n   * Returns whether an enum parameter type, specified using the {@code @enum}\n   * annotation, is present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasTypedefType#1121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
        "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }\n",
        "begin_line": 1121,
        "end_line": 1123,
        "comment": "\n   * Returns whether a typedef parameter type, specified using the\n   * {@code @typedef} annotation, is present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getLineno#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
        "snippet": "  final int getLineno() { return lineno; }\n",
        "begin_line": 225,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getCharno#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
        "snippet": "  final int getCharno() {\n    return lineno == initLineno ? initCharno + charno : charno;\n  }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getString#231",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
        "snippet": "  final String getString() { return string; }\n",
        "begin_line": 231,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.isAlpha#269",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
        "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }\n",
        "begin_line": 269,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processAssignment#577",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processAssignment(com.google.javascript.rhino.head.ast.Assignment)",
        "snippet": "    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n      return assign;\n    }\n",
        "begin_line": 577,
        "end_line": 588,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.JSDocInfoBuilder#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
        "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }\n",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordOriginalCommentString#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordOriginalCommentString(java.lang.String)",
        "snippet": "  public void recordOriginalCommentString(String sourceComment) {\n    if (parseDocumentation) {\n      currentInfo.setOriginalCommentString(sourceComment);\n    }\n  }\n",
        "begin_line": 78,
        "end_line": 82,
        "comment": "\n   * Sets the original JSDoc comment string. This is a no-op if the builder\n   * isn't configured to record documentation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.recordOriginalCommentPosition#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordOriginalCommentPosition(int)",
        "snippet": "  public void recordOriginalCommentPosition(int position) {\n    if (parseDocumentation) {\n      currentInfo.setOriginalCommentPosition(position);\n    }\n  }\n",
        "begin_line": 87,
        "end_line": 91,
        "comment": "\n   * Sets the position of original JSDoc comment.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.shouldParseDocumentation#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.shouldParseDocumentation()",
        "snippet": "  public boolean shouldParseDocumentation() {\n    return parseDocumentation;\n  }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.isPopulated#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
        "snippet": "  public boolean isPopulated() {\n    return populated;\n  }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": "\n   * Returns whether this builder is populated with information that can be\n   * used to {@link #build} a {@link JSDocInfo} object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.isPopulatedWithFileOverview#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
        "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns() ||\n         currentInfo.isNoCompile());\n  }\n",
        "begin_line": 110,
        "end_line": 114,
        "comment": "\n   * Returns whether this builder is populated with information that can be\n   * used to {@link #build} a {@link JSDocInfo} object that has a\n   * fileoverview tag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.build#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(com.google.javascript.rhino.Node)",
        "snippet": "  public JSDocInfo build(Node associatedNode) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setAssociatedNode(associatedNode);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 133,
        "end_line": 144,
        "comment": "\n   * Builds a {@link JSDocInfo} object based on the populated information and\n   * returns it. Once this method is called, the builder can be reused to build\n   * another {@link JSDocInfo} object.\n   *\n   * @param associatedNode The source node containing the JSDoc.\n   * @return a {@link JSDocInfo} object populated with the values given to this\n   *     builder. If no value was populated, this method simply returns\n   *     {@code null}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfoBuilder.populateDefaults#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }\n",
        "begin_line": 147,
        "end_line": 151,
        "comment": " Generate defaults when certain parameters are not specified. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isConstructor#497",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
        "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }\n",
        "begin_line": 497,
        "end_line": 499,
        "comment": "\n   * Returns whether the {@code @constructor} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isInterface#578",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
        "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }\n",
        "begin_line": 578,
        "end_line": 580,
        "comment": "\n   * Returns whether the {@code @interface} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isExterns#634",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
        "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }\n",
        "begin_line": 634,
        "end_line": 636,
        "comment": "\n   * Returns whether the {@code @externs} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.isNoCompile#650",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoCompile()",
        "snippet": "  public boolean isNoCompile() {\n    return getFlag(MASK_NOCOMPILE);\n  }\n",
        "begin_line": 650,
        "end_line": 652,
        "comment": "\n   * Returns whether the {@code @nocompile} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setVisibility#681",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(com.google.javascript.rhino.JSDocInfo.Visibility)",
        "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }\n",
        "begin_line": 681,
        "end_line": 683,
        "comment": " Visible for testing.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasFileOverview#1542",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
        "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }\n",
        "begin_line": 1542,
        "end_line": 1544,
        "comment": "\n   * Returns whether this has a fileoverview flag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.setAssociatedNode#1564",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setAssociatedNode(com.google.javascript.rhino.Node)",
        "snippet": "  public void setAssociatedNode(Node node) {\n    this.associatedNode = node;\n  }\n",
        "begin_line": 1564,
        "end_line": 1566,
        "comment": "\n   * Sets the node associated with this JSDoc.\n   * Notice that many nodes may have pointer to the same JSDocInfo\n   * object (because we propagate it across the type graph). But there\n   * is only one canonical \"owner\" node of the JSDocInfo, which corresponds\n   * to its original place in the syntax tree.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.JsDocTokenStream#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(java.lang.String, int, int)",
        "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }\n",
        "begin_line": 44,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getStringFromBuffer#235",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
        "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }\n",
        "begin_line": 235,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.addToString#240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
        "snippet": "  private void addToString(int c) {\n    int n = stringBufferTop;\n    if (n == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, n);\n        stringBuffer = tmp;\n    }\n    stringBuffer[n] = (char) c;\n    stringBufferTop = n + 1;\n  }\n",
        "begin_line": 240,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.ungetChar#251",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
        "snippet": "  void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }\n",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.isJSSpace#308",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
        "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char) c) == Character.SPACE_SEPARATOR;\n    }\n  }\n",
        "begin_line": 308,
        "end_line": 315,
        "comment": " As defined in ECMA.  jsscan.c uses C isspace() (which allows\n   * \\v, I think.)  note that code in getChar() implicitly accepts\n   * '\\r' == \\u000D as well.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getCharIgnoreLineEnd#391",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
        "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for (;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }\n",
        "begin_line": 391,
        "end_line": 435,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocTokenStream.getOffset#445",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
        "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }\n",
        "begin_line": 445,
        "end_line": 447,
        "comment": "\n   * Returns the offset into the current line.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.setFileLevelJsDocBuilder#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(com.google.javascript.rhino.Node.FileLevelJsDocBuilder)",
        "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }\n",
        "begin_line": 110,
        "end_line": 113,
        "comment": "\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.setFileOverviewJSDocInfo#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": "\n   * Sets the file overview JSDocInfo, in order to warn about multiple uses of\n   * the @fileoverview tag in a file.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.JsDocInfoParser#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(com.google.javascript.jscomp.parsing.JsDocTokenStream, com.google.javascript.rhino.head.ast.Comment, com.google.javascript.rhino.Node, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.associatedNode = associatedNode;\n\n    // Sometimes this will be null in tests.\n    this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();\n\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    if (commentNode != null) {\n      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n      this.jsdocBuilder.recordOriginalCommentPosition(commentNode.getPosition());\n    }\n    this.annotationNames = config.annotationNames;\n    this.suppressionNames = config.suppressionNames;\n\n    this.errorReporter = errorReporter;\n    this.templateNode = this.createTemplateNode();\n  }\n",
        "begin_line": 129,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.checkExtendedTypes#1079",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.checkExtendedTypes(java.util.List<com.google.javascript.jscomp.parsing.JsDocInfoParser.ExtendedTypeInfo>)",
        "snippet": "  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      // If interface, record the multiple extended interfaces\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1079,
        "end_line": 1094,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.createTemplateNode#2366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createTemplateNode()",
        "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = IR.script();\n    templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);\n    return templateNode;\n  }\n",
        "begin_line": 2366,
        "end_line": 2374,
        "comment": " e.g., source-name, between all nodes.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.match#2427",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }\n",
        "begin_line": 2427,
        "end_line": 2430,
        "comment": "\n   * Tests whether the next symbol of the token stream matches the specific\n   * token.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.next#2445",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
        "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }\n",
        "begin_line": 2445,
        "end_line": 2451,
        "comment": "\n   * Gets the next token of the token stream or the buffered token if a matching\n   * was previously made.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.current#2456",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
        "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }\n",
        "begin_line": 2456,
        "end_line": 2460,
        "comment": "\n   * Gets the current token, invalidating it in the process.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo#2488",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
        "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }\n",
        "begin_line": 2488,
        "end_line": 2490,
        "comment": "\n   * Determines whether the parser has been populated with docinfo with a\n   * fileoverview tag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo#2496",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
        "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(associatedNode);\n  }\n",
        "begin_line": 2496,
        "end_line": 2498,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsDocInfoParser.getFileOverviewJSDocInfo#2503",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
        "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }\n",
        "begin_line": 2503,
        "end_line": 2505,
        "comment": "\n   * Gets the fileoverview JSDocInfo, if any.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.handlePossibleFileOverviewJsDoc#264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.handlePossibleFileOverviewJsDoc(com.google.javascript.jscomp.parsing.JsDocInfoParser)",
        "snippet": "  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 264,
        "end_line": 271,
        "comment": "\n   * @return true if the jsDocParser represents a fileoverview.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.handleJsDoc#279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(com.google.javascript.rhino.head.ast.AstNode, com.google.javascript.rhino.Node)",
        "snippet": "  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node);\n        }\n        return info;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 279,
        "end_line": 293,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.createJsDocInfoParser#464",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.createJsDocInfoParser(com.google.javascript.rhino.head.ast.Comment, com.google.javascript.rhino.Node)",
        "snippet": "  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
        "begin_line": 464,
        "end_line": 484,
        "comment": "\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getVisibility#1004",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
        "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }\n",
        "begin_line": 1004,
        "end_line": 1006,
        "comment": "\n   * Gets the visibility specified by {@code @private}, {@code @protected} or\n   * {@code @public} annotation. If no visibility is specified, visibility\n   * is inherited from the base class.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasType#1105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
        "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1105,
        "end_line": 1107,
        "comment": "\n   * Returns whether a type, specified using the {@code @type} annotation, is\n   * present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.hasType#1133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
        "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }\n",
        "begin_line": 1133,
        "end_line": 1135,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transformTree#186",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(com.google.javascript.rhino.head.ast.AstRoot, com.google.javascript.rhino.jstype.StaticSourceFile, java.lang.String, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }\n",
        "begin_line": 186,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.JSDocInfo#351",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
        "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }\n",
        "begin_line": 351,
        "end_line": 353,
        "comment": "\n   * Creates a {@link JSDocInfo} object. This object should be created using\n   * a {@link JSDocInfoBuilder}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getFlag#676",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
        "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }\n",
        "begin_line": 676,
        "end_line": 678,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IR.script#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.script()",
        "snippet": "  public static Node script() {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    return block;\n  }\n",
        "begin_line": 124,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setJSDocInfo#1886",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  public Node setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n      return this;\n  }\n",
        "begin_line": 1886,
        "end_line": 1889,
        "comment": "\n   * Sets the {@link JSDocInfo} attached to this node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.validAssignmentTarget#1219",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.validAssignmentTarget(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.CAST: // CAST is a bit weird, but syntactically valid.\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n",
        "begin_line": 1219,
        "end_line": 1228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "SyntacticScopeCreator.declareVar#190",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(com.google.javascript.rhino.Node)",
        "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.isName());\n\n    CompilerInput input = compiler.getInput(inputId);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }\n",
        "begin_line": 190,
        "end_line": 202,
        "comment": "\n   * Declares a variable.\n   *\n   * @param n The node corresponding to the variable name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processPropertyGet#1028",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processPropertyGet(com.google.javascript.rhino.head.ast.PropertyGet)",
        "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      Node leftChild = transform(getNode.getTarget());\n      AstNode nodeProp = getNode.getProperty();\n      Node rightChild = transformAsString(nodeProp);\n      if (nodeProp instanceof Name && !isAllowedProp(\n          ((Name) nodeProp).getIdentifier())) {\n        errorReporter.warning(INVALID_ES3_PROP_NAME, sourceName,\n            rightChild.getLineno(), \"\", rightChild.getCharno());\n      }\n      Node newNode = newNode(\n          Token.GETPROP, leftChild, rightChild);\n      newNode.setLineno(leftChild.getLineno());\n      newNode.setCharno(leftChild.getCharno());\n      maybeSetLengthFrom(newNode, getNode);\n      return newNode;\n    }\n",
        "begin_line": 1028,
        "end_line": 1044,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.declare#479",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.declare(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }\n",
        "begin_line": 479,
        "end_line": 481,
        "comment": "\n   * Declares a variable whose type is inferred.\n   *\n   * @param name name of the variable\n   * @param nameNode the NAME node declaring the variable\n   * @param type the variable's type\n   * @param input the input in which this variable is defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.isExtern#337",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.isExtern()",
        "snippet": "  public boolean isExtern() {\n    if (ast == null || ast.getSourceFile() == null) {\n      return false;\n    }\n    return ast.getSourceFile().isExtern();\n  }\n",
        "begin_line": 337,
        "end_line": 342,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.isExtern#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.isExtern()",
        "snippet": "  @Override\n  public boolean isExtern() {\n    return isExternFile;\n  }\n",
        "begin_line": 179,
        "end_line": 182,
        "comment": " Returns whether this is an extern. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.setLanguageIn#1560",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setLanguageIn(com.google.javascript.jscomp.CompilerOptions.LanguageMode)",
        "snippet": "  public void setLanguageIn(LanguageMode languageIn) {\n    this.languageIn = languageIn;\n    this.languageOut = languageIn;\n  }\n",
        "begin_line": 1560,
        "end_line": 1563,
        "comment": "\n   * Sets ECMAScript version to use.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isGet#1581",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isGet(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isGet(Node n) {\n    return n.isGetProp() || n.isGetElem();\n  }\n",
        "begin_line": 1581,
        "end_line": 1583,
        "comment": "\n   * Is this a GETPROP or GETELEM node?\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0261
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processInfixExpression#862",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processInfixExpression(com.google.javascript.rhino.head.ast.InfixExpression)",
        "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      n.setLineno(exprNode.getLineno());\n      n.setCharno(position2charno(exprNode.getAbsolutePosition()));\n      maybeSetLengthFrom(n, exprNode);\n      return n;\n    }\n",
        "begin_line": 862,
        "end_line": 872,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.Node#364",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node)",
        "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 364,
        "end_line": 376,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getJSType#1837",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJSType()",
        "snippet": "  public JSType getJSType() {\n      return jsType;\n  }\n",
        "begin_line": 1837,
        "end_line": 1839,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.isGlobal#602",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
        "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }\n",
        "begin_line": 602,
        "end_line": 604,
        "comment": "\n   * Returns whether this is the global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.getOptionalNodeComparator#1021",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.getOptionalNodeComparator(boolean)",
        "snippet": "    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n",
        "begin_line": 1021,
        "end_line": 1046,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.compare#1031",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.Anonymous-e9a9cc57-7cd7-4266-9345-b30c30935746.compare(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n",
        "begin_line": 1031,
        "end_line": 1035,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transformAsString#548",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.transformAsString(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name) n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral) n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.isString());\n      return ret;\n    }\n",
        "begin_line": 548,
        "end_line": 561,
        "comment": "\n     * Transforms the given node and then sets its type to Token.STRING if it\n     * was Token.NAME. If its type was already Token.STRING, then quotes it.\n     * Used for properties, as the old AST uses String tokens, while the new one\n     * uses Name tokens for unquoted strings. For example, in\n     * var o = {'a' : 1, b: 2};\n     * the string 'a' is quoted, while the name b is turned into a string, but\n     * unquoted.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processName#914",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processName(com.google.javascript.rhino.head.ast.Name, boolean)",
        "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }\n",
        "begin_line": 914,
        "end_line": 926,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transformNameAsString#409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformNameAsString(com.google.javascript.rhino.head.ast.Name)",
        "snippet": "  private Node transformNameAsString(Name node) {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
        "begin_line": 409,
        "end_line": 417,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getOutEdges#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getOutEdges(N)",
        "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n  }\n",
        "begin_line": 127,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getDirectedPredNodes#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedPredNodes(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedPredNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getInEdges()) {\n      nodeList.add(edge.getSource());\n    }\n    return nodeList;\n  }\n",
        "begin_line": 227,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.DataFlowAnalysis#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(com.google.javascript.jscomp.ControlFlowGraph<N>, com.google.javascript.jscomp.JoinOp<L>)",
        "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 130,
        "comment": "\n   * Constructs a data flow analysis.\n   *\n   * <p>Typical usage\n   * <pre>\n   * DataFlowAnalysis dfa = ...\n   * dfa.analyze();\n   * </pre>\n   *\n   * {@link #analyze()} annotates the result to the control flow graph by\n   * means of {@link DiGraphNode#setAnnotation} without any\n   * modification of the graph itself. Additional calls to {@link #analyze()}\n   * recomputes the analysis which can be useful if the control flow graph\n   * has been modified.\n   *\n   * @param targetCfg The control flow graph object that this object performs\n   *     on. Modification of the graph requires a separate call to\n   *     {@link #analyze()}.\n   *\n   * @see #analyze()\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.getCfg#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
        "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n   * Returns the control flow graph that this analysis was performed on.\n   * Modifications can be done on this graph, however, the only time that the\n   * annotations are correct is after {@link #analyze()} is called and before\n   * the graph has been modified.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "DataFlowAnalysis.analyze#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
        "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }\n",
        "begin_line": 179,
        "end_line": 181,
        "comment": "\n   * Finds a fixed-point solution using at most {@link #MAX_STEPS}\n   * iterations.\n   *\n   * @see #analyze(int)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.getPosition#1052",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.getPosition(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n",
        "begin_line": 1052,
        "end_line": 1056,
        "comment": "\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getSource#478",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getSource()",
        "snippet": "    @Override\n    public DiGraphNode<N, E> getSource() {\n      return sourceNode;\n    }\n",
        "begin_line": 478,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "SyntacticScopeCreator.createScope#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    inputId = null;\n    if (parent == null) {\n      scope = Scope.createGlobalScope(n);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n);\n\n    inputId = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }\n",
        "begin_line": 55,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getAnnotation#441",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.getAnnotation()",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }\n",
        "begin_line": 441,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.setAnnotation#447",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.setAnnotation(com.google.javascript.jscomp.graph.Annotation)",
        "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }\n",
        "begin_line": 447,
        "end_line": 450,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.computeFollowNode#674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowAnalysis)",
        "snippet": "  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n",
        "begin_line": 674,
        "end_line": 676,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isSyntheticBlock#1949",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
        "snippet": "  public boolean isSyntheticBlock() {\n    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n  }\n",
        "begin_line": 1949,
        "end_line": 1951,
        "comment": "\n   * Returns whether this is a synthetic block that should not be considered\n   * a real source block.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode#437",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.AnnotatedLinkedDirectedGraphNode(N)",
        "snippet": "    AnnotatedLinkedDirectedGraphNode(N nodeValue) {\n      super(nodeValue);\n    }\n",
        "begin_line": 437,
        "end_line": 439,
        "comment": "\n     * @param nodeValue Node's value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getDirectedSuccNodes#240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }\n",
        "begin_line": 240,
        "end_line": 251,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Graph.connectIfNotFound#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N, E, N)",
        "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    if (!isConnected(n1, edge, n2)) {\n      connect(n1, edge, n2);\n    }\n  }\n",
        "begin_line": 119,
        "end_line": 123,
        "comment": "\n   * Connects two nodes in the graph with an edge if such edge does not already\n   * exists between the nodes.\n   *\n   * @param n1 First node.\n   * @param edge The edge.\n   * @param n2 Second node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiGraph.isConnected#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/DiGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.DiGraph",
        "signature": "com.google.javascript.jscomp.graph.DiGraph.isConnected(N, E, N)",
        "snippet": "  @Override\n  public boolean isConnected(N n1, E e, N n2) {\n    return isConnectedInDirection(n1, e, n2) ||\n        isConnectedInDirection(n2, e, n1);\n  }\n",
        "begin_line": 97,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowGraph.ControlFlowGraph#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N, boolean, boolean)",
        "snippet": "  ControlFlowGraph(\n      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n    super(nodeAnnotations, edgeAnnotations);\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }\n",
        "begin_line": 47,
        "end_line": 52,
        "comment": "\n   * Constructor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowGraph.getImplicitReturn#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
        "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n   * Gets the implicit return node.\n   *\n   * @return Return node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowGraph.getEntry#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
        "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }\n",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n   * Gets the entry point of the control flow graph. In general, this should be\n   * the beginning of the global script or beginning of a function.\n   *\n   * @return The entry point.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.AstControlFlowGraph#1013",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.AstControlFlowGraph(com.google.javascript.rhino.Node, java.util.Map<com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, java.lang.Integer>, boolean)",
        "snippet": "    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n",
        "begin_line": 1013,
        "end_line": 1019,
        "comment": "\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.ControlFlowAnalysis#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(com.google.javascript.jscomp.AbstractCompiler, boolean, boolean)",
        "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n",
        "begin_line": 137,
        "end_line": 142,
        "comment": "\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.getCfg#144",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
        "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n",
        "begin_line": 144,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.process#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n",
        "begin_line": 148,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.prioritizeFromEntryNode#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n",
        "begin_line": 196,
        "end_line": 215,
        "comment": "\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.computeFallThrough#796",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(com.google.javascript.rhino.Node)",
        "snippet": "  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n",
        "begin_line": 796,
        "end_line": 810,
        "comment": "\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.createEdge#818",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch, com.google.javascript.rhino.Node)",
        "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n",
        "begin_line": 818,
        "end_line": 823,
        "comment": "\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isTry#2425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isTry()",
        "snippet": "  public boolean isTry() {\n    return this.getType() == Token.TRY;\n  }\n",
        "begin_line": 2425,
        "end_line": 2427,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.026
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasMoreThanOneChild#1401",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasMoreThanOneChild()",
        "snippet": "  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }\n",
        "begin_line": 1401,
        "end_line": 1403,
        "comment": "\n   * Check for more than one child more efficiently than by iterating over all\n   * the children as is done with Node.getChildCount().\n   *\n   * @return Whether the node more than one child.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.isConnectedInDirection#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N, E, N)",
        "snippet": "  @Override\n  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n  }\n",
        "begin_line": 198,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.isConnectedInDirection#203",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N, com.google.common.base.Predicate<E>, N)",
        "snippet": "  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n    // Verify the nodes.\n    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2 &&\n          edgeMatcher.apply(outEdge.getValue())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 203,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getWarnings#1008",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
        "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n",
        "begin_line": 1008,
        "end_line": 1010,
        "comment": "\n   * Returns the array of warnings (never null).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.getWarnings#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
        "snippet": "  @Override\n  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }\n",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getValue#498",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getValue()",
        "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }\n",
        "begin_line": 498,
        "end_line": 501,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getInEdges#387",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getInEdges()",
        "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }\n",
        "begin_line": 387,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraphEdge#471",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.LinkedDirectedGraphEdge(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>, E, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "    LinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n        E edgeValue, DiGraphNode<N, E> destNode) {\n      this.value = edgeValue;\n      this.sourceNode = sourceNode;\n      this.destNode = destNode;\n    }\n",
        "begin_line": 471,
        "end_line": 476,
        "comment": "\n     * Constructor.\n     *\n     * @param edgeValue Edge Value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getDestination#483",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getDestination()",
        "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }\n",
        "begin_line": 483,
        "end_line": 486,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.connect#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N, E, N)",
        "snippet": "  @Override\n  public void connect(N srcValue, E edgeValue, N destValue) {\n    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n    LinkedDirectedGraphEdge<N, E> edge =\n        useEdgeAnnotations ?\n        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n  }\n",
        "begin_line": 77,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getNode#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
        "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isExprResult#2293",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isExprResult()",
        "snippet": "  public boolean isExprResult() {\n    return this.getType() == Token.EXPR_RESULT;\n  }\n",
        "begin_line": 2293,
        "end_line": 2295,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "Graph.getNodeOrFail#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.getNodeOrFail(N)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n    T node = (T) getNode(val);\n    if (node == null) {\n      throw new IllegalArgumentException(val + \" does not exist in graph\");\n    }\n    return node;\n  }\n",
        "begin_line": 218,
        "end_line": 225,
        "comment": "\n   * Gets the node of the specified type, or throws an\n   * IllegalArgumentException.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverseRoots#500",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(com.google.javascript.jscomp.AbstractCompiler, java.util.List<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n",
        "begin_line": 500,
        "end_line": 504,
        "comment": "\n   * Traverses a list of node trees.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getDirectedGraphNodes#105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
        "snippet": "  @Override\n  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n        nodes.values());\n  }\n",
        "begin_line": 105,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraphNode#346",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.LinkedDirectedGraphNode(N)",
        "snippet": "    LinkedDirectedGraphNode(N nodeValue) {\n      this.value = nodeValue;\n    }\n",
        "begin_line": 346,
        "end_line": 348,
        "comment": "\n     * Constructor\n     *\n     * @param nodeValue Node's value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getValue#350",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getValue()",
        "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }\n",
        "begin_line": 350,
        "end_line": 353,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getOutEdges#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getOutEdges()",
        "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }\n",
        "begin_line": 392,
        "end_line": 395,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraph#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraph(boolean, boolean)",
        "snippet": "  protected LinkedDirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }\n",
        "begin_line": 71,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.getDirectedGraphNode#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
        "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }\n",
        "begin_line": 111,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.createDirectedGraphNode#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
        "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = useNodeAnnotations ?\n          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n          new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }\n",
        "begin_line": 133,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedDirectedGraph.createNode#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
        "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }\n",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getParentNode#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getParentNode()",
        "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Gets the parent of the name node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverseBranch#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }\n",
        "begin_line": 515,
        "end_line": 541,
        "comment": "\n   * Traverses a branch.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0259
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.isDirective#626",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.isDirective(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) {\n        return false;\n      }\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n",
        "begin_line": 626,
        "end_line": 634,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0258
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroupWarningsGuard.disables#40",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0258
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processVariableDeclaration#1230",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processVariableDeclaration(com.google.javascript.rhino.head.ast.VariableDeclaration)",
        "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.rhino.head.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n",
        "begin_line": 1230,
        "end_line": 1242,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0258
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.shouldTraverse#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n",
        "begin_line": 133,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0258
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.Scope#386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Scope(com.google.javascript.jscomp.Scope, com.google.javascript.rhino.Node)",
        "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }\n",
        "begin_line": 386,
        "end_line": 394,
        "comment": "\n   * Creates a Scope given the parent Scope and the root node of the scope.\n   * @param parent  The parent Scope. Cannot be null.\n   * @param rootNode  Typically the FUNCTION node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.newNode#1516",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1516,
        "end_line": 1518,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "VoidType.VoidType#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "VoidType.toStringHelper#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 94,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "VoidType.getDisplayName#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }\n",
        "begin_line": 99,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ValueType.ValueType#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ValueType.java",
        "class_name": "com.google.javascript.rhino.jstype.ValueType",
        "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.UnknownType#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(com.google.javascript.rhino.jstype.JSTypeRegistry, boolean)",
        "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.isSubtype#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return true;\n  }\n",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.UnionTypeBuilder#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.UnionTypeBuilder#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry, int)",
        "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.build#316",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
        "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }\n",
        "begin_line": 316,
        "end_line": 324,
        "comment": "\n   * Creates a union.\n   * @return A UnionType if it has two or more alternates, the\n   *    only alternate if it has one and otherwise {@code NO_TYPE}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionTypeBuilder.getAlternateListCopy#326",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
        "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }\n",
        "begin_line": 326,
        "end_line": 328,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnionType.UnionType#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.util.Collection<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }\n",
        "begin_line": 79,
        "end_line": 83,
        "comment": "\n   * Creates a union type.\n   *\n   * @param alternates the alternates of the union\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMapReplacer.TemplateTypeMapReplacer#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMapReplacer.TemplateTypeMapReplacer(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "  public TemplateTypeMapReplacer(\n      JSTypeRegistry registry, TemplateTypeMap replacements) {\n    super(registry);\n    this.replacements = replacements;\n    this.visitedTypes = new ArrayDeque<TemplateType>();\n  }\n",
        "begin_line": 60,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getTemplateKeys#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getTemplateKeys()",
        "snippet": "  public ImmutableList<TemplateType> getTemplateKeys() {\n    return templateKeys;\n  }\n",
        "begin_line": 103,
        "end_line": 105,
        "comment": "\n   * Returns a list of all template keys.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getTemplateType#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getTemplateType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  public JSType getTemplateType(TemplateType key) {\n    int index = getTemplateTypeIndex(key);\n    return (index == -1) ? registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n         templateValues.get(index);\n  }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "\n   * Returns the JSType value associated with the specified template key. If no\n   * JSType value is associated, returns UNKNOWN_TYPE.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.getResolvedTemplateType#178",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.getResolvedTemplateType(com.google.javascript.rhino.jstype.TemplateType)",
        "snippet": "  private JSType getResolvedTemplateType(TemplateType key) {\n    int index = getTemplateTypeIndex(key);\n    return (index == -1) ? registry.getNativeType(JSTypeNative.UNKNOWN_TYPE) :\n         resolvedTemplateValues.get(index);\n  }\n",
        "begin_line": 178,
        "end_line": 182,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateTypeMap.failedEquivalenceCheck#250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateTypeMap",
        "signature": "com.google.javascript.rhino.jstype.TemplateTypeMap.failedEquivalenceCheck(com.google.javascript.rhino.jstype.TemplateTypeMap.EquivalenceMatch, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  private boolean failedEquivalenceCheck(\n      EquivalenceMatch eqMatch, EquivalenceMethod eqMethod) {\n    return eqMatch == EquivalenceMatch.VALUE_MISMATCH ||\n        (eqMatch == EquivalenceMatch.NO_KEY_MATCH &&\n         eqMethod != EquivalenceMethod.INVARIANT);\n  }\n",
        "begin_line": 250,
        "end_line": 255,
        "comment": "\n   * Determines if the specified EquivalenceMatch is considered a failing\n   * condition for an equivalence check, given the EquivalenceMethod used for\n   * the check.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "TemplateType.TemplateType#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TemplateType.java",
        "class_name": "com.google.javascript.rhino.jstype.TemplateType",
        "signature": "com.google.javascript.rhino.jstype.TemplateType.TemplateType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String)",
        "snippet": "  TemplateType(JSTypeRegistry registry, String name) {\n    super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n    this.name = name;\n  }\n",
        "begin_line": 53,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "StringType.StringType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.StringType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "StringType.toStringHelper#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 90,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "StringType.getDisplayName#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.ProxyObjectType#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n    this(registry, referencedType, null);\n  }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProxyObjectType.ProxyObjectType#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "  ProxyObjectType(JSTypeRegistry registry, JSType referencedType,\n                  TemplateTypeMap templateTypeMap) {\n    super(registry, templateTypeMap);\n    setReferencedType(referencedType);\n  }\n",
        "begin_line": 66,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.PrototypeObjectType#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false, null);\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "\n   * Creates an object type.\n   *\n   * @param className the name of the class.  May be {@code null} to\n   *        denote an anonymous class.\n   *\n   * @param implicitPrototype the implicit prototype\n   *        (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the\n   *        implicit prototype is {@code null} the implicit prototype will be\n   *        set to the {@link JSTypeNative#OBJECT_TYPE}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.PrototypeObjectType#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.jstype.ObjectType, boolean, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType,\n      TemplateTypeMap templateTypeMap) {\n    super(registry, templateTypeMap);\n    this.properties = new PropertyMap();\n    this.properties.setParentSource(this);\n\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }\n",
        "begin_line": 112,
        "end_line": 127,
        "comment": "\n   * Creates an object type, allowing specification of the implicit prototype,\n   * whether the object is native, and any templatized types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.setPrettyPrint#271",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPrettyPrint(boolean)",
        "snippet": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getImplicitPrototype#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }\n",
        "begin_line": 284,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.setImplicitPrototype#295",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }\n",
        "begin_line": 295,
        "end_line": 298,
        "comment": "\n   * This should only be reset on the FunctionPrototypeType, only to fix an\n   * incorrectly established prototype chain due to the user having a mismatch\n   * in super class declaration, and only before properties on that type are\n   * processed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.hasReferenceName#311",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
        "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }\n",
        "begin_line": 311,
        "end_line": 314,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown#365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
        "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }\n",
        "begin_line": 365,
        "end_line": 374,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.hasCachedValues#376",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
        "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }\n",
        "begin_line": 376,
        "end_line": 379,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.isNativeObjectType#382",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
        "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }\n",
        "begin_line": 382,
        "end_line": 385,
        "comment": " Whether this is a built-in object. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.setOwnerFunction#387",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setOwnerFunction(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  @Override\n  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }\n",
        "begin_line": 387,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getOwnerFunction#393",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnerFunction()",
        "snippet": "  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }\n",
        "begin_line": 393,
        "end_line": 396,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrototypeObjectType.getCtorExtendedInterfaces#405",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorExtendedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n",
        "begin_line": 405,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.PropertyMap#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.PropertyMap()",
        "snippet": "  PropertyMap() {\n    this(Maps.<String, Property>newTreeMap());\n  }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.PropertyMap#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.PropertyMap(java.util.Map<java.lang.String, com.google.javascript.rhino.jstype.Property>)",
        "snippet": "  private PropertyMap(Map<String, Property> underlyingMap) {\n    this.properties = underlyingMap;\n  }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "PropertyMap.setParentSource#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.setParentSource(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  void setParentSource(ObjectType ownerType) {\n    if (this != EMPTY_MAP) {\n      this.parentSource = ownerType;\n    }\n  }\n",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.Property#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.Property(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  Property(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n    this.propertyNode = propertyNode;\n  }\n",
        "begin_line": 79,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getType#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getType()",
        "snippet": "  @Override\n      public JSType getType() {\n    return type;\n  }\n",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.ObjectType#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.ObjectType#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "  ObjectType(JSTypeRegistry registry, TemplateTypeMap templateTypeMap) {\n    super(registry, templateTypeMap);\n  }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.hasCachedValues#584",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
        "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }\n",
        "begin_line": 584,
        "end_line": 586,
        "comment": "\n   * Returns true if any cached values have been set for this type.  If true,\n   * then the prototype chain should not be changed, as it might invalidate the\n   * cached values.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.isFunctionPrototypeType#608",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isFunctionPrototypeType()",
        "snippet": "  @Override\n  public final boolean isFunctionPrototypeType() {\n    return getOwnerFunction() != null;\n  }\n",
        "begin_line": 608,
        "end_line": 611,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NumberType.NumberType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NumberType.toStringHelper#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NumberType.getDisplayName#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }\n",
        "begin_line": 100,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NullType.NullType#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.NullType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NullType.toStringHelper#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NullType.getDisplayName#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }\n",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoType.NoType#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoType",
        "signature": "com.google.javascript.rhino.jstype.NoType.NoType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoType.isNoType#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoType",
        "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
        "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }\n",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoResolvedType.NoResolvedType#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoResolvedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
        "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoObjectType.NoObjectType#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }\n",
        "begin_line": 66,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModificationVisitor.ModificationVisitor#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.ModificationVisitor",
        "signature": "com.google.javascript.rhino.jstype.ModificationVisitor.ModificationVisitor(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public ModificationVisitor(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.initializeBuiltInTypes#241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
        "snippet": "  private void initializeBuiltInTypes() {\n    objectIndexTemplateKey = new TemplateType(this, OBJECT_INDEX_TEMPLATE);\n    objectElementTemplateKey = new TemplateType(this, OBJECT_ELEMENT_TEMPLATE);\n\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    UnknownType checkedUnknownType = new UnknownType(this, true);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, checkedUnknownType);\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true, null);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null,\n            createTemplateTypeMap(ImmutableList.of(\n                objectIndexTemplateKey, objectElementTemplateKey), null),\n            true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null,\n          createTemplateTypeMap(ImmutableList.of(\n              objectElementTemplateKey), null),\n          true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (null,void)\n    JSType NULL_VOID =\n        createUnionType(NULL_TYPE, VOID_TYPE);\n    registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the Unknown type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            UNKNOWN_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }\n",
        "begin_line": 241,
        "end_line": 569,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.JSTypeRegistry#193",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(com.google.javascript.rhino.ErrorReporter, boolean)",
        "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    this.emptyTemplateTypeMap = new TemplateTypeMap(\n        this, ImmutableList.<TemplateType>of(), ImmutableList.<JSType>of());\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }\n",
        "begin_line": 193,
        "end_line": 202,
        "comment": "\n   * Constructs a new type registry populated with the built-in types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getObjectElementKey#208",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getObjectElementKey()",
        "snippet": "  public TemplateType getObjectElementKey() {\n    return this.objectElementTemplateKey;\n  }\n",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n   * @return The template variable corresponding to the property value type for\n   * Javascript Objects and Arrays.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.resetForTypeCheck#232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
        "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }\n",
        "begin_line": 232,
        "end_line": 239,
        "comment": "\n   * Reset to run the TypeCheck pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.initializeRegistry#571",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
        "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }\n",
        "begin_line": 571,
        "end_line": 595,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.register#597",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }\n",
        "begin_line": 597,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.register#601",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(com.google.javascript.rhino.jstype.JSType, java.lang.String)",
        "snippet": "  private void register(JSType type, String name) {\n    Preconditions.checkArgument(\n        !name.contains(\"<\"), \"Type names cannot contain template annotations.\");\n\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }\n",
        "begin_line": 601,
        "end_line": 612,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.registerNativeType#614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(com.google.javascript.rhino.jstype.JSTypeNative, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }\n",
        "begin_line": 614,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.registerPropertyOnType#630",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }\n",
        "begin_line": 630,
        "end_line": 642,
        "comment": "\n   * Tells the type system that {@code owner} may have a property named\n   * {@code propertyName}. This allows the registry to keep track of what\n   * types a property is defined upon.\n   *\n   * This is NOT the same as saying that {@code owner} must have a property\n   * named type. ObjectType#hasProperty attempts to minimize false positives\n   * (\"if we're not sure, then don't type check this property\"). The type\n   * registry, on the other hand, should attempt to minimize false negatives\n   * (\"if this property is assigned anywhere in the program, it must\n   * show up in the type registry\").\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getNativeType#903",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }\n",
        "begin_line": 903,
        "end_line": 905,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getNativeObjectType#907",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }\n",
        "begin_line": 907,
        "end_line": 909,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.getNativeFunctionType#911",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }\n",
        "begin_line": 911,
        "end_line": 913,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createUnionType#1041",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1041,
        "end_line": 1047,
        "comment": "\n   * Creates a union type whose variants are the arguments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createArrowType#1077",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }\n",
        "begin_line": 1077,
        "end_line": 1079,
        "comment": "\n   * Creates an arrow type, an abstract representation of the parameters\n   * and return value of a function.\n   *\n   * @param parametersNode the parameters' types, formatted as a Node with\n   *     param names and optionality info.\n   * @param returnType the function's return type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createArrowType#1087",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(com.google.javascript.rhino.Node)",
        "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }\n",
        "begin_line": 1087,
        "end_line": 1089,
        "comment": "\n   * Creates an arrow type with an unknown return type.\n   *\n   * @param parametersNode the parameters' types, formatted as a Node with\n   *     param names and optionality info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createFunctionTypeWithVarArgs#1133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }\n",
        "begin_line": 1133,
        "end_line": 1137,
        "comment": "\n   * Creates a function type. The last parameter type of the function is\n   * considered a variable length argument.\n   *\n   * @param returnType the function's return type\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createNativeFunctionTypeWithVarArgs#1146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionTypeWithVarArgs(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  private FunctionType createNativeFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createNativeFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }\n",
        "begin_line": 1146,
        "end_line": 1150,
        "comment": "\n   * Creates a function type. The last parameter type of the function is\n   * considered a variable length argument.\n   *\n   * @param returnType the function's return type\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createParametersWithVarArgs#1254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }\n",
        "begin_line": 1254,
        "end_line": 1256,
        "comment": "\n   * Creates a tree hierarchy representing a typed argument list. The last\n   * parameter type is considered a variable length argument.\n   *\n   * @param parameterTypes the parameter types. The last element of this array\n   *     is considered a variable length argument.\n   * @return a tree hierarchy representing a typed argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createOptionalParameters#1262",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }\n",
        "begin_line": 1262,
        "end_line": 1266,
        "comment": "\n   * Creates a tree hierarchy representing a typed parameter list in which\n   * every parameter is optional.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createParameters#1278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1278,
        "end_line": 1289,
        "comment": "\n   * Creates a tree hierarchy representing a typed argument list.\n   *\n   * @param lastVarArgs whether the last type should considered as a variable\n   *     length argument.\n   * @param parameterTypes the parameter types. The last element of this array\n   *     is considered a variable length argument is {@code lastVarArgs} is\n   *     {@code true}.\n   * @return a tree hierarchy representing a typed argument list\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createFunctionType#1298",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }\n",
        "begin_line": 1298,
        "end_line": 1305,
        "comment": "\n   * Creates a function type.\n   * @param returnType the function's return type\n   * @param lastVarArgs whether the last parameter type should be considered as\n   * an extensible var_args parameter\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createFunctionType#1341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }\n",
        "begin_line": 1341,
        "end_line": 1347,
        "comment": "\n   * @param parameters the function's parameters or {@code null}\n   *        to indicate that the parameter types are unknown.\n   * @param returnType the function's return type or {@code null} to indicate\n   *        that the return type is unknown.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createNativeFunctionType#1349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  private FunctionType createNativeFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .forNativeType()\n        .build();\n  }\n",
        "begin_line": 1349,
        "end_line": 1356,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.createTemplateTypeMap#1486",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createTemplateTypeMap(com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.TemplateType>, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public TemplateTypeMap createTemplateTypeMap(\n      ImmutableList<TemplateType> templateKeys,\n      ImmutableList<JSType> templateValues) {\n    templateKeys = templateKeys == null ?\n        ImmutableList.<TemplateType>of() : templateKeys;\n    templateValues = templateValues == null ?\n        ImmutableList.<JSType>of() : templateValues;\n\n    return (templateKeys.isEmpty() && templateValues.isEmpty()) ?\n        emptyTemplateTypeMap :\n        new TemplateTypeMap(this, templateKeys, templateValues);\n  }\n",
        "begin_line": 1486,
        "end_line": 1497,
        "comment": "\n   * Creates a template type map from the specified list of template keys and\n   * template value types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.JSType#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.JSType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  JSType(JSTypeRegistry registry) {\n    this(registry, null);\n  }\n",
        "begin_line": 107,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.JSType#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.JSType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.TemplateTypeMap)",
        "snippet": "  JSType(JSTypeRegistry registry, TemplateTypeMap templateTypeMap) {\n    this.registry = registry;\n\n    this.templateTypeMap = templateTypeMap == null ?\n        registry.createTemplateTypeMap(null, null) : templateTypeMap;\n  }\n",
        "begin_line": 111,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.getNativeType#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n   * Utility method for less verbose code.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isNoType#163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
        "snippet": "  public boolean isNoType() {\n    return false;\n  }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isNoResolvedType#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
        "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }\n",
        "begin_line": 167,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isNoObjectType#171",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
        "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isEmptyType#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
        "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }\n",
        "begin_line": 175,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isAllType#252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
        "snippet": "  public boolean isAllType() {\n    return false;\n  }\n",
        "begin_line": 252,
        "end_line": 254,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isUnknownType#256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
        "snippet": "  public boolean isUnknownType() {\n    return false;\n  }\n",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isUnionType#264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isUnionType()",
        "snippet": "  public final boolean isUnionType() {\n    return toMaybeUnionType() != null;\n  }\n",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeUnionType#323",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeUnionType()",
        "snippet": "  public UnionType toMaybeUnionType() {\n    return null;\n  }\n",
        "begin_line": 323,
        "end_line": 325,
        "comment": "\n   * Downcasts this to a UnionType, or returns null if this is not a UnionType.\n   *\n   * Named in honor of Haskell's Maybe type constructor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isFunctionType#333",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionType()",
        "snippet": "  public final boolean isFunctionType() {\n    return toMaybeFunctionType() != null;\n  }\n",
        "begin_line": 333,
        "end_line": 335,
        "comment": " Returns true if toMaybeFunctionType returns a non-null FunctionType. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeFunctionType#349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType()",
        "snippet": "  public FunctionType toMaybeFunctionType() {\n    return null;\n  }\n",
        "begin_line": 349,
        "end_line": 351,
        "comment": "\n   * Downcasts this to a FunctionType, or returns null if this is not\n   * a function.\n   *\n   * For the purposes of this function, we define a MaybeFunctionType as any\n   * type in the sub-lattice\n   * { x | LEAST_FUNCTION_TYPE <= x <= GREATEST_FUNCTION_TYPE }\n   * This definition excludes bottom types like NoType and NoObjectType.\n   *\n   * This definition is somewhat arbitrary and axiomatic, but this is the\n   * definition that makes the most sense for the most callers.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isRecordType#386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isRecordType()",
        "snippet": "  public boolean isRecordType() {\n    return toMaybeRecordType() != null;\n  }\n",
        "begin_line": 386,
        "end_line": 388,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeRecordType#394",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeRecordType()",
        "snippet": "  RecordType toMaybeRecordType() {\n    return null;\n  }\n",
        "begin_line": 394,
        "end_line": 396,
        "comment": "\n   * Downcasts this to a RecordType, or returns null if this is not\n   * a RecordType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isTemplatizedType#398",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isTemplatizedType()",
        "snippet": "  public final boolean isTemplatizedType() {\n    return toMaybeTemplatizedType() != null;\n  }\n",
        "begin_line": 398,
        "end_line": 400,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeTemplatizedType#406",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeTemplatizedType()",
        "snippet": "  public TemplatizedType toMaybeTemplatizedType() {\n    return null;\n  }\n",
        "begin_line": 406,
        "end_line": 408,
        "comment": "\n   * Downcasts this to a TemplatizedType, or returns null if this is not\n   * a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isTemplateType#417",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isTemplateType()",
        "snippet": "  public final boolean isTemplateType() {\n    return toMaybeTemplateType() != null;\n  }\n",
        "begin_line": 417,
        "end_line": 419,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toMaybeTemplateType#425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeTemplateType()",
        "snippet": "  public TemplateType toMaybeTemplateType() {\n    return null;\n  }\n",
        "begin_line": 425,
        "end_line": 427,
        "comment": "\n   * Downcasts this to a TemplateType, or returns null if this is not\n   * a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.hasAnyTemplateTypes#436",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplateTypes()",
        "snippet": "  public boolean hasAnyTemplateTypes() {\n    if (!this.inTemplatedCheckVisit) {\n      this.inTemplatedCheckVisit = true;\n      boolean result = hasAnyTemplateTypesInternal();\n      this.inTemplatedCheckVisit = false;\n      return result;\n    } else {\n      // prevent infinite recursion, this is \"not yet\".\n      return false;\n    }\n  }\n",
        "begin_line": 436,
        "end_line": 446,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.hasAnyTemplateTypesInternal#448",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplateTypesInternal()",
        "snippet": "  boolean hasAnyTemplateTypesInternal() {\n    return templateTypeMap.hasAnyTemplateTypesInternal();\n  }\n",
        "begin_line": 448,
        "end_line": 450,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.getTemplateTypeMap#455",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getTemplateTypeMap()",
        "snippet": "  public TemplateTypeMap getTemplateTypeMap() {\n    return templateTypeMap;\n  }\n",
        "begin_line": 455,
        "end_line": 457,
        "comment": "\n   * Returns the template type map associated with this type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isNominalType#487",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
        "snippet": "  public boolean isNominalType() {\n    return false;\n  }\n",
        "begin_line": 487,
        "end_line": 489,
        "comment": "\n   * Whether this type is a nominal type (a named instance object or\n   * a named enum).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isEquivalentTo#542",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);\n  }\n",
        "begin_line": 542,
        "end_line": 544,
        "comment": "\n   * Checks if two types are equivalent.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.hashCode#655",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }\n",
        "begin_line": 655,
        "end_line": 658,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toObjectType#775",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
        "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }\n",
        "begin_line": 775,
        "end_line": 777,
        "comment": "\n   * Casts this to an ObjectType, or returns null if this is not an ObjectType.\n   * If this is a scalar type, it will *not* be converted to an object type.\n   * If you want to simulate JS autoboxing or dereferencing, you should use\n   * autoboxesTo() or dereference().\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isSubtype#1232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean isSubtype(JSType that) {\n    return isSubtypeHelper(this, that);\n  }\n",
        "begin_line": 1232,
        "end_line": 1234,
        "comment": "\n   * Checks whether {@code this} is a subtype of {@code that}.<p>\n   *\n   * Subtyping rules:\n   * <ul>\n   * <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li>\n   * <li>(no) &mdash; the No type is a subtype of every type.</li>\n   * <li>(no-object) &mdash; the NoObject type is a subtype of every object\n   * type (i.e. subtypes of the Object type).</li>\n   * <li>(ref) &mdash; a type is a subtype of itself.</li>\n   * <li>(union-l) &mdash; A union type is a subtype of a type U if all the\n   * union type's constituents are a subtype of U. Formally<br>\n   * {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only\n   * {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li>\n   * <li>(union-r) &mdash; A type U is a subtype of a union type if it is a\n   * subtype of one of the union type's constituents. Formally<br>\n   * {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only\n   * if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li>\n   * <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype\n   * of an object {@code O<sub>2</sub>} if it has more properties\n   * than {@code O<sub>2</sub>} and all common properties are\n   * pairwise subtypes.</li>\n   * </ul>\n   *\n   * @return {@code this &lt;: that}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isExemptFromTemplateTypeInvariance#1306",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isExemptFromTemplateTypeInvariance(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  static boolean isExemptFromTemplateTypeInvariance(JSType type) {\n    ObjectType objType = type.toObjectType();\n    return objType == null ||\n        \"Array\".equals(objType.getReferenceName()) ||\n        \"Object\".equals(objType.getReferenceName());\n  }\n",
        "begin_line": 1306,
        "end_line": 1311,
        "comment": "\n   * Determines if the specified type is exempt from standard invariant\n   * templatized typing rules.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.toString#1409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return toStringHelper(false);\n  }\n",
        "begin_line": 1409,
        "end_line": 1412,
        "comment": "\n   * A string representation of this type, suitable for printing\n   * in warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.InstanceObjectType#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.FunctionType, boolean)",
        "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType, constructor.getTemplateTypeMap());\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }\n",
        "begin_line": 58,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.getReferenceName#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }\n",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.hasReferenceName#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
        "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }\n",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.getImplicitPrototype#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }\n",
        "begin_line": 75,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.getConstructor#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
        "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }\n",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.toStringHelper#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toStringHelper(forAnnotations);\n    }\n  }\n",
        "begin_line": 95,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.isNominalType#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
        "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }\n",
        "begin_line": 151,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.hashCode#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }\n",
        "begin_line": 160,
        "end_line": 167,
        "comment": "\n   * If this is equal to a NamedType object, its hashCode must be equal\n   * to the hashCode of the NamedType object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "InstanceObjectType.getCtorExtendedInterfaces#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }\n",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.FunctionType#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.TemplateTypeMap, boolean, boolean)",
        "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n               ArrowType arrowType, JSType typeOfThis,\n               TemplateTypeMap templateTypeMap,\n               boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType, templateTypeMap);\n    setPrettyPrint(true);\n\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    if (isConstructor) {\n      this.kind = Kind.CONSTRUCTOR;\n      this.propAccess = PropAccess.ANY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.kind = Kind.ORDINARY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n  }\n",
        "begin_line": 134,
        "end_line": 159,
        "comment": " Creates an instance for a function that might be a constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isConstructor#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
        "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }\n",
        "begin_line": 192,
        "end_line": 195,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.isInterface#197",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
        "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }\n",
        "begin_line": 197,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.toMaybeFunctionType#255",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.toMaybeFunctionType()",
        "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return this;\n  }\n",
        "begin_line": 255,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getInternalArrowType#332",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
        "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }\n",
        "begin_line": 332,
        "end_line": 334,
        "comment": " Gets the internal arrow type. For use by subclasses only. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getPrototype#366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
        "snippet": "  public ObjectType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototypeSlot == null) {\n      String refName = getReferenceName();\n      if (refName == null) {\n        // Someone is trying to access the prototype of a structural function.\n        // We don't want to give real properties to this prototype, because\n        // then it would propagate to all structural functions.\n        setPrototypeNoCheck(\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),\n           null);\n      } else {\n        setPrototype(\n            new PrototypeObjectType(\n                registry,\n                getReferenceName() + \".prototype\",\n                registry.getNativeObjectType(OBJECT_TYPE),\n                isNativeObjectType(), null),\n            null);\n      }\n    }\n    return (ObjectType) prototypeSlot.getType();\n  }\n",
        "begin_line": 366,
        "end_line": 388,
        "comment": "\n   * Gets the {@code prototype} property of this function type. This is\n   * equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setPrototypeBasedOn#395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    setPrototypeBasedOn(baseType, null);\n  }\n",
        "begin_line": 395,
        "end_line": 397,
        "comment": "\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setPrototypeBasedOn#399",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n      baseType = new PrototypeObjectType(\n          registry, getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype(baseType, propertyNode);\n  }\n",
        "begin_line": 399,
        "end_line": 424,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setPrototype#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  boolean setPrototype(ObjectType prototype, Node propertyNode) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n    return setPrototypeNoCheck(prototype, propertyNode);\n  }\n",
        "begin_line": 440,
        "end_line": 449,
        "comment": "\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setPrototypeNoCheck#452",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeNoCheck(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) {\n    ObjectType oldPrototype = prototypeSlot == null\n        ? null : (ObjectType) prototypeSlot.getType();\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n        propertyNode == null ? source : propertyNode);\n    prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
        "begin_line": 452,
        "end_line": 487,
        "comment": " Set the prototype without doing any sanity checks. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getExtendedInterfaces#579",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }\n",
        "begin_line": 579,
        "end_line": 581,
        "comment": " Returns interfaces directly extended by an interface ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getSuperClassConstructor#848",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
        "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }\n",
        "begin_line": 848,
        "end_line": 855,
        "comment": "\n   * Given a constructor or an interface type, get its superclass constructor\n   * or {@code null} if none exists.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.getInstanceType#1078",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
        "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis.toObjectType();\n  }\n",
        "begin_line": 1078,
        "end_line": 1081,
        "comment": "\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.setInstanceType#1087",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }\n",
        "begin_line": 1087,
        "end_line": 1089,
        "comment": "\n   * Sets the instance type. This should only be used for special\n   * native types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.hasInstanceType#1094",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
        "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }\n",
        "begin_line": 1094,
        "end_line": 1096,
        "comment": "\n   * Returns whether this function type has an instance type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.addSubType#1133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }\n",
        "begin_line": 1133,
        "end_line": 1138,
        "comment": " Adds a type to the list of subtypes for this type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionType.hasCachedValues#1170",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
        "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototypeSlot != null || super.hasCachedValues();\n  }\n",
        "begin_line": 1170,
        "end_line": 1173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.FunctionParamBuilder#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.addRequiredParams#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }\n",
        "begin_line": 62,
        "end_line": 71,
        "comment": "\n   * Add parameters of the given type to the end of the param list.\n   * @return False if this is called after optional params are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.addOptionalParams#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }\n",
        "begin_line": 79,
        "end_line": 88,
        "comment": "\n   * Add optional parameters of the given type to the end of the param list.\n   * @param types Types for each optional parameter. The builder will make them\n   *     undefine-able.\n   * @return False if this is called after var args are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.addVarArgs#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }\n",
        "begin_line": 94,
        "end_line": 109,
        "comment": "\n   * Add variable arguments to the end of the parameter list.\n   * @return False if this is called after var args are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.newParameter#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }\n",
        "begin_line": 134,
        "end_line": 139,
        "comment": " Add a parameter to the list with the given type.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.build#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
        "snippet": "  public Node build() {\n    return root;\n  }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.hasOptionalOrVarArgs#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
        "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }\n",
        "begin_line": 145,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionParamBuilder.hasVarArgs#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
        "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }\n",
        "begin_line": 151,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.FunctionBuilder#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withParamsNode#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }\n",
        "begin_line": 90,
        "end_line": 93,
        "comment": "\n   * Set the parameters of the function type with a specially-formatted node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.withReturnType#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }\n",
        "begin_line": 96,
        "end_line": 99,
        "comment": " Set the return type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.forNativeType#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.forNativeType()",
        "snippet": "  FunctionBuilder forNativeType() {\n    this.isNativeType = true;\n    return this;\n  }\n",
        "begin_line": 141,
        "end_line": 144,
        "comment": " Make this a native type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "FunctionBuilder.build#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
        "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeMap, isConstructor, isNativeType);\n  }\n",
        "begin_line": 160,
        "end_line": 164,
        "comment": " Construct a new function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ErrorFunctionType.ErrorFunctionType#50",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ErrorFunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
        "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String)",
        "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }\n",
        "begin_line": 50,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "BooleanType.BooleanType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "BooleanType.toStringHelper#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "BooleanType.getDisplayName#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.ArrowType#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }\n",
        "begin_line": 62,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "ArrowType.ArrowType#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }\n",
        "begin_line": 67,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "AllType.AllType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.AllType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "AllType.isAllType#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
        "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setJSType#1841",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setJSType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }\n",
        "begin_line": 1841,
        "end_line": 1843,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setVarArgs#1906",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
        "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }\n",
        "begin_line": 1906,
        "end_line": 1908,
        "comment": "\n   * Sets whether this node is a variable length argument node. This\n   * method is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setOptionalArg#1924",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
        "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }\n",
        "begin_line": 1924,
        "end_line": 1926,
        "comment": "\n   * Sets whether this node is an optional argument node. This\n   * method is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getTypeRegistry#1202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
        "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n",
        "begin_line": 1202,
        "end_line": 1208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isAssignmentOp#1515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 1515,
        "end_line": 1532,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.isLocal#609",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isLocal()",
        "snippet": "  public boolean isLocal() {\n    return parent != null;\n  }\n",
        "begin_line": 609,
        "end_line": 611,
        "comment": "\n   * Returns whether this is a local scope (i.e. not the global scope).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0257
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getScopeRoot#660",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
        "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }\n",
        "begin_line": 660,
        "end_line": 666,
        "comment": " Returns the current scope's root. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0256
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getErrorCount#2177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
        "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n",
        "begin_line": 2177,
        "end_line": 2179,
        "comment": "\n   * Gets the number of errors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0256
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getVars#566",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getVars()",
        "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }\n",
        "begin_line": 566,
        "end_line": 568,
        "comment": "\n   * Return an iterator over all of the variables declared in this scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0256
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isString#2401",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isString()",
        "snippet": "  public boolean isString() {\n    return this.getType() == Token.STRING;\n  }\n",
        "begin_line": 2401,
        "end_line": 2403,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0256
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isParamList#2381",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isParamList()",
        "snippet": "  public boolean isParamList() {\n    return this.getType() == Token.PARAM_LIST;\n  }\n",
        "begin_line": 2381,
        "end_line": 2383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.extractCharno#1219",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
        "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }\n",
        "begin_line": 1219,
        "end_line": 1225,
        "comment": "\n   * Extracts the character number and character number from a merged line\n   * char number (see {@link #mergeLineCharNo(int, int)}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getInput#438",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
        "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(inputId);\n  }\n",
        "begin_line": 438,
        "end_line": 440,
        "comment": "\n   * Gets the current input source.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.Node#378",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 378,
        "end_line": 396,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processExpressionStatement#716",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processExpressionStatement(com.google.javascript.rhino.head.ast.ExpressionStatement)",
        "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n",
        "begin_line": 716,
        "end_line": 721,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isHoistedFunctionDeclaration#1945",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }\n",
        "begin_line": 1945,
        "end_line": 1949,
        "comment": "\n   * Is this node a hoisted function declaration? A function declaration in the\n   * scope root is hoisted to the top of the scope.\n   * See {@link #isFunctionDeclaration}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0255
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasOneChild#1391",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasOneChild()",
        "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }\n",
        "begin_line": 1391,
        "end_line": 1393,
        "comment": "\n   * Check for one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has exactly one child.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.transformNodeWithInlineJsDoc#396",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformNodeWithInlineJsDoc(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node transformNodeWithInlineJsDoc(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
        "begin_line": 396,
        "end_line": 407,
        "comment": "\n   * NAMEs in parameters or variable declarations are special, because they can\n   * have inline type docs attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.annotateDispatchers#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.annotateDispatchers(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.isFunction());\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.isAssign()) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }\n",
        "begin_line": 184,
        "end_line": 193,
        "comment": "\n     * Translate dispatcher info into the property expected node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isFunctionExpression#1974",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }\n",
        "begin_line": 1974,
        "end_line": 1976,
        "comment": "\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.popScope#616",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
        "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n    if (hasScope()) {\n      compiler.setScope(getScopeRoot());\n    }\n  }\n",
        "begin_line": 616,
        "end_line": 629,
        "comment": " Pops back to the previous scope (e.g. when leaving a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isCall#2245",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCall()",
        "snippet": "  public boolean isCall() {\n    return this.getType() == Token.CALL;\n  }\n",
        "begin_line": 2245,
        "end_line": 2247,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getParent#436",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getParent()",
        "snippet": "  public Scope getParent() {\n    return parent;\n  }\n",
        "begin_line": 436,
        "end_line": 438,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isFunctionDeclaration#1936",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }\n",
        "begin_line": 1936,
        "end_line": 1938,
        "comment": "\n   * Is this node a function declaration? A function declaration is a function\n   * that has a name that is added to the current scope (i.e. a function that\n   * is not part of a expression; see {@link #isFunctionExpression}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.NodeTraversal#238",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.NodeTraversal.Callback, com.google.javascript.jscomp.ScopeCreator)",
        "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }\n",
        "begin_line": 238,
        "end_line": 248,
        "comment": "\n   * Creates a node traversal using the specified callback interface\n   * and the scope creator.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.pushScope#594",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(com.google.javascript.rhino.Node)",
        "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    compiler.setScope(node);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n",
        "begin_line": 594,
        "end_line": 602,
        "comment": " Creates a new scope (e.g. when entering a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getScope#632",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
        "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n    // No need to call compiler.setScope; the top scopeRoot is now the top scope\n    return scope;\n  }\n",
        "begin_line": 632,
        "end_line": 646,
        "comment": " Gets the current scope. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processBlock#636",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processBlock(com.google.javascript.rhino.head.ast.Block)",
        "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n",
        "begin_line": 636,
        "end_line": 639,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverseRoots#298",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(java.util.List<com.google.javascript.rhino.Node>)",
        "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n",
        "begin_line": 298,
        "end_line": 321,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processGeneric#530",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processGeneric(com.google.javascript.rhino.head.Node)",
        "snippet": "    private Node processGeneric(\n        com.google.javascript.rhino.head.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.rhino.head.Node child : n) {\n        node.addChildToBack(transform((AstNode) child));\n      }\n      return node;\n    }\n",
        "begin_line": 530,
        "end_line": 537,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "LoggerErrorManager.LoggerErrorManager#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LoggerErrorManager.java",
        "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
        "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(com.google.javascript.jscomp.MessageFormatter, java.util.logging.Logger)",
        "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }\n",
        "begin_line": 35,
        "end_line": 38,
        "comment": "\n   * Creates an instance.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.Compiler#239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
        "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }\n",
        "begin_line": 239,
        "end_line": 241,
        "comment": "\n   * Creates a Compiler that reports errors and warnings to its logger.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.initOptions#283",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initOptions(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    reconcileOptionsWithGuards();\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }\n",
        "begin_line": 283,
        "end_line": 307,
        "comment": "\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0254
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.getRootNode#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
        "snippet": "  @Override\n  public Node getRootNode() {\n    return rootNode;\n  }\n",
        "begin_line": 431,
        "end_line": 434,
        "comment": "\n   * Gets the container node of the scope. This is typically the FUNCTION\n   * node or the global BLOCK/SCRIPT node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isObjectLitKey#2098",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isObjectLitKey(Node node) {\n    switch (node.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 2098,
        "end_line": 2106,
        "comment": "\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getInput#1062",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getInput(com.google.javascript.rhino.InputId)",
        "snippet": "  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n",
        "begin_line": 1062,
        "end_line": 1065,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.Var#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.Var(boolean, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.Scope, int, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "    private Var(boolean inferred, String name, Node nameNode, JSType type,\n                Scope scope, int index, CompilerInput input) {\n      this.name = name;\n      this.nameNode = nameNode;\n      this.type = type;\n      this.scope = scope;\n      this.index = index;\n      this.input = input;\n      this.typeInferred = inferred;\n    }\n",
        "begin_line": 120,
        "end_line": 129,
        "comment": "\n     * Creates a variable.\n     *\n     * @param inferred whether its type is inferred (as opposed to declared)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.declare#493",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.declare(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.CompilerInput, boolean)",
        "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input);\n    vars.put(name, var);\n    return var;\n  }\n",
        "begin_line": 493,
        "end_line": 503,
        "comment": "\n   * Declares a variable.\n   *\n   * @param name name of the variable\n   * @param nameNode the NAME node declaring the variable\n   * @param type the variable's type\n   * @param input the input in which this variable is defined.\n   * @param inferred Whether this variable's type is inferred (as opposed\n   *     to declared).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.getCodingConvention#1464",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
        "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }\n",
        "begin_line": 1464,
        "end_line": 1466,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getCodingConvention#2055",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
        "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n",
        "begin_line": 2055,
        "end_line": 2060,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isAssign#2229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isAssign()",
        "snippet": "  public boolean isAssign() {\n    return this.getType() == Token.ASSIGN;\n  }\n",
        "begin_line": 2229,
        "end_line": 2231,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isGetProp#2317",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isGetProp()",
        "snippet": "  public boolean isGetProp() {\n    return this.getType() == Token.GETPROP;\n  }\n",
        "begin_line": 2317,
        "end_line": 2319,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isControlStructure#1696",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1696,
        "end_line": 1713,
        "comment": "\n   * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isStatementBlock#1774",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }\n",
        "begin_line": 1774,
        "end_line": 1776,
        "comment": "\n   * @return Whether the node is of a type that contain other statements.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0253
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.Scope#402",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Scope(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private Scope(Node rootNode, boolean isBottom) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    this.isBottom = isBottom;\n    this.depth = 0;\n  }\n",
        "begin_line": 402,
        "end_line": 407,
        "comment": "\n   * Creates a empty Scope (bottom of the lattice).\n   * @param rootNode Typically a FUNCTION node or the global BLOCK node.\n   * @param isBottom Whether this is the bottom of a lattice. Otherwise,\n   *     it must be a global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "Scope.createGlobalScope#409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.createGlobalScope(com.google.javascript.rhino.Node)",
        "snippet": "  static Scope createGlobalScope(Node rootNode) {\n    return new Scope(rootNode, false);\n  }\n",
        "begin_line": 409,
        "end_line": 411,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.inGlobalScope#671",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
        "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }\n",
        "begin_line": 671,
        "end_line": 673,
        "comment": "\n   * Determines whether the traversal is currently in the global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getScopeDepth#675",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
        "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }\n",
        "begin_line": 675,
        "end_line": 677,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isStatementParent#1785",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1785,
        "end_line": 1798,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.getInputId#2931",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getInputId(com.google.javascript.rhino.Node)",
        "snippet": "  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }\n",
        "begin_line": 2931,
        "end_line": 2937,
        "comment": "\n   * @param n The node.\n   * @return The InputId property on the node or its ancestors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "ParserRunner.createConfig#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean, com.google.javascript.jscomp.parsing.Config.LanguageMode, boolean, java.util.Set<java.lang.String>)",
        "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }\n",
        "begin_line": 57,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isName#2349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isName()",
        "snippet": "  public boolean isName() {\n    return this.getType() == Token.NAME;\n  }\n",
        "begin_line": 2349,
        "end_line": 2351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getErrors#1001",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
        "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n",
        "begin_line": 1001,
        "end_line": 1003,
        "comment": "\n   * Returns the array of errors (never null).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.getErrors#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
        "snippet": "  @Override\n  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }\n",
        "begin_line": 83,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0252
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isStatement#1781",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }\n",
        "begin_line": 1781,
        "end_line": 1783,
        "comment": "\n   * @return Whether the node is used as a statement.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isBlock#2237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isBlock()",
        "snippet": "  public boolean isBlock() {\n    return this.getType() == Token.BLOCK;\n  }\n",
        "begin_line": 2237,
        "end_line": 2239,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getBooleanProp#819",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
        "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }\n",
        "begin_line": 819,
        "end_line": 821,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processName#909",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processName(com.google.javascript.rhino.head.ast.Name)",
        "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }\n",
        "begin_line": 909,
        "end_line": 912,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.newStringNode#1528",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int, java.lang.String)",
        "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1528,
        "end_line": 1530,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.matches#109",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(com.google.javascript.jscomp.DiagnosticType)",
        "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n   * Returns whether the given type matches a type in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.compare#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.GuardComparator.compare(com.google.javascript.jscomp.WarningsGuard, com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }\n",
        "begin_line": 60,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "WarningsGuard.getPriority#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
        "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "\n   * The priority in which warnings guards are applied. Lower means the\n   * guard will be applied sooner. Expressed on a scale of 1 to 100.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.setWarningLevel#1194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(com.google.javascript.jscomp.DiagnosticGroup, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }\n",
        "begin_line": 1194,
        "end_line": 1196,
        "comment": "\n   * Configure the given type of warning to the given level.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.addWarningsGuard#1220",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }\n",
        "begin_line": 1220,
        "end_line": 1222,
        "comment": "\n   * Add a guard to the set of warnings guards.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.chain#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.chain(com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }\n",
        "begin_line": 352,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.clonePropsFrom#776",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.clonePropsFrom(com.google.javascript.rhino.Node)",
        "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }\n",
        "begin_line": 776,
        "end_line": 781,
        "comment": "\n   * Clone the properties from the provided node without copying\n   * the property object.  The receiving node may not have any\n   * existing properties.\n   * @param other The node to clone properties from.\n   * @return this node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.removeProp#783",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeProp(int)",
        "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }\n",
        "begin_line": 783,
        "end_line": 788,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.removeProp#796",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeProp(com.google.javascript.rhino.Node.PropListItem, int)",
        "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }\n",
        "begin_line": 796,
        "end_line": 809,
        "comment": "\n   * @param item The item to inspect\n   * @param propType The property to look for\n   * @return The replacement list if the property was removed, or\n   *   'item' otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setStaticSourceFile#1092",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(com.google.javascript.rhino.jstype.StaticSourceFile)",
        "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }\n",
        "begin_line": 1092,
        "end_line": 1094,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getLineno#1138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getLineno()",
        "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }\n",
        "begin_line": 1138,
        "end_line": 1140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getCharno#1142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getCharno()",
        "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }\n",
        "begin_line": 1142,
        "end_line": 1144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setLineno#1162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setLineno(int)",
        "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 1162,
        "end_line": 1168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setCharno#1170",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setCharno(int)",
        "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }\n",
        "begin_line": 1170,
        "end_line": 1172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.extractLineno#1207",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
        "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }\n",
        "begin_line": 1207,
        "end_line": 1213,
        "comment": "\n   * Extracts the line number and character number from a merged line char\n   * number (see {@link #mergeLineCharNo(int, int)}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getJsDocBuilderForNode#1845",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
        "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }\n",
        "begin_line": 1845,
        "end_line": 1847,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isObjectLit#2373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isObjectLit()",
        "snippet": "  public boolean isObjectLit() {\n    return this.getType() == Token.OBJECTLIT;\n  }\n",
        "begin_line": 2373,
        "end_line": 2375,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "InputId.hashCode#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }\n",
        "begin_line": 59,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "ParserRunner.ParseResult#156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.ParseResult.ParseResult(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "    public ParseResult(Node ast, AstRoot oldAst) {\n      this.ast = ast;\n      this.oldAst = oldAst;\n    }\n",
        "begin_line": 156,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "ParserRunner.initResourceConfig#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
        "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n    reservedVars = extractList(config.getString(\"compiler.reserved.vars\"));\n  }\n",
        "begin_line": 78,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "ParserRunner.extractList#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(java.lang.String)",
        "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }\n",
        "begin_line": 89,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "ParserRunner.parse#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(com.google.javascript.rhino.jstype.StaticSourceFile, java.lang.String, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter, java.util.logging.Logger)",
        "snippet": "  public static ParseResult parse(StaticSourceFile sourceFile,\n                                  String sourceString,\n                                  Config config,\n                                  ErrorReporter errorReporter,\n                                  Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    compilerEnv.setReservedKeywordAsIdentifier(true);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return new ParseResult(root, astRoot);\n  }\n",
        "begin_line": 107,
        "end_line": 147,
        "comment": "\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processAstRoot#590",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processAstRoot(com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.rhino.head.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode) child));\n      }\n      parseDirectives(node);\n      return node;\n    }\n",
        "begin_line": 590,
        "end_line": 598,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.parseDirectives#609",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.parseDirectives(com.google.javascript.rhino.Node)",
        "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }\n",
        "begin_line": 609,
        "end_line": 624,
        "comment": "\n     * Parse the directives, encode them in the AST, and remove their nodes.\n     *\n     * For information on ES5 directives, see section 14.1 of\n     * ECMA-262, Edition 5.\n     *\n     * It would be nice if Rhino would eventually take care of this for\n     * us, but right now their directive-processing is a one-off.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.createTemplateNode#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
        "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }\n",
        "begin_line": 179,
        "end_line": 184,
        "comment": " This reduces the cost of these properties to O(nodes) to O(files).",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.setFileOverviewJsDoc#211",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(com.google.javascript.rhino.Node)",
        "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo();\n    if (rootNodeJsDoc != null) {\n      irNode.setJSDocInfo(rootNodeJsDoc);\n      rootNodeJsDoc.setAssociatedNode(irNode);\n    }\n\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n      fileOverviewInfo.setAssociatedNode(irNode);\n    }\n  }\n",
        "begin_line": 211,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.setSourceInfo#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    if (irNode.getLineno() == -1) {\n      // If we didn't already set the line, then set it now. This avoids\n      // cases like ParenthesizedExpression where we just return a previous\n      // node, but don't want the new node to get its parent's line number.\n      int lineno = node.getLineno();\n      irNode.setLineno(lineno);\n      int charno = position2charno(node.getAbsolutePosition());\n      irNode.setCharno(charno);\n      maybeSetLengthFrom(irNode, node);\n    }\n  }\n",
        "begin_line": 440,
        "end_line": 451,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.maybeSetLengthFrom#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }\n",
        "begin_line": 509,
        "end_line": 513,
        "comment": " Set the length on the node if we're in IDE mode.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.justTransform#525",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }\n",
        "begin_line": 525,
        "end_line": 527,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.newNode#1508",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
        "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1508,
        "end_line": 1510,
        "comment": " Simple helper to create nodes and set the initial node properties.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Config.Config#74",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/Config.java",
        "class_name": "com.google.javascript.jscomp.parsing.Config",
        "signature": "com.google.javascript.jscomp.parsing.Config.Config(java.util.Set<java.lang.String>, java.util.Set<java.lang.String>, boolean, com.google.javascript.jscomp.parsing.Config.LanguageMode, boolean)",
        "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }\n",
        "begin_line": 74,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Config.buildAnnotationNames#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/Config.java",
        "class_name": "com.google.javascript.jscomp.parsing.Config",
        "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(java.util.Set<java.lang.String>)",
        "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }\n",
        "begin_line": 89,
        "end_line": 102,
        "comment": "\n   * Create the annotation names from the user-specified\n   * annotation whitelist.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.getCode#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
        "snippet": "  public String getCode() throws IOException {\n    return code;\n  }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n   * Gets all the code in this source file.\n   * @throws IOException\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.getName#173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.getName()",
        "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }\n",
        "begin_line": 173,
        "end_line": 176,
        "comment": " Returns a unique name for the source file. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.setIsExtern#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
        "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }\n",
        "begin_line": 185,
        "end_line": 187,
        "comment": " Sets that this is an extern. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.PrepareAnnotations#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.PrepareAnnotations()",
        "snippet": "    PrepareAnnotations() {\n    }\n",
        "begin_line": 120,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.shouldTraverse#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }\n",
        "begin_line": 123,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.PrepareAst#39",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }\n",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.PrepareAst#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "PrepareAst.process#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations());\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations());\n      }\n    }\n  }\n",
        "begin_line": 54,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsAst.JsAst#41",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.JsAst(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.inputId = new InputId(sourceFile.getName());\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }\n",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsAst.getAstRoot#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n      root.setInputId(inputId);\n    }\n    return root;\n  }\n",
        "begin_line": 47,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsAst.getInputId#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getInputId()",
        "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }\n",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsAst.getSourceFile#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
        "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }\n",
        "begin_line": 70,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "JsAst.parse#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.parse(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  private void parse(AbstractCompiler compiler) {\n    int startErrorCount = compiler.getErrorManager().getErrorCount();\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null ||\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n        (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
        "begin_line": 81,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.CompilerInput#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceAst, boolean)",
        "snippet": "  public CompilerInput(SourceAst ast, boolean isExtern) {\n    this(ast, ast.getInputId(), isExtern);\n  }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.CompilerInput#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceAst, com.google.javascript.rhino.InputId, boolean)",
        "snippet": "  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n    this.ast = ast;\n    this.id = inputId;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }\n",
        "begin_line": 73,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.CompilerInput#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public CompilerInput(SourceFile file) {\n    this(file, false);\n  }\n",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.CompilerInput#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceFile, boolean)",
        "snippet": "  public CompilerInput(SourceFile file, boolean isExtern) {\n    this(new JsAst(file), isExtern);\n  }\n",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.getInputId#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getInputId()",
        "snippet": "  @Override\n  public InputId getInputId() {\n    return id;\n  }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": " Returns a name for this input. Must be unique across all inputs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.getAstRoot#115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    Node root = ast.getAstRoot(compiler);\n    // The root maybe null if the AST can not be created.\n    if (root != null) {\n      Preconditions.checkState(root.isScript());\n      Preconditions.checkNotNull(root.getInputId());\n    }\n    return root;\n  }\n",
        "begin_line": 115,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerInput.setCompiler#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.setCompiler(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public void setCompiler(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": " Sets an abstract compiler for doing parsing. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.acceptEcmaScript5#2067",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.acceptEcmaScript5()",
        "snippet": "  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n      case ECMASCRIPT3:\n        return false;\n    }\n    throw new IllegalStateException(\"unexpected language mode\");\n  }\n",
        "begin_line": 2067,
        "end_line": 2077,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.putCompilerInput#1098",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.putCompilerInput(com.google.javascript.rhino.InputId, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n",
        "begin_line": 1098,
        "end_line": 1101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getDefaultErrorReporter#1619",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
        "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n",
        "begin_line": 1619,
        "end_line": 1622,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.prepareAst#1970",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.prepareAst(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n",
        "begin_line": 1970,
        "end_line": 1974,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.isIdeMode#2062",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
        "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n",
        "begin_line": 2062,
        "end_line": 2065,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.acceptConstKeyword#2083",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
        "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n",
        "begin_line": 2083,
        "end_line": 2086,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getErrorManager#2310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrorManager()",
        "snippet": "  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n",
        "begin_line": 2310,
        "end_line": 2316,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.setOldParseTree#2607",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setOldParseTree(java.lang.String, com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "  @Override\n  public void setOldParseTree(String sourceName, AstRoot oldAst) {\n  }\n",
        "begin_line": 2607,
        "end_line": 2609,
        "comment": "\n   * {@inheritDoc}\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.AbstractCompiler": "\n    * Stores the \"new\" Rhino parse tree for a given source file.\n    * @param sourceName The source file name.\n    * @param astRoot The \"new\" Rhino parse tree.\n    "
        },
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicErrorManager.getErrorCount#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
        "snippet": "  @Override\n  public int getErrorCount() {\n    return errorCount;\n  }\n",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getParent#1321",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getParent()",
        "snippet": "  public Node getParent() {\n    return parent;\n  }\n",
        "begin_line": 1321,
        "end_line": 1323,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getChildCount#1405",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getChildCount()",
        "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next) {\n      c++;\n    }\n    return c;\n  }\n",
        "begin_line": 1405,
        "end_line": 1411,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0251
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.addChildToBack#605",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.addChildToBack(com.google.javascript.rhino.Node)",
        "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }\n",
        "begin_line": 605,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getString#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.getString()",
        "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }\n",
        "begin_line": 212,
        "end_line": 215,
        "comment": "\n     * returns the string content.\n     * @return non null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isVar#2433",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isVar()",
        "snippet": "  public boolean isVar() {\n    return this.getType() == Token.VAR;\n  }\n",
        "begin_line": 2433,
        "end_line": 2435,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeCheck.visitReturn#1871",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitReturn(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n          \"inconsistent return type\");\n    }\n  }\n",
        "begin_line": 1871,
        "end_line": 1899,
        "comment": "\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.ObjectPropListItem#300",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.ObjectPropListItem.ObjectPropListItem(int, java.lang.Object, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    ObjectPropListItem(int propType, Object objectValue, PropListItem next) {\n      super(propType, next);\n      this.objectValue = objectValue;\n    }\n",
        "begin_line": 300,
        "end_line": 303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getObjectValue#310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.ObjectPropListItem.getObjectValue()",
        "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }\n",
        "begin_line": 310,
        "end_line": 313,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getProp#811",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getProp(int)",
        "snippet": "  public Object getProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }\n",
        "begin_line": 811,
        "end_line": 817,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.putProp#843",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putProp(int, java.lang.Object)",
        "snippet": "  public void putProp(int propType, Object value) {\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }\n",
        "begin_line": 843,
        "end_line": 848,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.createProp#861",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.createProp(int, java.lang.Object, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }\n",
        "begin_line": 861,
        "end_line": 863,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getSourceFileName#1101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
        "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }\n",
        "begin_line": 1101,
        "end_line": 1104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getStaticSourceFile#1107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
        "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }\n",
        "begin_line": 1107,
        "end_line": 1109,
        "comment": " Returns the source file associated with this input. May be null ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setInputId#1114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setInputId(com.google.javascript.rhino.InputId)",
        "snippet": "  public void setInputId(InputId inputId) {\n    this.putProp(INPUT_ID, inputId);\n  }\n",
        "begin_line": 1114,
        "end_line": 1116,
        "comment": "\n   * @param inputId\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getInputId#1121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getInputId()",
        "snippet": "  public InputId getInputId() {\n    return ((InputId) this.getProp(INPUT_ID));\n  }\n",
        "begin_line": 1121,
        "end_line": 1123,
        "comment": "\n   * @return The Id of the CompilerInput associated with this Node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "InputId.InputId#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.InputId(java.lang.String)",
        "snippet": "  public InputId(String id) {\n    this.id = id;\n  }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.Preloaded#421",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Preloaded.Preloaded(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    Preloaded(String fileName, String originalPath, String code) {\n      super(fileName);\n      super.setOriginalPath(originalPath);\n      super.setCode(code);\n    }\n",
        "begin_line": 421,
        "end_line": 425,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.Builder#368",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Builder.Builder()",
        "snippet": "    public Builder() {}\n",
        "begin_line": 368,
        "end_line": 368,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.buildFromCode#390",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Builder.buildFromCode(java.lang.String, java.lang.String)",
        "snippet": "    public SourceFile buildFromCode(String fileName, String code) {\n      return new Preloaded(fileName, originalPath, code);\n    }\n",
        "begin_line": 390,
        "end_line": 392,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.SourceFile#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(java.lang.String)",
        "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n  }\n",
        "begin_line": 81,
        "end_line": 86,
        "comment": "\n   * Construct a new abstract source file.\n   *\n   * @param fileName The file name of the source file. It does not necessarily\n   *     need to correspond to a real path. But it should be unique. Will\n   *     appear in warning messages emitted by the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.setCode#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setCode(java.lang.String)",
        "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.setOriginalPath#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(java.lang.String)",
        "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.fromCode#322",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.fromCode(java.lang.String, java.lang.String)",
        "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return builder().buildFromCode(fileName, code);\n  }\n",
        "begin_line": 322,
        "end_line": 324,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SourceFile.builder#354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.builder()",
        "snippet": "  public static Builder builder() {\n    return new Builder();\n  }\n",
        "begin_line": 354,
        "end_line": 356,
        "comment": " Create a new builder for source files. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.getSourceName#691",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(com.google.javascript.rhino.Node)",
        "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }\n",
        "begin_line": 691,
        "end_line": 694,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getType#279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.getType()",
        "snippet": "    @Override\n    public int getType() {\n      return propType;\n    }\n",
        "begin_line": 279,
        "end_line": 282,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getNext#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.getNext()",
        "snippet": "    @Override\n    public PropListItem getNext() {\n      return next;\n    }\n",
        "begin_line": 284,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.lookupProperty#760",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
        "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }\n",
        "begin_line": 760,
        "end_line": 767,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getLastChild#541",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getLastChild()",
        "snippet": "  public Node getLastChild() {\n    return last;\n  }\n",
        "begin_line": 541,
        "end_line": 543,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.newString#513",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(int, java.lang.String)",
        "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }\n",
        "begin_line": 513,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getJSDocInfo#1879",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
        "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }\n",
        "begin_line": 1879,
        "end_line": 1881,
        "comment": "\n   * Get the {@link JSDocInfo} attached to this node.\n   * @return the information or {@code null} if no JSDoc is attached to this\n   * node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.setIsSyntheticBlock#1941",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
        "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }\n",
        "begin_line": 1941,
        "end_line": 1943,
        "comment": "\n   * Sets whether this is a synthetic block that should not be considered\n   * a real source block.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isFunction#2305",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFunction()",
        "snippet": "  public boolean isFunction() {\n    return this.getType() == Token.FUNCTION;\n  }\n",
        "begin_line": 2305,
        "end_line": 2307,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isScript#2393",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isScript()",
        "snippet": "  public boolean isScript() {\n    return this.getType() == Token.SCRIPT;\n  }\n",
        "begin_line": 2393,
        "end_line": 2395,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SyntacticScopeCreator.SyntacticScopeCreator#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n   * Creates a ScopeCreator.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.NodeTraversal#230",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }\n",
        "begin_line": 230,
        "end_line": 232,
        "comment": "\n   * Creates a node traversal using the specified callback interface.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverse#280",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(com.google.javascript.rhino.Node)",
        "snippet": "  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n",
        "begin_line": 280,
        "end_line": 292,
        "comment": "\n   * Traverses a parse tree recursively.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.traverse#491",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }\n",
        "begin_line": 491,
        "end_line": 495,
        "comment": "\n   * Traverses a node recursively.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeTraversal.hasScope#679",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.hasScope()",
        "snippet": "  public boolean hasScope() {\n    return !(scopes.isEmpty() && scopeRoots.isEmpty());\n  }\n",
        "begin_line": 679,
        "end_line": 681,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.setScope#2006",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setScope(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  void setScope(Node n) {\n    if (phaseOptimizer != null) {\n      phaseOptimizer.setScope(n);\n    }\n  }\n",
        "begin_line": 2006,
        "end_line": 2011,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.StringNode#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.StringNode(int, java.lang.String)",
        "snippet": "    StringNode(int type, String str) {\n      super(type);\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }\n",
        "begin_line": 192,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.IntPropListItem#332",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.IntPropListItem(int, int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    IntPropListItem(int propType, int intValue, PropListItem next) {\n      super(propType, next);\n      this.intValue = intValue;\n    }\n",
        "begin_line": 332,
        "end_line": 335,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.AbstractPropListItem#274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.AbstractPropListItem(int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    AbstractPropListItem(int propType, PropListItem next) {\n      this.propType = propType;\n      this.next = next;\n    }\n",
        "begin_line": 274,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.putBooleanProp#850",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putBooleanProp(int, boolean)",
        "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }\n",
        "begin_line": 850,
        "end_line": 852,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.putIntProp#854",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putIntProp(int, int)",
        "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }\n",
        "begin_line": 854,
        "end_line": 859,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.createProp#865",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.createProp(int, int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }\n",
        "begin_line": 865,
        "end_line": 867,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard#40",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(java.util.Map<java.lang.String, com.google.javascript.jscomp.DiagnosticGroup>)",
        "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressibleGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressibleGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }\n",
        "begin_line": 40,
        "end_line": 49,
        "comment": "\n   * The suppressible groups, indexed by name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SuppressDocWarningsGuard.getPriority#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
        "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }\n",
        "begin_line": 103,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "LightweightMessageFormatter.LightweightMessageFormatter#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
        "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider)",
        "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "LightweightMessageFormatter.LightweightMessageFormatter#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
        "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider, com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt)",
        "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }\n",
        "begin_line": 47,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ErrorFormat.toFormatter#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ErrorFormat.java",
        "class_name": "com.google.javascript.jscomp.ErrorFormat",
        "signature": "com.google.javascript.jscomp.ErrorFormat.toFormatter(com.google.javascript.jscomp.SourceExcerptProvider, boolean)",
        "snippet": "    @Override\n    public MessageFormatter toFormatter(\n        SourceExcerptProvider source, boolean colorize) {\n      LightweightMessageFormatter formatter = new LightweightMessageFormatter(\n          source);\n      formatter.setColorize(colorize);\n      return formatter;\n    }\n",
        "begin_line": 35,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.getRegisteredGroups#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
        "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }\n",
        "begin_line": 63,
        "end_line": 65,
        "comment": " Get the registered diagnostic groups, indexed by name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.getTypes#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
        "snippet": "  public Iterable<DiagnosticType> getTypes() {\n    return types;\n  }\n",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n   * Returns an iterable over all the types in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.addGuard#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      ComposeWarningsGuard composeGuard = (ComposeWarningsGuard) guard;\n      if (composeGuard.demoteErrors) {\n        this.demoteErrors = composeGuard.demoteErrors;\n      }\n\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(Lists.newArrayList(composeGuard.guards.descendingSet()));\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }\n",
        "begin_line": 86,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.addGuards#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(java.lang.Iterable<com.google.javascript.jscomp.WarningsGuard>)",
        "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }\n",
        "begin_line": 103,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.enables#1179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }\n",
        "begin_line": 1179,
        "end_line": 1181,
        "comment": "\n   * Whether the warnings guard in this Options object enables the given\n   * group of warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.getWarningsGuard#1198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
        "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }\n",
        "begin_line": 1198,
        "end_line": 1200,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.shouldColorizeErrorOutput#1415",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
        "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }\n",
        "begin_line": 1415,
        "end_line": 1417,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.getLanguageIn#1565",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
        "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }\n",
        "begin_line": 1565,
        "end_line": 1567,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.setErrorManager#264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(com.google.javascript.jscomp.ErrorManager)",
        "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n",
        "begin_line": 264,
        "end_line": 268,
        "comment": "\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.createMessageFormatter#274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
        "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n",
        "begin_line": 274,
        "end_line": 277,
        "comment": "\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CheckLevel.isOn#29",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckLevel.java",
        "class_name": "com.google.javascript.jscomp.CheckLevel",
        "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
        "snippet": "  boolean isOn() {\n    return this != OFF;\n  }\n",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractMessageFormatter.AbstractMessageFormatter#31",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
        "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider)",
        "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }\n",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractMessageFormatter.setColorize#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
        "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
        "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ObjectType.createDelegateSuffix#237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(java.lang.String)",
        "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }\n",
        "begin_line": 237,
        "end_line": 239,
        "comment": "\n   * Creates a suffix for a proxy delegate.\n   * @see #getNormalizedReferenceName\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleErrorReporter.getMessage0#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/SimpleErrorReporter.java",
        "class_name": "com.google.javascript.rhino.SimpleErrorReporter",
        "signature": "com.google.javascript.rhino.SimpleErrorReporter.getMessage0(java.lang.String)",
        "snippet": "    public static String getMessage0(String messageId) {\n      return getMessage(messageId, null);\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleErrorReporter.getMessage#117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/SimpleErrorReporter.java",
        "class_name": "com.google.javascript.rhino.SimpleErrorReporter",
        "signature": "com.google.javascript.rhino.SimpleErrorReporter.getMessage(java.lang.String, java.lang.Object[])",
        "snippet": "    static String getMessage(String messageId, Object[] arguments) {\n      final String defaultResource\n          = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n      Locale locale = Locale.getDefault();\n\n      // ResourceBundle does caching.\n      ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n      String formatString;\n      try {\n          formatString = rb.getString(messageId);\n      } catch (java.util.MissingResourceException mre) {\n          throw new RuntimeException\n              (\"no message resource found for message property \" + messageId);\n      }\n\n      /*\n       * It's OK to format the string, even if 'arguments' is null;\n       * we need to format it anyway, to make double ''s collapse to\n       * single 's.\n       */\n      MessageFormat formatter = new MessageFormat(formatString);\n      return formatter.format(arguments);\n    }\n",
        "begin_line": 117,
        "end_line": 141,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getType#525",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getType()",
        "snippet": "  public int getType() {\n    return type;\n  }\n",
        "begin_line": 525,
        "end_line": 527,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getFirstChild#537",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getFirstChild()",
        "snippet": "  public Node getFirstChild() {\n    return first;\n  }\n",
        "begin_line": 537,
        "end_line": 539,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getNext#545",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getNext()",
        "snippet": "  public Node getNext() {\n    return next;\n  }\n",
        "begin_line": 545,
        "end_line": 547,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "WarningsGuard.Priority#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.Priority.Priority(int)",
        "snippet": "    Priority(int value) {\n      this.value = value;\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.OldRhinoErrorReporter#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.OldRhinoErrorReporter.OldRhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    private OldRhinoErrorReporter(AbstractCompiler compiler) {\n      super(compiler);\n    }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.NewRhinoErrorReporter#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.NewRhinoErrorReporter.NewRhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    private NewRhinoErrorReporter(AbstractCompiler compiler) {\n      super(compiler);\n    }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.replacePlaceHolders#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(java.lang.String)",
        "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }\n",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n   * For each message such as \"Not a good use of {0}\", replace the place\n   * holder {0} with a wild card that matches all possible strings.\n   * Also put the any non-place-holder in quotes for regex matching later.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.RhinoErrorReporter#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.RhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  private RhinoErrorReporter(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    typeMap = ImmutableMap.<Pattern, DiagnosticType>builder()\n        // Trailing comma\n        .put(replacePlaceHolders(\n            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n                \"msg.extra.trailing.comma\")),\n            TRAILING_COMMA)\n\n        // Duplicate parameter\n        .put(replacePlaceHolders(\n            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n                \"msg.dup.parms\")),\n            DUPLICATE_PARAM)\n\n        // Unknown @annotations.\n        .put(replacePlaceHolders(\n            SimpleErrorReporter.getMessage0(\"msg.bad.jsdoc.tag\")),\n            BAD_JSDOC_ANNOTATION)\n\n        // Unexpected @type annotations\n        .put(Pattern.compile(\"^Type annotations are not allowed here.*\"),\n            MISPLACED_TYPE_ANNOTATION)\n\n        // Unexpected @type annotations\n        .put(Pattern.compile(\"^Keywords and reserved words\" +\n            \" are not allowed as unquoted property.*\"),\n            INVALID_ES3_PROP_NAME)\n\n        // Type annotation errors.\n        .put(Pattern.compile(\"^Bad type annotation.*\"),\n            TYPE_PARSE_ERROR)\n\n        // Parse tree too deep.\n        .put(replacePlaceHolders(\n            com.google.javascript.rhino.head.ScriptRuntime.getMessage0(\n                \"msg.too.deep.parser.recursion\")),\n            PARSE_TREE_TOO_DEEP)\n        .build();\n  }\n",
        "begin_line": 85,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.forNewRhino#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public static com.google.javascript.rhino.head.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }\n",
        "begin_line": 126,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "RhinoErrorReporter.forOldRhino#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.TweakFunction#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String)",
        "snippet": "    TweakFunction(String name) {\n      this(name, null, Token.ERROR, Token.ERROR, null);\n    }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.TweakFunction#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA) {\n      this(name, expectedTypeName, validNodeTypeA, Token.ERROR, null);\n    }\n",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.TweakFunction#132",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int, int)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA, int validNodeTypeB) {\n      this(name, expectedTypeName, validNodeTypeA, validNodeTypeB, null);\n    }\n",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.TweakFunction#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, com.google.javascript.jscomp.ProcessTweaks.TweakFunction)",
        "snippet": "    TweakFunction(String name, TweakFunction registerFunction) {\n      this(name, null, Token.ERROR, Token.ERROR, registerFunction);\n    }\n",
        "begin_line": 137,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.TweakFunction#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int, int, com.google.javascript.jscomp.ProcessTweaks.TweakFunction)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA, int validNodeTypeB,\n        TweakFunction registerFunction) {\n      this.name = name;\n      this.expectedTypeName = expectedTypeName;\n      this.validNodeTypeA = validNodeTypeA;\n      this.validNodeTypeB = validNodeTypeB;\n      this.registerFunction = registerFunction;\n    }\n",
        "begin_line": 141,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ProcessTweaks.getName#164",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.getName()",
        "snippet": "    String getName() {\n      return name;\n    }\n",
        "begin_line": 164,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "PassFactory.PassFactory#37",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassFactory.java",
        "class_name": "com.google.javascript.jscomp.PassFactory",
        "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(java.lang.String, boolean)",
        "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": "\n   * @param name The name of the pass that this factory creates.\n   * @param isOneTimePass If true, the pass produced by this factory can\n   *     only be run once.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.disabled#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }\n",
        "begin_line": 73,
        "end_line": 76,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.OFF\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.equals#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }\n",
        "begin_line": 111,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.hashCode#117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }\n",
        "begin_line": 117,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.DiagnosticGroups#33",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
        "snippet": "  public DiagnosticGroups() {}\n",
        "begin_line": 33,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.registerDeprecatedGroup#38",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerDeprecatedGroup(java.lang.String)",
        "snippet": "  static DiagnosticGroup registerDeprecatedGroup(String name) {\n    return registerGroup(name, new DiagnosticGroup(name, UNUSED));\n  }\n",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.registerGroup#42",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 42,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.registerGroup#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 48,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroups.registerGroup#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup...)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 55,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard#29",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(com.google.javascript.jscomp.DiagnosticGroup, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }\n",
        "begin_line": 29,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n   * Create a group that matches all errors of the given types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n   * Create a group that matches all errors of the given types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup...)",
        "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }\n",
        "begin_line": 87,
        "end_line": 96,
        "comment": "\n   * Create a composite group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.Compiler#246",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Compiler(java.io.PrintStream)",
        "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n",
        "begin_line": 246,
        "end_line": 249,
        "comment": "\n   * Creates a Compiler that reports errors and warnings to an output stream.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.addChangeHandler#1996",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(com.google.javascript.jscomp.CodeChangeHandler)",
        "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n",
        "begin_line": 1996,
        "end_line": 1999,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.getDiagnosticGroups#2129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
        "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n",
        "begin_line": 2129,
        "end_line": 2131,
        "comment": "\n   * The warning classes that are available from the command-line, and\n   * are suppressible by the {@code @suppress} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.Proxy#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.Proxy(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "    protected Proxy(CodingConvention convention) {\n      this.nextConvention = convention;\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getIndirectlyDeclaredProperties#465",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getIndirectlyDeclaredProperties()",
        "snippet": "    @Override\n    public Collection<String> getIndirectlyDeclaredProperties() {\n      return ImmutableList.of();\n    }\n",
        "begin_line": 465,
        "end_line": 468,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.ClosureCodingConvention#49",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention()",
        "snippet": "  public ClosureCodingConvention() {\n    this(CodingConventions.getDefault());\n  }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureCodingConvention.ClosureCodingConvention#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public ClosureCodingConvention(CodingConvention wrapped) {\n    super(wrapped);\n\n    Set<String> props = Sets.newHashSet(\n        \"superClass_\",\n        \"instance_\",\n        \"getInstance\");\n    props.addAll(wrapped.getIndirectlyDeclaredProperties());\n    indirectlyDeclaredProperties = ImmutableSet.copyOf(props);\n  }\n",
        "begin_line": 53,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.Node#358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int)",
        "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 358,
        "end_line": 362,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodingConventions.getDefault#41",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.getDefault()",
        "snippet": "  public static CodingConvention getDefault() {\n    return new DefaultCodingConvention();\n  }\n",
        "begin_line": 41,
        "end_line": 43,
        "comment": " Gets the default coding convention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.025
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.warning#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.warning(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.WARNING\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.GuardComparator#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.GuardComparator.GuardComparator(java.util.Map<com.google.javascript.jscomp.WarningsGuard, java.lang.Integer>)",
        "snippet": "    private GuardComparator(Map<WarningsGuard, Integer> orderOfAddition) {\n      this.orderOfAddition = orderOfAddition;\n    }\n",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.ComposeWarningsGuard#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(java.util.List<com.google.javascript.jscomp.WarningsGuard>)",
        "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "ComposeWarningsGuard.ComposeWarningsGuard#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(com.google.javascript.jscomp.WarningsGuard...)",
        "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "CompilerOptions.CompilerOptions#901",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
        "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkDeterminism = false;\n    checkSymbols = false;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    reportMissingOverride = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n    checkEventfulObjectDisposalPolicy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.OFF;\n\n    // Optimizations\n    aggressiveRenaming = false;\n    alternateRenaming = false;\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    assumeClosuresOnlyCaptureReferences = false;\n    inlineProperties = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedClassProperties = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    jqueryPass = false;\n    angularPass = false;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    exportLocalPropertyDefinitions = false;\n    cssRenamingMap = null;\n    cssRenamingWhitelist = null;\n    processObjectPropertyString = false;\n    idGenerators = ImmutableMap.of();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n    propertyInvalidationErrors = Maps.newHashMap();\n\n    // Instrumentation\n    instrumentationTemplate = null;  // instrument functions\n    instrumentMemoryAllocations = false; // instrument allocations\n    instrumentForCoverage = false;  // instrument lines\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    preferLineBreakAtEndOfFile = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n    errorHandler = null;\n  }\n",
        "begin_line": 901,
        "end_line": 1050,
        "comment": "\n   * Initializes compiler options. All options are disabled by default.\n   *\n   * Command-line frontends to the compiler should set these properties\n   * like a builder.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "AnonymousFunctionNamingPolicy.AnonymousFunctionNamingPolicy#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AnonymousFunctionNamingPolicy.java",
        "class_name": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy",
        "signature": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy.AnonymousFunctionNamingPolicy(char[])",
        "snippet": "  AnonymousFunctionNamingPolicy(char[] reservedCharacters) {\n    this.reservedCharacters = reservedCharacters;\n  }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.error#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.error(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.ERROR\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.make#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.make(java.lang.String, com.google.javascript.jscomp.CheckLevel, java.lang.String)",
        "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": "\n   * Create a DiagnosticType at a given CheckLevel.\n   *\n   * @param name An identifier\n   * @param level Either CheckLevel.ERROR or CheckLevel.WARNING\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagnosticType.DiagnosticType#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.DiagnosticType(java.lang.String, com.google.javascript.jscomp.CheckLevel, java.text.MessageFormat)",
        "snippet": "  private DiagnosticType(String key, CheckLevel level, MessageFormat format) {\n    this.key = key;\n    this.defaultLevel = level;\n    this.format = format;\n\n    this.level = this.defaultLevel;\n  }\n",
        "begin_line": 95,
        "end_line": 101,
        "comment": "\n   * Create a DiagnosticType. Private to force use of static factory methods.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypeInference.traverseReturn#467",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseReturn(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseReturn(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node retValue = n.getFirstChild();\n    if (retValue != null) {\n      JSType type = functionScope.getRootNode().getJSType();\n      if (type != null) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n          inferPropertyTypesToMatchConstraint(\n              retValue.getJSType(), fnType.getReturnType());\n        }\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 467,
        "end_line": 482,
        "comment": "\n   * Traverse a return value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0247
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.getRootNode#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.getRootNode()",
        "snippet": "  @Override\n  public Node getRootNode() {\n    return getFunctionScope().getRootNode();\n  }\n",
        "begin_line": 129,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0247
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.recordNonEmptyReturn#950",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.recordNonEmptyReturn()",
        "snippet": "    void recordNonEmptyReturn() {\n      hasNonEmptyReturns = true;\n    }\n",
        "begin_line": 950,
        "end_line": 952,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0247
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.handleReturn#639",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleReturn(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n",
        "begin_line": 639,
        "end_line": 666,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0244
        },
        "num_failing_tests": 1
    },
    {
        "name": "VoidType.restrictByNotNullOrUndefined#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.restrictByNotNullOrUndefined()",
        "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    return registry.getNativeType(JSTypeNative.NO_TYPE);\n  }\n",
        "begin_line": 57,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0237
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.getLeastSupertype#915",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.toMaybeUnionType().getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }\n",
        "begin_line": 915,
        "end_line": 921,
        "comment": "\n   * Gets the least supertype of {@code this} and {@code that}.\n   * The least supertype is the join (&#8744;) or supremum of both types in the\n   * type lattice.<p>\n   * Examples:\n   * <ul>\n   * <li>{@code number &#8744; *} = {@code *}</li>\n   * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>\n   * <li>{@code Number &#8744; Object} = {@code Object}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0235
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processReturnStatement#1064",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processReturnStatement(com.google.javascript.rhino.head.ast.ReturnStatement)",
        "snippet": "    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n",
        "begin_line": 1064,
        "end_line": 1071,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0234
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.getLeastSupertype#927",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    boolean areEquivalent = thisType.isEquivalentTo(thatType);\n    return areEquivalent ? thisType :\n        filterNoResolvedType(\n            thisType.registry.createUnionType(thisType, thatType));\n  }\n",
        "begin_line": 927,
        "end_line": 932,
        "comment": "\n   * A generic implementation meant to be used as a helper for common\n   * getLeastSupertype implementations.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.023
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processNumberLiteral#956",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processNumberLiteral(com.google.javascript.rhino.head.ast.NumberLiteral)",
        "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }\n",
        "begin_line": 956,
        "end_line": 959,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0205
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.newNumberNode#1532",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(java.lang.Double)",
        "snippet": "  private Node newNumberNode(Double value) {\n    return IR.number(value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1532,
        "end_line": 1534,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0205
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.number#454",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.number(double)",
        "snippet": "  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n",
        "begin_line": 454,
        "end_line": 456,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0203
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.NumberNode#150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.NumberNode.NumberNode(double)",
        "snippet": "    NumberNode(double number) {\n      super(Token.NUMBER);\n      this.number = number;\n    }\n",
        "begin_line": 150,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0203
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.newNumber#501",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newNumber(double)",
        "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }\n",
        "begin_line": 501,
        "end_line": 503,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0203
        },
        "num_failing_tests": 1
    }
]