[
    {
        "name": "AdaptiveStepsizeIntegrator.filterStep#277",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.filterStep(double, boolean, boolean)",
        "snippet": "  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n    throws IntegratorException {\n\n      double filteredH = h;\n      if (Math.abs(h) < minStep) {\n          if (acceptSmall) {\n              filteredH = forward ? minStep : -minStep;\n          } else {\n              throw new IntegratorException(\n                      \"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\",\n                      minStep, Math.abs(h));\n          }\n      }\n\n      if (filteredH > maxStep) {\n          filteredH = maxStep;\n      } else if (filteredH < -maxStep) {\n          filteredH = -maxStep;\n      }\n\n      return filteredH;\n\n  }\n",
        "begin_line": 277,
        "end_line": 299,
        "comment": " Filter the integration step.\n   * @param h signed step\n   * @param forward forward integration indicator\n   * @param acceptSmall if true, steps smaller than the minimal value\n   * are silently increased up to this value, if false such small\n   * steps generate an exception\n   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n   * @exception IntegratorException if the step is too small and acceptSmall is false\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.integrate#202",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "    @Override\n    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0,\n                            final double t, final double[] y)\n        throws DerivativeException, IntegratorException {\n\n        final int n = y0.length;\n        sanityChecks(equations, t0, y0, t, y);\n        setEquations(equations);\n        resetEvaluations();\n        final boolean forward = t > t0;\n\n        // initialize working arrays\n        if (y != y0) {\n            System.arraycopy(y0, 0, y, 0, n);\n        }\n        final double[] yDot = new double[y0.length];\n        final double[] yTmp = new double[y0.length];\n\n        // set up two interpolators sharing the integrator arrays\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n        interpolator.reinitialize(y, forward);\n        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n        interpolatorTmp.reinitialize(yTmp, forward);\n\n        // set up integration control objects\n        for (StepHandler handler : stepHandlers) {\n            handler.reset();\n        }\n        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n\n        // compute the initial Nordsieck vector using the configured starter integrator\n        start(t0, y, t);\n        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n        interpolator.storeTime(stepStart);\n\n        double hNew = stepSize;\n        interpolator.rescale(hNew);\n\n        boolean lastStep = false;\n        while (!lastStep) {\n\n            // shift all data\n            interpolator.shift();\n\n            double error = 0;\n            for (boolean loop = true; loop;) {\n\n                stepSize = hNew;\n\n                // predict a first estimate of the state at step end (P in the PECE sequence)\n                final double stepEnd = stepStart + stepSize;\n                interpolator.setInterpolatedTime(stepEnd);\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n\n                // evaluate a first estimate of the derivative (first E in the PECE sequence)\n                computeDerivatives(stepEnd, yTmp, yDot);\n\n                // update Nordsieck vector\n                final double[] predictedScaled = new double[y0.length];\n                for (int j = 0; j < y0.length; ++j) {\n                    predictedScaled[j] = stepSize * yDot[j];\n                }\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n\n                // apply correction (C in the PECE sequence)\n                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n\n                if (error <= 1.0) {\n\n                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n                    computeDerivatives(stepEnd, yTmp, yDot);\n\n                    // update Nordsieck vector\n                    final double[] correctedScaled = new double[y0.length];\n                    for (int j = 0; j < y0.length; ++j) {\n                        correctedScaled[j] = stepSize * yDot[j];\n                    }\n                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n\n                    // discrete events handling\n                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n                    interpolatorTmp.storeTime(stepStart);\n                    interpolatorTmp.shift();\n                    interpolatorTmp.storeTime(stepEnd);\n                    if (manager.evaluateStep(interpolatorTmp)) {\n                        final double dt = manager.getEventTime() - stepStart;\n                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                            // rejecting the step would lead to a too small next step, we accept it\n                            loop = false;\n                        } else {\n                            // reject the step to match exactly the next switch time\n                            hNew = dt;\n                            interpolator.rescale(hNew);\n                        }\n                    } else {\n                        // accept the step\n                        scaled    = correctedScaled;\n                        nordsieck = nordsieckTmp;\n                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                        loop = false;\n                    }\n\n                } else {\n                    // reject the step and attempt to reduce error by stepsize control\n                    final double factor = computeStepGrowShrinkFactor(error);\n                    hNew = filterStep(stepSize * factor, forward, false);\n                    interpolator.rescale(hNew);\n                }\n\n            }\n\n            // the step has been accepted (may have been truncated)\n            final double nextStep = stepStart + stepSize;\n            System.arraycopy(yTmp, 0, y, 0, n);\n            interpolator.storeTime(nextStep);\n            manager.stepAccepted(nextStep, y);\n            lastStep = manager.stop();\n\n            // provide the step data to the step handler\n            for (StepHandler handler : stepHandlers) {\n                interpolator.setInterpolatedTime(nextStep);\n                handler.handleStep(interpolator, lastStep);\n            }\n            stepStart = nextStep;\n\n            if (!lastStep && manager.reset(stepStart, y)) {\n\n                // some events handler has triggered changes that\n                // invalidate the derivatives, we need to restart from scratch\n                start(stepStart, y, t);\n                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n\n            }\n\n            if (! lastStep) {\n                // in some rare cases we may get here with stepSize = 0, for example\n                // when an event occurs at integration start, reducing the first step\n                // to zero; we have to reset the step to some safe non zero value\n                stepSize = filterStep(stepSize, forward, true);\n\n                // stepsize control for next step\n                final double  factor     = computeStepGrowShrinkFactor(error);\n                final double  scaledH    = stepSize * factor;\n                final double  nextT      = stepStart + scaledH;\n                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                hNew = filterStep(scaledH, forward, nextIsLast);\n                interpolator.rescale(hNew);\n            }\n\n        }\n\n        final double stopTime  = stepStart;\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        return stopTime;\n\n    }\n",
        "begin_line": 202,
        "end_line": 361,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdamsIntegrator": " {@inheritDoc} ",
            "org.apache.commons.math.ode.MultistepIntegrator": null,
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": " Perform some sanity checks on the integration parameters.\n   * @param equations differential equations set\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param t target time for the integration\n   * @param y placeholder where to put the state vector\n   * @exception IntegratorException if some inconsistency is detected\n   "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.Corrector#390",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.Corrector.Corrector(double[], double[], double[])",
        "snippet": "        public Corrector(final double[] previous, final double[] scaled, final double[] state) {\n            this.previous = previous;\n            this.scaled   = scaled;\n            this.after    = state;\n            this.before   = state.clone();\n        }\n",
        "begin_line": 390,
        "end_line": 395,
        "comment": " Simple constructor.\n         * @param previous previous state\n         * @param scaled current scaled first derivative\n         * @param state state to correct (will be overwritten after visit)\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.start#398",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.Corrector.start(int, int, int, int, int, int)",
        "snippet": "        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            Arrays.fill(after, 0.0);\n        }\n",
        "begin_line": 398,
        "end_line": 401,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     ",
            "org.apache.commons.math.ode.nonstiff.AdamsIntegrator": null,
            "org.apache.commons.math.ode.MultistepIntegrator": null,
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.AbstractIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.visit#404",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.Corrector.visit(int, int, double)",
        "snippet": "        public void visit(int row, int column, double value)\n            throws MatrixVisitorException {\n            if ((row & 0x1) == 0) {\n                after[column] -= value;\n            } else {\n                after[column] += value;\n            }\n        }\n",
        "begin_line": 404,
        "end_line": 411,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrixPreservingVisitor": "\n     * Visit one matrix entry.\n     * @param row row index of the entry\n     * @param column column index of the entry\n     * @param value current value of the entry\n     * @throws MatrixVisitorException if something wrong occurs\n     ",
            "org.apache.commons.math.ode.nonstiff.AdamsIntegrator": null,
            "org.apache.commons.math.ode.MultistepIntegrator": null,
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.AbstractIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.end#422",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.Corrector.end()",
        "snippet": "        public double end() {\n\n            double error = 0;\n            for (int i = 0; i < after.length; ++i) {\n                after[i] += previous[i] + scaled[i];\n                final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n                final double tol = (vecAbsoluteTolerance == null) ?\n                                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                                   (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                final double ratio  = (after[i] - before[i]) / tol;\n                error += ratio * ratio;\n            }\n\n            return Math.sqrt(error / after.length);\n\n        }\n",
        "begin_line": 422,
        "end_line": 437,
        "comment": "\n         * End visiting te Nordsieck vector.\n         * <p>The correction is used to control stepsize. So its amplitude is\n         * considered to be an error, which must be normalized according to\n         * error control settings. If the normalized value is greater than 1,\n         * the correction was too large and the step must be rejected.</p>\n         * @return the normalized correction, if greater than 1, the step\n         * must be rejected\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.walkInRowOrder#493",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
        "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 493,
        "end_line": 506,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.walkInOptimizedOrder#917",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.RealMatrixPreservingVisitor)",
        "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 917,
        "end_line": 920,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsMoultonIntegrator.AdamsMoultonIntegrator#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.AdamsMoultonIntegrator(int, double, double, double, double)",
        "snippet": "    public AdamsMoultonIntegrator(final int nSteps,\n                                  final double minStep, final double maxStep,\n                                  final double scalAbsoluteTolerance,\n                                  final double scalRelativeTolerance)\n        throws IllegalArgumentException {\n        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n              scalAbsoluteTolerance, scalRelativeTolerance);\n    }\n",
        "begin_line": 171,
        "end_line": 178,
        "comment": "\n     * Build an Adams-Moulton integrator with the given order and error control parameters.\n     * @param nSteps number of steps of the method excluding the one being computed\n     * @param minStep minimal step (must be positive even for backward\n     * integration), the last step can be smaller than this\n     * @param maxStep maximal step (must be positive even for backward\n     * integration)\n     * @param scalAbsoluteTolerance allowed absolute error\n     * @param scalRelativeTolerance allowed relative error\n     * @exception IllegalArgumentException if order is 1 or less\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "NordsieckStepInterpolator.reinitialize#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.reinitialize(double, double, double[], org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public void reinitialize(final double time, final double stepSize,\n                             final double[] scaledDerivative,\n                             final Array2DRowRealMatrix nordsieckVector) {\n        this.referenceTime = time;\n        this.scalingH      = stepSize;\n        this.scaled        = scaledDerivative;\n        this.nordsieck     = nordsieckVector;\n\n        // make sure the state and derivatives will depend on the new arrays\n        setInterpolatedTime(getInterpolatedTime());\n\n    }\n",
        "begin_line": 124,
        "end_line": 135,
        "comment": " Reinitialize the instance.\n     * <p>Beware that all arrays <em>must</em> be references to integrator\n     * arrays, in order to ensure proper update without copy.</p>\n     * @param time time at which all arrays are defined\n     * @param stepSize step size used in the scaled and nordsieck arrays\n     * @param scaledDerivative reference to the integrator array holding the first\n     * scaled derivative\n     * @param nordsieckVector reference to the integrator matrix holding the\n     * nordsieck vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "NordsieckStepInterpolator.rescale#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.rescale(double)",
        "snippet": "    public void rescale(final double stepSize) {\n\n        final double ratio = stepSize / scalingH;\n        for (int i = 0; i < scaled.length; ++i) {\n            scaled[i] *= ratio;\n        }\n\n        final double[][] nData = nordsieck.getDataRef();\n        double power = ratio;\n        for (int i = 0; i < nData.length; ++i) {\n            power *= ratio;\n            final double[] nDataI = nData[i];\n            for (int j = 0; j < nDataI.length; ++j) {\n                nDataI[j] *= power;\n            }\n        }\n\n        scalingH = stepSize;\n\n    }\n",
        "begin_line": 142,
        "end_line": 161,
        "comment": " Rescale the instance.\n     * <p>Since the scaled and Nordiseck arrays are shared with the caller,\n     * this method has the side effect of rescaling this arrays in the caller too.</p>\n     * @param stepSize new step size to use in the scaled and nordsieck arrays\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "NordsieckStepInterpolator.computeInterpolatedStateAndDerivatives#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.computeInterpolatedStateAndDerivatives(double, double)",
        "snippet": "    @Override\n    protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n\n        final double x = interpolatedTime - referenceTime;\n        final double normalizedAbscissa = x / scalingH;\n\n        Arrays.fill(stateVariation, 0.0);\n        Arrays.fill(interpolatedDerivatives, 0.0);\n\n        // apply Taylor formula from high order to low order,\n        // for the sake of numerical accuracy\n        final double[][] nData = nordsieck.getDataRef();\n        for (int i = nData.length - 1; i >= 0; --i) {\n            final int order = i + 2;\n            final double[] nDataI = nData[i];\n            final double power = Math.pow(normalizedAbscissa, order);\n            for (int j = 0; j < nDataI.length; ++j) {\n                final double d = nDataI[j] * power;\n                stateVariation[j]          += d;\n                interpolatedDerivatives[j] += order * d;\n            }\n        }\n\n        for (int j = 0; j < currentState.length; ++j) {\n            stateVariation[j] += scaled[j] * normalizedAbscissa;\n            interpolatedState[j] = currentState[j] + stateVariation[j];\n            interpolatedDerivatives[j] =\n                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;\n        }\n\n    }\n",
        "begin_line": 185,
        "end_line": 215,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Compute the state and derivatives at the interpolated time.\n   * This is the main processing method that should be implemented by\n   * the derived classes to perform the interpolation.\n   * @param theta normalized interpolation abscissa within the step\n   * (theta is zero at the previous time step and one at the current time step)\n   * @param oneMinusThetaH time gap between the interpolated time and\n   * the current time\n   * @throws DerivativeException this exception is propagated to the caller if the\n   * underlying user function triggers one\n   "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.initializeHighOrderDerivatives#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.initializeHighOrderDerivatives(double[], double[][])",
        "snippet": "    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n                                                     final double[][] multistep) {\n        for (int i = 0; i < multistep.length; ++i) {\n            final double[] msI = multistep[i];\n            for (int j = 0; j < first.length; ++j) {\n                msI[j] -= first[j];\n            }\n        }\n        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n    }\n",
        "begin_line": 260,
        "end_line": 269,
        "comment": " Initialize the high order scaled derivatives at step start.\n     * @param first first scaled derivative at step start\n     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n     * will be modified\n     * @return high order derivatives at step start\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.updateHighOrderDerivativesPhase1#282",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase1(org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n        return update.multiply(highOrder);\n    }\n",
        "begin_line": 282,
        "end_line": 284,
        "comment": " Update the high order scaled derivatives for Adams integrators (phase 1).\n     * <p>The complete update of high order derivatives has a form similar to:\n     * <pre>\n     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n     * </pre>\n     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n     * @param highOrder high order scaled derivatives\n     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n     * @return updated high order derivatives\n     * @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.updateHighOrderDerivativesPhase2#299",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase2(double[], double[], org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public void updateHighOrderDerivativesPhase2(final double[] start,\n                                                 final double[] end,\n                                                 final Array2DRowRealMatrix highOrder) {\n        final double[][] data = highOrder.getDataRef();\n        for (int i = 0; i < data.length; ++i) {\n            final double[] dataI = data[i];\n            final double c1I = c1[i];\n            for (int j = 0; j < dataI.length; ++j) {\n                dataI[j] += c1I * (start[j] - end[j]);\n            }\n        }\n    }\n",
        "begin_line": 299,
        "end_line": 310,
        "comment": " Update the high order scaled derivatives Adams integrators (phase 2).\n     * <p>The complete update of high order derivatives has a form similar to:\n     * <pre>\n     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n     * </pre>\n     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n     * <p>Phase 1 of the update must already have been performed.</p>\n     * @param start first order scaled derivatives at step start\n     * @param end first order scaled derivatives at step end\n     * @param highOrder high order scaled derivatives, will be modified\n     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n     * @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsIntegrator.initializeHighOrderDerivatives#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.initializeHighOrderDerivatives(double[], double[][])",
        "snippet": "    @Override\n    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n                                                        final double[][] multistep) {\n        return transformer.initializeHighOrderDerivatives(first, multistep);\n    }\n",
        "begin_line": 91,
        "end_line": 95,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.MultistepIntegrator": " Initialize the high order scaled derivatives at step start.\n     * @param first first scaled derivative at step start\n     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n     * will be modified\n     * @return high order scaled derivatives at step start\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsIntegrator.updateHighOrderDerivativesPhase1#108",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase1(org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n        return transformer.updateHighOrderDerivativesPhase1(highOrder);\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": " Update the high order scaled derivatives for Adams integrators (phase 1).\n     * <p>The complete update of high order derivatives has a form similar to:\n     * <pre>\n     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n     * </pre>\n     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n     * @param highOrder high order scaled derivatives\n     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n     * @return updated high order derivatives\n     * @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsIntegrator.updateHighOrderDerivativesPhase2#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase2(double[], double[], org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public void updateHighOrderDerivativesPhase2(final double[] start,\n                                                 final double[] end,\n                                                 final Array2DRowRealMatrix highOrder) {\n        transformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n    }\n",
        "begin_line": 125,
        "end_line": 129,
        "comment": " Update the high order scaled derivatives Adams integrators (phase 2).\n     * <p>The complete update of high order derivatives has a form similar to:\n     * <pre>\n     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n     * </pre>\n     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n     * <p>Phase 1 of the update must already have been performed.</p>\n     * @param start first order scaled derivatives at step start\n     * @param end first order scaled derivatives at step end\n     * @param highOrder high order scaled derivatives, will be modified\n     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n     * @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.handleStep#321",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.NordsieckInitializer.handleStep(org.apache.commons.math.ode.sampling.StepInterpolator, boolean)",
        "snippet": "        public void handleStep(StepInterpolator interpolator, boolean isLast)\n            throws DerivativeException {\n\n            final double prev = interpolator.getPreviousTime();\n            final double curr = interpolator.getCurrentTime();\n            stepStart = prev;\n            stepSize  = (curr - prev) / (nSteps + 1);\n\n            // compute the first scaled derivative\n            interpolator.setInterpolatedTime(prev);\n            scaled = interpolator.getInterpolatedDerivatives().clone();\n            for (int j = 0; j < n; ++j) {\n                scaled[j] *= stepSize;\n            }\n\n            // compute the high order scaled derivatives\n            final double[][] multistep = new double[nSteps][];\n            for (int i = 1; i <= nSteps; ++i) {\n                interpolator.setInterpolatedTime(prev + stepSize * i);\n                final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n                for (int j = 0; j < n; ++j) {\n                    msI[j] *= stepSize;\n                }\n                multistep[i - 1] = msI;\n            }\n            nordsieck = initializeHighOrderDerivatives(scaled, multistep);\n\n            // stop the integrator after the first step has been handled\n            throw new InitializationCompletedMarkerException();\n\n        }\n",
        "begin_line": 321,
        "end_line": 351,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepHandler": "\n   * Handle the last accepted step\n   * @param interpolator interpolator for the last accepted step. For\n   * efficiency purposes, the various integrators reuse the same\n   * object on each call, so if the instance wants to keep it across\n   * all calls (for example to provide at the end of the integration a\n   * continuous model valid throughout the integration range, as the\n   * {@link org.apache.commons.math.ode.ContinuousOutputModel\n   * ContinuousOutputModel} class does), it should build a local copy\n   * using the clone method of the interpolator and store this copy.\n   * Keeping only a reference to the interpolator and reusing it will\n   * result in unpredictable behavior (potentially crashing the application).\n   * @param isLast true if the step is the last one\n   * @throws DerivativeException this exception is propagated to the\n   * caller if the underlying user function triggers one\n   ",
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.AbstractIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.InitializationCompletedMarkerException#373",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.InitializationCompletedMarkerException.InitializationCompletedMarkerException()",
        "snippet": "        public InitializationCompletedMarkerException() {\n            super((Throwable) null);\n        }\n",
        "begin_line": 373,
        "end_line": 375,
        "comment": " Simple constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.start#209",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.start(double, double[], double)",
        "snippet": "    protected void start(final double t0, final double[] y0, final double t)\n        throws DerivativeException, IntegratorException {\n\n        // make sure NO user event nor user step handler is triggered,\n        // this is the task of the top level integrator, not the task\n        // of the starter integrator\n        starter.clearEventHandlers();\n        starter.clearStepHandlers();\n\n        // set up one specific step handler to extract initial Nordsieck vector\n        starter.addStepHandler(new NordsieckInitializer(y0.length));\n\n        // start integration, expecting a InitializationCompletedMarkerException\n        try {\n            starter.integrate(new CountingDifferentialEquations(y0.length),\n                              t0, y0, t, new double[y0.length]);\n        } catch (DerivativeException de) {\n            if (!(de instanceof InitializationCompletedMarkerException)) {\n                // this is not the expected nominal interruption of the start integrator\n                throw de;\n            }\n        }\n\n        // remove the specific step handler\n        starter.clearStepHandlers();\n\n    }\n",
        "begin_line": 209,
        "end_line": 235,
        "comment": " Start the integration.\n     * <p>This method computes one step using the underlying starter integrator,\n     * and initializes the Nordsieck vector at step start. The starter integrator\n     * purpose is only to establish initial conditions, it does not really change\n     * time by itself. The top level multistep integrator remains in charge of\n     * handling time propagation and events handling as it will starts its own\n     * computation right from the beginning. In a sense, the starter integrator\n     * can be seen as a dummy one and so it will never trigger any user event nor\n     * call any user step handler.</p>\n     * @param t0 initial time\n     * @param y0 initial value of the state vector at t0\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws IntegratorException if the integrator cannot perform integration\n     * @throws DerivativeException this exception is propagated to the caller if\n     * the underlying user function triggers one\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.computeStepGrowShrinkFactor#292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.computeStepGrowShrinkFactor(double)",
        "snippet": "    protected double computeStepGrowShrinkFactor(final double error) {\n        return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n    }\n",
        "begin_line": 292,
        "end_line": 294,
        "comment": " Compute step grow/shrink factor according to normalized error.\n     * @param error normalized error of the current step\n     * @return grow/shrink factor for next step\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.getEvaluations#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations;\n    }\n",
        "begin_line": 152,
        "end_line": 154,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Get the number of evaluations of the differential equations function.\n     * <p>\n     * The number of evaluations corresponds to the last call to the\n     * <code>integrate</code> method. It is 0 if the method has not been called yet.\n     * </p>\n     * @return number of evaluations of the differential equations function\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#648",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 648,
        "end_line": 656,
        "comment": "\n     * Check if matrices are multiplication compatible\n     * @param left left hand side matrix\n     * @param right right hand side matrix\n     * @exception IllegalArgumentException if matrices are not multiplication compatible\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.FieldLUDecompositionImpl#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.FieldLUDecompositionImpl(org.apache.commons.math.linear.FieldMatrix<T>)",
        "snippet": "    public FieldLUDecompositionImpl(FieldMatrix<T> matrix)\n        throws NonSquareMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        field = matrix.getField();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            T sum = field.getZero();\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int nonZero = col; // permutation row\n            for (int row = col; row < m; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n\n                if (lu[nonZero][col].equals(field.getZero())) {\n                    // try to select a better permutation choice\n                    ++nonZero;\n                }\n            }\n\n            // Singularity check\n            if (nonZero >= m) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (nonZero != col) {\n                T tmp = field.getZero();\n                for (int i = 0; i < m; i++) {\n                    tmp = lu[nonZero][i];\n                    lu[nonZero][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = pivot[nonZero];\n                pivot[nonZero] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final T luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                final T[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag);\n            }\n        }\n\n    }\n",
        "begin_line": 71,
        "end_line": 152,
        "comment": "\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @exception NonSquareMatrixException if matrix is not square\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.multiply#288",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(org.apache.commons.math.linear.Array2DRowRealMatrix)",
        "snippet": "    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }\n",
        "begin_line": 288,
        "end_line": 312,
        "comment": "\n     * Returns the result of postmultiplying this by <code>m</code>.\n     * @param m    matrix to postmultiply by\n     * @return     this*m\n     * @throws     IllegalArgumentException\n     *             if columnDimension(this) != rowDimension(m)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getDataRef#327",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getDataRef()",
        "snippet": "    public double[][] getDataRef() {\n        return data;\n    }\n",
        "begin_line": 327,
        "end_line": 329,
        "comment": "\n     * Returns a reference to the underlying data array.\n     * <p>\n     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n     *\n     * @return 2-dimensional array of entries\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#418",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 418,
        "end_line": 421,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#424",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 424,
        "end_line": 427,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "DerivativeException.DerivativeException#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/DerivativeException.java",
        "class_name": "org.apache.commons.math.ode.DerivativeException",
        "signature": "org.apache.commons.math.ode.DerivativeException.DerivativeException(java.lang.Throwable)",
        "snippet": "  public DerivativeException(final Throwable cause) {\n    super(cause);\n  }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": " Build an instance from an underlying cause.\n   * @param cause cause for the exception\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3015
        },
        "num_failing_tests": 1
    },
    {
        "name": "NordsieckStepInterpolator.NordsieckStepInterpolator#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.NordsieckStepInterpolator()",
        "snippet": "    public NordsieckStepInterpolator() {\n    }\n",
        "begin_line": 72,
        "end_line": 73,
        "comment": " Simple constructor.\n     * This constructor builds an instance that is not usable yet, the\n     * {@link AbstractStepInterpolator#reinitialize} method should be called\n     * before using the instance in order to initialize the internal arrays. This\n     * constructor is used only in order to delay the initialization in\n     * some cases.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "NordsieckStepInterpolator.reinitialize#108",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.reinitialize(double[], boolean)",
        "snippet": "    @Override\n    public void reinitialize(final double[] y, final boolean forward) {\n        super.reinitialize(y, forward);\n        stateVariation = new double[y.length];\n    }\n",
        "begin_line": 108,
        "end_line": 112,
        "comment": " Reinitialize the instance.\n     * <p>Beware that all arrays <em>must</em> be references to integrator\n     * arrays, in order to ensure proper update without copy.</p>\n     * @param y reference to the integrator array holding the state at\n     * the end of the step\n     * @param forward integration direction indicator\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsIntegrator.AdamsIntegrator#50",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.AdamsIntegrator(java.lang.String, int, int, double, double, double, double)",
        "snippet": "    public AdamsIntegrator(final String name, final int nSteps, final int order,\n                           final double minStep, final double maxStep,\n                           final double scalAbsoluteTolerance,\n                           final double scalRelativeTolerance)\n        throws IllegalArgumentException {\n        super(name, nSteps, order, minStep, maxStep,\n              scalAbsoluteTolerance, scalRelativeTolerance);\n        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n    }\n",
        "begin_line": 50,
        "end_line": 58,
        "comment": "\n     * Build an Adams integrator with the given order and step control prameters.\n     * @param name name of the method\n     * @param nSteps number of steps of the method excluding the one being computed\n     * @param order order of the method\n     * @param minStep minimal step (must be positive even for backward\n     * integration), the last step can be smaller than this\n     * @param maxStep maximal step (must be positive even for backward\n     * integration)\n     * @param scalAbsoluteTolerance allowed absolute error\n     * @param scalRelativeTolerance allowed relative error\n     * @exception IllegalArgumentException if order is 1 or less\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.NordsieckInitializer#316",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.NordsieckInitializer.NordsieckInitializer(int)",
        "snippet": "        public NordsieckInitializer(final int n) {\n            this.n = n;\n        }\n",
        "begin_line": 316,
        "end_line": 318,
        "comment": " Simple constructor.\n         * @param n problem dimension\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.requiresDenseOutput#354",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.NordsieckInitializer.requiresDenseOutput()",
        "snippet": "        public boolean requiresDenseOutput() {\n            return true;\n        }\n",
        "begin_line": 354,
        "end_line": 356,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepHandler": " Determines whether this handler needs dense output.\n   * <p>This method allows the integrator to avoid performing extra\n   * computation if the handler does not need dense output. If this\n   * method returns false, the integrator will call the {@link\n   * #handleStep} method with a {@link DummyStepInterpolator} rather\n   * than a custom interpolator.</p>\n   * @return true if the handler needs dense output\n   ",
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.AbstractIntegrator": " Check if one of the step handlers requires dense output.\n     * @return true if one of the step handlers requires dense output\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.reset#359",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.NordsieckInitializer.reset()",
        "snippet": "        public void reset() {\n            // nothing to do\n        }\n",
        "begin_line": 359,
        "end_line": 361,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepHandler": " Reset the step handler.\n   * Initialize the internal data as required before the first step is\n   * handled.\n   ",
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.AbstractIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.CountingDifferentialEquations#388",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.CountingDifferentialEquations.CountingDifferentialEquations(int)",
        "snippet": "        public CountingDifferentialEquations(final int dimension) {\n            this.dimension = dimension;\n        }\n",
        "begin_line": 388,
        "end_line": 390,
        "comment": " Simple constructor.\n         * @param dimension dimension of the problem\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.computeDerivatives#393",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.CountingDifferentialEquations.computeDerivatives(double, double[], double[])",
        "snippet": "        public void computeDerivatives(double t, double[] y, double[] dot)\n                throws DerivativeException {\n            MultistepIntegrator.this.computeDerivatives(t, y, dot);\n        }\n",
        "begin_line": 393,
        "end_line": 396,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderDifferentialEquations": " Get the current time derivative of the state vector.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @throws DerivativeException this exception is propagated to the caller if the\n     * underlying user function triggers one\n     ",
            "org.apache.commons.math.ode.AbstractIntegrator": " Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @throws DerivativeException this exception is propagated to the caller if the\n     * underlying user function triggers one\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.getDimension#399",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.CountingDifferentialEquations.getDimension()",
        "snippet": "        public int getDimension() {\n            return dimension;\n        }\n",
        "begin_line": 399,
        "end_line": 401,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderDifferentialEquations": " Get the dimension of the problem.\n     * @return dimension of the problem\n     ",
            "org.apache.commons.math.ode.AbstractIntegrator": null,
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.MultistepIntegrator#106",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.MultistepIntegrator(java.lang.String, int, int, double, double, double, double)",
        "snippet": "    protected MultistepIntegrator(final String name, final int nSteps,\n                                  final int order,\n                                  final double minStep, final double maxStep,\n                                  final double scalAbsoluteTolerance,\n                                  final double scalRelativeTolerance) {\n\n        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n        if (nSteps <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"{0} method needs at least one previous point\",\n                  name);\n        }\n\n        starter = new DormandPrince853Integrator(minStep, maxStep,\n                                                 scalAbsoluteTolerance,\n                                                 scalRelativeTolerance);\n        this.nSteps = nSteps;\n\n        exp = -1.0 / order;\n\n        // set the default values of the algorithm control parameters\n        setSafety(0.9);\n        setMinReduction(0.2);\n        setMaxGrowth(Math.pow(2.0, -exp));\n\n    }\n",
        "begin_line": 106,
        "end_line": 132,
        "comment": "\n     * Build a multistep integrator with the given stepsize bounds.\n     * <p>The default starter integrator is set to the {@link\n     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n     * some defaults settings.</p>\n     * <p>\n     * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.\n     * </p>\n     * @param name name of the method\n     * @param nSteps number of steps of the multistep method\n     * (excluding the one being computed)\n     * @param order order of the method\n     * @param minStep minimal step (must be positive even for backward\n     * integration), the last step can be smaller than this\n     * @param maxStep maximal step (must be positive even for backward\n     * integration)\n     * @param scalAbsoluteTolerance allowed absolute error\n     * @param scalRelativeTolerance allowed relative error\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.clearStepHandlers#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.clearStepHandlers()",
        "snippet": "    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Remove all the step handlers that have been added to the integrator.\n     * @see #addStepHandler(StepHandler)\n     * @see #getStepHandlers()\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getInterpolatedDerivatives#284",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedDerivatives()",
        "snippet": "  public double[] getInterpolatedDerivatives() throws DerivativeException {\n\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = currentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n\n      return interpolatedDerivatives;\n\n  }\n",
        "begin_line": 284,
        "end_line": 296,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the derivatives of the state vector of the interpolated point.\n   * <p>The returned vector is a reference to a reused array, so\n   * it should not be modified and it should be copied if it needs\n   * to be preserved across several calls.</p>\n   * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n   * @see #getInterpolatedState()\n   * @throws DerivativeException if this call induces an automatic\n   * step finalization that throws one\n   * @since 2.0\n   "
        },
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathException.MathException#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/MathException.java",
        "class_name": "org.apache.commons.math.MathException",
        "signature": "org.apache.commons.math.MathException.MathException(java.lang.Throwable)",
        "snippet": "    public MathException(Throwable rootCause) {\n        super(rootCause);\n        this.pattern   = getMessage();\n        this.arguments = new Object[0];\n    }\n",
        "begin_line": 79,
        "end_line": 83,
        "comment": "\n     * Constructs a new <code>MathException</code> with specified\n     * nested <code>Throwable</code> root cause.\n     *\n     * @param rootCause  the exception or error that caused this exception\n     *                   to be thrown.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathException.getMessage#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/MathException.java",
        "class_name": "org.apache.commons.math.MathException",
        "signature": "org.apache.commons.math.MathException.getMessage(java.util.Locale)",
        "snippet": "    public String getMessage(final Locale locale) {\n        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n    }\n",
        "begin_line": 152,
        "end_line": 154,
        "comment": " Gets the message in a specified locale.\n     *\n     * @param locale Locale in which the message should be translated\n     *\n     * @return localized message\n     * @since 1.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathException.getMessage#157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/MathException.java",
        "class_name": "org.apache.commons.math.MathException",
        "signature": "org.apache.commons.math.MathException.getMessage()",
        "snippet": "    @Override\n    public String getMessage() {\n        return getMessage(Locale.US);\n    }\n",
        "begin_line": 157,
        "end_line": 160,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.lang.Exception": null
        },
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.AdamsNordsieckTransformer#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.AdamsNordsieckTransformer(int)",
        "snippet": "    private AdamsNordsieckTransformer(final int nSteps) {\n\n        // compute exact coefficients\n        FieldMatrix<BigFraction> bigP = buildP(nSteps);\n        FieldDecompositionSolver<BigFraction> pSolver =\n            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver();\n\n        BigFraction[] u = new BigFraction[nSteps];\n        Arrays.fill(u, BigFraction.ONE);\n        BigFraction[] bigC1 = pSolver.solve(u);\n\n        // update coefficients are computed by combining transform from\n        // Nordsieck to multistep, then shifting rows to represent step advance\n        // then applying inverse transform\n        BigFraction[][] shiftedP = bigP.getData();\n        for (int i = shiftedP.length - 1; i > 0; --i) {\n            // shift rows\n            shiftedP[i] = shiftedP[i - 1];\n        }\n        shiftedP[0] = new BigFraction[nSteps];\n        Arrays.fill(shiftedP[0], BigFraction.ZERO);\n        FieldMatrix<BigFraction> bigMSupdate =\n            pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n\n        // initialization coefficients, computed from a R matrix = abs(P)\n        bigP.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<BigFraction>(BigFraction.ZERO) {\n            /** {@inheritDoc} */\n            @Override\n            public BigFraction visit(int row, int column, BigFraction value) {\n                return ((column & 0x1) == 0x1) ? value : value.negate();\n            }\n        });\n        FieldMatrix<BigFraction> bigRInverse =\n            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver().getInverse();\n\n        // convert coefficients to double\n        initialization = MatrixUtils.bigFractionMatrixToRealMatrix(bigRInverse);\n        update         = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n        c1             = new double[nSteps];\n        for (int i = 0; i < nSteps; ++i) {\n            c1[i] = bigC1[i].doubleValue();\n        }\n\n    }\n",
        "begin_line": 152,
        "end_line": 195,
        "comment": " Simple constructor.\n     * @param nSteps number of steps of the multistep method\n     * (excluding the one being computed)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.visit#179",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.Anonymous-fe1efccf-3500-4b45-853f-7315d3c2a325.visit(int, int, org.apache.commons.math.fraction.BigFraction)",
        "snippet": "            @Override\n            public BigFraction visit(int row, int column, BigFraction value) {\n                return ((column & 0x1) == 0x1) ? value : value.negate();\n            }\n",
        "begin_line": 179,
        "end_line": 182,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.getInstance#202",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.getInstance(int)",
        "snippet": "    public static AdamsNordsieckTransformer getInstance(final int nSteps) {\n        synchronized(CACHE) {\n            AdamsNordsieckTransformer t = CACHE.get(nSteps);\n            if (t == null) {\n                t = new AdamsNordsieckTransformer(nSteps);\n                CACHE.put(nSteps, t);\n            }\n            return t;\n        }\n    }\n",
        "begin_line": 202,
        "end_line": 211,
        "comment": " Get the Nordsieck transformer for a given number of steps.\n     * @param nSteps number of steps of the multistep method\n     * (excluding the one being computed)\n     * @return Nordsieck transformer for the specified number of steps\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdamsNordsieckTransformer.buildP#235",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
        "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.buildP(int)",
        "snippet": "    private FieldMatrix<BigFraction> buildP(final int nSteps) {\n\n        final BigFraction[][] pData = new BigFraction[nSteps][nSteps];\n\n        for (int i = 0; i < pData.length; ++i) {\n            // build the P matrix elements from Taylor series formulas\n            final BigFraction[] pI = pData[i];\n            final int factor = -(i + 1);\n            int aj = factor;\n            for (int j = 0; j < pI.length; ++j) {\n                pI[j] = new BigFraction(aj * (j + 2));\n                aj *= factor;\n            }\n        }\n\n        return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n\n    }\n",
        "begin_line": 235,
        "end_line": 252,
        "comment": " Build the P matrix.\n     * <p>The P matrix general terms are shifted j (-i)<sup>j-1</sup> terms:\n     * <pre>\n     *        [  -2   3   -4    5  ... ]\n     *        [  -4  12  -32   80  ... ]\n     *   P =  [  -6  27 -108  405  ... ]\n     *        [  -8  48 -256 1280  ... ]\n     *        [          ...           ]\n     * </pre></p>\n     * @param nSteps number of steps of the multistep method\n     * (excluding the one being computed)\n     * @return P matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.setMinReduction#256",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.setMinReduction(double)",
        "snippet": "    public void setMinReduction(final double minReduction) {\n        this.minReduction = minReduction;\n    }\n",
        "begin_line": 256,
        "end_line": 258,
        "comment": " Set the minimal reduction factor for stepsize control.\n     * @param minReduction minimal reduction factor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.setMaxGrowth#270",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.setMaxGrowth(double)",
        "snippet": "    public void setMaxGrowth(final double maxGrowth) {\n        this.maxGrowth = maxGrowth;\n    }\n",
        "begin_line": 270,
        "end_line": 272,
        "comment": " Set the maximal growth factor for stepsize control.\n     * @param maxGrowth maximal growth factor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultistepIntegrator.setSafety#284",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java",
        "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
        "signature": "org.apache.commons.math.ode.MultistepIntegrator.setSafety(double)",
        "snippet": "    public void setSafety(final double safety) {\n      this.safety = safety;\n    }\n",
        "begin_line": 284,
        "end_line": 286,
        "comment": " Set the safety factor for stepsize control.\n     * @param safety safety factor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.BigFractionMatrixConverter#720",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.BigFractionMatrixConverter.BigFractionMatrixConverter()",
        "snippet": "        public BigFractionMatrixConverter() {\n            super(BigFraction.ZERO);\n        }\n",
        "begin_line": 720,
        "end_line": 722,
        "comment": " Simple constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.start#725",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.BigFractionMatrixConverter.start(int, int, int, int, int, int)",
        "snippet": "        @Override\n        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            data = new double[rows][columns];\n        }\n",
        "begin_line": 725,
        "end_line": 729,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor": " {@inheritDoc} ",
            "org.apache.commons.math.linear.FieldMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.visit#732",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.BigFractionMatrixConverter.visit(int, int, org.apache.commons.math.fraction.BigFraction)",
        "snippet": "        @Override\n        public void visit(int row, int column, BigFraction value) {\n            data[row][column] = value.doubleValue();\n        }\n",
        "begin_line": 732,
        "end_line": 735,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor": null,
            "org.apache.commons.math.linear.FieldMatrixPreservingVisitor": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.getConvertedMatrix#740",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.BigFractionMatrixConverter.getConvertedMatrix()",
        "snippet": "        Array2DRowRealMatrix getConvertedMatrix() {\n            return new Array2DRowRealMatrix(data, false);\n        }\n",
        "begin_line": 740,
        "end_line": 742,
        "comment": " Get the converted matrix.\n         * @return converted matrix\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.bigFractionMatrixToRealMatrix#707",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.bigFractionMatrixToRealMatrix(org.apache.commons.math.linear.FieldMatrix<org.apache.commons.math.fraction.BigFraction>)",
        "snippet": "    public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n        final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n        m.walkInOptimizedOrder(converter);\n        return converter.getConvertedMatrix();\n    }\n",
        "begin_line": 707,
        "end_line": 711,
        "comment": "\n     * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n     * @param m matrix to convert\n     * @return converted matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.Solver#246",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.Solver.Solver(org.apache.commons.math.Field<T>, T[][], int[], boolean)",
        "snippet": "        private Solver(final Field<T> field, final T[][] lu,\n                       final int[] pivot, final boolean singular) {\n            this.field    = field;\n            this.lu       = lu;\n            this.pivot    = pivot;\n            this.singular = singular;\n        }\n",
        "begin_line": 246,
        "end_line": 252,
        "comment": "\n         * Build a solver from decomposed matrix.\n         * @param field field to which the matrix elements belong\n         * @param lu entries of LU decomposition\n         * @param pivot pivot permutation associated with LU decomposition\n         * @param singular singularity indicator\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.solve#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.Solver.solve(T[])",
        "snippet": "        public T[] solve(T[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = pivot.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            @SuppressWarnings(\"unchecked\") // field is of type T\n            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n\n            // Apply permutations to b\n            for (int row = 0; row < m; row++) {\n                bp[row] = b[pivot[row]];\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final T bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                bp[col] = bp[col].divide(lu[col][col]);\n                final T bpCol = bp[col];\n                for (int i = 0; i < col; i++) {\n                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n                }\n            }\n\n            return bp;\n\n        }\n",
        "begin_line": 260,
        "end_line": 300,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldLUDecomposition": null,
            "org.apache.commons.math.linear.FieldDecompositionSolver": " Solve the linear equation A &times; X = B for matrices A.\n     * <p>The A matrix is implicit, it is provided by the underlying\n     * decomposition algorithm.</p>\n     * @param b right-hand side of the equation A &times; X = B\n     * @return a vector X that minimizes the two norm of A &times; X - B\n     * @exception IllegalArgumentException if matrices dimensions don't match\n     * @exception InvalidMatrixException if decomposed matrix is singular\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.solve#362",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.Solver.solve(org.apache.commons.math.linear.FieldMatrix<T>)",
        "snippet": "        public FieldMatrix<T> solve(FieldMatrix<T> b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = pivot.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            final int nColB = b.getColumnDimension();\n\n            // Apply permutations to b\n            @SuppressWarnings(\"unchecked\") // field is of type T\n            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n            for (int row = 0; row < m; row++) {\n                final T[] bpRow = bp[row];\n                final int pRow = pivot[row];\n                for (int col = 0; col < nColB; col++) {\n                    bpRow[col] = b.getEntry(pRow, col);\n                }\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final T[] bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    final T[] bpI = bp[i];\n                    final T luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n                    }\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                final T[] bpCol = bp[col];\n                final T luDiag = lu[col][col];\n                for (int j = 0; j < nColB; j++) {\n                    bpCol[j] = bpCol[j].divide(luDiag);\n                }\n                for (int i = 0; i < col; i++) {\n                    final T[] bpI = bp[i];\n                    final T luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n                    }\n                }\n            }\n\n            return new Array2DRowFieldMatrix<T>(bp, false);\n\n        }\n",
        "begin_line": 362,
        "end_line": 418,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldLUDecomposition": null,
            "org.apache.commons.math.linear.FieldDecompositionSolver": " Solve the linear equation A &times; X = B for matrices A.\n     * <p>The A matrix is implicit, it is provided by the underlying\n     * decomposition algorithm.</p>\n     * @param b right-hand side of the equation A &times; X = B\n     * @return a matrix X that minimizes the two norm of A &times; X - B\n     * @exception IllegalArgumentException if matrices dimensions don't match\n     * @exception InvalidMatrixException if decomposed matrix is singular\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.getInverse#421",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.Solver.getInverse()",
        "snippet": "        public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n            final int m = pivot.length;\n            final T one = field.getOne();\n            FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                identity.setEntry(i, i, one);\n            }\n            return solve(identity);\n        }\n",
        "begin_line": 421,
        "end_line": 429,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldLUDecomposition": null,
            "org.apache.commons.math.linear.FieldDecompositionSolver": " Get the inverse (or pseudo-inverse) of the decomposed matrix.\n     * @return inverse matrix\n     * @throws InvalidMatrixException if decomposed matrix is singular\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldLUDecompositionImpl.getSolver#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
        "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.getSolver()",
        "snippet": "    public FieldDecompositionSolver<T> getSolver() {\n        return new Solver<T>(field, lu, pivot, singular);\n    }\n",
        "begin_line": 217,
        "end_line": 219,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldLUDecomposition": "\n     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n     * @return a solver\n     ",
            "org.apache.commons.math.linear.FieldDecompositionSolver": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultFieldMatrixPreservingVisitor.DefaultFieldMatrixPreservingVisitor#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor.DefaultFieldMatrixPreservingVisitor(T)",
        "snippet": "    public DefaultFieldMatrixPreservingVisitor(final T zero) {\n        this.zero = zero;\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": " Build a new instance.\n     * @param zero additive identity of the field\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultFieldMatrixPreservingVisitor.end#57",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor.end()",
        "snippet": "    public T end() {\n        return zero;\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrixPreservingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultFieldMatrixChangingVisitor.DefaultFieldMatrixChangingVisitor#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor.DefaultFieldMatrixChangingVisitor(T)",
        "snippet": "    public DefaultFieldMatrixChangingVisitor(final T zero) {\n        this.zero = zero;\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": " Build a new instance.\n     * @param zero additive identity of the field\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultFieldMatrixChangingVisitor.start#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor.start(int, int, int, int, int, int)",
        "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrixChangingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultFieldMatrixChangingVisitor.end#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java",
        "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor",
        "signature": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor.end()",
        "snippet": "    public T end() {\n        return zero;\n    }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrixChangingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_ROW_MESSAGE);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_COLUMN_MESSAGE);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 133,
        "end_line": 159,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the <code>copyArray</code> may be\n     * set to <code>false</code. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.</p>\n     * @param d data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.Array2DRowFieldMatrix#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix(org.apache.commons.math.Field<T>, int, int)",
        "snippet": "    public Array2DRowFieldMatrix(final Field<T> field,\n                           final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(field, rowDimension, columnDimension);\n        data = buildArray(field, rowDimension, columnDimension);\n    }\n",
        "begin_line": 82,
        "end_line": 87,
        "comment": "\n     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n     *\n     * @param field field to which the elements belong\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.Array2DRowFieldMatrix#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix(T[][], boolean)",
        "snippet": "    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        super(extractField(d));\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_ROW_MESSAGE);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_COLUMN_MESSAGE);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 123,
        "end_line": 150,
        "comment": "\n     * Create a new FieldMatrix<T> using the input array as the underlying\n     * data array.\n     * <p>If an array is built specially in order to be embedded in a\n     * FieldMatrix<T> and not used directly, the <code>copyArray</code> may be\n     * set to <code>false</code. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.</p>\n     * @param d data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #Array2DRowFieldMatrix(FieldElement[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.getData#307",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getData()",
        "snippet": "    @Override\n    public T[][] getData() {\n        return copyOut();\n    }\n",
        "begin_line": 307,
        "end_line": 310,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return    2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.getEntry#362",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public T getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 362,
        "end_line": 371,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Returns the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be fetched\n     * @param column  column location of entry to be fetched\n     * @return matrix entry in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.setEntry#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.setEntry(int, int, T)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final T value)\n        throws MatrixIndexException {\n        try {\n            data[row][column] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 374,
        "end_line": 383,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Set the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be set\n     * @param column  column location of entry to be set\n     * @param value matrix entry to be set in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.getRowDimension#410",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 410,
        "end_line": 413,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.getColumnDimension#416",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 416,
        "end_line": 419,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.walkInRowOrder#469",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor<T>)",
        "snippet": "    @Override\n    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final T[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                rowI[j] = visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 469,
        "end_line": 482,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Visit (and possibly change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.walkInRowOrder#485",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.walkInRowOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor<T>)",
        "snippet": "    @Override\n    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final T[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 485,
        "end_line": 498,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractFieldMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "Array2DRowFieldMatrix.copyOut#607",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
        "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.copyOut()",
        "snippet": "    private T[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final T[][] out = buildArray(getField(), nRows, getColumnDimension());\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n",
        "begin_line": 607,
        "end_line": 615,
        "comment": "\n     * Returns a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.AbstractFieldMatrix#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(org.apache.commons.math.Field<T>)",
        "snippet": "    protected AbstractFieldMatrix(final Field<T> field) {\n        this.field = field;\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Creates a matrix with no data\n     * @param field field to which the elements belong\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.AbstractFieldMatrix#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(org.apache.commons.math.Field<T>, int, int)",
        "snippet": "    protected AbstractFieldMatrix(final Field<T> field,\n                                  final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        this.field = field;\n    }\n",
        "begin_line": 64,
        "end_line": 78,
        "comment": "\n     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n     *\n     * @param field field to which the elements belong\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.extractField#87",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.extractField(T[][])",
        "snippet": "    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n        throws IllegalArgumentException {\n        if (d.length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n        }\n        if (d[0].length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n        }\n        return d[0][0].getField();\n    }\n",
        "begin_line": 87,
        "end_line": 96,
        "comment": "\n     * Get the elements type from an array.\n     * @param <T> the type of the field elements\n     * @param d data array\n     * @return field to which array elements belong\n     * @exception IllegalArgumentException if array is empty\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.buildArray#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.buildArray(org.apache.commons.math.Field<T>, int, int)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field,\n                                                                  final int rows,\n                                                                  final int columns) {\n        if (columns < 0) {\n            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0);\n            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n        }\n        T[][] array =\n            (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n        for (int i = 0; i < array.length; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n        return array;\n    }\n",
        "begin_line": 124,
        "end_line": 138,
        "comment": " Build an array of elements.\n     * <p>\n     * Complete arrays are filled with field.getZero()\n     * </p>\n     * @param <T> the type of the field elements\n     * @param field field to which array elements belong\n     * @param rows number of rows\n     * @param columns number of columns (may be negative to build partial\n     * arrays in the same way <code>new Field[rows][]</code> works)\n     * @return a new array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.getField#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getField()",
        "snippet": "    public Field<T> getField() {\n        return field;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Get the type of field elements of the matrix.\n     * @return type of field elements of the matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.isSquare#646",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }\n",
        "begin_line": 646,
        "end_line": 648,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.walkInOptimizedOrder#906",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixChangingVisitor<T>)",
        "snippet": "    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 906,
        "end_line": 909,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Visit (and possibly change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractFieldMatrix.walkInOptimizedOrder#912",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
        "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(org.apache.commons.math.linear.FieldMatrixPreservingVisitor<T>)",
        "snippet": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 912,
        "end_line": 915,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.FieldMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @exception  MatrixVisitorException if the visitor cannot process an entry\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFractionField.BigFractionField#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFractionField.java",
        "class_name": "org.apache.commons.math.fraction.BigFractionField",
        "signature": "org.apache.commons.math.fraction.BigFractionField.BigFractionField()",
        "snippet": "    private BigFractionField() {\n    }\n",
        "begin_line": 40,
        "end_line": 41,
        "comment": " Private constructor for the singleton.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFractionField.getInstance#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFractionField.java",
        "class_name": "org.apache.commons.math.fraction.BigFractionField",
        "signature": "org.apache.commons.math.fraction.BigFractionField.getInstance()",
        "snippet": "    public static BigFractionField getInstance() {\n        return LazyHolder.INSTANCE;\n    }\n",
        "begin_line": 46,
        "end_line": 48,
        "comment": " Get the unique instance.\n     * @return the unique instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFractionField.getOne#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFractionField.java",
        "class_name": "org.apache.commons.math.fraction.BigFractionField",
        "signature": "org.apache.commons.math.fraction.BigFractionField.getOne()",
        "snippet": "    public BigFraction getOne() {\n        return BigFraction.ONE;\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.Field": " Get the multiplicative identity of the field.\n     * <p>\n     * The multiplicative identity is the element e<sub>1</sub> of the field such that\n     * for all elements a of the field, the equalities a &times; e<sub>1</sub> =\n     * e<sub>1</sub> &times; a = a hold.\n     * </p>\n     * @return multiplicative identity of the field\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFractionField.getZero#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFractionField.java",
        "class_name": "org.apache.commons.math.fraction.BigFractionField",
        "signature": "org.apache.commons.math.fraction.BigFractionField.getZero()",
        "snippet": "    public BigFraction getZero() {\n        return BigFraction.ZERO;\n    }\n",
        "begin_line": 56,
        "end_line": 58,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.Field": " Get the additive identity of the field.\n     * <p>\n     * The additive identity is the element e<sub>0</sub> of the field such that\n     * for all elements a of the field, the equalities a + e<sub>0</sub> =\n     * e<sub>0</sub> + a = a hold.\n     * </p>\n     * @return additive identity of the field\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.BigFraction#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(java.math.BigInteger, java.math.BigInteger)",
        "snippet": "    public BigFraction(BigInteger num, BigInteger den) {\n        if (num == null) {\n            throw MathRuntimeException.createNullPointerException(\"numerator is null\");\n        }\n        if (den == null) {\n            throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n        }\n        if (BigInteger.ZERO.equals(den)) {\n            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n        }\n        if (BigInteger.ZERO.equals(num)) {\n            numerator   = BigInteger.ZERO;\n            denominator = BigInteger.ONE;\n        } else {\n\n            // reduce numerator and denominator by greatest common denominator\n            final BigInteger gcd = num.gcd(den);\n            if (BigInteger.ONE.compareTo(gcd) < 0) {\n                num = num.divide(gcd);\n                den = den.divide(gcd);\n            }\n\n            // move sign to numerator\n            if (BigInteger.ZERO.compareTo(den) > 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n\n            // store the values in the final fields\n            numerator   = num;\n            denominator = den;\n\n        }\n    }\n",
        "begin_line": 124,
        "end_line": 157,
        "comment": "\n     * <p>\n     * Create a {@link BigFraction} given the numerator and denominator as\n     * <code>BigInteger</code>. The {@link BigFraction} is reduced to lowest terms.\n     * </p>\n     *\n     * @param num\n     *            the numerator, must not be <code>null</code>.\n     * @param den\n     *            the denominator, must not be <code>null</code>.\n     * @throws ArithmeticException\n     *             if the denominator is <code>zero</code>.\n     * @throws NullPointerException\n     *             if the numerator or the denominator is <code>zero</code>.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.BigFraction#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(int)",
        "snippet": "    public BigFraction(final int num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": "\n     * <p>\n     * Create a {@link BigFraction} equivalent to the passed <tt>int</tt>, ie\n     * \"num / 1\".\n     * </p>\n     *\n     * @param num\n     *            the numerator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.BigFraction#389",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(int, int)",
        "snippet": "    public BigFraction(final int num, final int den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }\n",
        "begin_line": 389,
        "end_line": 391,
        "comment": "\n     * <p>\n     * Create a {@link BigFraction} given the numerator and denominator as simple\n     * <tt>int</tt>. The {@link BigFraction} is reduced to lowest terms.\n     * </p>\n     *\n     * @param num\n     *            the numerator.\n     * @param den\n     *            the denominator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.divide#673",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.divide(org.apache.commons.math.fraction.BigFraction)",
        "snippet": "    public BigFraction divide(final BigFraction fraction) {\n        if (BigInteger.ZERO.equals(fraction.numerator)) {\n            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n        }\n\n        return multiply(fraction.reciprocal());\n    }\n",
        "begin_line": 673,
        "end_line": 679,
        "comment": "\n     * <p>\n     * Divide the value of this fraction by another, returning the result in\n     * reduced form.\n     * </p>\n     *\n     * @param fraction\n     *            the fraction to divide by, must not be <code>null</code>.\n     * @return a {@link BigFraction} instance with the resulting values.\n     * @throws NullPointerException\n     *             if the fraction is <code>null</code>.\n     * @throws ArithmeticException\n     *             if the fraction to divide by is zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.doubleValue#690",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.doubleValue()",
        "snippet": "    @Override\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n",
        "begin_line": 690,
        "end_line": 693,
        "comment": "\n     * <p>\n     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n     * the numerator divided by denominator.\n     * </p>\n     *\n     * @return the fraction as a <tt>double</tt>\n     * @see java.lang.Number#doubleValue()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.equals#710",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(final Object other) {\n        boolean ret = false;\n\n        if (this == other) {\n            ret = true;\n        } else if (other instanceof BigFraction) {\n            BigFraction rhs = ((BigFraction) other).reduce();\n            BigFraction thisOne = this.reduce();\n            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 710,
        "end_line": 723,
        "comment": "\n     * <p>\n     * Test for the equality of two fractions. If the lowest term numerator and\n     * denominators are the same for both fractions, the two fractions are\n     * considered to be equal.\n     * </p>\n     *\n     * @param other\n     *            fraction to test for equality to this fraction, can be\n     *            <code>null</code>.\n     * @return true if two fractions are equal, false if object is\n     *         <code>null</code>, not an instance of {@link BigFraction}, or not\n     *         equal to this fraction instance.\n     * @see java.lang.Object#equals(java.lang.Object)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.getNumeratorAsInt#790",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.getNumeratorAsInt()",
        "snippet": "    public int getNumeratorAsInt() {\n        return numerator.intValue();\n    }\n",
        "begin_line": 790,
        "end_line": 792,
        "comment": "\n     * <p>\n     * Access the numerator as a <tt>int</tt>.\n     * </p>\n     *\n     * @return the numerator as a <tt>int</tt>.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.multiply#902",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.multiply(org.apache.commons.math.fraction.BigFraction)",
        "snippet": "    public BigFraction multiply(final BigFraction fraction) {\n        BigFraction ret = ZERO;\n\n        if (getNumeratorAsInt() != 0 && fraction.getNumeratorAsInt() != 0) {\n            ret = new BigFraction(numerator.multiply(fraction.numerator), denominator.multiply(fraction.denominator));\n        }\n\n        return ret;\n    }\n",
        "begin_line": 902,
        "end_line": 910,
        "comment": "\n     * <p>\n     * Multiplies the value of this fraction by another, returning the result in\n     * reduced form.\n     * </p>\n     *\n     * @param fraction\n     *            the fraction to multiply by, must not be <code>null</code>.\n     * @return a {@link BigFraction} instance with the resulting values.\n     * @throws NullPointerException\n     *             if the fraction is <code>null</code>.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.negate#920",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.negate()",
        "snippet": "    public BigFraction negate() {\n        return new BigFraction(numerator.negate(), denominator);\n    }\n",
        "begin_line": 920,
        "end_line": 922,
        "comment": "\n     * <p>\n     * Return the additive inverse of this fraction, returning the result in\n     * reduced form.\n     * </p>\n     *\n     * @return the negation of this fraction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.reciprocal#1015",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.reciprocal()",
        "snippet": "    public BigFraction reciprocal() {\n        return new BigFraction(denominator, numerator);\n    }\n",
        "begin_line": 1015,
        "end_line": 1017,
        "comment": "\n     * <p>\n     * Return the multiplicative inverse of this fraction.\n     * </p>\n     *\n     * @return the reciprocal fraction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.reduce#1027",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.reduce()",
        "snippet": "    public BigFraction reduce() {\n        final BigInteger gcd = numerator.gcd(denominator);\n        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n    }\n",
        "begin_line": 1027,
        "end_line": 1030,
        "comment": "\n     * <p>\n     * Reduce this <code>BigFraction</code> to its lowest terms.\n     * </p>\n     *\n     * @return the reduced <code>BigFraction</code>. It doesn't change anything if\n     *         the fraction can be reduced.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.subtract#1091",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.subtract(org.apache.commons.math.fraction.BigFraction)",
        "snippet": "    public BigFraction subtract(final BigFraction fraction) {\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.subtract(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }\n",
        "begin_line": 1091,
        "end_line": 1107,
        "comment": "\n     * <p>\n     * Subtracts the value of another fraction from the value of this one,\n     * returning the result in reduced form.\n     * </p>\n     *\n     * @param fraction\n     *            the {@link BigFraction} to subtract, must not be\n     *            <code>null</code>.\n     * @return a {@link BigFraction} instance with the resulting values\n     * @throws NullPointerException\n     *             if the fraction is <code>null</code>.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BigFraction.getField#1132",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/fraction/BigFraction.java",
        "class_name": "org.apache.commons.math.fraction.BigFraction",
        "signature": "org.apache.commons.math.fraction.BigFraction.getField()",
        "snippet": "    public BigFractionField getField() {\n        return BigFractionField.getInstance();\n    }\n",
        "begin_line": 1132,
        "end_line": 1134,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.lang.Comparable": null,
            "org.apache.commons.math.FieldElement": " Get the {@link Field} to which the instance belongs.\n     * @return {@link Field} to which the instance belongs\n     ",
            "java.lang.Number": null,
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.clearEventsHandlers#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.clearEventsHandlers()",
        "snippet": "    public void clearEventsHandlers() {\n        states.clear();\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": " Remove all the events handlers that have been added to the manager.\n     * @see #addEventHandler(EventHandler, double, double, int)\n     * @see #getEventsHandlers()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.clearEventHandlers#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.clearEventHandlers()",
        "snippet": "    public void clearEventHandlers() {\n        eventsHandlersManager.clearEventsHandlers();\n    }\n",
        "begin_line": 115,
        "end_line": 117,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Remove all the event handlers that have been added to the integrator.\n     * @see #addEventHandler(EventHandler, double, double, int)\n     * @see #getEventHandlers()\n     "
        },
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.getCurrentStepStart#308",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getCurrentStepStart()",
        "snippet": "  @Override\n  public double getCurrentStepStart() {\n    return stepStart;\n  }\n",
        "begin_line": 308,
        "end_line": 311,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.AbstractIntegrator": " {@inheritDoc} ",
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Get the current value of the step start time t<sub>i</sub>.\n     * <p>This method can be called during integration (typically by\n     * the object implementing the {@link FirstOrderDifferentialEquations\n     * differential equations} problem) if the value of the current step that\n     * is attempted is needed.</p>\n     * <p>The result is undefined if the method is called outside of\n     * calls to <code>integrate</code>.</p>\n     * @return current value of the step start time t<sub>i</sub>\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.getCurrentSignedStepsize#137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.getCurrentSignedStepsize()",
        "snippet": "    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }\n",
        "begin_line": 137,
        "end_line": 139,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Get the current signed value of the integration stepsize.\n     * <p>This method can be called during integration (typically by\n     * the object implementing the {@link FirstOrderDifferentialEquations\n     * differential equations} problem) if the signed value of the current stepsize\n     * that is tried is needed.</p>\n     * <p>The result is undefined if the method is called outside of\n     * calls to <code>integrate</code>.</p>\n     * @return current signed value of the stepsize\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives#313",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives(double, double)",
        "snippet": "  @Override\n  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH)\n    throws DerivativeException {\n\n    if (! vectorsInitialized) {\n\n      if (v == null) {\n        v = new double[7][];\n        for (int k = 0; k < 7; ++k) {\n          v[k] = new double[interpolatedState.length];\n        }\n      }\n\n      // perform the last evaluations if they have not been done yet\n      finalizeStep();\n\n      // compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot1  = yDotK[0][i];\n          final double yDot6  = yDotK[5][i];\n          final double yDot7  = yDotK[6][i];\n          final double yDot8  = yDotK[7][i];\n          final double yDot9  = yDotK[8][i];\n          final double yDot10 = yDotK[9][i];\n          final double yDot11 = yDotK[10][i];\n          final double yDot12 = yDotK[11][i];\n          final double yDot13 = yDotK[12][i];\n          final double yDot14 = yDotKLast[0][i];\n          final double yDot15 = yDotKLast[1][i];\n          final double yDot16 = yDotKLast[2][i];\n          v[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\n                    B_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\n                    B_11 * yDot11 + B_12 * yDot12;\n          v[1][i] = yDot1 - v[0][i];\n          v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n          for (int k = 0; k < D.length; ++k) {\n              v[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\n                          D[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\n                          D[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\n                          D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n          }\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    final double eta      = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double theta2   = theta * theta;\n    final double dot1 = 1 - twoTheta;\n    final double dot2 = theta * (2 - 3 * theta);\n    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n\n    for (int i = 0; i < interpolatedState.length; ++i) {\n      interpolatedState[i] = currentState[i] -\n                             oneMinusThetaH * (v[0][i] -\n                                               theta * (v[1][i] +\n                                                        theta * (v[2][i] +\n                                                                 eta * (v[3][i] +\n                                                                        theta * (v[4][i] +\n                                                                                 eta * (v[5][i] +\n                                                                                        theta * (v[6][i])))))));\n      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n                                    dot3 * v[3][i] + dot4 * v[4][i] +\n                                    dot5 * v[5][i] + dot6 * v[6][i];\n    }\n\n  }\n",
        "begin_line": 313,
        "end_line": 385,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Compute the state and derivatives at the interpolated time.\n   * This is the main processing method that should be implemented by\n   * the derived classes to perform the interpolation.\n   * @param theta normalized interpolation abscissa within the step\n   * (theta is zero at the previous time step and one at the current time step)\n   * @param oneMinusThetaH time gap between the interpolated time and\n   * the current time\n   * @throws DerivativeException this exception is propagated to the caller if the\n   * underlying user function triggers one\n   "
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doFinalize#388",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doFinalize()",
        "snippet": "  @Override\n  protected void doFinalize()\n    throws DerivativeException {\n\n    if (currentState == null) {\n      // we are finalizing an uninitialized instance\n      return;\n    }\n\n    double s;\n    final double[] yTmp = new double[currentState.length];\n\n    // k14\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\n\n    // k15\n    for (int j = 0; j < currentState.length; ++j) {\n     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n         K15_14 * yDotKLast[0][j];\n     yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\n\n    // k16\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n\n  }\n",
        "begin_line": 388,
        "end_line": 429,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": "\n   * Really finalize the step.\n   * The default implementation of this method does nothing.\n   * @throws DerivativeException this exception is propagated to the\n   * caller if the underlying user function triggers one\n   "
        },
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#243",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator(org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator)",
        "snippet": "  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState == null) {\n\n      yDotKLast = null;\n      v         = null;\n      vectorsInitialized = false;\n\n    } else {\n\n      final int dimension = interpolator.currentState.length;\n\n      yDotKLast    = new double[3][];\n      for (int k = 0; k < yDotKLast.length; ++k) {\n        yDotKLast[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n                         dimension);\n      }\n\n      v = new double[7][];\n      for (int k = 0; k < v.length; ++k) {\n        v[k] = new double[dimension];\n        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n      }\n\n      vectorsInitialized = interpolator.vectorsInitialized;\n\n    }\n\n  }\n",
        "begin_line": 243,
        "end_line": 274,
        "comment": " Copy constructor.\n   * @param interpolator interpolator to copy from. The copy is a deep\n   * copy: its arrays are separated from the original arrays of the\n   * instance\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doCopy#277",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doCopy()",
        "snippet": "  @Override\n  protected StepInterpolator doCopy() {\n    return new DormandPrince853StepInterpolator(this);\n  }\n",
        "begin_line": 277,
        "end_line": 280,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Really copy the finalized instance.\n    * <p>This method is called by {@link #copy()} after the\n    * step has been finalized. It must perform a deep copy\n    * to have an new instance completely independent for the\n    * original instance.\n    * @return a copy of the finalized instance\n    "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.reinitialize#283",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean)",
        "snippet": "  @Override\n  public void reinitialize(final AbstractIntegrator integrator,\n                           final double[] y, final double[][] yDotK, final boolean forward) {\n\n    super.reinitialize(integrator, y, yDotK, forward);\n\n    final int dimension = currentState.length;\n\n    yDotKLast = new double[3][];\n    for (int k = 0; k < yDotKLast.length; ++k) {\n      yDotKLast[k] = new double[dimension];\n    }\n\n    v = new double[7][];\n    for (int k = 0; k < v.length; ++k) {\n      v[k]  = new double[dimension];\n    }\n\n    vectorsInitialized = false;\n\n  }\n",
        "begin_line": 283,
        "end_line": 303,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.storeTime#306",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.storeTime(double)",
        "snippet": "  @Override\n  public void storeTime(final double t) {\n    super.storeTime(t);\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 306,
        "end_line": 310,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Store the current step time.\n   * @param t current time\n   "
        },
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.estimateError#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.estimateError(double[][], double[], double[], double)",
        "snippet": "  @Override\n  protected double estimateError(final double[][] yDotK,\n                                 final double[] y0, final double[] y1,\n                                 final double h) {\n    double error1 = 0;\n    double error2 = 0;\n\n    for (int j = 0; j < y0.length; ++j) {\n      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\n                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\n                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\n                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\n      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\n                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\n                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\n                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n\n      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n      final double tol = (vecAbsoluteTolerance == null) ?\n                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n      final double ratio1  = errSum1 / tol;\n      error1        += ratio1 * ratio1;\n      final double ratio2  = errSum2 / tol;\n      error2        += ratio2 * ratio2;\n    }\n\n    double den = error1 + 0.01 * error2;\n    if (den <= 0.0) {\n      den = 1.0;\n    }\n\n    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n\n  }\n",
        "begin_line": 245,
        "end_line": 279,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator": " Compute the error ratio.\n   * @param yDotK derivatives computed during the first stages\n   * @param y0 estimate of the step at the start of the step\n   * @param y1 estimate of the step at the end of the step\n   * @param h  current step\n   * @return error ratio, greater than 1 if step should be rejected\n   "
        },
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.DormandPrince853Integrator#213",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator(double, double, double, double)",
        "snippet": "  public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n          new DormandPrince853StepInterpolator(),\n          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n  }\n",
        "begin_line": 213,
        "end_line": 219,
        "comment": " Simple constructor.\n   * Build an eighth order Dormand-Prince integrator with the given step bounds\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getInterpolatedTime#239",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedTime()",
        "snippet": "  public double getInterpolatedTime() {\n    return interpolatedTime;\n  }\n",
        "begin_line": 239,
        "end_line": 241,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the time of the interpolated point.\n   * If {@link #setInterpolatedTime} has not been called, it returns\n   * the current grid point time.\n   * @return interpolation point time\n   "
        },
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.solve#215",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(org.apache.commons.math.analysis.UnivariateRealFunction, double, double, double, double, double, double)",
        "snippet": "    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n",
        "begin_line": 215,
        "end_line": 310,
        "comment": "\n     * Find a zero starting search according to the three provided points.\n     * @param f the function to solve\n     * @param x0 old approximation for the root\n     * @param y0 function value at the approximation for the root\n     * @param x1 last calculated approximation for the root\n     * @param y1 function value at the last calculated approximation\n     * for the root\n     * @param x2 bracket point (must be set to x0 if no bracket point is\n     * known, this will force starting with linear interpolation)\n     * @param y2 function value at the bracket point.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#231",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator()",
        "snippet": "  public DormandPrince853StepInterpolator() {\n    super();\n    yDotKLast = null;\n    v         = null;\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 231,
        "end_line": 236,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n   * prototyping design pattern to create the step interpolators by\n   * cloning an uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.getOrder#239",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.getOrder()",
        "snippet": "  @Override\n  public int getOrder() {\n    return 8;\n  }\n",
        "begin_line": 239,
        "end_line": 242,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator": " Get the order of the method.\n   * @return order of the method\n   "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.eventOccurred#261",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.EndTimeChecker.eventOccurred(double, double[], boolean)",
        "snippet": "        public int eventOccurred(double t, double[] y, boolean increasing) {\n            return STOP;\n        }\n",
        "begin_line": 261,
        "end_line": 263,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.events.EventHandler": " Handle an event and choose what to do next.\n\n   * <p>This method is called when the integrator has accepted a step\n   * ending exactly on a sign change of the function, just <em>before</em>\n   * the step handler itself is called (see below for scheduling). It\n   * allows the user to update his internal data to acknowledge the fact\n   * the event has been handled (for example setting a flag in the {@link\n   * org.apache.commons.math.ode.FirstOrderDifferentialEquations\n   * differential equations} to switch the derivatives computation in\n   * case of discontinuity), or to direct the integrator to either stop\n   * or continue integration, possibly with a reset state or derivatives.</p>\n\n   * <ul>\n   *   <li>if {@link #STOP} is returned, the step handler will be called\n   *   with the <code>isLast</code> flag of the {@link\n   *   org.apache.commons.math.ode.sampling.StepHandler#handleStep handleStep}\n   *   method set to true and the integration will be stopped,</li>\n   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n   *   resetState} method will be called once the step handler has\n   *   finished its task, and the integrator will also recompute the\n   *   derivatives,</li>\n   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n   *   will recompute the derivatives,\n   *   <li>if {@link #CONTINUE} is returned, no specific action will\n   *   be taken (apart from having called this method) and integration\n   *   will continue.</li>\n   * </ul>\n\n   * <p>The scheduling between this method and the {@link\n   * org.apache.commons.math.ode.sampling.StepHandler StepHandler} method {@link\n   * org.apache.commons.math.ode.sampling.StepHandler#handleStep(\n   * org.apache.commons.math.ode.sampling.StepInterpolator, boolean)\n   * handleStep(interpolator, isLast)} is to call this method first and\n   * <code>handleStep</code> afterwards. This scheduling allows the integrator to\n   * pass <code>true</code> as the <code>isLast</code> parameter to the step\n   * handler to make it aware the step will be the last one if this method\n   * returns {@link #STOP}. As the interpolator may be used to navigate back\n   * throughout the last step (as {@link\n   * org.apache.commons.math.ode.sampling.StepNormalizer StepNormalizer}\n   * does for example), user code called by this method and user\n   * code called by step handlers may experience apparently out of order values\n   * of the independent time variable. As an example, if the same user object\n   * implements both this {@link EventHandler EventHandler} interface and the\n   * {@link org.apache.commons.math.ode.sampling.FixedStepHandler FixedStepHandler}\n   * interface, a <em>forward</em> integration may call its\n   * <code>eventOccurred</code> method with t = 10 first and call its\n   * <code>handleStep</code> method with t = 9 afterwards. Such out of order\n   * calls are limited to the size of the integration step for {@link\n   * org.apache.commons.math.ode.sampling.StepHandler variable step handlers} and\n   * to the size of the fixed step for {@link\n   * org.apache.commons.math.ode.sampling.FixedStepHandler fixed step handlers}.</p>\n\n   * @param t current value of the independent <i>time</i> variable\n   * @param y array containing the current value of the state vector\n   * @param increasing if true, the value of the switching function increases\n   * when times increases around event (note that increase is measured with respect\n   * to physical time, not with respect to integration which may go backward in time)\n   * @return indication of what the integrator should do next, this\n   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n   * @exception EventException if the event occurrence triggers an error\n   ",
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.1667
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.evaluateStep#167",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.evaluateStep(org.apache.commons.math.ode.sampling.StepInterpolator)",
        "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    if (ga * gb > 0) {\n                        // this is a corner case:\n                        // - there was an event near ta,\n                        // - there is another event between ta and tb\n                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                        // about bracketing\n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            // this should never happen\n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }\n",
        "begin_line": 167,
        "end_line": 274,
        "comment": " Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.getEventTime#281",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.getEventTime()",
        "snippet": "    public double getEventTime() {\n        return pendingEventTime;\n    }\n",
        "begin_line": 281,
        "end_line": 283,
        "comment": " Get the occurrence time of the event triggered in the current\n     * step.\n     * @return occurrence time of the event triggered in the current\n     * step.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.stepAccepted#293",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.stepAccepted(double, double[])",
        "snippet": "    public void stepAccepted(final double t, final double[] y)\n        throws EventException {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.CONTINUE;\n        }\n    }\n",
        "begin_line": 293,
        "end_line": 308,
        "comment": " Acknowledge the fact the step has been accepted by the integrator.\n     * @param t value of the independent <i>time</i> variable at the\n     * end of the step\n     * @param y array containing the current value of the state vector\n     * at the end of the step\n     * @exception EventException if the value of the event\n     * handler cannot be evaluated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.evaluateStep#122",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.evaluateStep(org.apache.commons.math.ode.sampling.StepInterpolator)",
        "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, IntegratorException {\n\n        try {\n\n            first = null;\n            if (states.isEmpty()) {\n                // there is nothing to do, return now to avoid setting the\n                // interpolator time (and hence avoid unneeded calls to the\n                // user function due to interpolator finalization)\n                return false;\n            }\n\n            if (! initialized) {\n\n                // initialize the events states\n                final double t0 = interpolator.getPreviousTime();\n                interpolator.setInterpolatedTime(t0);\n                final double [] y = interpolator.getInterpolatedState();\n                for (EventState state : states) {\n                    state.reinitializeBegin(t0, y);\n                }\n\n                initialized = true;\n\n            }\n\n            // check events occurrence\n            for (EventState state : states) {\n\n                if (state.evaluateStep(interpolator)) {\n                    if (first == null) {\n                        first = state;\n                    } else {\n                        if (interpolator.isForward()) {\n                            if (state.getEventTime() < first.getEventTime()) {\n                                first = state;\n                            }\n                        } else {\n                            if (state.getEventTime() > first.getEventTime()) {\n                                first = state;\n                            }\n                        }\n                    }\n                }\n\n            }\n\n            return first != null;\n\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        } catch (ConvergenceException ce) {\n            throw new IntegratorException(ce);\n        }\n\n    }\n",
        "begin_line": 122,
        "end_line": 178,
        "comment": " Evaluate the impact of the proposed step on all managed\n     * event handlers.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if at least one event handler triggers an event\n     * before the end of the proposed step (this implies the step should\n     * be rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the function somewhere within the step\n     * @exception IntegratorException if an event cannot be located\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.getEventTime#186",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.getEventTime()",
        "snippet": "    public double getEventTime() {\n        return (first == null) ? Double.NaN : first.getEventTime();\n    }\n",
        "begin_line": 186,
        "end_line": 188,
        "comment": " Get the occurrence time of the first event triggered in the\n     * last evaluated step.\n     * @return occurrence time of the first event triggered in the last\n     * evaluated step, or </code>Double.NaN</code> if no event is\n     * triggered\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.stop#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.stop()",
        "snippet": "    public boolean stop() {\n        for (EventState state : states) {\n            if (state.stop()) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "begin_line": 214,
        "end_line": 221,
        "comment": " Check if the integration should be stopped at the end of the\n     * current step.\n     * @return true if the integration should be stopped\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverImpl.setResult#140",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.setResult(double, int)",
        "snippet": "    protected final void setResult(final double newResult, final int iterationCount) {\n        this.result         = newResult;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }\n",
        "begin_line": 140,
        "end_line": 144,
        "comment": "\n     * Convenience function for implementations.\n     *\n     * @param newResult the result to set\n     * @param iterationCount the iteration count to set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.solve#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(org.apache.commons.math.analysis.UnivariateRealFunction, double, double)",
        "snippet": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max)\n        throws MaxIterationsExceededException,\n        FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"function values at endpoints do not have different signs.  \" +\n                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n                        min, max, yMin, yMax);\n            }\n        } else if (sign < 0){\n            // solve using only the first endpoint as initial guess\n            ret = solve(f, min, yMin, max, yMax, min, yMin);\n        } else {\n            // either min or max is a root\n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }\n",
        "begin_line": 153,
        "end_line": 196,
        "comment": "\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1601
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.value#215",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.Anonymous-8ec853b9-faf5-4925-8372-6104dc4474ed.value(double)",
        "snippet": "                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n",
        "begin_line": 215,
        "end_line": 224,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverImpl.UnivariateRealSolverImpl#91",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.UnivariateRealSolverImpl(int, double)",
        "snippet": "    protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n                                       final double defaultAbsoluteAccuracy) {\n        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n        this.defaultFunctionValueAccuracy = 1.0e-15;\n        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n    }\n",
        "begin_line": 91,
        "end_line": 96,
        "comment": "\n     * Construct a solver with given iteration count and accuracy.\n     *\n     * @param defaultAbsoluteAccuracy maximum absolute error\n     * @param defaultMaximalIterationCount maximum number of iterations\n     * @throws IllegalArgumentException if f is null or the\n     * defaultAbsoluteAccuracy is not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverImpl.clearResult#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.clearResult()",
        "snippet": "    protected final void clearResult() {\n        this.iterationCount = 0;\n        this.resultComputed = false;\n    }\n",
        "begin_line": 164,
        "end_line": 167,
        "comment": "\n     * Convenience function for implementations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverImpl.verifyInterval#207",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifyInterval(double, double)",
        "snippet": "    protected void verifyInterval(final double lower, final double upper) {\n        if (lower >= upper) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"endpoints do not specify an interval: [{0}, {1}]\",\n                    lower, upper);\n        }\n    }\n",
        "begin_line": 207,
        "end_line": 213,
        "comment": "\n     * Verifies that the endpoints specify an interval,\n     * throws IllegalArgumentException if not\n     *\n     * @param lower  lower endpoint\n     * @param upper upper endpoint\n     * @throws IllegalArgumentException\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.BrentSolver#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.BrentSolver()",
        "snippet": "    public BrentSolver() {\n        super(100, 1E-6);\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Construct a solver.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int, double)",
        "snippet": "    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }\n",
        "begin_line": 60,
        "end_line": 69,
        "comment": "\n     * Construct an algorithm with given iteration count and accuracy.\n     *\n     * @param defaultAbsoluteAccuracy maximum absolute error\n     * @param defaultMaximalIterationCount maximum number of iterations\n     * @throws IllegalArgumentException if f is null or the\n     * defaultAbsoluteAccuracy is not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
        "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }\n",
        "begin_line": 77,
        "end_line": 79,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the absolute accuracy.\n     * <p>\n     * The default is usually chosen so that results in the interval\n     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n     * expected absolute value of your results is of much smaller magnitude, set\n     * this to a smaller value.</p>\n     * <p>\n     * Algorithms are advised to do a plausibility check with the relative\n     * accuracy, but clients should not rely on this.</p>\n     *\n     * @param accuracy the accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     * the solver or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.setMaximalIterationCount#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
        "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the upper limit for the number of iterations.\n     * <p>\n     * Usually a high iteration count indicates convergence problems. However,\n     * the \"reasonable value\" varies widely for different algorithms. Users are\n     * advised to use the default value supplied by the algorithm.</p>\n     * <p>\n     * A {@link ConvergenceException} will be thrown if this number\n     * is exceeded.</p>\n     *\n     * @param count maximum number of iterations\n     "
        },
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.integrate#191",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale;\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // rejecting the step would lead to a too small next step, we accept it\n                  loop = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
        "begin_line": 191,
        "end_line": 359,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": " Perform some sanity checks on the integration parameters.\n   * @param equations differential equations set\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param t target time for the integration\n   * @param y placeholder where to put the state vector\n   * @exception IntegratorException if some inconsistency is detected\n   "
        },
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.reinitializeBegin#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.reinitializeBegin(double, double[])",
        "snippet": "    public void reinitializeBegin(final double tStart, final double[] yStart)\n        throws EventException {\n        t0 = tStart;\n        g0 = handler.g(tStart, yStart);\n        g0Positive = g0 >= 0;\n    }\n",
        "begin_line": 149,
        "end_line": 154,
        "comment": " Reinitialize the beginning of the step.\n     * @param tStart value of the independent <i>time</i> variable at the\n     * beginning of the step\n     * @param yStart array containing the current value of the state vector\n     * at the beginning of the step\n     * @exception EventException if the event handler\n     * value cannot be evaluated at the beginning of the step\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.stop#314",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.stop()",
        "snippet": "    public boolean stop() {\n        return nextAction == EventHandler.STOP;\n    }\n",
        "begin_line": 314,
        "end_line": 316,
        "comment": " Check if the integration should be stopped at the end of the\n     * current step.\n     * @return true if the integration should be stopped\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.reset#327",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.reset(double, double[])",
        "snippet": "    public boolean reset(final double t, final double[] y)\n        throws EventException {\n\n        if (! pendingEvent) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.RESET_STATE) ||\n               (nextAction == EventHandler.RESET_DERIVATIVES);\n\n    }\n",
        "begin_line": 327,
        "end_line": 343,
        "comment": " Let the event handler reset the state if it wants.\n     * @param t value of the independent <i>time</i> variable at the\n     * beginning of the next step\n     * @param y array were to put the desired state vector at the beginning\n     * of the next step\n     * @return true if the integrator should reset the derivatives too\n     * @exception EventException if the state cannot be reseted by the event\n     * handler\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.stepAccepted#199",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.stepAccepted(double, double[])",
        "snippet": "    public void stepAccepted(final double t, final double[] y)\n    throws IntegratorException {\n        try {\n            for (EventState state : states) {\n                state.stepAccepted(t, y);\n            }\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        }\n    }\n",
        "begin_line": 199,
        "end_line": 208,
        "comment": " Inform the event handlers that the step has been accepted\n     * by the integrator.\n     * @param t value of the independent <i>time</i> variable at the\n     * end of the step\n     * @param y array containing the current value of the state vector\n     * at the end of the step\n     * @exception IntegratorException if the value of one of the\n     * events states cannot be evaluated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.reset#232",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.reset(double, double[])",
        "snippet": "    public boolean reset(final double t, final double[] y)\n        throws IntegratorException {\n        try {\n            boolean resetDerivatives = false;\n            for (EventState state : states) {\n                if (state.reset(t, y)) {\n                    resetDerivatives = true;\n                }\n            }\n            return resetDerivatives;\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        }\n    }\n",
        "begin_line": 232,
        "end_line": 245,
        "comment": " Let the event handlers reset the state if they want.\n     * @param t value of the independent <i>time</i> variable at the\n     * beginning of the next step\n     * @param y array were to put the desired state vector at the beginning\n     * of the next step\n     * @return true if the integrator should reset the derivatives too\n     * @exception IntegratorException if one of the events states\n     * that should reset the state fails to do it\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.g#266",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.EndTimeChecker.g(double, double[])",
        "snippet": "        public double g(double t, double[] y) {\n            return t - endTime;\n        }\n",
        "begin_line": 266,
        "end_line": 268,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.events.EventHandler": " Compute the value of the switching function.\n\n   * <p>The discrete events are generated when the sign of this\n   * switching function changes. The integrator will take care to change\n   * the stepsize in such a way these events occur exactly at step boundaries.\n   * The switching function must be continuous in its roots neighborhood\n   * (but not necessarily smooth), as the integrator will need to find its\n   * roots to locate precisely the events.</p>\n\n   * @param t current value of the independent <i>time</i> variable\n   * @param y array containing the current value of the state vector\n   * @return value of the g switching function\n   * @exception EventException if the switching function cannot be evaluated\n   ",
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.requiresDenseOutput#122",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.requiresDenseOutput()",
        "snippet": "    protected boolean requiresDenseOutput() {\n        for (StepHandler handler : stepHandlers) {\n            if (handler.requiresDenseOutput()) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
        "begin_line": 122,
        "end_line": 129,
        "comment": " Check if one of the step handlers requires dense output.\n     * @return true if one of the step handlers requires dense output\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator(org.apache.commons.math.ode.sampling.AbstractStepInterpolator)",
        "snippet": "  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\n    previousTime      = interpolator.previousTime;\n    currentTime       = interpolator.currentTime;\n    h                 = interpolator.h;\n    interpolatedTime  = interpolator.interpolatedTime;\n\n    if (interpolator.currentState != null) {\n      currentState            = interpolator.currentState.clone();\n      interpolatedState       = interpolator.interpolatedState.clone();\n      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n    } else {\n      currentState            = null;\n      interpolatedState       = null;\n      interpolatedDerivatives = null;\n    }\n\n    finalized  = interpolator.finalized;\n    forward    = interpolator.forward;\n    dirtyState = interpolator.dirtyState;\n\n  }\n",
        "begin_line": 141,
        "end_line": 162,
        "comment": " Copy constructor.\n\n   * <p>The copied interpolator should have been finalized before the\n   * copy, otherwise the copy will not be able to perform correctly\n   * any derivative computation and will throw a {@link\n   * NullPointerException} later. Since we don't want this constructor\n   * to throw the exceptions finalization may involve and since we\n   * don't want this method to modify the state of the copied\n   * interpolator, finalization is <strong>not</strong> done\n   * automatically, it remains under user control.</p>\n\n   * <p>The copy is a deep copy: its arrays are separated from the\n   * original arrays of the instance.</p>\n\n   * @param interpolator interpolator to copy from.\n\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.reinitialize#169",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.reinitialize(double[], boolean)",
        "snippet": "  protected void reinitialize(final double[] y, final boolean isForward) {\n\n    previousTime      = Double.NaN;\n    currentTime       = Double.NaN;\n    h                 = Double.NaN;\n    interpolatedTime  = Double.NaN;\n\n    currentState            = y;\n    interpolatedState       = new double[y.length];\n    interpolatedDerivatives = new double[y.length];\n\n    finalized         = false;\n    this.forward      = isForward;\n    this.dirtyState   = true;\n\n  }\n",
        "begin_line": 169,
        "end_line": 184,
        "comment": " Reinitialize the instance\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param isForward integration direction indicator\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getPreviousTime#229",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getPreviousTime()",
        "snippet": "  public double getPreviousTime() {\n    return previousTime;\n  }\n",
        "begin_line": 229,
        "end_line": 231,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the previous grid point time.\n   * @return previous grid point time\n   "
        },
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getCurrentTime#234",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getCurrentTime()",
        "snippet": "  public double getCurrentTime() {\n    return currentTime;\n  }\n",
        "begin_line": 234,
        "end_line": 236,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the current grid point time.\n   * @return current grid point time\n   "
        },
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.isForward#250",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.isForward()",
        "snippet": "  public boolean isForward() {\n    return forward;\n  }\n",
        "begin_line": 250,
        "end_line": 252,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": " Check if the natural integration direction is forward.\n   * <p>This method provides the integration direction as specified by\n   * the integrator itself, it avoid some nasty problems in\n   * degenerated cases like null steps due to cancellation at step\n   * initialization, step control or discrete events\n   * triggering.</p>\n   * @return true if the integration variable (time) increases during\n   * integration\n   "
        },
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getInterpolatedState#269",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedState()",
        "snippet": "  public double[] getInterpolatedState() throws DerivativeException {\n\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = currentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n\n      return interpolatedState;\n\n  }\n",
        "begin_line": 269,
        "end_line": 281,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the state vector of the interpolated point.\n   * <p>The returned vector is a reference to a reused array, so\n   * it should not be modified and it should be copied if it needs\n   * to be preserved across several calls.</p>\n   * @return state vector at time {@link #getInterpolatedTime}\n   * @see #getInterpolatedDerivatives()\n   * @throws DerivativeException if this call induces an automatic\n   * step finalization that throws one\n   "
        },
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator(org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator)",
        "snippet": "  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState != null) {\n      final int dimension = currentState.length;\n\n      yDotK = new double[interpolator.yDotK.length][];\n      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n        yDotK[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotK[k], 0,\n                         yDotK[k], 0, dimension);\n      }\n\n    } else {\n      yDotK = null;\n    }\n\n    // we cannot keep any reference to the equations in the copy\n    // the interpolator should have been finalized before\n    integrator = null;\n\n  }\n",
        "begin_line": 79,
        "end_line": 101,
        "comment": " Copy constructor.\n\n  * <p>The copied interpolator should have been finalized before the\n  * copy, otherwise the copy will not be able to perform correctly any\n  * interpolation and will throw a {@link NullPointerException}\n  * later. Since we don't want this constructor to throw the\n  * exceptions finalization may involve and since we don't want this\n  * method to modify the state of the copied interpolator,\n  * finalization is <strong>not</strong> done automatically, it\n  * remains under user control.</p>\n\n  * <p>The copy is a deep copy: its arrays are separated from the\n  * original arrays of the instance.</p>\n\n  * @param interpolator interpolator to copy from.\n\n  ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.reinitialize#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean)",
        "snippet": "  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward) {\n    reinitialize(y, forward);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
        "begin_line": 124,
        "end_line": 129,
        "comment": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1508
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.copy#187",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.copy()",
        "snippet": "   public StepInterpolator copy() throws DerivativeException {\n\n     // finalize the step before performing copy\n     finalizeStep();\n\n     // create the new independent instance\n     return doCopy();\n\n   }\n",
        "begin_line": 187,
        "end_line": 195,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": " Copy the instance.\n   * <p>The copied instance is guaranteed to be independent from the\n   * original one. Both can be used with different settings for\n   * interpolated time without any side effect.</p>\n   * @return a deep copy of the instance, which can be used independently.\n   * @throws DerivativeException if this call induces an automatic\n   * step finalization that throws one\n   * @see #setInterpolatedTime(double)\n   "
        },
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.finalizeStep#339",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.finalizeStep()",
        "snippet": "  public final void finalizeStep()\n    throws DerivativeException {\n    if (! finalized) {\n      doFinalize();\n      finalized = true;\n    }\n  }\n",
        "begin_line": 339,
        "end_line": 345,
        "comment": "\n   * Finalize the step.\n\n   * <p>Some embedded Runge-Kutta integrators need fewer functions\n   * evaluations than their counterpart step interpolators. These\n   * interpolators should perform the last evaluations they need by\n   * themselves only if they need them. This method triggers these\n   * extra evaluations. It can be called directly by the user step\n   * handler and it is called automatically if {@link\n   * #setInterpolatedTime} is called.</p>\n\n   * <p>Once this method has been called, <strong>no</strong> other\n   * evaluation will be performed on this step. If there is a need to\n   * have some side effects between the step handler and the\n   * differential equations (for example update some data in the\n   * equations once the step has been done), it is advised to call\n   * this method explicitly from the step handler before these side\n   * effects are set up. If the step handler induces no side effect,\n   * then this method can safely be ignored, it will be called\n   * transparently as needed.</p>\n\n   * <p><strong>Warning</strong>: since the step interpolator provided\n   * to the step handler as a parameter of the {@link\n   * StepHandler#handleStep handleStep} is valid only for the duration\n   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n   * simply store a reference and reuse it later. One should first\n   * finalize the instance, then copy this finalized instance into a\n   * new object that can be kept.</p>\n\n   * <p>This method calls the protected <code>doFinalize</code> method\n   * if it has never been called during this step and set a flag\n   * indicating that it has been called once. It is the <code>\n   * doFinalize</code> method which should perform the evaluations.\n   * This wrapping prevents from calling <code>doFinalize</code> several\n   * times and hence evaluating the differential equations too often.\n   * Therefore, subclasses are not allowed not reimplement it, they\n   * should rather reimplement <code>doFinalize</code>.</p>\n\n   * @throws DerivativeException this exception is propagated to the\n   * caller if the underlying user function triggers one\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.initializeStep#203",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.initializeStep(org.apache.commons.math.ode.FirstOrderDifferentialEquations, boolean, int, double[], double, double[], double[], double[], double[])",
        "snippet": "  public double initializeStep(final FirstOrderDifferentialEquations equations,\n                               final boolean forward, final int order, final double[] scale,\n                               final double t0, final double[] y0, final double[] yDot0,\n                               final double[] y1, final double[] yDot1)\n      throws DerivativeException {\n\n    if (initialStep > 0) {\n      // use the user provided value\n      return forward ? initialStep : -initialStep;\n    }\n\n    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n    // this guess will be used to perform an Euler step\n    double ratio;\n    double yOnScale2 = 0;\n    double yDotOnScale2 = 0;\n    for (int j = 0; j < y0.length; ++j) {\n      ratio         = y0[j] / scale[j];\n      yOnScale2    += ratio * ratio;\n      ratio         = yDot0[j] / scale[j];\n      yDotOnScale2 += ratio * ratio;\n    }\n\n    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n    if (! forward) {\n      h = -h;\n    }\n\n    // perform an Euler step using the preceding rough guess\n    for (int j = 0; j < y0.length; ++j) {\n      y1[j] = y0[j] + h * yDot0[j];\n    }\n    computeDerivatives(t0 + h, y1, yDot1);\n\n    // estimate the second derivative of the solution\n    double yDDotOnScale = 0;\n    for (int j = 0; j < y0.length; ++j) {\n      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n      yDDotOnScale += ratio * ratio;\n    }\n    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n\n    // step size is computed such that\n    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n    final double h1 = (maxInv2 < 1.0e-15) ?\n                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n                      Math.pow(0.01 / maxInv2, 1.0 / order);\n    h = Math.min(100.0 * Math.abs(h), h1);\n    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n    if (h < getMinStep()) {\n      h = getMinStep();\n    }\n    if (h > getMaxStep()) {\n      h = getMaxStep();\n    }\n    if (! forward) {\n      h = -h;\n    }\n\n    return h;\n\n  }\n",
        "begin_line": 203,
        "end_line": 266,
        "comment": " Initialize the integration step.\n   * @param equations differential equations set\n   * @param forward forward integration indicator\n   * @param order order of the method\n   * @param scale scaling vector for the state vector\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param yDot0 first time derivative of y0\n   * @param y1 work array for a state vector\n   * @param yDot1 work array for the first time derivative of y1\n   * @return first integration step\n   * @exception DerivativeException this exception is propagated to\n   * the caller if the underlying user function triggers one\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.getMinStep#322",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMinStep()",
        "snippet": "  public double getMinStep() {\n    return minStep;\n  }\n",
        "begin_line": 322,
        "end_line": 324,
        "comment": " Get the minimal step.\n   * @return minimal step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.getMaxStep#329",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMaxStep()",
        "snippet": "  public double getMaxStep() {\n    return maxStep;\n  }\n",
        "begin_line": 329,
        "end_line": 331,
        "comment": " Get the maximal step.\n   * @return maximal step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.addStepHandler#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.addStepHandler(org.apache.commons.math.ode.sampling.StepHandler)",
        "snippet": "    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Add a step handler to this integrator.\n     * <p>The handler will be called by the integrator for each accepted\n     * step.</p>\n     * @param handler handler for the accepted steps\n     * @see #getStepHandlers()\n     * @see #clearStepHandlers()\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.computeDerivatives#177",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.computeDerivatives(double, double[], double[])",
        "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws DerivativeException {\n        if (++evaluations > maxEvaluations) {\n            throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n        }\n        equations.computeDerivatives(t, y, yDot);\n    }\n",
        "begin_line": 177,
        "end_line": 183,
        "comment": " Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @throws DerivativeException this exception is propagated to the caller if the\n     * underlying user function triggers one\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator(java.lang.String, boolean, double[], double[][], double[], org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator, double, double, double, double)",
        "snippet": "  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n",
        "begin_line": 109,
        "end_line": 131,
        "comment": " Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator#88",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator(java.lang.String, double, double, double, double)",
        "snippet": "  public AdaptiveStepsizeIntegrator(final String name,\n                                    final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n\n    super(name);\n\n    this.minStep     = Math.abs(minStep);\n    this.maxStep     = Math.abs(maxStep);\n    this.initialStep = -1.0;\n\n    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n    this.scalRelativeTolerance = scalRelativeTolerance;\n    this.vecAbsoluteTolerance  = null;\n    this.vecRelativeTolerance  = null;\n\n    resetInternalState();\n\n  }\n",
        "begin_line": 88,
        "end_line": 106,
        "comment": " Build an integrator with the given stepsize bounds.\n   * The default step handler does nothing.\n   * @param name name of the method\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.sanityChecks#165",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.sanityChecks(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "  @Override\n  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n                              final double t0, final double[] y0,\n                              final double t, final double[] y)\n      throws IntegratorException {\n\n      super.sanityChecks(equations, t0, y0, t, y);\n\n      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n          throw new IntegratorException(\n                  \"dimensions mismatch: state vector has dimension {0},\" +\n                  \" absolute tolerance vector has dimension {1}\",\n                  y0.length, vecAbsoluteTolerance.length);\n      }\n\n      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n          throw new IntegratorException(\n                  \"dimensions mismatch: state vector has dimension {0},\" +\n                  \" relative tolerance vector has dimension {1}\",\n                  y0.length, vecRelativeTolerance.length);\n      }\n\n  }\n",
        "begin_line": 165,
        "end_line": 187,
        "comment": " Perform some sanity checks on the integration parameters.\n   * @param equations differential equations set\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param t target time for the integration\n   * @param y placeholder where to put the state vector\n   * @exception IntegratorException if some inconsistency is detected\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.EventState#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.EventState(org.apache.commons.math.ode.events.EventHandler, double, double, int)",
        "snippet": "    public EventState(final EventHandler handler, final double maxCheckInterval,\n                      final double convergence, final int maxIterationCount) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = Math.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n\n        // some dummy values ...\n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.CONTINUE;\n\n    }\n",
        "begin_line": 94,
        "end_line": 111,
        "comment": " Simple constructor.\n     * @param handler event handler\n     * @param maxCheckInterval maximal time interval between switching\n     * function checks (this interval prevents missing sign changes in\n     * case the integration steps becomes very large)\n     * @param convergence convergence threshold in the event time search\n     * @param maxIterationCount upper limit of the iteration count in\n     * the event time search\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.addEventHandler#69",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.addEventHandler(org.apache.commons.math.ode.events.EventHandler, double, double, int)",
        "snippet": "    public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\n                                final double convergence, final int maxIterationCount) {\n        states.add(new EventState(handler, maxCheckInterval,\n                                  convergence, maxIterationCount));\n    }\n",
        "begin_line": 69,
        "end_line": 73,
        "comment": " Add an events handler.\n     * @param handler event handler\n     * @param maxCheckInterval maximal time interval between events\n     * checks (this interval prevents missing sign changes in\n     * case the integration steps becomes very large)\n     * @param convergence convergence threshold in the event time search\n     * @param maxIterationCount upper limit of the iteration count in\n     * the event time search\n     * @see #getEventsHandlers()\n     * @see #clearEventsHandlers()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.getEventsStates#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.getEventsStates()",
        "snippet": "    public Collection<EventState> getEventsStates() {\n        return states;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": " Get all the events state wrapping the handlers that have been added to the manager.\n     * @return a collection of the events states\n     * @see #getEventsHandlers()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.EndTimeChecker#256",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.EndTimeChecker.EndTimeChecker(double)",
        "snippet": "        public EndTimeChecker(final double endTime) {\n            this.endTime = endTime;\n        }\n",
        "begin_line": 256,
        "end_line": 258,
        "comment": " Build an instance.\n         * @param endTime desired time\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setEquations#166",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setEquations(org.apache.commons.math.ode.FirstOrderDifferentialEquations)",
        "snippet": "    protected void setEquations(final FirstOrderDifferentialEquations equations) {\n        this.equations = equations;\n    }\n",
        "begin_line": 166,
        "end_line": 168,
        "comment": " Set the differential equations.\n     * @param equations differential equations to integrate\n     * @see #computeDerivatives(double, double[], double[])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.addEndTimeChecker#230",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.addEndTimeChecker(double, double, org.apache.commons.math.ode.events.CombinedEventsManager)",
        "snippet": "    protected CombinedEventsManager addEndTimeChecker(final double startTime,\n                                                      final double endTime,\n                                                      final CombinedEventsManager manager) {\n        CombinedEventsManager newManager = new CombinedEventsManager();\n        for (final EventState state : manager.getEventsStates()) {\n            newManager.addEventHandler(state.getEventHandler(),\n                                       state.getMaxCheckInterval(),\n                                       state.getConvergence(),\n                                       state.getMaxIterationCount());\n        }\n        newManager.addEventHandler(new EndTimeChecker(endTime),\n                                   Double.POSITIVE_INFINITY,\n                                   Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n                                   100);\n        return newManager;\n    }\n",
        "begin_line": 230,
        "end_line": 245,
        "comment": " Add an event handler for end time checking.\n     * <p>This method can be used to simplify handling of integration end time.\n     * It leverages the nominal stop condition with the exceptional stop\n     * conditions.</p>\n     * @param startTime integration start time\n     * @param endTime desired end time\n     * @param manager manager containing the user-defined handlers\n     * @return a new manager containing all the user-defined handlers plus a\n     * dedicated manager triggering a stop event at entTime\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.shift#210",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.shift()",
        "snippet": "  public void shift() {\n    previousTime = currentTime;\n  }\n",
        "begin_line": 210,
        "end_line": 212,
        "comment": " Shift one step forward.\n   * Copy the current time into the previous time, hence preparing the\n   * interpolator for future calls to {@link #storeTime storeTime}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.storeTime#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.storeTime(double)",
        "snippet": "  public void storeTime(final double t) {\n\n    currentTime = t;\n    h           = currentTime - previousTime;\n    setInterpolatedTime(t);\n\n    // the step is not finalized anymore\n    finalized  = false;\n\n  }\n",
        "begin_line": 217,
        "end_line": 226,
        "comment": " Store the current step time.\n   * @param t current time\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.setInterpolatedTime#244",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setInterpolatedTime(double)",
        "snippet": "  public void setInterpolatedTime(final double time) {\n      interpolatedTime = time;\n      dirtyState       = true;\n  }\n",
        "begin_line": 244,
        "end_line": 247,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Set the time of the interpolated point.\n   * <p>Setting the time outside of the current step is now allowed, but\n   * should be used with care since the accuracy of the interpolator will\n   * probably be very poor far from this step. This allowance has been\n   * added to simplify implementation of search algorithms near the\n   * step endpoints.</p>\n   * <p>Setting the time changes the instance internal state. If a\n   * specific state must be preserved, a copy of the instance must be\n   * created using {@link #copy()}.</p>\n   * @param time time of the interpolated point\n   "
        },
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.sanityChecks#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.sanityChecks(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "    protected void sanityChecks(final FirstOrderDifferentialEquations ode,\n                                final double t0, final double[] y0,\n                                final double t, final double[] y)\n        throws IntegratorException {\n\n        if (ode.getDimension() != y0.length) {\n            throw new IntegratorException(\n                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n                    \" initial state vector has dimension {1}\",\n                    ode.getDimension(), y0.length);\n        }\n\n        if (ode.getDimension() != y.length) {\n            throw new IntegratorException(\n                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n                    \" final state vector has dimension {1}\",\n                    ode.getDimension(), y.length);\n        }\n\n        if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n            throw new IntegratorException(\n                    \"too small integration interval: length = {0}\",\n                    Math.abs(t - t0));\n        }\n\n    }\n",
        "begin_line": 193,
        "end_line": 218,
        "comment": " Perform some sanity checks on the integration parameters.\n     * @param ode differential equations set\n     * @param t0 start time\n     * @param y0 state vector at t0\n     * @param t target time for the integration\n     * @param y placeholder where to put the state vector\n     * @exception IntegratorException if some inconsistency is detected\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#89",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator()",
        "snippet": "  protected AbstractStepInterpolator() {\n    previousTime            = Double.NaN;\n    currentTime             = Double.NaN;\n    h                       = Double.NaN;\n    interpolatedTime        = Double.NaN;\n    currentState            = null;\n    interpolatedState       = null;\n    interpolatedDerivatives = null;\n    finalized               = false;\n    this.forward            = true;\n    this.dirtyState         = true;\n  }\n",
        "begin_line": 89,
        "end_line": 100,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. As an example, the {@link\n   * org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator}\n   * class uses the prototyping design pattern to create the step\n   * interpolators by cloning an uninitialized model and latter\n   * initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator()",
        "snippet": "  protected RungeKuttaStepInterpolator() {\n    super();\n    yDotK      = null;\n    integrator = null;\n  }\n",
        "begin_line": 56,
        "end_line": 60,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n   * pattern to create the step interpolators by cloning an\n   * uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setSafety#186",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setSafety(double)",
        "snippet": "  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n",
        "begin_line": 186,
        "end_line": 188,
        "comment": " Set the safety factor for stepsize control.\n   * @param safety safety factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMinReduction#371",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMinReduction(double)",
        "snippet": "  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n",
        "begin_line": 371,
        "end_line": 373,
        "comment": " Set the minimal reduction factor for stepsize control.\n   * @param minReduction minimal reduction factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMaxGrowth#385",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMaxGrowth(double)",
        "snippet": "  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n",
        "begin_line": 385,
        "end_line": 387,
        "comment": " Set the maximal growth factor for stepsize control.\n   * @param maxGrowth maximal growth factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.resetInternalState#314",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.resetInternalState()",
        "snippet": "  protected void resetInternalState() {\n    stepStart = Double.NaN;\n    stepSize  = Math.sqrt(minStep * maxStep);\n  }\n",
        "begin_line": 314,
        "end_line": 317,
        "comment": " Reset internal state to dummy values. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "CombinedEventsManager.CombinedEventsManager#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java",
        "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
        "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.CombinedEventsManager()",
        "snippet": "    public CombinedEventsManager() {\n        states      = new ArrayList<EventState>();\n        first       = null;\n        initialized = false;\n    }\n",
        "begin_line": 52,
        "end_line": 56,
        "comment": " Simple constructor.\n     * Create an empty manager\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.AbstractIntegrator#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.AbstractIntegrator(java.lang.String)",
        "snippet": "    public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsHandlersManager = new CombinedEventsManager();\n        setMaxEvaluations(-1);\n        resetEvaluations();\n    }\n",
        "begin_line": 64,
        "end_line": 72,
        "comment": " Build an instance.\n     * @param name name of the method\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setMaxEvaluations#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n    }\n",
        "begin_line": 142,
        "end_line": 144,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Set the maximal number of differential equations function evaluations.\n     * <p>The purpose of this method is to avoid infinite loops which can occur\n     * for example when stringent error constraints are set or when lots of\n     * discrete events are triggered, thus leading to many rejected steps.</p>\n     * @param maxEvaluations maximal number of function evaluations (negative\n     * values are silently converted to maximal integer value, thus representing\n     * almost unlimited evaluations)\n     "
        },
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.resetEvaluations#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.resetEvaluations()",
        "snippet": "    protected void resetEvaluations() {\n        evaluations = 0;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": " Reset the number of evaluations to zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    }
]