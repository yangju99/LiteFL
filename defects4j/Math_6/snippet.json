[
    {
        "name": "BaseOptimizer.getIterations#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.getIterations()",
        "snippet": "    public int getIterations() {\n        return iterations.getCount();\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n     * Gets the number of iterations performed by the algorithm.\n     * The number iterations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 28
    },
    {
        "name": "CMAESOptimizer.doOptimize#367",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }\n",
        "begin_line": 367,
        "end_line": 515,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7559
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.diag#1101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.diag(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }\n",
        "begin_line": 1101,
        "end_line": 1115,
        "comment": "\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7319
        },
        "num_failing_tests": 16
    },
    {
        "name": "TriDiagonalTransformer.getQT#97",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQT()",
        "snippet": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    double beta = 1.0 / secondary[k - 1];\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }\n",
        "begin_line": 97,
        "end_line": 132,
        "comment": "\n     * Returns the transpose of the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7319
        },
        "num_failing_tests": 15
    },
    {
        "name": "TriDiagonalTransformer.transform#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.transform()",
        "snippet": "    private void transform() {\n        final int m = householderVectors.length;\n        final double[] z = new double[m];\n        for (int k = 0; k < m - 1; k++) {\n\n            //zero-out a row and a column simultaneously\n            final double[] hK = householderVectors[k];\n            main[k] = hK[k];\n            double xNormSqr = 0;\n            for (int j = k + 1; j < m; ++j) {\n                final double c = hK[j];\n                xNormSqr += c * c;\n            }\n            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n            secondary[k] = a;\n            if (a != 0.0) {\n                // apply Householder transform from left and right simultaneously\n\n                hK[k + 1] -= a;\n                final double beta = -1 / (a * hK[k + 1]);\n\n                // compute a = beta A v, where v is the Householder vector\n                // this loop is written in such a way\n                //   1) only the upper triangular part of the matrix is accessed\n                //   2) access is cache-friendly for a matrix stored in rows\n                Arrays.fill(z, k + 1, m, 0);\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    final double hKI = hK[i];\n                    double zI = hI[i] * hKI;\n                    for (int j = i + 1; j < m; ++j) {\n                        final double hIJ = hI[j];\n                        zI   += hIJ * hK[j];\n                        z[j] += hIJ * hKI;\n                    }\n                    z[i] = beta * (z[i] + zI);\n                }\n\n                // compute gamma = beta vT z / 2\n                double gamma = 0;\n                for (int i = k + 1; i < m; ++i) {\n                    gamma += z[i] * hK[i];\n                }\n                gamma *= beta / 2;\n\n                // compute z = z - gamma v\n                for (int i = k + 1; i < m; ++i) {\n                    z[i] -= gamma * hK[i];\n                }\n\n                // update matrix: A = A - v zT - z vT\n                // only the upper triangular part of the matrix is updated\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    for (int j = i; j < m; ++j) {\n                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                    }\n                }\n            }\n        }\n        main[m - 1] = householderVectors[m - 1][m - 1];\n    }\n",
        "begin_line": 192,
        "end_line": 253,
        "comment": "\n     * Transform original matrix to tridiagonal form.\n     * <p>Transformation is done using Householder transforms.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7319
        },
        "num_failing_tests": 15
    },
    {
        "name": "MatrixUtils.isSymmetricInternal#387",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetricInternal(org.apache.commons.math3.linear.RealMatrix, double, boolean)",
        "snippet": "    private static boolean isSymmetricInternal(RealMatrix matrix,\n                                               double relativeTolerance,\n                                               boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        if (rows != matrix.getColumnDimension()) {\n            if (raiseException) {\n                throw new NonSquareMatrixException(rows, matrix.getColumnDimension());\n            } else {\n                return false;\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = i + 1; j < rows; j++) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * relativeTolerance) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, relativeTolerance);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n",
        "begin_line": 387,
        "end_line": 413,
        "comment": "\n     * Checks whether a matrix is symmetric, within a given relative tolerance.\n     *\n     * @param matrix Matrix to check.\n     * @param relativeTolerance Tolerance of the symmetry check.\n     * @param raiseException If {@code true}, an exception will be raised if\n     * the matrix is not symmetric.\n     * @return {@code true} if {@code matrix} is symmetric.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7319
        },
        "num_failing_tests": 15
    },
    {
        "name": "EigenDecomposition.findEigenVectors#572",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.findEigenVectors(double[][])",
        "snippet": "    private void findEigenVectors(final double[][] householderMatrix) {\n        final double[][]z = householderMatrix.clone();\n        final int n = main.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        final double[] e = new double[n];\n        for (int i = 0; i < n - 1; i++) {\n            realEigenvalues[i] = main[i];\n            e[i] = secondary[i];\n        }\n        realEigenvalues[n - 1] = main[n - 1];\n        e[n - 1] = 0;\n\n        // Determine the largest main and secondary value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n            }\n            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(e[i]);\n            }\n        }\n        // Make null any main and secondary value too small to be significant\n        if (maxAbsoluteValue != 0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    e[i]=0;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            int its = 0;\n            int m;\n            do {\n                for (m = j; m < n - 1; m++) {\n                    double delta = FastMath.abs(realEigenvalues[m]) +\n                        FastMath.abs(realEigenvalues[m + 1]);\n                    if (FastMath.abs(e[m]) + delta == delta) {\n                        break;\n                    }\n                }\n                if (m != j) {\n                    if (its == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    its++;\n                    double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                    double t = FastMath.sqrt(1 + q * q);\n                    if (q < 0.0) {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                    } else {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n                    }\n                    double u = 0.0;\n                    double s = 1.0;\n                    double c = 1.0;\n                    int i;\n                    for (i = m - 1; i >= j; i--) {\n                        double p = s * e[i];\n                        double h = c * e[i];\n                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                            c = q / p;\n                            t = FastMath.sqrt(c * c + 1.0);\n                            e[i + 1] = p * t;\n                            s = 1.0 / t;\n                            c = c * s;\n                        } else {\n                            s = p / q;\n                            t = FastMath.sqrt(s * s + 1.0);\n                            e[i + 1] = q * t;\n                            c = 1.0 / t;\n                            s = s * c;\n                        }\n                        if (e[i + 1] == 0.0) {\n                            realEigenvalues[i + 1] -= u;\n                            e[m] = 0.0;\n                            break;\n                        }\n                        q = realEigenvalues[i + 1] - u;\n                        t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n                        u = s * t;\n                        realEigenvalues[i + 1] = q + u;\n                        q = c * t - h;\n                        for (int ia = 0; ia < n; ia++) {\n                            p = z[ia][i + 1];\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\n                            z[ia][i] = c * z[ia][i] - s * p;\n                        }\n                    }\n                    if (t == 0.0 && i >= j) {\n                        continue;\n                    }\n                    realEigenvalues[j] -= u;\n                    e[j] = q;\n                    e[m] = 0.0;\n                }\n            } while (m != j);\n        }\n\n        //Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n            }\n        }\n        // Make null any eigen value too small to be significant\n        if (maxAbsoluteValue != 0.0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n            }\n        }\n        eigenvectors = new ArrayRealVector[n];\n        final double[] tmp = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tmp[j] = z[j][i];\n            }\n            eigenvectors[i] = new ArrayRealVector(tmp);\n        }\n    }\n",
        "begin_line": 572,
        "end_line": 721,
        "comment": "\n     * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\n     *\n     * @param householderMatrix Householder matrix of the transformation\n     * to tridiagonal form.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7319
        },
        "num_failing_tests": 15
    },
    {
        "name": "MathArrays.copyOf#761",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[], int)",
        "snippet": "    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n",
        "begin_line": 761,
        "end_line": 765,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "MersenneTwister.next#228",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.next(int)",
        "snippet": "    @Override\n    protected int next(int bits) {\n\n        int y;\n\n        if (mti >= N) { // generate N words at one time\n            int mtNext = mt[0];\n            for (int k = 0; k < N - M; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            for (int k = N - M; k < N - 1; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            y = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\n            mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\n\n            mti = 0;\n        }\n\n        y = mt[mti++];\n\n        // tempering\n        y ^=  y >>> 11;\n        y ^= (y <<   7) & 0x9d2c5680;\n        y ^= (y <<  15) & 0xefc60000;\n        y ^=  y >>> 18;\n\n        return y >>> (32 - bits);\n\n    }\n",
        "begin_line": 228,
        "end_line": 263,
        "comment": " Generate next pseudorandom number.\n     * <p>This method is the core generation algorithm. It is used by all the\n     * public generation methods for the various primitive types {@link\n     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n     * {@link #next(int)} and {@link #nextLong()}.</p>\n     * @param bits number of random bits to produce\n     * @return random bits generated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.FitnessFunction#892",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.FitnessFunction()",
        "snippet": "        public FitnessFunction() {\n            valueRange = 1;\n            isRepairMode = true;\n        }\n",
        "begin_line": 892,
        "end_line": 895,
        "comment": " Simple constructor.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.value#901",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.value(double[])",
        "snippet": "        public double value(final double[] point) {\n            double value;\n            if (isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n                    penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this.computeObjectiveValue(point);\n            }\n            return isMinimize ? value : -value;\n        }\n",
        "begin_line": 901,
        "end_line": 911,
        "comment": "\n         * @param point Normalized objective variables.\n         * @return the objective value + penalty for violated bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.setValueRange#935",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.setValueRange(double)",
        "snippet": "        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }\n",
        "begin_line": 935,
        "end_line": 937,
        "comment": "\n         * @param valueRange Adjusts the penalty computation.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.repair#943",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.repair(double[])",
        "snippet": "        private double[] repair(final double[] x) {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            final double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }\n",
        "begin_line": 943,
        "end_line": 958,
        "comment": "\n         * @param x Normalized objective variables.\n         * @return the repaired (i.e. all in bounds) objective variables.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.penalty#965",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.FitnessFunction.penalty(double[], double[])",
        "snippet": "        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }\n",
        "begin_line": 965,
        "end_line": 972,
        "comment": "\n         * @param x Normalized objective variables.\n         * @param repaired Repaired objective variables.\n         * @return Penalty value according to the violation of the bounds.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.DoubleIndex#843",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.DoubleIndex(double, int)",
        "snippet": "        DoubleIndex(double value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n",
        "begin_line": 843,
        "end_line": 846,
        "comment": "\n         * @param value Value to compare.\n         * @param index Index into sorted array.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.compareTo#849",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex.compareTo(org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.DoubleIndex)",
        "snippet": "        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }\n",
        "begin_line": 849,
        "end_line": 851,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.lang.Comparable": null,
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.parseOptimizationData#527",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof Sigma) {\n                inputSigma = ((Sigma) data).getSigma();\n                continue;\n            }\n            if (data instanceof PopulationSize) {\n                lambda = ((PopulationSize) data).getPopulationSize();\n                continue;\n            }\n        }\n\n        checkParameters();\n    }\n",
        "begin_line": 527,
        "end_line": 546,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Sigma}</li>\n     *  <li>{@link PopulationSize}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.checkParameters#551",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] > uB[i] - lB[i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, uB[i] - lB[i]);\n                }\n            }\n        }\n    }\n",
        "begin_line": 551,
        "end_line": 566,
        "comment": "\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.initializeCMA#573",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.initializeCMA(double[])",
        "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            throw new NotStrictlyPositiveException(lambda);\n        }\n        // initialize sigma\n        final double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            sigmaArray[i][0] = inputSigma[i];\n        }\n        final RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1 / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4 + mueff / dimension) /\n                (dimension + 4 + 2 * mueff / dimension);\n        cs = (mueff + 2) / (dimension + mueff + 3.);\n        damps = (1 + 2 * Math.max(0, Math.sqrt((mueff - 1) /\n                                               (dimension + 1)) - 1)) *\n            Math.max(0.3,\n                     1 - dimension / (1e-6 + maxIterations)) + cs; // minor increment\n        ccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /\n                          ((dimension + 2) * (dimension + 2) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);\n        chiN = Math.sqrt(dimension) *\n            (1 - 1 / ((double) 4 * dimension) + 1 / ((double) 21 * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables\n        diagD = insigma.scalarMultiply(1 / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3 * 10 * dimension / (double) lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }\n",
        "begin_line": 573,
        "end_line": 637,
        "comment": "\n     * Initialization of the dynamic search parameters\n     *\n     * @param guess Initial guess for the arguments of the fitness function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.updateEvolutionPaths#647",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateEvolutionPaths(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1 - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2 - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        final boolean hsig = normps /\n            Math.sqrt(1 - Math.pow(1 - cs, 2 * iterations)) /\n            chiN < 1.4 + 2 / ((double) dimension + 1);\n        pc = pc.scalarMultiply(1 - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(Math.sqrt(cc * (2 - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }\n",
        "begin_line": 647,
        "end_line": 660,
        "comment": "\n     * Update of the evolution paths ps and pc.\n     *\n     * @param zmean Weighted row matrix of the gaussian random numbers generating\n     * the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     * @return hsig flag indicating a small correction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.push#803",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.push(double[], double)",
        "snippet": "    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }\n",
        "begin_line": 803,
        "end_line": 808,
        "comment": "\n     * Pushes the current best fitness value in a history queue.\n     *\n     * @param vals History queue.\n     * @param val Current best fitness value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.sortedIndices#816",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sortedIndices(double[])",
        "snippet": "    private int[] sortedIndices(final double[] doubles) {\n        final DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }\n",
        "begin_line": 816,
        "end_line": 827,
        "comment": "\n     * Sorts fitness values.\n     *\n     * @param doubles Array of values to be sorted.\n     * @return a sorted array of indices pointing into doubles.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.log#981",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.log(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 981,
        "end_line": 989,
        "comment": "\n     * @param m Input matrix\n     * @return Matrix representing the element-wise logarithm of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.sqrt#995",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sqrt(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 995,
        "end_line": 1003,
        "comment": "\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square root of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.square#1009",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.square(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1009,
        "end_line": 1018,
        "comment": "\n     * @param m Input matrix.\n     * @return Matrix representing the element-wise square of m.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.times#1025",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.times(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1025,
        "end_line": 1033,
        "comment": "\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.selectColumns#1055",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.selectColumns(org.apache.commons.math3.linear.RealMatrix, int[])",
        "snippet": "    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1055,
        "end_line": 1063,
        "comment": "\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.copyColumn#1125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.copyColumn(org.apache.commons.math3.linear.RealMatrix, int, org.apache.commons.math3.linear.RealMatrix, int)",
        "snippet": "    private static void copyColumn(final RealMatrix m1, int col1,\n                                   RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }\n",
        "begin_line": 1125,
        "end_line": 1130,
        "comment": "\n     * Copies a column from m1 to m2.\n     *\n     * @param m1 Source matrix.\n     * @param col1 Source column.\n     * @param m2 Target matrix.\n     * @param col2 Target column.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.ones#1137",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.ones(int, int)",
        "snippet": "    private static RealMatrix ones(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1137,
        "end_line": 1143,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix filled with 1.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.eye#1151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.eye(int, int)",
        "snippet": "    private static RealMatrix eye(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1151,
        "end_line": 1159,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of 0 values out of diagonal, and 1 values on\n     * the diagonal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.zeros#1166",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.zeros(int, int)",
        "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }\n",
        "begin_line": 1166,
        "end_line": 1168,
        "comment": "\n     * @param n Number of rows.\n     * @param m Number of columns.\n     * @return n-by-m matrix of zero values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.repmat#1176",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.repmat(org.apache.commons.math3.linear.RealMatrix, int, int)",
        "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        final int rd = mat.getRowDimension();\n        final int cd = mat.getColumnDimension();\n        final double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1176,
        "end_line": 1186,
        "comment": "\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.sequence#1194",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sequence(double, double, double)",
        "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        final int size = (int) ((end - start) / step + 1);\n        final double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1194,
        "end_line": 1203,
        "comment": "\n     * @param start Start value.\n     * @param end End value.\n     * @param step Step size.\n     * @return a sequence as column matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.max#1209",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }\n",
        "begin_line": 1209,
        "end_line": 1220,
        "comment": "\n     * @param m Input matrix.\n     * @return the maximum of the matrix element values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.min#1226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }\n",
        "begin_line": 1226,
        "end_line": 1237,
        "comment": "\n     * @param m Input matrix.\n     * @return the minimum of the matrix element values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.max#1243",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(double[])",
        "snippet": "    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }\n",
        "begin_line": 1243,
        "end_line": 1251,
        "comment": "\n     * @param m Input array.\n     * @return the maximum of the array values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.min#1257",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(double[])",
        "snippet": "    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }\n",
        "begin_line": 1257,
        "end_line": 1265,
        "comment": "\n     * @param m Input array.\n     * @return the minimum of the array values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.randn1#1308",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.randn1(int, int)",
        "snippet": "    private RealMatrix randn1(int size, int popSize) {\n        final double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1308,
        "end_line": 1316,
        "comment": "\n     * @param size Number of rows.\n     * @param popSize Population size.\n     * @return a 2-dimensional matrix of Gaussian random numbers.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "MatrixUtils.createColumnRealMatrix#336",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createColumnRealMatrix(double[])",
        "snippet": "    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }\n",
        "begin_line": 336,
        "end_line": 347,
        "comment": "\n     * Creates a column {@link RealMatrix} using the data from the input\n     * array.\n     *\n     * @param columnData  the input column data\n     * @return a columnData x 1 RealMatrix\n     * @throws NoDataException if {@code columnData} is empty.\n     * @throws NullArgumentException if {@code columnData} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "MatrixUtils.checkAdditionCompatible#569",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkAdditionCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 569,
        "end_line": 576,
        "comment": "\n     * Check if matrices are addition compatible.\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws MatrixDimensionMismatchException if the matrices are not addition\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "MatrixUtils.checkSubtractionCompatible#586",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkSubtractionCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 586,
        "end_line": 593,
        "comment": "\n     * Check if matrices are subtraction compatible\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws MatrixDimensionMismatchException if the matrices are not addition\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.getFrobeniusNorm#279",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getFrobeniusNorm()",
        "snippet": "    public double getFrobeniusNorm() {\n        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n            /** Sum of squared entries. */\n            private double sum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return FastMath.sqrt(sum);\n            }\n        });\n    }\n",
        "begin_line": 279,
        "end_line": 302,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the <a href=\"http://mathworld.wolfram.com/FrobeniusNorm.html\">\n     * Frobenius norm</a> of the matrix.\n     *\n     * @return norm\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.start#286",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-334607bc-8dd2-471d-83ba-af11074c1ce0.start(int, int, int, int, int, int)",
        "snippet": "            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n",
        "begin_line": 286,
        "end_line": 290,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.visit#293",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-7f1edba3-38eb-442b-adac-faa1daeeb0c6.visit(int, int, double)",
        "snippet": "            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n",
        "begin_line": 293,
        "end_line": 295,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.end#298",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-2c6d68fc-934e-4856-a3bf-4aefebb2bd42.end()",
        "snippet": "            public double end() {\n                return FastMath.sqrt(sum);\n            }\n",
        "begin_line": 298,
        "end_line": 300,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.add#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.add(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix add(RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 77,
        "end_line": 91,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.subtract#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.subtract(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix subtract(final RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 94,
        "end_line": 108,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.scalarAdd#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarAdd(double)",
        "snippet": "    public RealMatrix scalarAdd(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + d);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 111,
        "end_line": 122,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of adding {@code d} to each entry of {@code this}.\n     *\n     * @param d value to be added to each entry\n     * @return {@code d + this}\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.getColumnMatrix#464",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumnMatrix(int)",
        "snippet": "    public RealMatrix getColumnMatrix(final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final RealMatrix out = createMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, 0, getEntry(i, column));\n        }\n\n        return out;\n    }\n",
        "begin_line": 464,
        "end_line": 474,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given column index as a column matrix. Column\n     * indices start at 0.\n     *\n     * @param column Column to be fetched.\n     * @return column Matrix.\n     * @throws OutOfRangeException if the specified column index is invalid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.getColumn#558",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumn(int)",
        "snippet": "    public double[] getColumn(final int column) throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final double[] out = new double[nRows];\n        for (int i = 0; i < nRows; ++i) {\n            out[i] = getEntry(i, column);\n        }\n\n        return out;\n    }\n",
        "begin_line": 558,
        "end_line": 567,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given column index as an array. Column indices\n     * start at 0.\n     *\n     * @param column Column to be fetched.\n     * @return the array of entries in the column.\n     * @throws OutOfRangeException if the specified column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7127
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.log#1129",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1129,
        "end_line": 1353,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6937
        },
        "num_failing_tests": 16
    },
    {
        "name": "BitsStreamGenerator.nextGaussian#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextGaussian()",
        "snippet": "    public double nextGaussian() {\n\n        final double random;\n        if (Double.isNaN(nextGaussian)) {\n            // generate a new pair of gaussian numbers\n            final double x = nextDouble();\n            final double y = nextDouble();\n            final double alpha = 2 * FastMath.PI * x;\n            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n            random       = r * FastMath.cos(alpha);\n            nextGaussian = r * FastMath.sin(alpha);\n        } else {\n            // use the second element of the pair already generated\n            random = nextGaussian;\n            nextGaussian = Double.NaN;\n        }\n\n        return random;\n\n    }\n",
        "begin_line": 101,
        "end_line": 120,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.random.RandomGenerator": "\n     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n     * <code>double</code> value with mean <code>0.0</code> and standard\n     * deviation <code>1.0</code> from this random number generator's sequence.\n     *\n     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n     * <code>double</code> value with mean <code>0.0</code> and\n     * standard deviation <code>1.0</code> from this random number\n     *  generator's sequence\n     "
        },
        "susp": {
            "ochiai_susp": 0.6937
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.updateCovariance#700",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovariance(boolean, org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix, int[], org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n                                  final RealMatrix arz, final int[] arindex,\n                                  final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            final RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                .scalarMultiply(1 / sigma); // mu difference vectors\n            final RealMatrix roneu = pc.multiply(pc.transpose())\n                .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\n            oldFac += 1 - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1 - ccovmu) * 0.25 * mueff /\n                    (Math.pow(dimension + 2, 1.5) + 2 * mueff);\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                final double negminresidualvariance = 0.66;\n                // where to make up for the variance loss\n                final double negalphaold = 0.5;\n                // prepare vectors, compute negative updating matrix Cneg\n                final int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                final int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                final RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                final int[] idxReverse = reverse(idxnorms);\n                final RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                final int[] idxInv = inverse(idxnorms);\n                final RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                final double negcovMax = (1 - negminresidualvariance) /\n                    square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                final RealMatrix artmp = BD.multiply(arzneg);\n                final RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                    .add(roneu) // regard old matrix\n                    .add(arpos.scalarMultiply( // plus rank one update\n                                              ccovmu + (1 - negalphaold) * negccov) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())))\n                    .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                    .add(roneu) // plus rank one update\n                    .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }\n",
        "begin_line": 700,
        "end_line": 759,
        "comment": "\n     * Update of the covariance matrix C.\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArx Fitness-sorted matrix of the argument vectors producing the\n     * current offspring.\n     * @param arz Unsorted matrix containing the gaussian random values of the\n     * current offspring.\n     * @param arindex Indices indicating the fitness-order of the current offspring.\n     * @param xold xmean matrix of the previous generation.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.updateBD#766",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateBD(double)",
        "snippet": "    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n            (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            final EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0);\n                    }\n                }\n                final double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                final double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }\n",
        "begin_line": 766,
        "end_line": 795,
        "comment": "\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.divide#1040",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.divide(org.apache.commons.math3.linear.RealMatrix, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1040,
        "end_line": 1048,
        "comment": "\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.triu#1070",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.triu(org.apache.commons.math3.linear.RealMatrix, int)",
        "snippet": "    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1070,
        "end_line": 1078,
        "comment": "\n     * @param m Input matrix.\n     * @param k Diagonal position.\n     * @return Upper triangular part of matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.sumRows#1084",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sumRows(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n",
        "begin_line": 1084,
        "end_line": 1094,
        "comment": "\n     * @param m Input matrix.\n     * @return Row matrix representing the sums of the rows.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.inverse#1271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.inverse(int[])",
        "snippet": "    private static int[] inverse(final int[] indices) {\n        final int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }\n",
        "begin_line": 1271,
        "end_line": 1277,
        "comment": "\n     * @param indices Input index array.\n     * @return the inverse of the mapping defined by indices.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "CMAESOptimizer.reverse#1283",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.reverse(int[])",
        "snippet": "    private static int[] reverse(final int[] indices) {\n        final int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }\n",
        "begin_line": 1283,
        "end_line": 1289,
        "comment": "\n     * @param indices Input index array.\n     * @return the indices in inverse order (last is first).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "TriDiagonalTransformer.TriDiagonalTransformer#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.TriDiagonalTransformer(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public TriDiagonalTransformer(RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getRowDimension();\n        householderVectors = matrix.getData();\n        main      = new double[m];\n        secondary = new double[m - 1];\n        cachedQ   = null;\n        cachedQt  = null;\n        cachedT   = null;\n\n        // transform matrix\n        transform();\n    }\n",
        "begin_line": 62,
        "end_line": 78,
        "comment": "\n     * Build the transformation to tridiagonal shape of a symmetrical matrix.\n     * <p>The specified matrix is assumed to be symmetrical without any check.\n     * Only the upper triangular part of the matrix is used.</p>\n     *\n     * @param matrix Symmetrical matrix to transform.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "TriDiagonalTransformer.getQ#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQ()",
        "snippet": "    public RealMatrix getQ() {\n        if (cachedQ == null) {\n            cachedQ = getQT().transpose();\n        }\n        return cachedQ;\n    }\n",
        "begin_line": 85,
        "end_line": 90,
        "comment": "\n     * Returns the matrix Q of the transform.\n     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n     * @return the Q matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "TriDiagonalTransformer.getMainDiagonalRef#174",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getMainDiagonalRef()",
        "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "\n     * Get the main diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the main diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "TriDiagonalTransformer.getSecondaryDiagonalRef#184",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/TriDiagonalTransformer.java",
        "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
        "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getSecondaryDiagonalRef()",
        "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Get the secondary diagonal elements of the matrix T of the transform.\n     * <p>Note that since this class is only intended for internal use,\n     * it returns directly a reference to its internal arrays, not a copy.</p>\n     * @return the secondary diagonal elements of the T matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "MatrixUtils.createRealDiagonalMatrix#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
        "snippet": "    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }\n",
        "begin_line": 214,
        "end_line": 220,
        "comment": "\n     * Returns a diagonal matrix with specified elements.\n     *\n     * @param diagonal diagonal elements of the matrix (the array elements\n     * will be copied)\n     * @return diagonal matrix\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "MatrixUtils.isSymmetric#437",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetric(org.apache.commons.math3.linear.RealMatrix, double)",
        "snippet": "    public static boolean isSymmetric(RealMatrix matrix,\n                                      double eps) {\n        return isSymmetricInternal(matrix, eps, false);\n    }\n",
        "begin_line": 437,
        "end_line": 440,
        "comment": "\n     * Checks whether a matrix is symmetric.\n     *\n     * @param matrix Matrix to check.\n     * @param eps Relative tolerance.\n     * @return {@code true} if {@code matrix} is symmetric.\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "EigenDecomposition.EigenDecomposition#117",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.EigenDecomposition(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public EigenDecomposition(final RealMatrix matrix)\n        throws MathArithmeticException {\n        final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\n        isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\n        if (isSymmetric) {\n            transformToTridiagonal(matrix);\n            findEigenVectors(transformer.getQ().getData());\n        } else {\n            final SchurTransformer t = transformToSchur(matrix);\n            findEigenVectorsFromSchur(t);\n        }\n    }\n",
        "begin_line": 117,
        "end_line": 128,
        "comment": "\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "EigenDecomposition.getV#197",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getV()",
        "snippet": "    public RealMatrix getV() {\n\n        if (cachedV == null) {\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        // return the cached matrix\n        return cachedV;\n    }\n",
        "begin_line": 197,
        "end_line": 208,
        "comment": "\n     * Gets the matrix V of the decomposition.\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\n     * The columns of V are the eigenvectors of the original matrix.\n     * No assumption is made about the orientation of the system axes formed\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\n     * or right-handed system).\n     *\n     * @return the V matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "EigenDecomposition.getD#221",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.getD()",
        "snippet": "    public RealMatrix getD() {\n\n        if (cachedD == null) {\n            // cache the matrix for subsequent calls\n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n\n            for (int i = 0; i < imagEigenvalues.length; i++) {\n                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                }\n            }\n        }\n        return cachedD;\n    }\n",
        "begin_line": 221,
        "end_line": 236,
        "comment": "\n     * Gets the block diagonal matrix D of the decomposition.\n     * D is a block diagonal matrix.\n     * Real eigenvalues are on the diagonal while complex values are on\n     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\n     *\n     * @return the D matrix.\n     *\n     * @see #getRealEigenvalues()\n     * @see #getImagEigenvalues()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "EigenDecomposition.transformToTridiagonal#559",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
        "signature": "org.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void transformToTridiagonal(final RealMatrix matrix) {\n        // transform the matrix to tridiagonal\n        transformer = new TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n    }\n",
        "begin_line": 559,
        "end_line": 564,
        "comment": "\n     * Transforms the matrix to tridiagonal form.\n     *\n     * @param matrix Matrix to transform.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "AbstractRealMatrix.setColumnVector#519",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.setColumnVector(int, org.apache.commons.math3.linear.RealVector)",
        "snippet": "    public void setColumnVector(final int column, final RealVector vector)\n        throws OutOfRangeException, MatrixDimensionMismatchException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (vector.getDimension() != nRows) {\n            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n                                                       nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n    }\n",
        "begin_line": 519,
        "end_line": 530,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": "\n     * Returns the result of multiplying {@code this} by the vector {@code x}.\n     *\n     * @param x the vector to operate on\n     * @return the product of {@code this} instance with {@code x}\n     * @throws DimensionMismatchException if the column dimension does not match\n     * the size of {@code x}\n     ",
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Sets the specified {@code row} of {@code this} matrix to the entries of\n     * the specified {@code vector}. Row indices start at 0.\n     *\n     * @param row Row to be set.\n     * @param vector row vector to be copied (must have the same number of\n     * column as the instance).\n     * @throws OutOfRangeException if the specified row index is invalid.\n     * @throws MatrixDimensionMismatchException if the {@code vector} dimension\n     * does not match the column dimension of {@code this} matrix.\n     "
        },
        "susp": {
            "ochiai_susp": 0.6875
        },
        "num_failing_tests": 15
    },
    {
        "name": "BitsStreamGenerator.nextDouble#89",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextDouble()",
        "snippet": "    public double nextDouble() {\n        final long high = ((long) next(26)) << 26;\n        final int  low  = next(26);\n        return (high | low) * 0x1.0p-52d;\n    }\n",
        "begin_line": 89,
        "end_line": 93,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "java.io.Serializable": null,
            "org.apache.commons.math3.random.RandomGenerator": "\n     * Returns the next pseudorandom, uniformly distributed\n     * <code>double</code> value between <code>0.0</code> and\n     * <code>1.0</code> from this random number generator's sequence.\n     *\n     * @return  the next pseudorandom, uniformly distributed\n     *  <code>double</code> value between <code>0.0</code> and\n     *  <code>1.0</code> from this random number generator's sequence\n     "
        },
        "susp": {
            "ochiai_susp": 0.6761
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.getSigma#303",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.Sigma.getSigma()",
        "snippet": "        public double[] getSigma() {\n            return sigma.clone();\n        }\n",
        "begin_line": 303,
        "end_line": 305,
        "comment": "\n         * @return the sigma values.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6761
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.getPopulationSize#337",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize.getPopulationSize()",
        "snippet": "        public int getPopulationSize() {\n            return lambda;\n        }\n",
        "begin_line": 337,
        "end_line": 339,
        "comment": "\n         * @return the population size.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6761
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.Sigma#289",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.Sigma.Sigma(double[])",
        "snippet": "        public Sigma(double[] s)\n            throws NotPositiveException {\n            for (int i = 0; i < s.length; i++) {\n                if (s[i] < 0) {\n                    throw new NotPositiveException(s[i]);\n                }\n            }\n\n            sigma = s.clone();\n        }\n",
        "begin_line": 289,
        "end_line": 298,
        "comment": "\n         * @param s Sigma values.\n         * @throws NotPositiveException if any of the array entries is smaller\n         * than zero.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.PopulationSize#326",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.PopulationSize.PopulationSize(int)",
        "snippet": "        public PopulationSize(int size)\n            throws NotStrictlyPositiveException {\n            if (size <= 0) {\n                throw new NotStrictlyPositiveException(size);\n            }\n            lambda = size;\n        }\n",
        "begin_line": 326,
        "end_line": 332,
        "comment": "\n         * @param size Population size.\n         * @throws NotStrictlyPositiveException if {@code size <= 0}.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.optimize#358",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 358,
        "end_line": 364,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * MultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link Sigma}</li>\n     *  <li>{@link PopulationSize}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "MatrixUtils.createRealMatrix#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int, int)",
        "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }\n",
        "begin_line": 80,
        "end_line": 83,
        "comment": "\n     * Returns a {@link RealMatrix} with specified dimensions.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The matrix elements are all set to 0.0.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @return  RealMatrix with specified dimensions\n     * @see #createRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.start#32",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int, int, int, int, int, int)",
        "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }\n",
        "begin_line": 32,
        "end_line": 34,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * Start visiting a matrix.\n     * <p>This method is called once before any entry of the matrix is visited.</p>\n     * @param rows number of rows of the matrix\n     * @param columns number of columns of the matrix\n     * @param startRow Initial row index\n     * @param endRow Final row index (inclusive)\n     * @param startColumn Initial column index\n     * @param endColumn Final column index (inclusive)\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "DefaultRealMatrixPreservingVisitor.end#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DefaultRealMatrixPreservingVisitor.java",
        "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
        "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
        "snippet": "    public double end() {\n        return 0;\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealMatrixPreservingVisitor": "\n     * End visiting a matrix.\n     * <p>This method is called once after all entries of the matrix have been visited.</p>\n     * @return the value that the <code>walkInXxxOrder</code> must return\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "Array2DRowRealMatrix.walkInRowOrder#408",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }\n",
        "begin_line": 408,
        "end_line": 420,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.transpose#597",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
        "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }\n",
        "begin_line": 597,
        "end_line": 612,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.visit#604",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.Anonymous-41404a75-43ca-4448-954b-902cba49d1bb.visit(int, int, double)",
        "snippet": "            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n",
        "begin_line": 604,
        "end_line": 607,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": null
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.multiply#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 139,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractRealMatrix.walkInOptimizedOrder#872",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(org.apache.commons.math3.linear.RealMatrixPreservingVisitor)",
        "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }\n",
        "begin_line": 872,
        "end_line": 874,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Visit (but don't change) all matrix entries in row order.\n     * <p>Row order starts at upper left and iterating through all elements\n     * of a row from left to right before going to the leftmost element\n     * of the next row.</p>\n     * @param visitor visitor used to process all matrix entries\n     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n     * of the walk\n     "
        },
        "susp": {
            "ochiai_susp": 0.6305
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.max#3488",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
        "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n",
        "begin_line": 3488,
        "end_line": 3490,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "MersenneTwister.MersenneTwister#106",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
        "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": " Creates a new random number generator.\n     * <p>The instance is initialized using the current time plus the\n     * system identity hash code of this instance as the seed.</p>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "MersenneTwister.setSeed#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
        "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }\n",
        "begin_line": 141,
        "end_line": 155,
        "comment": " Reinitialize the generator as if just built with the given int seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "MersenneTwister.setSeed#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
        "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }\n",
        "begin_line": 164,
        "end_line": 207,
        "comment": " Reinitialize the generator as if just built with the given int array seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (32 bits integers array), if null\n     * the seed of the generator will be the current system time plus the\n     * system identity hash code of this instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "MersenneTwister.setSeed#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/MersenneTwister.java",
        "class_name": "org.apache.commons.math3.random.MersenneTwister",
        "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
        "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }\n",
        "begin_line": 214,
        "end_line": 217,
        "comment": " Reinitialize the generator as if just built with the given long seed.\n     * <p>The state of the generator is exactly the same as a new\n     * generator built with the same seed.</p>\n     * @param seed the initial seed (64 bits integer)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "CMAESOptimizer.CMAESOptimizer#223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.CMAESOptimizer(int, double, boolean, int, int, org.apache.commons.math3.random.RandomGenerator, boolean, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public CMAESOptimizer(int maxIterations,\n                          double stopFitness,\n                          boolean isActiveCMA,\n                          int diagonalOnly,\n                          int checkFeasableCount,\n                          RandomGenerator random,\n                          boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }\n",
        "begin_line": 223,
        "end_line": 239,
        "comment": "\n     * @param maxIterations Maximal number of iterations.\n     * @param stopFitness Whether to stop if objective function value is smaller than\n     * {@code stopFitness}.\n     * @param isActiveCMA Chooses the covariance matrix update method.\n     * @param diagonalOnly Number of initial iterations, where the covariance matrix\n     * remains diagonal.\n     * @param checkFeasableCount Determines how often new random objective variables are\n     * generated in case they are out of bounds.\n     * @param random Random generator.\n     * @param generateStatistics Whether statistic data is collected.\n     * @param checker Convergence checker.\n     *\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6172
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.sin#2225",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
        "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2225,
        "end_line": 2284,
        "comment": "\n     * Sine function.\n     *\n     * @param x Argument.\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5966
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.cos#2292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
        "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }\n",
        "begin_line": 2292,
        "end_line": 2338,
        "comment": "\n     * Cosine function.\n     *\n     * @param x Argument.\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.593
        },
        "num_failing_tests": 16
    },
    {
        "name": "BitsStreamGenerator.BitsStreamGenerator#40",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
        "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": "\n     * Creates a new random number generator.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.593
        },
        "num_failing_tests": 16
    },
    {
        "name": "BitsStreamGenerator.clear#194",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java",
        "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
        "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
        "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": "\n     * Clears the cache used by the default implementation of\n     * {@link #nextGaussian}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.593
        },
        "num_failing_tests": 16
    },
    {
        "name": "Incrementor.getCount#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.getCount()",
        "snippet": "    public int getCount() {\n        return count;\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Gets the current count.\n     *\n     * @return the current count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5843
        },
        "num_failing_tests": 28
    },
    {
        "name": "MultivariateOptimizer.computeObjectiveValue#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.computeObjectiveValue(double[])",
        "snippet": "    protected double computeObjectiveValue(double[] params) {\n        super.incrementEvaluationCount();\n        return function.value(params);\n    }\n",
        "begin_line": 114,
        "end_line": 117,
        "comment": "\n     * Computes the objective function value.\n     * This method <em>must</em> be called by subclasses to enforce the\n     * evaluation counter limit.\n     *\n     * @param params Point at which the objective function must be evaluated.\n     * @return the objective function value at the specified point.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5636
        },
        "num_failing_tests": 26
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return a clone of the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5521
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.log#1119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.log(double)",
        "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }\n",
        "begin_line": 1119,
        "end_line": 1121,
        "comment": "\n     * Natural logarithm.\n     *\n     * @param x   a double\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5521
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.CodyWaite#3808",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.CodyWaite(double)",
        "snippet": "        CodyWaite(double xa) {\n            // Estimate k.\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder.\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2.\n                --k;\n            }\n\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n",
        "begin_line": 3808,
        "end_line": 3844,
        "comment": "\n         * @param xa Argument.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.getK#3849",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getK()",
        "snippet": "        int getK() {\n            return finalK;\n        }\n",
        "begin_line": 3849,
        "end_line": 3851,
        "comment": "\n         * @return k\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.getRemA#3855",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemA()",
        "snippet": "        double getRemA() {\n            return finalRemA;\n        }\n",
        "begin_line": 3855,
        "end_line": 3857,
        "comment": "\n         * @return remA\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.getRemB#3861",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.CodyWaite.getRemB()",
        "snippet": "        double getRemB() {\n            return finalRemB;\n        }\n",
        "begin_line": 3861,
        "end_line": 3863,
        "comment": "\n         * @return remB\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.polySine#1676",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
        "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }\n",
        "begin_line": 1676,
        "end_line": 1689,
        "comment": "\n     *  Computes sin(x) - x, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return sin(x) - x\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.polyCosine#1697",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
        "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }\n",
        "begin_line": 1697,
        "end_line": 1707,
        "comment": "\n     *  Computes cos(x) - 1, where |x| < 1/16.\n     *  Use a Remez polynomial approximation.\n     *  @param x a number smaller than 1/16\n     *  @return cos(x) - 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.sinQ#1716",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
        "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }\n",
        "begin_line": 1716,
        "end_line": 1831,
        "comment": "\n     *  Compute sine over the first quadrant (0 < x < pi/2).\n     *  Use combination of table lookup and rational polynomial expansion.\n     *  @param xa number from which sine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return sin(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.cosQ#1840",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
        "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }\n",
        "begin_line": 1840,
        "end_line": 1849,
        "comment": "\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n     *  @param xa number from which cosine is requested\n     *  @param xb extra bits for x (may be 0.0)\n     *  @return cos(xa + xb)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.551
        },
        "num_failing_tests": 17
    },
    {
        "name": "PointValuePair.getPoint#69",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointValuePair",
        "signature": "org.apache.commons.math3.optim.PointValuePair.getPoint()",
        "snippet": "    public double[] getPoint() {\n        final double[] p = getKey();\n        return p == null ? null : p.clone();\n    }\n",
        "begin_line": 69,
        "end_line": 72,
        "comment": "\n     * Gets the point.\n     *\n     * @return a copy of the stored point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5494
        },
        "num_failing_tests": 26
    },
    {
        "name": "ObjectiveFunction.getObjectiveFunction#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunction.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction.getObjectiveFunction()",
        "snippet": "    public MultivariateFunction getObjectiveFunction() {\n        return function;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the function to be optimized.\n     *\n     * @return the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5393
        },
        "num_failing_tests": 26
    },
    {
        "name": "MultivariateOptimizer.parseOptimizationData#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof GoalType) {\n                goal = (GoalType) data;\n                continue;\n            }\n            if (data instanceof ObjectiveFunction) {\n                function = ((ObjectiveFunction) data).getObjectiveFunction();\n                continue;\n            }\n        }\n    }\n",
        "begin_line": 78,
        "end_line": 95,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link ObjectiveFunction}</li>\n     *  <li>{@link GoalType}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5393
        },
        "num_failing_tests": 26
    },
    {
        "name": "ObjectiveFunction.ObjectiveFunction#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunction.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction.ObjectiveFunction(org.apache.commons.math3.analysis.MultivariateFunction)",
        "snippet": "    public ObjectiveFunction(MultivariateFunction f) {\n        function = f;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param f Function to be optimized.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5208
        },
        "num_failing_tests": 26
    },
    {
        "name": "FastMath.atan#2422",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.atan(double)",
        "snippet": "    public static double atan(double x) {\n        return atan(x, 0.0, false);\n    }\n",
        "begin_line": 2422,
        "end_line": 2424,
        "comment": "\n     * Arctangent function\n     *  @param x a number\n     *  @return atan(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.504
        },
        "num_failing_tests": 8
    },
    {
        "name": "MultivariateOptimizer.getGoalType#100",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4841
        },
        "num_failing_tests": 26
    },
    {
        "name": "SimpleBounds.unbounded#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleBounds.java",
        "class_name": "org.apache.commons.math3.optim.SimpleBounds",
        "signature": "org.apache.commons.math3.optim.SimpleBounds.unbounded(int)",
        "snippet": "    public static SimpleBounds unbounded(int dim) {\n        final double[] lB = new double[dim];\n        Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n        final double[] uB = new double[dim];\n        Arrays.fill(uB, Double.POSITIVE_INFINITY);\n\n        return new SimpleBounds(lB, uB);\n    }\n",
        "begin_line": 72,
        "end_line": 79,
        "comment": "\n     * Factory method that creates instance of this class that represents\n     * unbounded ranges.\n     *\n     * @param dim Number of parameters.\n     * @return a new instance suitable for passing to an optimizer that\n     * requires bounds specification.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.483
        },
        "num_failing_tests": 14
    },
    {
        "name": "PointValuePair.PointValuePair#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointValuePair",
        "signature": "org.apache.commons.math3.optim.PointValuePair.PointValuePair(double[], double)",
        "snippet": "    public PointValuePair(final double[] point,\n                          final double value) {\n        this(point, value, true);\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": "\n     * Builds a point/objective function value pair.\n     *\n     * @param point Point coordinates. This instance will store\n     * a copy of the array, not the array passed as argument.\n     * @param value Value of the objective function at the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4818
        },
        "num_failing_tests": 26
    },
    {
        "name": "PointValuePair.PointValuePair#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointValuePair",
        "signature": "org.apache.commons.math3.optim.PointValuePair.PointValuePair(double[], double, boolean)",
        "snippet": "    public PointValuePair(final double[] point,\n                          final double value,\n                          final boolean copyArray) {\n        super(copyArray ? ((point == null) ? null :\n                           point.clone()) :\n              point,\n              value);\n    }\n",
        "begin_line": 55,
        "end_line": 62,
        "comment": "\n     * Builds a point/objective function value pair.\n     *\n     * @param point Point coordinates.\n     * @param value Value of the objective function at the point.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4818
        },
        "num_failing_tests": 26
    },
    {
        "name": "Pair.getValue#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.getValue()",
        "snippet": "    public V getValue() {\n        return value;\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": "\n     * Get the value.\n     *\n     * @return the value (second element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.462
        },
        "num_failing_tests": 27
    },
    {
        "name": "AbstractRealMatrix.isSquare#615",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }\n",
        "begin_line": 615,
        "end_line": 617,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": null,
            "org.apache.commons.math3.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.4611
        },
        "num_failing_tests": 16
    },
    {
        "name": "MultivariateOptimizer.optimize#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 60,
        "end_line": 65,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * BaseMultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link ObjectiveFunction}</li>\n     *  <li>{@link GoalType}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.4582
        },
        "num_failing_tests": 26
    },
    {
        "name": "MultivariateOptimizer.MultivariateOptimizer#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/MultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.MultivariateOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4562
        },
        "num_failing_tests": 26
    },
    {
        "name": "BaseMultivariateOptimizer.checkParameters#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (start != null) {\n            final int dim = start.length;\n            if (lowerBound != null) {\n                if (lowerBound.length != dim) {\n                    throw new DimensionMismatchException(lowerBound.length, dim);\n                }\n                for (int i = 0; i < dim; i++) {\n                    final double v = start[i];\n                    final double lo = lowerBound[i];\n                    if (v < lo) {\n                        throw new NumberIsTooSmallException(v, lo, true);\n                    }\n                }\n            }\n            if (upperBound != null) {\n                if (upperBound.length != dim) {\n                    throw new DimensionMismatchException(upperBound.length, dim);\n                }\n                for (int i = 0; i < dim; i++) {\n                    final double v = start[i];\n                    final double hi = upperBound[i];\n                    if (v > hi) {\n                        throw new NumberIsTooLargeException(v, hi, true);\n                    }\n                }\n            }\n        }\n    }\n",
        "begin_line": 127,
        "end_line": 155,
        "comment": "\n     * Check parameters consistency.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4558
        },
        "num_failing_tests": 28
    },
    {
        "name": "FastMath.atan#2432",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.atan(double, double, boolean)",
        "snippet": "    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa == 0.0) { // Matches +/- 0.0; return correct sign\n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa < 0) {\n            // negative\n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { // Very large input\n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n        if (xa < 1) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        /* Compute eps = eps / (1.0 + xa*tangent) */\n        temp = xa * HEX_40000000;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        //if (idx > 8 || idx == 0)\n        if (idx == 0) {\n            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1d + temp2;\n            double zb = -(za - 1d - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            /* Correct for rounding in division */\n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        /* Evaluate polynomial */\n        final double epsA2 = epsA * epsA;\n\n        /*\n    yb = -0.09001346640161823;\n    yb = yb * epsA2 + 0.11110718400605211;\n    yb = yb * epsA2 + -0.1428571349122913;\n    yb = yb * epsA2 + 0.19999999999273194;\n    yb = yb * epsA2 + -0.33333333333333093;\n    yb = yb * epsA2 * epsA;\n         */\n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n        yb += epsB / (1d + epsA * epsA);\n\n        //result = yb + eighths[idx] + ya;\n        double za = EIGHTHS[idx] + ya;\n        double zb = -(za - EIGHTHS[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        double result = za + zb;\n        double resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            // Result is in the left plane\n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }\n",
        "begin_line": 2432,
        "end_line": 2571,
        "comment": " Internal helper function to compute arctangent.\n     * @param xa number from which arctangent is requested\n     * @param xb extra bits for x (may be 0.0)\n     * @param leftPlane if true, result angle must be put in the left half plane\n     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4558
        },
        "num_failing_tests": 8
    },
    {
        "name": "SimpleBounds.getLower#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleBounds.java",
        "class_name": "org.apache.commons.math3.optim.SimpleBounds",
        "signature": "org.apache.commons.math3.optim.SimpleBounds.getLower()",
        "snippet": "    public double[] getLower() {\n        return lower.clone();\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Gets the lower bounds.\n     *\n     * @return the lower bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4411
        },
        "num_failing_tests": 16
    },
    {
        "name": "SimpleBounds.getUpper#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleBounds.java",
        "class_name": "org.apache.commons.math3.optim.SimpleBounds",
        "signature": "org.apache.commons.math3.optim.SimpleBounds.getUpper()",
        "snippet": "    public double[] getUpper() {\n        return upper.clone();\n    }\n",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Gets the upper bounds.\n     *\n     * @return the upper bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4411
        },
        "num_failing_tests": 16
    },
    {
        "name": "BaseMultivariateOptimizer.parseOptimizationData#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof InitialGuess) {\n                start = ((InitialGuess) data).getInitialGuess();\n                continue;\n            }\n            if (data instanceof SimpleBounds) {\n                final SimpleBounds bounds = (SimpleBounds) data;\n                lowerBound = bounds.getLower();\n                upperBound = bounds.getUpper();\n                continue;\n            }\n        }\n\n        // Check input consistency.\n        checkParameters();\n    }\n",
        "begin_line": 79,
        "end_line": 101,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link InitialGuess}</li>\n     *  <li>{@link SimpleBounds}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4411
        },
        "num_failing_tests": 28
    },
    {
        "name": "FastMath.max#3531",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3531,
        "end_line": 3549,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4375
        },
        "num_failing_tests": 27
    },
    {
        "name": "SimpleBounds.SimpleBounds#41",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleBounds.java",
        "class_name": "org.apache.commons.math3.optim.SimpleBounds",
        "signature": "org.apache.commons.math3.optim.SimpleBounds.SimpleBounds(double[], double[])",
        "snippet": "    public SimpleBounds(double[] lB,\n                        double[] uB) {\n        lower = lB.clone();\n        upper = uB.clone();\n    }\n",
        "begin_line": 41,
        "end_line": 45,
        "comment": "\n     * @param lB Lower bounds.\n     * @param uB Upper bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4364
        },
        "num_failing_tests": 16
    },
    {
        "name": "Precision.compareTo#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, double)",
        "snippet": "    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n            return -1;\n        }\n        return 1;\n    }\n",
        "begin_line": 95,
        "end_line": 102,
        "comment": "\n     * Compares two numbers given some amount of allowed error.\n     *\n     * @param x the first number\n     * @param y the second number\n     * @param eps the amount of error to allow when checking for equality\n     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4274
        },
        "num_failing_tests": 15
    },
    {
        "name": "Precision.equals#271",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
        "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "\n     * Returns {@code true} if there is no double value strictly between the\n     * arguments or the difference between them is within the range of allowed\n     * error (inclusive).\n     *\n     * @param x First value.\n     * @param y Second value.\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4274
        },
        "num_failing_tests": 15
    },
    {
        "name": "BaseOptimizer.getConvergenceChecker#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.getConvergenceChecker()",
        "snippet": "    public ConvergenceChecker<PAIR> getConvergenceChecker() {\n        return checker;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": "\n     * Gets the convergence checker.\n     *\n     * @return the object used to check for convergence.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseMultivariateOptimizer.getStartPoint#108",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getStartPoint()",
        "snippet": "    public double[] getStartPoint() {\n        return start == null ? null : start.clone();\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "\n     * Gets the initial guess.\n     *\n     * @return the initial guess, or {@code null} if not set.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.407
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseMultivariateOptimizer.getUpperBound#120",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getUpperBound()",
        "snippet": "    public double[] getUpperBound() {\n        return upperBound == null ? null : upperBound.clone();\n    }\n",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n     * @return the upper bounds, or {@code null} if not set.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.407
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseMultivariateOptimizer.getLowerBound#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getLowerBound()",
        "snippet": "    public double[] getLowerBound() {\n        return lowerBound == null ? null : lowerBound.clone();\n    }\n",
        "begin_line": 114,
        "end_line": 116,
        "comment": "\n     * @return the lower bounds, or {@code null} if not set.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseOptimizer.incrementEvaluationCount#160",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount()\n        throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n    }\n",
        "begin_line": 160,
        "end_line": 163,
        "comment": "\n     * Increment the evaluation count.\n     *\n     * @throws TooManyEvaluationsException if the allowed evaluations\n     * have been exhausted.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3955
        },
        "num_failing_tests": 28
    },
    {
        "name": "InitialGuess.getInitialGuess#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/InitialGuess.java",
        "class_name": "org.apache.commons.math3.optim.InitialGuess",
        "signature": "org.apache.commons.math3.optim.InitialGuess.getInitialGuess()",
        "snippet": "    public double[] getInitialGuess() {\n        return init.clone();\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the initial guess.\n     *\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3944
        },
        "num_failing_tests": 28
    },
    {
        "name": "InitialGuess.InitialGuess#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/InitialGuess.java",
        "class_name": "org.apache.commons.math3.optim.InitialGuess",
        "signature": "org.apache.commons.math3.optim.InitialGuess.InitialGuess(double[])",
        "snippet": "    public InitialGuess(double[] startPoint) {\n        init = startPoint.clone();\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param startPoint Initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3933
        },
        "num_failing_tests": 28
    },
    {
        "name": "Pair.getKey#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.getKey()",
        "snippet": "    public K getKey() {\n        return key;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Get the key.\n     *\n     * @return the key (first element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3837
        },
        "num_failing_tests": 26
    },
    {
        "name": "Pair.Pair#45",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Pair.java",
        "class_name": "org.apache.commons.math3.util.Pair",
        "signature": "org.apache.commons.math3.util.Pair.Pair(K, V)",
        "snippet": "    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n     * Create an entry representing a mapping from the specified key to the\n     * specified value.\n     *\n     * @param k Key (first element of the pair).\n     * @param v Value (second element of the pair).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3809
        },
        "num_failing_tests": 28
    },
    {
        "name": "MaxEval.getMaxEval#48",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/MaxEval.java",
        "class_name": "org.apache.commons.math3.optim.MaxEval",
        "signature": "org.apache.commons.math3.optim.MaxEval.getMaxEval()",
        "snippet": "    public int getMaxEval() {\n        return maxEval;\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "\n     * Gets the maximum number of evaluations.\n     *\n     * @return the allowed number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3799
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseOptimizer.parseOptimizationData#187",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    protected void parseOptimizationData(OptimizationData... optData) {\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof MaxEval) {\n                evaluations.setMaximalCount(((MaxEval) data).getMaxEval());\n                continue;\n            }\n            if (data instanceof MaxIter) {\n                iterations.setMaximalCount(((MaxIter) data).getMaxIter());\n                continue;\n            }\n        }\n    }\n",
        "begin_line": 187,
        "end_line": 200,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link MaxEval}</li>\n     *  <li>{@link MaxIter}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3799
        },
        "num_failing_tests": 28
    },
    {
        "name": "MaxEval.MaxEval#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/MaxEval.java",
        "class_name": "org.apache.commons.math3.optim.MaxEval",
        "signature": "org.apache.commons.math3.optim.MaxEval.MaxEval(int)",
        "snippet": "    public MaxEval(int max) {\n        if (max <= 0) {\n            throw new NotStrictlyPositiveException(max);\n        }\n\n        maxEval = max;\n    }\n",
        "begin_line": 35,
        "end_line": 41,
        "comment": "\n     * @param max Allowed number of evalutations.\n     * @throws NotStrictlyPositiveException if {@code max <= 0}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3789
        },
        "num_failing_tests": 28
    },
    {
        "name": "MultiDirectionalSimplex.MultiDirectionalSimplex#100",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/MultiDirectionalSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex(double[])",
        "snippet": "    public MultiDirectionalSimplex(final double[] steps) {\n        this(steps, DEFAULT_KHI, DEFAULT_GAMMA);\n    }\n",
        "begin_line": 100,
        "end_line": 102,
        "comment": "\n     * Build a multi-directional simplex with default coefficients.\n     * The default values are 2.0 for khi and 0.5 for gamma.\n     *\n     * @param steps Steps along the canonical axes representing box edges.\n     * They may be negative but not zero. See\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 4
    },
    {
        "name": "MultiDirectionalSimplex.MultiDirectionalSimplex#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/MultiDirectionalSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex(double[], double, double)",
        "snippet": "    public MultiDirectionalSimplex(final double[] steps,\n                                   final double khi, final double gamma) {\n        super(steps);\n\n        this.khi   = khi;\n        this.gamma = gamma;\n    }\n",
        "begin_line": 113,
        "end_line": 119,
        "comment": "\n     * Build a multi-directional simplex with specified coefficients.\n     *\n     * @param steps Steps along the canonical axes representing box edges.\n     * They may be negative but not zero. See\n     * {@link AbstractSimplex#AbstractSimplex(double[])}.\n     * @param khi Expansion coefficient.\n     * @param gamma Contraction coefficient.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 4
    },
    {
        "name": "Precision.equals#330",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 330,
        "end_line": 345,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3735
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.abs#2998",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 2998,
        "end_line": 3000,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3735
        },
        "num_failing_tests": 17
    },
    {
        "name": "Incrementor.incrementCount#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() throws MaxCountExceededException {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 154,
        "end_line": 158,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3705
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseMultivariateOptimizer.optimize#63",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PAIR optimize(OptimizationData... optData) {\n        // Perform optimization.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 63,
        "end_line": 67,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer},\n     * this method will register the following data:\n     * <ul>\n     *  <li>{@link InitialGuess}</li>\n     *  <li>{@link SimpleBounds}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3678
        },
        "num_failing_tests": 28
    },
    {
        "name": "FastMath.abs#3016",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3016,
        "end_line": 3018,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3673
        },
        "num_failing_tests": 27
    },
    {
        "name": "AbstractRealMatrix.getRow#533",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getRow(int)",
        "snippet": "    public double[] getRow(final int row) throws OutOfRangeException {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols = getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int i = 0; i < nCols; ++i) {\n            out[i] = getEntry(row, i);\n        }\n\n        return out;\n    }\n",
        "begin_line": 533,
        "end_line": 542,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entries at the given row index. Row indices start at 0.\n     *\n     * @param row Row to be fetched.\n     * @return the array of entries in the row.\n     * @throws OutOfRangeException if the specified row index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.364
        },
        "num_failing_tests": 16
    },
    {
        "name": "BaseMultivariateOptimizer.BaseMultivariateOptimizer#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.BaseMultivariateOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<PAIR>)",
        "snippet": "    protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\n        super(checker);\n    }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3634
        },
        "num_failing_tests": 28
    },
    {
        "name": "Incrementor.resetCount#163",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3617
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseOptimizer.optimize#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    public PAIR optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               TooManyIterationsException {\n        // Parse options.\n        parseOptimizationData(optData);\n\n        // Reset counters.\n        evaluations.resetCount();\n        iterations.resetCount();\n        // Perform optimization.\n        return doOptimize();\n    }\n",
        "begin_line": 133,
        "end_line": 144,
        "comment": "\n     * Stores data and performs the optimization.\n     * <br/>\n     * The list of parameters is open-ended so that sub-classes can extend it\n     * with arguments specific to their concrete implementations.\n     * <br/>\n     * When the method is called multiple times, instance data is overwritten\n     * only when actually present in the list of arguments: when not specified,\n     * data set in a previous call is retained (and thus is optional in\n     * subsequent calls).\n     * <br/>\n     * Important note: Subclasses <em>must</em> override\n     * {@link #parseOptimizationData(OptimizationData[])} if they need to register\n     * their own options; but then, they <em>must</em> also call\n     * {@code super.parseOptimizationData(optData)} within that method.\n     *\n     * @param optData Optimization data.\n     * This method will register the following data:\n     * <ul>\n     *  <li>{@link MaxEval}</li>\n     *  <li>{@link MaxIter}</li>\n     * </ul>\n     * @return a point/value pair that satifies the convergence criteria.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws TooManyIterationsException if the maximal number of\n     * iterations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3617
        },
        "num_failing_tests": 28
    },
    {
        "name": "AbstractRealMatrix.scalarMultiply#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarMultiply(double)",
        "snippet": "    public RealMatrix scalarMultiply(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) * d);\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 125,
        "end_line": 136,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of multiplying each entry of {@code this} by\n     * {@code d}.\n     *\n     * @param d value to multiply all entries by\n     * @return {@code d * this}\n     "
        },
        "susp": {
            "ochiai_susp": 0.3592
        },
        "num_failing_tests": 17
    },
    {
        "name": "Array2DRowRealMatrix.createMatrix#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int, int)",
        "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }\n",
        "begin_line": 141,
        "end_line": 146,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Create a new RealMatrix of the same type as the instance with the\n     * supplied\n     * row and column dimensions.\n     *\n     * @param rowDimension the number of rows in the new matrix\n     * @param columnDimension the number of columns in the new matrix\n     * @return a new matrix of the same type as the instance\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.357
        },
        "num_failing_tests": 17
    },
    {
        "name": "Incrementor.setMaximalCount#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3559
        },
        "num_failing_tests": 28
    },
    {
        "name": "Incrementor.Incrementor#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int, org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max, MaxCountExceededCallback cb)\n        throws NullArgumentException {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 79,
        "end_line": 86,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     * @throws NullArgumentException if {@code cb} is {@code null}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3512
        },
        "num_failing_tests": 28
    },
    {
        "name": "BaseOptimizer.BaseOptimizer#47",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.BaseOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<PAIR>)",
        "snippet": "    protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n    }\n",
        "begin_line": 47,
        "end_line": 52,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3512
        },
        "num_failing_tests": 28
    },
    {
        "name": "ArrayRealVector.getEntry#597",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getEntry(int)",
        "snippet": "    @Override\n    public double getEntry(int index) throws OutOfRangeException {\n        try {\n            return data[index];\n        } catch (IndexOutOfBoundsException e) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n                getDimension() - 1);\n        }\n    }\n",
        "begin_line": 597,
        "end_line": 605,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Return the entry at the specified index.\n     *\n     * @param index Index location of entry to be fetched.\n     * @return the vector entry at {@code index}.\n     * @throws OutOfRangeException if the index is not valid.\n     * @see #setEntry(int, double)\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3446
        },
        "num_failing_tests": 16
    },
    {
        "name": "Array2DRowRealMatrix.getData#252",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }\n",
        "begin_line": 252,
        "end_line": 255,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return 2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.3381
        },
        "num_failing_tests": 16
    },
    {
        "name": "FastMath.min#3420",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
        "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }\n",
        "begin_line": 3420,
        "end_line": 3422,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3367
        },
        "num_failing_tests": 20
    },
    {
        "name": "Array2DRowRealMatrix.copyOut#527",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
        "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n",
        "begin_line": 527,
        "end_line": 535,
        "comment": "\n     * Get a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.336
        },
        "num_failing_tests": 16
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#603",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math3.linear.AnyMatrix, org.apache.commons.math3.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }\n",
        "begin_line": 603,
        "end_line": 610,
        "comment": "\n     * Check if matrices are multiplication compatible\n     *\n     * @param left Left hand side matrix.\n     * @param right Right hand side matrix.\n     * @throws DimensionMismatchException if matrices are not multiplication\n     * compatible.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3289
        },
        "num_failing_tests": 18
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#99",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][], boolean)",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws DimensionMismatchException, NoDataException,\n        NullArgumentException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullArgumentException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data = d;\n        }\n    }\n",
        "begin_line": 99,
        "end_line": 123,
        "comment": "\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the {@code copyArray} may be\n     * set to {@code false}. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.\n     *\n     * @param d Data for new matrix.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     * @throws DimensionMismatchException if {@code d} is not rectangular.\n     * @throws NoDataException if {@code d} row or colum dimension is zero.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #Array2DRowRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3243
        },
        "num_failing_tests": 18
    },
    {
        "name": "ArrayRealVector.getDimension#608",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDimension()",
        "snippet": "    @Override\n    public int getDimension() {\n        return data.length;\n    }\n",
        "begin_line": 608,
        "end_line": 611,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Returns the size of the vector.\n     *\n     * @return the size of this vector.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.3242
        },
        "num_failing_tests": 16
    },
    {
        "name": "AbstractSimplex.AbstractSimplex#97",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex(double[])",
        "snippet": "    protected AbstractSimplex(final double[] steps) {\n        if (steps == null) {\n            throw new NullArgumentException();\n        }\n        if (steps.length == 0) {\n            throw new ZeroException();\n        }\n        dimension = steps.length;\n\n        // Only the relative position of the n final vertices with respect\n        // to the first one are stored.\n        startConfiguration = new double[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            final double[] vertexI = startConfiguration[i];\n            for (int j = 0; j < i + 1; j++) {\n                if (steps[j] == 0) {\n                    throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX);\n                }\n                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n            }\n        }\n    }\n",
        "begin_line": 97,
        "end_line": 118,
        "comment": "\n     * The start configuration for simplex is built from a box parallel to\n     * the canonical axes of the space. The simplex is the subset of vertices\n     * of a box parallel to the canonical axes. It is built as the path followed\n     * while traveling from one vertex of the box to the diagonally opposite\n     * vertex moving only along the box edges. The first vertex of the box will\n     * be located at the start point of the optimization.\n     * As an example, in dimension 3 a simplex has 4 vertices. Setting the\n     * steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the\n     * start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }.\n     * The first vertex would be set to the start point at (1, 1, 1) and the\n     * last vertex would be set to the diagonally opposite vertex at (2, 11, 3).\n     *\n     * @param steps Steps along the canonical axes representing box edges. They\n     * may be negative but not zero.\n     * @throws NullArgumentException if {@code steps} is {@code null}.\n     * @throws ZeroException if one of the steps is zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3223
        },
        "num_failing_tests": 8
    },
    {
        "name": "MatrixUtils.createRealMatrix#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }\n",
        "begin_line": 127,
        "end_line": 136,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.\n     * <p>The type of matrix returned depends on the dimension. Below\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n     * square matrix) which can be stored in a 32kB array, a {@link\n     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n     * BlockRealMatrix} instance is built.</p>\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if {@code data} is not rectangular (not all rows have the same length).\n     * @throws NoDataException if a row or column is empty.\n     * @throws NullArgumentException if either {@code data} or {@code data[0]}\n     * is {@code null}.\n     * @throws DimensionMismatchException if {@code data} is not rectangular.\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.312
        },
        "num_failing_tests": 17
    },
    {
        "name": "MultiDirectionalSimplex.iterate#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/MultiDirectionalSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.iterate(org.apache.commons.math3.analysis.MultivariateFunction, java.util.Comparator<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    @Override\n    public void iterate(final MultivariateFunction evaluationFunction,\n                        final Comparator<PointValuePair> comparator) {\n        // Save the original simplex.\n        final PointValuePair[] original = getPoints();\n        final PointValuePair best = original[0];\n\n        // Perform a reflection step.\n        final PointValuePair reflected = evaluateNewSimplex(evaluationFunction,\n                                                                original, 1, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            // Compute the expanded simplex.\n            final PointValuePair[] reflectedSimplex = getPoints();\n            final PointValuePair expanded = evaluateNewSimplex(evaluationFunction,\n                                                                   original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // Keep the reflected simplex.\n                setPoints(reflectedSimplex);\n            }\n            // Keep the expanded simplex.\n            return;\n        }\n\n        // Compute the contracted simplex.\n        evaluateNewSimplex(evaluationFunction, original, gamma, comparator);\n\n    }\n",
        "begin_line": 153,
        "end_line": 179,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex": "\n     * Compute the next simplex of the algorithm.\n     *\n     * @param evaluationFunction Evaluation function.\n     * @param comparator Comparator to use to sort simplex vertices from best\n     * to worst.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the algorithm fails to converge.\n     "
        },
        "susp": {
            "ochiai_susp": 0.3086
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractSimplex.setPoints#324",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoints(org.apache.commons.math3.optim.PointValuePair[])",
        "snippet": "    protected void setPoints(PointValuePair[] points) {\n        if (points.length != simplex.length) {\n            throw new DimensionMismatchException(points.length, simplex.length);\n        }\n        simplex = points;\n    }\n",
        "begin_line": 324,
        "end_line": 329,
        "comment": "\n     * Replace all points.\n     * Note that no deep-copy of {@code points} is performed.\n     *\n     * @param points New Points.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3086
        },
        "num_failing_tests": 4
    },
    {
        "name": "FastMath.sqrt#378",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 378,
        "end_line": 380,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3079
        },
        "num_failing_tests": 19
    },
    {
        "name": "SimplexOptimizer.doOptimize#126",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n            if (iteration > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n\t\t\t++iteration;\n        }\n    }\n",
        "begin_line": 126,
        "end_line": 177,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2965
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
        "snippet": "    protected AbstractRealMatrix() {}\n",
        "begin_line": 56,
        "end_line": 56,
        "comment": "\n     * Creates a matrix with no data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.295
        },
        "num_failing_tests": 18
    },
    {
        "name": "SimplexOptimizer.compare#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.Anonymous-6eb86043-5784-4c62-8f03-e20dea52b94f.compare(org.apache.commons.math3.optim.PointValuePair, org.apache.commons.math3.optim.PointValuePair)",
        "snippet": "            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n",
        "begin_line": 142,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "SimplexOptimizer.value#134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.Anonymous-13c488a9-21bd-43ec-b86f-ecefaebbed8d.value(double[])",
        "snippet": "                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n",
        "begin_line": 134,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "SimplexOptimizer.checkParameters#212",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (simplex == null) {\n            throw new NullArgumentException();\n        }\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }\n",
        "begin_line": 212,
        "end_line": 220,
        "comment": "\n     * @throws MathUnsupportedOperationException if bounds were passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     * @throws NullArgumentException if no initial simplex was passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.getDimension#182",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getDimension()",
        "snippet": "    public int getDimension() {\n        return dimension;\n    }\n",
        "begin_line": 182,
        "end_line": 184,
        "comment": "\n     * Get simplex dimension.\n     *\n     * @return the dimension of the simplex.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.getSize#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getSize()",
        "snippet": "    public int getSize() {\n        return simplex.length;\n    }\n",
        "begin_line": 193,
        "end_line": 195,
        "comment": "\n     * Get simplex size.\n     * After calling the {@link #build(double[]) build} method, this method will\n     * will be equivalent to {@code getDimension() + 1}.\n     *\n     * @return the size of the simplex.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.build#216",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.build(double[])",
        "snippet": "    public void build(final double[] startPoint) {\n        if (dimension != startPoint.length) {\n            throw new DimensionMismatchException(dimension, startPoint.length);\n        }\n\n        // Set first vertex.\n        simplex = new PointValuePair[dimension + 1];\n        simplex[0] = new PointValuePair(startPoint, Double.NaN);\n\n        // Set remaining vertices.\n        for (int i = 0; i < dimension; i++) {\n            final double[] confI = startConfiguration[i];\n            final double[] vertexI = new double[dimension];\n            for (int k = 0; k < dimension; k++) {\n                vertexI[k] = startPoint[k] + confI[k];\n            }\n            simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n        }\n    }\n",
        "begin_line": 216,
        "end_line": 234,
        "comment": "\n     * Build an initial simplex.\n     *\n     * @param startPoint First point of the simplex.\n     * @throws DimensionMismatchException if the start point does not match\n     * simplex dimension.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.evaluate#244",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.evaluate(org.apache.commons.math3.analysis.MultivariateFunction, java.util.Comparator<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public void evaluate(final MultivariateFunction evaluationFunction,\n                         final Comparator<PointValuePair> comparator) {\n        // Evaluate the objective function at all non-evaluated simplex points.\n        for (int i = 0; i < simplex.length; i++) {\n            final PointValuePair vertex = simplex[i];\n            final double[] point = vertex.getPointRef();\n            if (Double.isNaN(vertex.getValue())) {\n                simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n            }\n        }\n\n        // Sort the simplex from best to worst.\n        Arrays.sort(simplex, comparator);\n    }\n",
        "begin_line": 244,
        "end_line": 257,
        "comment": "\n     * Evaluate all the non-evaluated points of the simplex.\n     *\n     * @param evaluationFunction Evaluation function.\n     * @param comparator Comparator to use to sort simplex vertices from best to worst.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.getPoints#283",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoints()",
        "snippet": "    public PointValuePair[] getPoints() {\n        final PointValuePair[] copy = new PointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, copy, 0, simplex.length);\n        return copy;\n    }\n",
        "begin_line": 283,
        "end_line": 287,
        "comment": "\n     * Get the points of the simplex.\n     *\n     * @return all the simplex points.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractSimplex.getPoint#295",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoint(int)",
        "snippet": "    public PointValuePair getPoint(int index) {\n        if (index < 0 ||\n            index >= simplex.length) {\n            throw new OutOfRangeException(index, 0, simplex.length - 1);\n        }\n        return simplex[index];\n    }\n",
        "begin_line": 295,
        "end_line": 301,
        "comment": "\n     * Get the simplex point stored at the requested {@code index}.\n     *\n     * @param index Location.\n     * @return the point at location {@code index}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.291
        },
        "num_failing_tests": 8
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#58",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int, int)",
        "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }\n",
        "begin_line": 58,
        "end_line": 63,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows in the new matrix.\n     * @param columnDimension Number of columns in the new matrix.\n     * @throws NotStrictlyPositiveException if the row or column dimension is\n     * not positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2909
        },
        "num_failing_tests": 17
    },
    {
        "name": "Array2DRowRealMatrix.setEntry#311",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }\n",
        "begin_line": 311,
        "end_line": 316,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Set the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be set.\n     * @param column Column index of entry to be set.\n     * @param value the new value of the entry.\n     * @throws OutOfRangeException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.2909
        },
        "num_failing_tests": 17
    },
    {
        "name": "Array2DRowRealMatrix.Array2DRowRealMatrix#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
        "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": "\n     * Create a new {@code RealMatrix} using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n     * with the second argument set to {@code true}.</p>\n     *\n     * @param d Data for the new matrix.\n     * @throws DimensionMismatchException if {@code d} is not rectangular.\n     * @throws NoDataException if {@code d} row or colum dimension is zero.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #Array2DRowRealMatrix(double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2862
        },
        "num_failing_tests": 17
    },
    {
        "name": "Array2DRowRealMatrix.setSubMatrix#267",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][], int, int)",
        "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }\n",
        "begin_line": 267,
        "end_line": 300,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n    * Replace the submatrix starting at {@code row, column} using data in the\n    * input {@code subMatrix} array. Indexes are 0-based.\n    * <p>\n    * Example:<br>\n    * Starting with <pre>\n    * 1  2  3  4\n    * 5  6  7  8\n    * 9  0  1  2\n    * </pre>\n    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n    * {@code setSubMatrix(subMatrix,1,1))} will result in <pre>\n    * 1  2  3  4\n    * 5  3  4  8\n    * 9  5  6  2\n    * </pre></p>\n    *\n    * @param subMatrix  array containing the submatrix replacement data\n    * @param row  row coordinate of the top, left element to be replaced\n    * @param column  column coordinate of the top, left element to be replaced\n    * @throws NoDataException if {@code subMatrix} is empty.\n    * @throws OutOfRangeException if {@code subMatrix} does not fit into\n    * this matrix from element in {@code (row, column)}.\n    * @throws DimensionMismatchException if {@code subMatrix} is not rectangular\n    * (not all rows have the same length) or empty.\n    * @throws NullArgumentException if {@code subMatrix} is {@code null}.\n    * @since 2.0\n    "
        },
        "susp": {
            "ochiai_susp": 0.2862
        },
        "num_failing_tests": 17
    },
    {
        "name": "Array2DRowRealMatrix.copyIn#545",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
        "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }\n",
        "begin_line": 545,
        "end_line": 548,
        "comment": "\n     * Replace data with a fresh copy of the input array.\n     *\n     * @param in Data to copy.\n     * @throws NoDataException if the input array is empty.\n     * @throws DimensionMismatchException if the input array is not rectangular.\n     * @throws NullArgumentException if the input array is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2862
        },
        "num_failing_tests": 17
    },
    {
        "name": "MultiDirectionalSimplex.evaluateNewSimplex#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/MultiDirectionalSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.evaluateNewSimplex(org.apache.commons.math3.analysis.MultivariateFunction, org.apache.commons.math3.optim.PointValuePair[], double, java.util.Comparator<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    private PointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\n                                                  final PointValuePair[] original,\n                                                  final double coeff,\n                                                  final Comparator<PointValuePair> comparator) {\n        final double[] xSmallest = original[0].getPointRef();\n        // Perform a linear transformation on all the simplex points,\n        // except the first one.\n        setPoint(0, original[0]);\n        final int dim = getDimension();\n        for (int i = 1; i < getSize(); i++) {\n            final double[] xOriginal = original[i].getPointRef();\n            final double[] xTransformed = new double[dim];\n            for (int j = 0; j < dim; j++) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            setPoint(i, new PointValuePair(xTransformed, Double.NaN, false));\n        }\n\n        // Evaluate the simplex.\n        evaluate(evaluationFunction, comparator);\n\n        return getPoint(0);\n    }\n",
        "begin_line": 193,
        "end_line": 215,
        "comment": "\n     * Compute and evaluate a new simplex.\n     *\n     * @param evaluationFunction Evaluation function.\n     * @param original Original simplex (to be preserved).\n     * @param coeff Linear coefficient.\n     * @param comparator Comparator to use to sort simplex vertices from best\n     * to poorest.\n     * @return the best point in the transformed simplex.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2857
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }\n",
        "begin_line": 65,
        "end_line": 74,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws NotStrictlyPositiveException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2812
        },
        "num_failing_tests": 19
    },
    {
        "name": "SimplexOptimizer.SimplexOptimizer#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public SimplexOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2807
        },
        "num_failing_tests": 8
    },
    {
        "name": "SimplexOptimizer.optimize#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData) {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 119,
        "end_line": 123,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * MultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link AbstractSimplex}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2807
        },
        "num_failing_tests": 8
    },
    {
        "name": "SimplexOptimizer.parseOptimizationData#189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof AbstractSimplex) {\n                simplex = (AbstractSimplex) data;\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }\n",
        "begin_line": 189,
        "end_line": 204,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link AbstractSimplex}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2807
        },
        "num_failing_tests": 8
    },
    {
        "name": "PointValuePair.getPointRef#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointValuePair",
        "signature": "org.apache.commons.math3.optim.PointValuePair.getPointRef()",
        "snippet": "    public double[] getPointRef() {\n        return getKey();\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * Gets a reference to the point.\n     *\n     * @return a reference to the internal array storing the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2807
        },
        "num_failing_tests": 8
    },
    {
        "name": "Array2DRowRealMatrix.getEntry#303",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }\n",
        "begin_line": 303,
        "end_line": 308,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be fetched.\n     * @param column Column index of entry to be fetched.\n     * @return the matrix entry at {@code (row, column)}.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2796
        },
        "num_failing_tests": 18
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#98",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2787
        },
        "num_failing_tests": 19
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#130",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }\n",
        "begin_line": 130,
        "end_line": 143,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2787
        },
        "num_failing_tests": 19
    },
    {
        "name": "RealMatrixFormat.getFormat#206",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
        "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }\n",
        "begin_line": 206,
        "end_line": 208,
        "comment": "\n     * Get the components format.\n     * @return components format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2787
        },
        "num_failing_tests": 19
    },
    {
        "name": "RealMatrixFormat.getInstance#223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2787
        },
        "num_failing_tests": 19
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(java.util.Locale)",
        "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }\n",
        "begin_line": 53,
        "end_line": 57,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing that the maximum number of fraction digits is set to 10.\n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2779
        },
        "num_failing_tests": 19
    },
    {
        "name": "CompositeFormat.getDefaultNumberFormat#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/CompositeFormat.java",
        "class_name": "org.apache.commons.math3.util.CompositeFormat",
        "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
        "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance()} with the only customizing that the\n     * maximum number of fraction digits is set to 10.\n     * @return the default number format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "RealMatrixFormat.RealMatrixFormat#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }\n",
        "begin_line": 112,
        "end_line": 117,
        "comment": "\n     * Create an instance with custom prefix, suffix and separator.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param rowPrefix row prefix to use instead of the default \"{\"\n     * @param rowSuffix row suffix to use instead of the default \"}\"\n     * @param rowSeparator tow separator to use instead of the default \";\"\n     * @param columnSeparator column separator to use instead of the default \", \"\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "RealMatrixFormat.getInstance#214",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealMatrixFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
        "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
        "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 214,
        "end_line": 216,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "MatrixUtils.checkMatrixIndex#451",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(org.apache.commons.math3.linear.AnyMatrix, int, int)",
        "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }\n",
        "begin_line": 451,
        "end_line": 456,
        "comment": "\n     * Check if matrix indices are valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code row} or {@code column} is not\n     * a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "MatrixUtils.checkRowIndex#465",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }\n",
        "begin_line": 465,
        "end_line": 472,
        "comment": "\n     * Check if a row index is valid.\n     *\n     * @param m Matrix.\n     * @param row Row index to check.\n     * @throws OutOfRangeException if {@code row} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "MatrixUtils.checkColumnIndex#481",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math3.linear.MatrixUtils",
        "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(org.apache.commons.math3.linear.AnyMatrix, int)",
        "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }\n",
        "begin_line": 481,
        "end_line": 487,
        "comment": "\n     * Check if a column index is valid.\n     *\n     * @param m Matrix.\n     * @param column Column index to check.\n     * @throws OutOfRangeException if {@code column} is not a valid index.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "Array2DRowRealMatrix.getRowDimension#337",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }\n",
        "begin_line": 337,
        "end_line": 340,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of rows of this matrix.\n     *\n     * @return the number of rows.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "Array2DRowRealMatrix.getColumnDimension#343",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/Array2DRowRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
        "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }\n",
        "begin_line": 343,
        "end_line": 346,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of columns of this matrix.\n     *\n     * @return the number of columns.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.2768
        },
        "num_failing_tests": 18
    },
    {
        "name": "MathUtils.checkNotNull#262",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathUtils.java",
        "class_name": "org.apache.commons.math3.util.MathUtils",
        "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 262,
        "end_line": 267,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2759
        },
        "num_failing_tests": 18
    },
    {
        "name": "SimpleValueChecker.converged#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.SimpleValueChecker",
        "signature": "org.apache.commons.math3.optim.SimpleValueChecker.converged(int, org.apache.commons.math3.optim.PointValuePair, org.apache.commons.math3.optim.PointValuePair)",
        "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointValuePair previous,\n                             final PointValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }\n",
        "begin_line": 111,
        "end_line": 127,
        "comment": "\n     * Check if the optimization algorithm has converged considering the\n     * last two points.\n     * This method may be called several time from the same algorithm\n     * iteration with different points. This can be detected by checking the\n     * iteration number at each call if needed. Each time this method is\n     * called, the previous and current point correspond to points with the\n     * same role at each iteration, so they can be compared. As an example,\n     * simplex-based algorithms call this method for all points of the simplex,\n     * not only for the best or worst ones.\n     *\n     * @param iteration Index of current iteration\n     * @param previous Best point in the previous iteration.\n     * @param current Best point in the current iteration.\n     * @return {@code true} if the algorithm has converged.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2759
        },
        "num_failing_tests": 9
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
        "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Construct a vector from an array, copying the input array.\n     *\n     * @param d Array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2715
        },
        "num_failing_tests": 17
    },
    {
        "name": "FastMath.pow#1611",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.pow(double, int)",
        "snippet": "    public static double pow(double d, int e) {\n\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n\n        // split d as two 26 bits numbers\n        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n        final int splitFactor = 0x8000001;\n        final double cd       = splitFactor * d;\n        final double d1High   = cd - (cd - d);\n        final double d1Low    = d - d1High;\n\n        // prepare result\n        double resultHigh = 1;\n        double resultLow  = 0;\n\n        // d^(2p)\n        double d2p     = d;\n        double d2pHigh = d1High;\n        double d2pLow  = d1Low;\n\n        while (e != 0) {\n\n            if ((e & 0x1) != 0) {\n                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n                final double tmpHigh = resultHigh * d2p;\n                final double cRH     = splitFactor * resultHigh;\n                final double rHH     = cRH - (cRH - resultHigh);\n                final double rHL     = resultHigh - rHH;\n                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh = tmpHigh;\n                resultLow  = resultLow * d2p + tmpLow;\n            }\n\n            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH   = splitFactor * d2pHigh;\n            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   = d2pHigh - d2pHH;\n            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     = d2pHigh + d2pLow;\n\n            e = e >> 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }\n",
        "begin_line": 1611,
        "end_line": 1668,
        "comment": "\n     * Raise a double to an int power.\n     *\n     * @param d Number to raise.\n     * @param e Exponent.\n     * @return d<sup>e</sup>\n     * @since 3.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleValueChecker.SimpleValueChecker#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.SimpleValueChecker",
        "signature": "org.apache.commons.math3.optim.SimpleValueChecker.SimpleValueChecker(double, double)",
        "snippet": "    public SimpleValueChecker(final double relativeThreshold,\n                              final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }\n",
        "begin_line": 64,
        "end_line": 68,
        "comment": " Build an instance with specified thresholds.\n     *\n     * In order to perform only relative checks, the absolute tolerance\n     * must be set to a negative value. In order to perform only absolute\n     * checks, the relative tolerance must be set to a negative value.\n     *\n     * @param relativeThreshold relative tolerance threshold\n     * @param absoluteThreshold absolute tolerance threshold\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2656
        },
        "num_failing_tests": 9
    },
    {
        "name": "SimplexOptimizer.SimplexOptimizer#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer(double, double)",
        "snippet": "    public SimplexOptimizer(double rel, double abs) {\n        this(new SimpleValueChecker(rel, abs));\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2646
        },
        "num_failing_tests": 7
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Create an instance with a custom number format for components.\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2632
        },
        "num_failing_tests": 17
    },
    {
        "name": "RealVectorFormat.RealVectorFormat#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(java.lang.String, java.lang.String, java.lang.String, java.text.NumberFormat)",
        "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }\n",
        "begin_line": 105,
        "end_line": 114,
        "comment": "\n     * Create an instance with custom prefix, suffix, separator and format\n     * for components.\n     * @param prefix prefix to use instead of the default \"{\"\n     * @param suffix suffix to use instead of the default \"}\"\n     * @param separator separator to use instead of the default \"; \"\n     * @param format the custom format for components.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2632
        },
        "num_failing_tests": 17
    },
    {
        "name": "RealVectorFormat.getInstance#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
        "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * Returns the default real vector format for the current locale.\n     * @return the default real vector format.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2632
        },
        "num_failing_tests": 17
    },
    {
        "name": "RealVectorFormat.getInstance#170",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/RealVectorFormat.java",
        "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
        "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(java.util.Locale)",
        "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }\n",
        "begin_line": 170,
        "end_line": 172,
        "comment": "\n     * Returns the default real vector format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the real vector format specific to the given locale.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2632
        },
        "num_failing_tests": 17
    },
    {
        "name": "AbstractConvergenceChecker.getAbsoluteThreshold#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.getAbsoluteThreshold()",
        "snippet": "    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }\n",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * @return the absolute threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2485
        },
        "num_failing_tests": 11
    },
    {
        "name": "AbstractConvergenceChecker.getRelativeThreshold#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.getRelativeThreshold()",
        "snippet": "    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * @return the relative threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2467
        },
        "num_failing_tests": 11
    },
    {
        "name": "AbstractSimplex.setPoint#310",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoint(int, org.apache.commons.math3.optim.PointValuePair)",
        "snippet": "    protected void setPoint(int index, PointValuePair point) {\n        if (index < 0 ||\n            index >= simplex.length) {\n            throw new OutOfRangeException(index, 0, simplex.length - 1);\n        }\n        simplex[index] = point;\n    }\n",
        "begin_line": 310,
        "end_line": 316,
        "comment": "\n     * Store a new point at location {@code index}.\n     * Note that no deep-copy of {@code point} is performed.\n     *\n     * @param index Location.\n     * @param point New value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.239
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractConvergenceChecker.AbstractConvergenceChecker#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/AbstractConvergenceChecker.java",
        "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
        "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.AbstractConvergenceChecker(double, double)",
        "snippet": "    public AbstractConvergenceChecker(final double relativeThreshold,\n                                      final double absoluteThreshold) {\n        this.relativeThreshold = relativeThreshold;\n        this.absoluteThreshold = absoluteThreshold;\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Build an instance with a specified thresholds.\n     *\n     * @param relativeThreshold relative tolerance threshold\n     * @param absoluteThreshold absolute tolerance threshold\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.231
        },
        "num_failing_tests": 11
    },
    {
        "name": "NelderMeadSimplex.NelderMeadSimplex#120",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/NelderMeadSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex(double[])",
        "snippet": "    public NelderMeadSimplex(final double[] steps) {\n        this(steps, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n    }\n",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n     * Build a Nelder-Mead simplex with default coefficients.\n     * The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n     * for both gamma and sigma.\n     *\n     * @param steps Steps along the canonical axes representing box edges.\n     * They may be negative but not zero. See\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2279
        },
        "num_failing_tests": 4
    },
    {
        "name": "NelderMeadSimplex.NelderMeadSimplex#136",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/NelderMeadSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex(double[], double, double, double, double)",
        "snippet": "    public NelderMeadSimplex(final double[] steps,\n                             final double rho, final double khi,\n                             final double gamma, final double sigma) {\n        super(steps);\n\n        this.rho = rho;\n        this.khi = khi;\n        this.gamma = gamma;\n        this.sigma = sigma;\n    }\n",
        "begin_line": 136,
        "end_line": 145,
        "comment": "\n     * Build a Nelder-Mead simplex with specified coefficients.\n     *\n     * @param steps Steps along the canonical axes representing box edges.\n     * They may be negative but not zero. See\n     * {@link AbstractSimplex#AbstractSimplex(double[])}.\n     * @param rho Reflection coefficient.\n     * @param khi Expansion coefficient.\n     * @param gamma Contraction coefficient.\n     * @param sigma Shrinkage coefficient.\n     * @throws IllegalArgumentException if one of the steps is zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2279
        },
        "num_failing_tests": 4
    },
    {
        "name": "BaseOptimizer.getEvaluations#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * Gets the number of evaluations of the objective function.\n     * The number of evaluations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2117
        },
        "num_failing_tests": 8
    },
    {
        "name": "BracketFinder.search#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.search(org.apache.commons.math3.analysis.UnivariateFunction, org.apache.commons.math3.optim.nonlinear.scalar.GoalType, double, double)",
        "snippet": "    public void search(UnivariateFunction func, GoalType goal, double xA, double xB) {\n        evaluations.resetCount();\n        final boolean isMinim = goal == GoalType.MINIMIZE;\n\n        double fA = eval(func, xA);\n        double fB = eval(func, xB);\n        if (isMinim ?\n            fA < fB :\n            fA > fB) {\n\n            double tmp = xA;\n            xA = xB;\n            xB = tmp;\n\n            tmp = fA;\n            fA = fB;\n            fB = tmp;\n        }\n\n        double xC = xB + GOLD * (xB - xA);\n        double fC = eval(func, xC);\n\n        while (isMinim ? fC < fB : fC > fB) {\n            double tmp1 = (xB - xA) * (fB - fC);\n            double tmp2 = (xB - xC) * (fB - fA);\n\n            double val = tmp2 - tmp1;\n            double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val;\n\n            double w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom;\n            double wLim = xB + growLimit * (xC - xB);\n\n            double fW;\n            if ((w - xC) * (xB - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xA = xB;\n                    xB = w;\n                    fA = fB;\n                    fB = fW;\n                    break;\n                } else if (isMinim ?\n                           fW > fB :\n                           fW < fB) {\n                    xC = w;\n                    fC = fW;\n                    break;\n                }\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            } else if ((w - wLim) * (wLim - xC) >= 0) {\n                w = wLim;\n                fW = eval(func, w);\n            } else if ((w - wLim) * (xC - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xB = xC;\n                    xC = w;\n                    w = xC + GOLD * (xC - xB);\n                    fB = fC;\n                    fC =fW;\n                    fW = eval(func, w);\n                }\n            } else {\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            }\n\n            xA = xB;\n            fA = fB;\n            xB = xC;\n            fB = fC;\n            xC = w;\n            fC = fW;\n        }\n\n        lo = xA;\n        fLo = fA;\n        mid = xB;\n        fMid = fB;\n        hi = xC;\n        fHi = fC;\n\n        if (lo > hi) {\n            double tmp = lo;\n            lo = hi;\n            hi = tmp;\n\n            tmp = fLo;\n            fLo = fHi;\n            fHi = tmp;\n        }\n    }\n",
        "begin_line": 112,
        "end_line": 208,
        "comment": "\n     * Search new points that bracket a local optimum of the function.\n     *\n     * @param func Function whose optimum should be bracketed.\n     * @param goal {@link GoalType Goal type}.\n     * @param xA Initial point.\n     * @param xB Initial point.\n     * @throws TooManyEvaluationsException if the maximum number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sinc.value#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/Sinc.java",
        "class_name": "org.apache.commons.math3.analysis.function.Sinc",
        "signature": "org.apache.commons.math3.analysis.function.Sinc.value(double)",
        "snippet": "    public double value(final double x) {\n        final double scaledX = normalized ? FastMath.PI * x : x;\n        if (FastMath.abs(scaledX) <= SHORTCUT) {\n            // use Taylor series\n            final double scaledX2 = scaledX * scaledX;\n            return ((scaledX2 - 20) * scaledX2 + 120) / 120;\n        } else {\n            // use definition expression\n            return FastMath.sin(scaledX) / scaledX;\n        }\n    }\n",
        "begin_line": 86,
        "end_line": 96,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.DifferentiableUnivariateFunction": null,
            "org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction": null,
            "org.apache.commons.math3.analysis.UnivariateFunction": "\n     * Compute the value of the function.\n     *\n     * @param x Point at which the function value should be computed.\n     * @return the value of the function.\n     * @throws IllegalArgumentException when the activated method itself can\n     * ascertain that a precondition, specified in the API expressed at the\n     * level of the activated method, has been violated.\n     * When Commons Math throws an {@code IllegalArgumentException}, it is\n     * usually the consequence of checking the actual parameters passed to\n     * the method.\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "NelderMeadSimplex.iterate#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/NelderMeadSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.iterate(org.apache.commons.math3.analysis.MultivariateFunction, java.util.Comparator<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    @Override\n    public void iterate(final MultivariateFunction evaluationFunction,\n                        final Comparator<PointValuePair> comparator) {\n        // The simplex has n + 1 points if dimension is n.\n        final int n = getDimension();\n\n        // Interesting values.\n        final PointValuePair best = getPoint(0);\n        final PointValuePair secondBest = getPoint(n - 1);\n        final PointValuePair worst = getPoint(n);\n        final double[] xWorst = worst.getPointRef();\n\n        // Compute the centroid of the best vertices (dismissing the worst\n        // point at index n).\n        final double[] centroid = new double[n];\n        for (int i = 0; i < n; i++) {\n            final double[] x = getPoint(i).getPointRef();\n            for (int j = 0; j < n; j++) {\n                centroid[j] += x[j];\n            }\n        }\n        final double scaling = 1.0 / n;\n        for (int j = 0; j < n; j++) {\n            centroid[j] *= scaling;\n        }\n\n        // compute the reflection point\n        final double[] xR = new double[n];\n        for (int j = 0; j < n; j++) {\n            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n        }\n        final PointValuePair reflected\n            = new PointValuePair(xR, evaluationFunction.value(xR), false);\n\n        if (comparator.compare(best, reflected) <= 0 &&\n            comparator.compare(reflected, secondBest) < 0) {\n            // Accept the reflected point.\n            replaceWorstPoint(reflected, comparator);\n        } else if (comparator.compare(reflected, best) < 0) {\n            // Compute the expansion point.\n            final double[] xE = new double[n];\n            for (int j = 0; j < n; j++) {\n                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n            }\n            final PointValuePair expanded\n                = new PointValuePair(xE, evaluationFunction.value(xE), false);\n\n            if (comparator.compare(expanded, reflected) < 0) {\n                // Accept the expansion point.\n                replaceWorstPoint(expanded, comparator);\n            } else {\n                // Accept the reflected point.\n                replaceWorstPoint(reflected, comparator);\n            }\n        } else {\n            if (comparator.compare(reflected, worst) < 0) {\n                // Perform an outside contraction.\n                final double[] xC = new double[n];\n                for (int j = 0; j < n; j++) {\n                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                }\n                final PointValuePair outContracted\n                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n                if (comparator.compare(outContracted, reflected) <= 0) {\n                    // Accept the contraction point.\n                    replaceWorstPoint(outContracted, comparator);\n                    return;\n                }\n            } else {\n                // Perform an inside contraction.\n                final double[] xC = new double[n];\n                for (int j = 0; j < n; j++) {\n                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                }\n                final PointValuePair inContracted\n                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n\n                if (comparator.compare(inContracted, worst) < 0) {\n                    // Accept the contraction point.\n                    replaceWorstPoint(inContracted, comparator);\n                    return;\n                }\n            }\n\n            // Perform a shrink.\n            final double[] xSmallest = getPoint(0).getPointRef();\n            for (int i = 1; i <= n; i++) {\n                final double[] x = getPoint(i).getPoint();\n                for (int j = 0; j < n; j++) {\n                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n                }\n                setPoint(i, new PointValuePair(x, Double.NaN, false));\n            }\n            evaluate(evaluationFunction, comparator);\n        }\n    }\n",
        "begin_line": 185,
        "end_line": 280,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex": "\n     * Compute the next simplex of the algorithm.\n     *\n     * @param evaluationFunction Evaluation function.\n     * @param comparator Comparator to use to sort simplex vertices from best\n     * to worst.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the algorithm fails to converge.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1782
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractSimplex.replaceWorstPoint#266",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/AbstractSimplex.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.replaceWorstPoint(org.apache.commons.math3.optim.PointValuePair, java.util.Comparator<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    protected void replaceWorstPoint(PointValuePair pointValuePair,\n                                     final Comparator<PointValuePair> comparator) {\n        for (int i = 0; i < dimension; i++) {\n            if (comparator.compare(simplex[i], pointValuePair) > 0) {\n                PointValuePair tmp = simplex[i];\n                simplex[i] = pointValuePair;\n                pointValuePair = tmp;\n            }\n        }\n        simplex[dimension] = pointValuePair;\n    }\n",
        "begin_line": 266,
        "end_line": 276,
        "comment": "\n     * Replace the worst point of the simplex by a new point.\n     *\n     * @param pointValuePair Point to insert.\n     * @param comparator Comparator to use for sorting the simplex vertices\n     * from best to worst.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 4
    },
    {
        "name": "PowellOptimizer.PowellOptimizer#164",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double, double, double, double)",
        "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs) {\n        this(rel, abs, lineRel, lineAbs, null);\n    }\n",
        "begin_line": 164,
        "end_line": 169,
        "comment": "\n     * Builds an instance with the default convergence checking procedure.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.doOptimize#172",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }\n",
        "begin_line": 172,
        "end_line": 268,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sinc.Sinc#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/Sinc.java",
        "class_name": "org.apache.commons.math3.analysis.function.Sinc",
        "signature": "org.apache.commons.math3.analysis.function.Sinc.Sinc()",
        "snippet": "    public Sinc() {\n        this(false);\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * The sinc function, {@code sin(x) / x}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "Sinc.Sinc#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/function/Sinc.java",
        "class_name": "org.apache.commons.math3.analysis.function.Sinc",
        "signature": "org.apache.commons.math3.analysis.function.Sinc.Sinc(boolean)",
        "snippet": "    public Sinc(boolean normalized) {\n        this.normalized = normalized;\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Instantiates the sinc function.\n     *\n     * @param normalized If {@code true}, the function is\n     * <code> sin(&pi;x) / &pi;x</code>, otherwise {@code sin(x) / x}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "CMAESOptimizer.updateCovarianceDiagonalOnly#669",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovarianceDiagonalOnly(boolean, org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void updateCovarianceDiagonalOnly(boolean hsig,\n                                              final RealMatrix bestArz) {\n        // minor correction if hsig==false\n        double oldFac = hsig ? 0 : ccov1Sep * cc * (2 - cc);\n        oldFac += 1 - ccov1Sep - ccovmuSep;\n        diagC = diagC.scalarMultiply(oldFac) // regard old matrix\n            .add(square(pc).scalarMultiply(ccov1Sep)) // plus rank one update\n            .add((times(diagC, square(bestArz).multiply(weights))) // plus rank mu update\n                 .scalarMultiply(ccovmuSep));\n        diagD = sqrt(diagC); // replaces eig(C)\n        if (diagonalOnly > 1 &&\n            iterations > diagonalOnly) {\n            // full covariance matrix from now on\n            diagonalOnly = 0;\n            B = eye(dimension, dimension);\n            BD = diag(diagD);\n            C = diag(diagC);\n        }\n    }\n",
        "begin_line": 669,
        "end_line": 687,
        "comment": "\n     * Update of the covariance matrix C for diagonalOnly > 0\n     *\n     * @param hsig Flag indicating a small correction.\n     * @param bestArz Fitness-sorted matrix of the gaussian random values of the\n     * current offspring.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1091
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.getLo#228",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getLo()",
        "snippet": "    public double getLo() {\n        return lo;\n    }\n",
        "begin_line": 228,
        "end_line": 230,
        "comment": "\n     * @return the lower bound of the bracket.\n     * @see #getFLo()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.getHi#244",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getHi()",
        "snippet": "    public double getHi() {\n        return hi;\n    }\n",
        "begin_line": 244,
        "end_line": 246,
        "comment": "\n     * @return the higher bound of the bracket.\n     * @see #getFHi()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.getMid#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getMid()",
        "snippet": "    public double getMid() {\n        return mid;\n    }\n",
        "begin_line": 260,
        "end_line": 262,
        "comment": "\n     * @return a point in the middle of the bracket.\n     * @see #getFMid()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.eval#279",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.eval(org.apache.commons.math3.analysis.UnivariateFunction, double)",
        "snippet": "    private double eval(UnivariateFunction f, double x) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return f.value(x);\n    }\n",
        "begin_line": 279,
        "end_line": 286,
        "comment": "\n     * @param f Function.\n     * @param x Argument.\n     * @return {@code f(x)}\n     * @throws TooManyEvaluationsException if the maximal number of evaluations is\n     * exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.search#344",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch.search(double[], double[])",
        "snippet": "        public UnivariatePointValuePair search(final double[] p, final double[] d) {\n            final int n = p.length;\n            final UnivariateFunction f = new UnivariateFunction() {\n                    public double value(double alpha) {\n                        final double[] x = new double[n];\n                        for (int i = 0; i < n; i++) {\n                            x[i] = p[i] + alpha * d[i];\n                        }\n                        final double obj = PowellOptimizer.this.computeObjectiveValue(x);\n                        return obj;\n                    }\n                };\n\n            final GoalType goal = PowellOptimizer.this.getGoalType();\n            bracket.search(f, goal, 0, 1);\n            // Passing \"MAX_VALUE\" as a dummy value because it is the enclosing\n            // class that counts the number of evaluations (and will eventually\n            // generate the exception).\n            return optimize(new MaxEval(Integer.MAX_VALUE),\n                            new UnivariateObjectiveFunction(f),\n                            goal,\n                            new SearchInterval(bracket.getLo(),\n                                               bracket.getHi(),\n                                               bracket.getMid()));\n        }\n",
        "begin_line": 344,
        "end_line": 368,
        "comment": "\n         * Find the minimum of the function {@code f(p + alpha * d)}.\n         *\n         * @param p Starting point.\n         * @param d Search direction.\n         * @return the optimum.\n         * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n         * if the number of evaluations is exceeded.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.value#347",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch.Anonymous-d794245a-2cda-4503-becc-376a172a3283.value(double)",
        "snippet": "                    public double value(double alpha) {\n                        final double[] x = new double[n];\n                        for (int i = 0; i < n; i++) {\n                            x[i] = p[i] + alpha * d[i];\n                        }\n                        final double obj = PowellOptimizer.this.computeObjectiveValue(x);\n                        return obj;\n                    }\n",
        "begin_line": 347,
        "end_line": 354,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.PowellOptimizer#98",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double, double, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        this(rel, abs, FastMath.sqrt(rel), FastMath.sqrt(abs), checker);\n    }\n",
        "begin_line": 98,
        "end_line": 102,
        "comment": "\n     * This constructor allows to specify a user-defined convergence checker,\n     * in addition to the parameters that control the default convergence\n     * checking procedure.\n     * <br/>\n     * The internal line search tolerances are set to the square-root of their\n     * corresponding value in the multivariate optimizer.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Convergence checker.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.PowellOptimizer#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double, double)",
        "snippet": "    public PowellOptimizer(double rel,\n                           double abs) {\n        this(rel, abs, null);\n    }\n",
        "begin_line": 149,
        "end_line": 152,
        "comment": "\n     * The parameters control the default convergence checking procedure.\n     * <br/>\n     * The internal line search tolerances are set to the square-root of their\n     * corresponding value in the multivariate optimizer.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.newPointAndDirection#280",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.newPointAndDirection(double[], double[], double)",
        "snippet": "    private double[][] newPointAndDirection(double[] p,\n                                            double[] d,\n                                            double optimum) {\n        final int n = p.length;\n        final double[] nP = new double[n];\n        final double[] nD = new double[n];\n        for (int i = 0; i < n; i++) {\n            nD[i] = d[i] * optimum;\n            nP[i] = p[i] + nD[i];\n        }\n\n        final double[][] result = new double[2][];\n        result[0] = nP;\n        result[1] = nD;\n\n        return result;\n    }\n",
        "begin_line": 280,
        "end_line": 296,
        "comment": "\n     * Compute a new point (in the original space) and a new direction\n     * vector, resulting from the line search.\n     *\n     * @param p Point used in the line search.\n     * @param d Direction used in the line search.\n     * @param optimum Optimum found by the line search.\n     * @return a 2-element array containing the new point (at index 0) and\n     * the new direction (at index 1).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.checkParameters#375",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }\n",
        "begin_line": 375,
        "end_line": 380,
        "comment": "\n     * @throws MathUnsupportedOperationException if bounds were passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) throws MaxCountExceededException {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 61,
        "end_line": 69,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 2
    },
    {
        "name": "Incrementor.Incrementor#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleUnivariateValueChecker.converged#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker",
        "signature": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker.converged(int, org.apache.commons.math3.optim.univariate.UnivariatePointValuePair, org.apache.commons.math3.optim.univariate.UnivariatePointValuePair)",
        "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final UnivariatePointValuePair previous,\n                             final UnivariatePointValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }\n",
        "begin_line": 113,
        "end_line": 129,
        "comment": "\n     * Check if the optimization algorithm has converged considering the\n     * last two points.\n     * This method may be called several time from the same algorithm\n     * iteration with different points. This can be detected by checking the\n     * iteration number at each call if needed. Each time this method is\n     * called, the previous and current point correspond to points with the\n     * same role at each iteration, so they can be compared. As an example,\n     * simplex-based algorithms call this method for all points of the simplex,\n     * not only for the best or worst ones.\n     *\n     * @param iteration Index of current iteration\n     * @param previous Best point in the previous iteration.\n     * @param current Best point in the current iteration.\n     * @return {@code true} if the algorithm has converged.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.doOptimize#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(previous,\n                                 current,\n                                 isMinim),\n                            isMinim);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return best(best,\n                            best(previous,\n                                 current,\n                                 isMinim),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
        "begin_line": 114,
        "end_line": 288,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.univariate.UnivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.BracketFinder#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.BracketFinder()",
        "snippet": "    public BracketFinder() {\n        this(100, 50);\n    }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "\n     * Constructor with default values {@code 100, 50} (see the\n     * {@link #BracketFinder(double,int) other constructor}).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketFinder.BracketFinder#89",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BracketFinder.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
        "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.BracketFinder(double, int)",
        "snippet": "    public BracketFinder(double growLimit,\n                         int maxEvaluations) {\n        if (growLimit <= 0) {\n            throw new NotStrictlyPositiveException(growLimit);\n        }\n        if (maxEvaluations <= 0) {\n            throw new NotStrictlyPositiveException(maxEvaluations);\n        }\n\n        this.growLimit = growLimit;\n        evaluations.setMaximalCount(maxEvaluations);\n    }\n",
        "begin_line": 89,
        "end_line": 100,
        "comment": "\n     * Create a bracketing interval finder.\n     *\n     * @param growLimit Expanding factor.\n     * @param maxEvaluations Maximum number of evaluations allowed for finding\n     * a bracketing interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.LineSearch#328",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.LineSearch.LineSearch(double, double)",
        "snippet": "        LineSearch(double rel,\n                   double abs) {\n            super(REL_TOL_UNUSED,\n                  ABS_TOL_UNUSED,\n                  new SimpleUnivariateValueChecker(rel, abs));\n        }\n",
        "begin_line": 328,
        "end_line": 333,
        "comment": "\n         * The \"BrentOptimizer\" default stopping criterion uses the tolerances\n         * to check the domain (point) values, not the function values.\n         * We thus create a custom checker to use function values.\n         *\n         * @param rel Relative threshold.\n         * @param abs Absolute threshold.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "PowellOptimizer.PowellOptimizer#117",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double, double, double, double, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n\n        // Create the line search optimizer.\n        line = new LineSearch(lineRel,\n                              lineAbs);\n    }\n",
        "begin_line": 117,
        "end_line": 136,
        "comment": "\n     * This constructor allows to specify a user-defined convergence checker,\n     * in addition to the parameters that control the default convergence\n     * checking procedure and the line search tolerances.\n     *\n     * @param rel Relative threshold for this optimizer.\n     * @param abs Absolute threshold for this optimizer.\n     * @param lineRel Relative threshold for the internal line search optimizer.\n     * @param lineAbs Absolute threshold for the internal line search optimizer.\n     * @param checker Convergence checker.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "SimpleUnivariateValueChecker.SimpleUnivariateValueChecker#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker",
        "signature": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker.SimpleUnivariateValueChecker(double, double)",
        "snippet": "    public SimpleUnivariateValueChecker(final double relativeThreshold,\n                                        final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }\n",
        "begin_line": 66,
        "end_line": 70,
        "comment": " Build an instance with specified thresholds.\n     *\n     * In order to perform only relative checks, the absolute tolerance\n     * must be set to a negative value. In order to perform only absolute\n     * checks, the relative tolerance must be set to a negative value.\n     *\n     * @param relativeThreshold relative tolerance threshold\n     * @param absoluteThreshold absolute tolerance threshold\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#243",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Precision.java",
        "class_name": "org.apache.commons.math3.util.Precision",
        "signature": "org.apache.commons.math3.util.Precision.equals(double, double)",
        "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n",
        "begin_line": 243,
        "end_line": 245,
        "comment": "\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0702
        },
        "num_failing_tests": 2
    },
    {
        "name": "FastMath.min#3463",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.min(double, double)",
        "snippet": "    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n",
        "begin_line": 3463,
        "end_line": 3481,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.063
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#748",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
        "snippet": "     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n",
        "begin_line": 748,
        "end_line": 750,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathArrays.copyOf#776",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java",
        "class_name": "org.apache.commons.math3.util.MathArrays",
        "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[], int)",
        "snippet": "    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n",
        "begin_line": 776,
        "end_line": 780,
        "comment": "\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.brent#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.brent(double, double, double, double)",
        "snippet": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\n                    q = -q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }\n",
        "begin_line": 142,
        "end_line": 233,
        "comment": "\n     * Search for a zero inside the provided interval.\n     * This implementation is based on the algorithm described at page 58 of\n     * the book\n     * <quote>\n     *  <b>Algorithms for Minimization Without Derivatives</b>\n     *  <it>Richard P. Brent</it>\n     *  Dover 0-486-41998-3\n     * </quote>\n     *\n     * @param lo Lower bound of the search interval.\n     * @param hi Higher bound of the search interval.\n     * @param fLo Function value at the lower bound of the search interval.\n     * @param fHi Function value at the higher bound of the search interval.\n     * @return the value where the function is zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer#69",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer(org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.Formula, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\n                                               ConvergenceChecker<PointValuePair> checker) {\n        this(updateFormula,\n             checker,\n             new BrentSolver(),\n             new IdentityPreconditioner());\n    }\n",
        "begin_line": 69,
        "end_line": 75,
        "comment": "\n     * Constructor with default {@link BrentSolver line search solver} and\n     * {@link IdentityPreconditioner preconditioner}.\n     *\n     * @param updateFormula formula to use for updating the &beta; parameter,\n     * must be one of {@link Formula#FLETCHER_REEVES} or\n     * {@link Formula#POLAK_RIBIERE}.\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.057
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.precondition#345",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.IdentityPreconditioner.precondition(double[], double[])",
        "snippet": "        public double[] precondition(double[] variables, double[] r) {\n            return r.clone();\n        }\n",
        "begin_line": 345,
        "end_line": 347,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.scalar.gradient.Preconditioner": "\n     * Precondition a search direction.\n     * <p>\n     * The returned preconditioned search direction must be computed fast or\n     * the algorithm performances will drop drastically. A classical approach\n     * is to compute only the diagonal elements of the hessian and to divide\n     * the raw search direction by these elements if they are all positive.\n     * If at least one of them is negative, it is safer to return a clone of\n     * the raw search direction as if the hessian was the identity matrix. The\n     * rationale for this simplified choice is that a negative diagonal element\n     * means the current point is far from the optimum and preconditioning will\n     * not be efficient anyway in this case.\n     * </p>\n     * @param point current point at which the search direction was computed\n     * @param r raw search direction (i.e. opposite of the gradient)\n     * @return approximation of H<sup>-1</sup>r where H is the objective function hessian\n     ",
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.doOptimize#191",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n            if (iter % n == 0 ||\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }\n",
        "begin_line": 191,
        "end_line": 288,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.BrentSolver#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.BrentSolver()",
        "snippet": "    public BrentSolver() {\n        this(DEFAULT_ABSOLUTE_ACCURACY);\n    }\n",
        "begin_line": 46,
        "end_line": 48,
        "comment": "\n     * Construct a solver with default accuracy (1e-6).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.BrentSolver#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.BrentSolver(double)",
        "snippet": "    public BrentSolver(double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "\n     * Construct a solver.\n     *\n     * @param absoluteAccuracy Absolute accuracy.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentSolver.doSolve#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BrentSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.doSolve()",
        "snippet": "    @Override\n    protected double doSolve()\n        throws NoBracketingException,\n               TooManyEvaluationsException,\n               NumberIsTooLargeException {\n        double min = getMin();\n        double max = getMax();\n        final double initial = getStartValue();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        verifySequence(min, initial, max);\n\n        // Return the initial guess if it is good enough.\n        double yInitial = computeObjectiveValue(initial);\n        if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n            return initial;\n        }\n\n        // Return the first endpoint if it is good enough.\n        double yMin = computeObjectiveValue(min);\n        if (FastMath.abs(yMin) <= functionValueAccuracy) {\n            return min;\n        }\n\n        // Reduce interval if min and initial bracket the root.\n        if (yInitial * yMin < 0) {\n            return brent(min, initial, yMin, yInitial);\n        }\n\n        // Return the second endpoint if it is good enough.\n        double yMax = computeObjectiveValue(max);\n        if (FastMath.abs(yMax) <= functionValueAccuracy) {\n            return max;\n        }\n\n        // Reduce interval if initial and max bracket the root.\n        if (yInitial * yMax < 0) {\n            return brent(initial, max, yInitial, yMax);\n        }\n\n        throw new NoBracketingException(min, max, yMin, yMax);\n    }\n",
        "begin_line": 83,
        "end_line": 124,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver": null,
            "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the root.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the initial search interval does not bracket\n     * a root and the solver requires it.\n     ",
            "org.apache.commons.math3.analysis.solvers.UnivariateSolver": null,
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": null
        },
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver#66",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double)",
        "snippet": "    protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\n        this(DEFAULT_RELATIVE_ACCURACY,\n             absoluteAccuracy,\n             DEFAULT_FUNCTION_VALUE_ACCURACY);\n    }\n",
        "begin_line": 66,
        "end_line": 70,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateSolver.AbstractUnivariateSolver#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver(double)",
        "snippet": "    protected AbstractUnivariateSolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.LineSearchFunction#370",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.LineSearchFunction.LineSearchFunction(double[], double[])",
        "snippet": "        public LineSearchFunction(double[] point,\n                                  double[] direction) {\n            currentPoint = point.clone();\n            searchDirection = direction.clone();\n        }\n",
        "begin_line": 370,
        "end_line": 374,
        "comment": "\n         * @param point Current point.\n         * @param direction Search direction.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.value#377",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.LineSearchFunction.value(double)",
        "snippet": "        public double value(double x) {\n            // current point in the search direction\n            final double[] shiftedPoint = currentPoint.clone();\n            for (int i = 0; i < shiftedPoint.length; ++i) {\n                shiftedPoint[i] += x * searchDirection[i];\n            }\n\n            // gradient of the objective function\n            final double[] gradient = computeObjectiveGradient(shiftedPoint);\n\n            // dot product with the search direction\n            double dotProduct = 0;\n            for (int i = 0; i < gradient.length; ++i) {\n                dotProduct += gradient[i] * searchDirection[i];\n            }\n\n            return dotProduct;\n        }\n",
        "begin_line": 377,
        "end_line": 394,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer": null,
            "org.apache.commons.math3.analysis.UnivariateFunction": "\n     * Compute the value of the function.\n     *\n     * @param x Point at which the function value should be computed.\n     * @return the value of the function.\n     * @throws IllegalArgumentException when the activated method itself can\n     * ascertain that a precondition, specified in the API expressed at the\n     * level of the activated method, has been violated.\n     * When Commons Math throws an {@code IllegalArgumentException}, it is\n     * usually the consequence of checking the actual parameters passed to\n     * the method.\n     ",
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": null
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.parseOptimizationData#300",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if  (data instanceof BracketingStep) {\n                initialStep = ((BracketingStep) data).getBracketingStep();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n\n        checkParameters();\n    }\n",
        "begin_line": 300,
        "end_line": 317,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link BracketingStep}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.findUpperBound#328",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.findUpperBound(org.apache.commons.math3.analysis.UnivariateFunction, double, double)",
        "snippet": "    private double findUpperBound(final UnivariateFunction f,\n                                  final double a, final double h) {\n        final double yA = f.value(a);\n        double yB = yA;\n        for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n            final double b = a + step;\n            yB = f.value(b);\n            if (yA * yB <= 0) {\n                return b;\n            }\n        }\n        throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n    }\n",
        "begin_line": 328,
        "end_line": 340,
        "comment": "\n     * Finds the upper bound b ensuring bracketing of a root between a and b.\n     *\n     * @param f function whose root must be bracketed.\n     * @param a lower bound of the interval.\n     * @param h initial step to try.\n     * @return b such that f(a) and f(b) have opposite signs.\n     * @throws MathIllegalStateException if no bracket can be found.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.checkParameters#401",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }\n",
        "begin_line": 401,
        "end_line": 406,
        "comment": "\n     * @throws MathUnsupportedOperationException if bounds were passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "GradientMultivariateOptimizer.computeObjectiveGradient#53",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.computeObjectiveGradient(double[])",
        "snippet": "    protected double[] computeObjectiveGradient(final double[] params) {\n        return gradient.value(params);\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Compute the gradient vector.\n     *\n     * @param params Point at which the gradient must be evaluated.\n     * @return the gradient at the specified point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateSolverUtils.verifyInterval#350",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
        "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifyInterval(double, double)",
        "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper)\n        throws NumberIsTooLargeException {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }\n",
        "begin_line": 350,
        "end_line": 357,
        "comment": "\n     * Check that the endpoints specify an interval.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateSolverUtils.verifySequence#368",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/UnivariateSolverUtils.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
        "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifySequence(double, double, double)",
        "snippet": "    public static void verifySequence(final double lower,\n                                      final double initial,\n                                      final double upper)\n        throws NumberIsTooLargeException {\n        verifyInterval(lower, initial);\n        verifyInterval(initial, upper);\n    }\n",
        "begin_line": 368,
        "end_line": 374,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n     * {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getEvaluations#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n",
        "begin_line": 105,
        "end_line": 107,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Get the number of evaluations of the objective function.\n     * The number of evaluations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getMin#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getMax#117",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 117,
        "end_line": 119,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getStartValue#123",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getAbsoluteAccuracy#129",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 129,
        "end_line": 131,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Get the absolute accuracy of the solver.  Solutions returned by the\n     * solver should be accurate to this tolerance, i.e., if &epsilon; is the\n     * absolute accuracy of the solver and {@code v} is a value returned by\n     * one of the {@code solve} methods, then a root of the function should\n     * exist somewhere in the interval ({@code v} - &epsilon;, {@code v} + &epsilon;).\n     *\n     * @return the absolute accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getRelativeAccuracy#135",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 135,
        "end_line": 137,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Get the relative accuracy of the solver.  The contract for relative\n     * accuracy is the same as {@link #getAbsoluteAccuracy()}, but using\n     * relative, rather than absolute error.  If &rho; is the relative accuracy\n     * configured for a solver and {@code v} is a value returned, then a root\n     * of the function should exist somewhere in the interval\n     * ({@code v} - &rho; {@code v}, {@code v} + &rho; {@code v}).\n     *\n     * @return the relative accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.getFunctionValueAccuracy#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getFunctionValueAccuracy()",
        "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Get the function value accuracy of the solver.  If {@code v} is\n     * a value returned by the solver for a function {@code f},\n     * then by contract, {@code |f(v)|} should be less than or equal to\n     * the function value accuracy configured for the solver.\n     *\n     * @return the function value accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.computeObjectiveValue#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }\n",
        "begin_line": 153,
        "end_line": 157,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.setup#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.setup(int, FUNC, double, double, double)",
        "snippet": "    protected void setup(int maxEval,\n                         FUNC f,\n                         double min, double max,\n                         double startValue)\n        throws NullArgumentException {\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 171,
        "end_line": 186,
        "comment": "\n     * Prepare for computation.\n     * Subclasses must call this method if they override any of the\n     * {@code solve} methods.\n     *\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of evaluations.\n     * @exception NullArgumentException if f is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.solve#189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.solve(int, FUNC, double, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max, double startValue)\n        throws TooManyEvaluationsException,\n               NoBracketingException {\n        // Initialization.\n        setup(maxEval, f, min, max, startValue);\n\n        // Perform computation.\n        return doSolve();\n    }\n",
        "begin_line": 189,
        "end_line": 197,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.analysis.solvers.BaseUnivariateSolver": "\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a value where the function is zero.\n     * @throws MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.verifySequence#273",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.verifySequence(double, double, double)",
        "snippet": "    protected void verifySequence(final double lower,\n                                  final double initial,\n                                  final double upper)\n        throws NumberIsTooLargeException {\n        UnivariateSolverUtils.verifySequence(lower, initial, upper);\n    }\n",
        "begin_line": 273,
        "end_line": 278,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n     * {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.incrementEvaluationCount#307",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount()\n        throws TooManyEvaluationsException {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }\n",
        "begin_line": 307,
        "end_line": 314,
        "comment": "\n     * Increment the evaluation count by one.\n     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n     * It is provided for subclasses that do not exclusively use\n     * {@code computeObjectiveValue} to solve the function.\n     * See e.g. {@link AbstractUnivariateDifferentiableSolver}.\n     *\n     * @throws TooManyEvaluationsException when the allowed number of function\n     * evaluations has been exhausted.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(double[][])",
        "snippet": "    public BlockRealMatrix(final double[][] rawData)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }\n",
        "begin_line": 125,
        "end_line": 128,
        "comment": "\n     * Create a new dense matrix copying entries from raw layout data.\n     * <p>The input array <em>must</em> already be in raw layout.</p>\n     * <p>Calling this constructor is equivalent to call:\n     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n     *                                   toBlocksLayout(rawData), false);</pre>\n     * </p>\n     *\n     * @param rawData data for new matrix, in raw layout\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.toBlocksLayout#201",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.toBlocksLayout(double[][])",
        "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException {\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }\n",
        "begin_line": 201,
        "end_line": 243,
        "comment": "\n     * Convert a data array from raw layout to blocks layout.\n     * <p>\n     * Raw layout is the straightforward layout where element at row i and\n     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n     * is split in square blocks (except at right and bottom side where blocks may\n     * be rectangular to fit matrix size) and each block is stored in a flattened\n     * one-dimensional array.\n     * </p>\n     * <p>\n     * This method creates an array in blocks layout from an input array in raw layout.\n     * It can be used to provide the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rawData Data array in raw layout.\n     * @return a new data array containing the same entries but in blocks layout.\n     * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n     * @see #createBlocksLayout(int, int)\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 2
    },
    {
        "name": "BrentOptimizer.best#301",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.best(org.apache.commons.math3.optim.univariate.UnivariatePointValuePair, org.apache.commons.math3.optim.univariate.UnivariatePointValuePair, boolean)",
        "snippet": "    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                          UnivariatePointValuePair b,\n                                          boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n\n        if (isMinim) {\n            return a.getValue() <= b.getValue() ? a : b;\n        } else {\n            return a.getValue() >= b.getValue() ? a : b;\n        }\n    }\n",
        "begin_line": 301,
        "end_line": 316,
        "comment": "\n     * Selects the best of two points.\n     *\n     * @param a Point and value.\n     * @param b Point and value.\n     * @param isMinim {@code true} if the selected point must be the one with\n     * the lowest value.\n     * @return the best point, or {@code null} if {@code a} and {@code b} are\n     * both {@code null}. When {@code a} and {@code b} have the same function\n     * value, {@code a} is returned.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer(org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.Formula, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>, org.apache.commons.math3.analysis.solvers.UnivariateSolver, org.apache.commons.math3.optim.nonlinear.scalar.gradient.Preconditioner)",
        "snippet": "    public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\n                                               ConvergenceChecker<PointValuePair> checker,\n                                               final UnivariateSolver lineSearchSolver,\n                                               final Preconditioner preconditioner) {\n        super(checker);\n\n        this.updateFormula = updateFormula;\n        solver = lineSearchSolver;\n        this.preconditioner = preconditioner;\n        initialStep = 1;\n    }\n",
        "begin_line": 158,
        "end_line": 168,
        "comment": "\n     * @param updateFormula formula to use for updating the &beta; parameter,\n     * must be one of {@link Formula#FLETCHER_REEVES} or\n     * {@link Formula#POLAK_RIBIERE}.\n     * @param checker Convergence checker.\n     * @param lineSearchSolver Solver to use during line search.\n     * @param preconditioner Preconditioner.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "NonLinearConjugateGradientOptimizer.optimize#183",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 183,
        "end_line": 188,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * GradientMultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link BracketingStep}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations (of the objective function) is exceeded.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectiveFunctionGradient.ObjectiveFunctionGradient#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunctionGradient.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient.ObjectiveFunctionGradient(org.apache.commons.math3.analysis.MultivariateVectorFunction)",
        "snippet": "    public ObjectiveFunctionGradient(MultivariateVectorFunction g) {\n        gradient = g;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param g Gradient of the function to be optimized.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectiveFunctionGradient.getObjectiveFunctionGradient#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/ObjectiveFunctionGradient.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient.getObjectiveFunctionGradient()",
        "snippet": "    public MultivariateVectorFunction getObjectiveFunctionGradient() {\n        return gradient;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the gradient of the function to be optimized.\n     *\n     * @return the objective function gradient.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "GradientMultivariateOptimizer.GradientMultivariateOptimizer#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.GradientMultivariateOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair>)",
        "snippet": "    protected GradientMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "GradientMultivariateOptimizer.optimize#70",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 70,
        "end_line": 75,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * MultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link ObjectiveFunctionGradient}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations (of the objective function) is exceeded.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "GradientMultivariateOptimizer.parseOptimizationData#87",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/GradientMultivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if  (data instanceof ObjectiveFunctionGradient) {\n                gradient = ((ObjectiveFunctionGradient) data).getObjectiveFunctionGradient();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }\n",
        "begin_line": 87,
        "end_line": 102,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link ObjectiveFunctionGradient}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(int, int)",
        "snippet": "    public BlockRealMatrix(final int rows, final int columns)\n        throws NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n    }\n",
        "begin_line": 96,
        "end_line": 108,
        "comment": "\n     * Create a new matrix with the supplied row and column dimensions.\n     *\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.transpose#1213",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.transpose()",
        "snippet": "    @Override\n    public BlockRealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final double[] outBlock = out.blocks[blockIndex];\n                final double[] tBlock = blocks[jBlock * blockColumns + iBlock];\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n                // go to next block\n                ++blockIndex;\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 1213,
        "end_line": 1246,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java",
        "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
        "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double, double, double)",
        "snippet": "    protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }\n",
        "begin_line": 92,
        "end_line": 98,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0505
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.getRowDimension#1249",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }\n",
        "begin_line": 1249,
        "end_line": 1252,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of rows of this matrix.\n     *\n     * @return the number of rows.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0501
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.getColumnDimension#1255",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }\n",
        "begin_line": 1255,
        "end_line": 1258,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of columns of this matrix.\n     *\n     * @return the number of columns.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0501
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(int, int, double[][], boolean)",
        "snippet": "    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n    }\n",
        "begin_line": 146,
        "end_line": 178,
        "comment": "\n     * Create a new dense matrix copying entries from block layout data.\n     * <p>The input array <em>must</em> already be in blocks layout.</p>\n     *\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @param blockData data for new matrix\n     * @param copyArray Whether the input array will be copied or referenced.\n     * @throws DimensionMismatchException if the shape of {@code blockData} is\n     * inconsistent with block layout.\n     * @throws NotStrictlyPositiveException if row or column dimension is not\n     * positive.\n     * @see #createBlocksLayout(int, int)\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0496
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.blockHeight#1570",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.blockHeight(int)",
        "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1570,
        "end_line": 1572,
        "comment": "\n     * Get the height of a block.\n     * @param blockRow row index (in block sense) of the block\n     * @return height (number of rows) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0496
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.blockWidth#1579",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.blockWidth(int)",
        "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1579,
        "end_line": 1581,
        "comment": "\n     * Get the width of a block.\n     * @param blockColumn column index (in block sense) of the block\n     * @return width (number of columns) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0496
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnivariatePointValuePair.UnivariatePointValuePair#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariatePointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.UnivariatePointValuePair(double, double)",
        "snippet": "    public UnivariatePointValuePair(final double point,\n                                    final double value) {\n        this.point = point;\n        this.value = value;\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Build a point/objective function value pair.\n     *\n     * @param point Point.\n     * @param value Value of an objective function at the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0472
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariatePointValuePair.getPoint#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariatePointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.getPoint()",
        "snippet": "    public double getPoint() {\n        return point;\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Get the point.\n     *\n     * @return the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0472
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariatePointValuePair.getValue#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariatePointValuePair.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.getValue()",
        "snippet": "    public double getValue() {\n        return value;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Get the value of the objective function.\n     *\n     * @return the stored value of the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0472
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.getGoalType#76",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0458
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.getStartValue#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return start;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0458
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.getMin#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getMin()",
        "snippet": "    public double getMin() {\n        return min;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * @return the lower bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0458
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.getMax#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getMax()",
        "snippet": "    public double getMax() {\n        return max;\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * @return the upper bounds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0458
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.computeObjectiveValue#147",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double x) {\n        super.incrementEvaluationCount();\n        return function.value(x);\n    }\n",
        "begin_line": 147,
        "end_line": 150,
        "comment": "\n     * Computes the objective function value.\n     * This method <em>must</em> be called by subclasses to enforce the\n     * evaluation counter limit.\n     *\n     * @param x Point at which the objective function must be evaluated.\n     * @return the objective function value at the specified point.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0458
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.parseOptimizationData#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof SearchInterval) {\n                final SearchInterval interval = (SearchInterval) data;\n                min = interval.getMin();\n                max = interval.getMax();\n                start = interval.getStartValue();\n                continue;\n            }\n            if (data instanceof UnivariateObjectiveFunction) {\n                function = ((UnivariateObjectiveFunction) data).getObjectiveFunction();\n                continue;\n            }\n            if (data instanceof GoalType) {\n                goal = (GoalType) data;\n                continue;\n            }\n        }\n    }\n",
        "begin_line": 92,
        "end_line": 116,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link GoalType}</li>\n     *  <li>{@link SearchInterval}</li>\n     *  <li>{@link UnivariateObjectiveFunction}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "SearchInterval.SearchInterval#46",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SearchInterval.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
        "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.SearchInterval(double, double, double)",
        "snippet": "    public SearchInterval(double lo,\n                          double hi,\n                          double init) {\n        if (lo >= hi) {\n            throw new NumberIsTooLargeException(lo, hi, false);\n        }\n        if (init < lo ||\n            init > hi) {\n            throw new OutOfRangeException(init, lo, hi);\n        }\n\n        lower = lo;\n        upper = hi;\n        start = init;\n    }\n",
        "begin_line": 46,
        "end_line": 60,
        "comment": "\n     * @param lo Lower bound.\n     * @param hi Upper bound.\n     * @param init Start value.\n     * @throws NumberIsTooLargeException if {@code lo >= hi}.\n     * @throws OutOfRangeException if {@code init < lo} or {@code init > hi}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "SearchInterval.getMin#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SearchInterval.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
        "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getMin()",
        "snippet": "    public double getMin() {\n        return lower;\n    }\n",
        "begin_line": 77,
        "end_line": 79,
        "comment": "\n     * Gets the lower bound.\n     *\n     * @return the lower bound.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "SearchInterval.getMax#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SearchInterval.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
        "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getMax()",
        "snippet": "    public double getMax() {\n        return upper;\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Gets the upper bound.\n     *\n     * @return the upper bound.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "SearchInterval.getStartValue#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/SearchInterval.java",
        "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
        "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return start;\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "\n     * Gets the start value.\n     *\n     * @return the start value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.createBlocksLayout#257",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(int, int)",
        "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }\n",
        "begin_line": 257,
        "end_line": 277,
        "comment": "\n     * Create a data array in blocks layout.\n     * <p>\n     * This method can be used to create the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rows Number of rows in the new matrix.\n     * @param columns Number of columns in the new matrix.\n     * @return a new data array in blocks layout.\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0445
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.optimize#67",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    public UnivariatePointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 67,
        "end_line": 71,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link BaseOptimizer#parseOptimizationData(OptimizationData[])\n     * BaseOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link GoalType}</li>\n     *  <li>{@link SearchInterval}</li>\n     *  <li>{@link UnivariateObjectiveFunction}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0434
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateObjectiveFunction.UnivariateObjectiveFunction#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateObjectiveFunction.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction.UnivariateObjectiveFunction(org.apache.commons.math3.analysis.UnivariateFunction)",
        "snippet": "    public UnivariateObjectiveFunction(UnivariateFunction f) {\n        function = f;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param f Function to be optimized.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0434
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateObjectiveFunction.getObjectiveFunction#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateObjectiveFunction.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction.getObjectiveFunction()",
        "snippet": "    public UnivariateFunction getObjectiveFunction() {\n        return function;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the function to be optimized.\n     *\n     * @return the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0434
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.doOptimize#283",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.doOptimize()",
        "snippet": "    @Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n                        if (checker.converged(iter, previous, current)) {\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }\n",
        "begin_line": 283,
        "end_line": 534,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0434
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ulp#3025",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/FastMath.java",
        "class_name": "org.apache.commons.math3.util.FastMath",
        "signature": "org.apache.commons.math3.util.FastMath.ulp(double)",
        "snippet": "    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n",
        "begin_line": 3025,
        "end_line": 3030,
        "comment": "\n     * Compute least significant bit (Unit in Last Position) for a number.\n     * @param x number from which ulp is requested\n     * @return ulp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0423
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateOptimizer.UnivariateOptimizer#48",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.UnivariateOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.univariate.UnivariatePointValuePair>)",
        "snippet": "    protected UnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0423
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.BrentOptimizer(double, double, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.univariate.UnivariatePointValuePair>)",
        "snippet": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }\n",
        "begin_line": 78,
        "end_line": 92,
        "comment": "\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0423
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.determineLMParameter#558",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.determineLMParameter(double[], double, double[], double[], double[], double[])",
        "snippet": "    private void determineLMParameter(double[] qy, double delta, double[] diag,\n                                      double[] work1, double[] work2, double[] work3) {\n        final int nC = weightedJacobian[0].length;\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < nC; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = FastMath.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }\n",
        "begin_line": 558,
        "end_line": 706,
        "comment": "\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0423
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.computeCost#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeCost(double[])",
        "snippet": "    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }\n",
        "begin_line": 75,
        "end_line": 78,
        "comment": "\n     * Computes the cost.\n     *\n     * @param residuals Residuals.\n     * @return the cost.\n     * @see #computeResiduals(double[])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.setCost#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.setCost(double)",
        "snippet": "    protected void setCost(double cost) {\n        this.cost = cost;\n    }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": "\n     * Sets the cost.\n     *\n     * @param cost Cost value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.multiply#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.multiply(org.apache.commons.math3.linear.DiagonalMatrix)",
        "snippet": "    public DiagonalMatrix multiply(final DiagonalMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int dim = getRowDimension();\n        final double[] outData = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            outData[i] = data[i] * m.data[i];\n        }\n\n        return new DiagonalMatrix(outData, false);\n    }\n",
        "begin_line": 161,
        "end_line": 172,
        "comment": "\n     * Returns the result of postmultiplying {@code this} by {@code m}.\n     *\n     * @param m matrix to postmultiply by\n     * @return {@code this * m}\n     * @throws DimensionMismatchException if\n     * {@code columnDimension(this) != rowDimension(m)}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.getDataRef#218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getDataRef()",
        "snippet": "    public double[] getDataRef() {\n        return data;\n    }\n",
        "begin_line": 218,
        "end_line": 220,
        "comment": "\n     * Gets a reference to the underlying data array.\n     *\n     * @return 1-dimensional array of entries.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.operate#286",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.operate(double[])",
        "snippet": "    @Override\n    public double[] operate(final double[] v)\n        throws DimensionMismatchException {\n        return multiply(new DiagonalMatrix(v, false)).getDataRef();\n    }\n",
        "begin_line": 286,
        "end_line": 290,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of multiplying this by the vector {@code v}.\n     *\n     * @param v the vector to operate on\n     * @return {@code this * v}\n     * @throws DimensionMismatchException if the length of {@code v} does not\n     * match the column dimension of {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleVectorValueChecker.converged#113",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleVectorValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.SimpleVectorValueChecker",
        "signature": "org.apache.commons.math3.optim.SimpleVectorValueChecker.converged(int, org.apache.commons.math3.optim.PointVectorValuePair, org.apache.commons.math3.optim.PointVectorValuePair)",
        "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointVectorValuePair previous,\n                             final PointVectorValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double[] p = previous.getValueRef();\n        final double[] c = current.getValueRef();\n        for (int i = 0; i < p.length; ++i) {\n            final double pi         = p[i];\n            final double ci         = c[i];\n            final double difference = FastMath.abs(pi - ci);\n            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n            if (difference > size * getRelativeThreshold() &&\n                difference > getAbsoluteThreshold()) {\n                return false;\n            }\n        }\n        return true;\n    }\n",
        "begin_line": 113,
        "end_line": 136,
        "comment": "\n     * Check if the optimization algorithm has converged considering the\n     * last two points.\n     * This method may be called several times from the same algorithm\n     * iteration with different points. This can be detected by checking the\n     * iteration number at each call if needed. Each time this method is\n     * called, the previous and current point correspond to points with the\n     * same role at each iteration, so they can be compared. As an example,\n     * simplex-based algorithms call this method for all points of the simplex,\n     * not only for the best or worst ones.\n     *\n     * @param iteration Index of current iteration\n     * @param previous Best point in the previous iteration.\n     * @param current Best point in the current iteration.\n     * @return {@code true} if the arguments satify the convergence criterion.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0412
        },
        "num_failing_tests": 1
    },
    {
        "name": "GaussNewtonOptimizer.doOptimize#79",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.doOptimize()",
        "snippet": "    @Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }\n",
        "begin_line": 79,
        "end_line": 169,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer": null,
            "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer": null,
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": null,
            "org.apache.commons.math3.optim.BaseOptimizer": "\n     * Performs the bulk of the optimization algorithm.\n     *\n     * @return the point/value pair giving the optimal value of the\n     * objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0403
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.computeWeightedJacobian#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeWeightedJacobian(double[])",
        "snippet": "    protected RealMatrix computeWeightedJacobian(double[] params) {\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Computes the weighted Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.computeResiduals#215",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeResiduals(double[])",
        "snippet": "    protected double[] computeResiduals(double[] objectiveValue) {\n        final double[] target = getTarget();\n        if (objectiveValue.length != target.length) {\n            throw new DimensionMismatchException(target.length,\n                                                 objectiveValue.length);\n        }\n\n        final double[] residuals = new double[target.length];\n        for (int i = 0; i < target.length; i++) {\n            residuals[i] = target[i] - objectiveValue[i];\n        }\n\n        return residuals;\n    }\n",
        "begin_line": 215,
        "end_line": 228,
        "comment": "\n     * Computes the residuals.\n     * The residual is the difference between the observed (target)\n     * values and the model (objective function) value.\n     * There is one residual for each element of the vector-valued\n     * function.\n     *\n     * @param objectiveValue Value of the the objective function. This is\n     * the value returned from a call to\n     * {@link #computeObjectiveValue(double[]) computeObjectiveValue}\n     * (whose array argument contains the model parameters).\n     * @return the residuals.\n     * @throws DimensionMismatchException if {@code params} has a wrong\n     * length.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModelFunctionJacobian.ModelFunctionJacobian#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunctionJacobian.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian.ModelFunctionJacobian(org.apache.commons.math3.analysis.MultivariateMatrixFunction)",
        "snippet": "    public ModelFunctionJacobian(MultivariateMatrixFunction j) {\n        jacobian = j;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param j Jacobian of the model function to be optimized.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModelFunctionJacobian.getModelFunctionJacobian#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunctionJacobian.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian.getModelFunctionJacobian()",
        "snippet": "    public MultivariateMatrixFunction getModelFunctionJacobian() {\n        return jacobian;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the Jacobian of the model function to be optimized.\n     *\n     * @return the model function Jacobian.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "JacobianMultivariateVectorOptimizer.computeJacobian#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.computeJacobian(double[])",
        "snippet": "    protected double[][] computeJacobian(final double[] params) {\n        return jacobian.value(params);\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Computes the Jacobian matrix.\n     *\n     * @param params Point at which the Jacobian must be evaluated.\n     * @return the Jacobian at the specified point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "JacobianMultivariateVectorOptimizer.parseOptimizationData#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof ModelFunctionJacobian) {\n                jacobian = ((ModelFunctionJacobian) data).getModelFunctionJacobian();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }\n",
        "begin_line": 96,
        "end_line": 111,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data.\n     * The following data will be looked for:\n     * <ul>\n     *  <li>{@link ModelFunctionJacobian}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "PointVectorValuePair.PointVectorValuePair#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointVectorValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
        "signature": "org.apache.commons.math3.optim.PointVectorValuePair.PointVectorValuePair(double[], double[])",
        "snippet": "    public PointVectorValuePair(final double[] point,\n                                final double[] value) {\n        this(point, value, true);\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": "\n     * Builds a point/objective function value pair.\n     *\n     * @param point Point coordinates. This instance will store\n     * a copy of the array, not the array passed as argument.\n     * @param value Value of the objective function at the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "PointVectorValuePair.PointVectorValuePair#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointVectorValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
        "signature": "org.apache.commons.math3.optim.PointVectorValuePair.PointVectorValuePair(double[], double[], boolean)",
        "snippet": "    public PointVectorValuePair(final double[] point,\n                                final double[] value,\n                                final boolean copyArray) {\n        super(copyArray ?\n              ((point == null) ? null :\n               point.clone()) :\n              point,\n              copyArray ?\n              ((value == null) ? null :\n               value.clone()) :\n              value);\n    }\n",
        "begin_line": 55,
        "end_line": 66,
        "comment": "\n     * Build a point/objective function value pair.\n     *\n     * @param point Point coordinates.\n     * @param value Value of the objective function at the point.\n     * @param copyArray if {@code true}, the input arrays will be copied,\n     * otherwise they will be referenced.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.multiply#182",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.multiply(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        if (m instanceof DiagonalMatrix) {\n            return multiply((DiagonalMatrix) m);\n        } else {\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n            final int nRows = m.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final double[][] product = new double[nRows][nCols];\n            for (int r = 0; r < nRows; r++) {\n                for (int c = 0; c < nCols; c++) {\n                    product[r][c] = data[r] * m.getEntry(r, c);\n                }\n            }\n            return new Array2DRowRealMatrix(product, false);\n        }\n    }\n",
        "begin_line": 182,
        "end_line": 198,
        "comment": "\n     * Returns the result of postmultiplying {@code this} by {@code m}.\n     *\n     * @param m matrix to postmultiply by\n     * @return {@code this * m}\n     * @throws DimensionMismatchException if\n     * {@code columnDimension(this) != rowDimension(m)}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0401
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.computeObjectiveValue#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.computeObjectiveValue(double[])",
        "snippet": "    protected double[] computeObjectiveValue(double[] params) {\n        super.incrementEvaluationCount();\n        return model.value(params);\n    }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "\n     * Computes the objective function value.\n     * This method <em>must</em> be called by subclasses to enforce the\n     * evaluation counter limit.\n     *\n     * @param params Point at which the objective function must be evaluated.\n     * @return the objective function value at the specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * (of the model vector function) is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.getWeight#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.getWeight()",
        "snippet": "    public RealMatrix getWeight() {\n        return weightMatrix.copy();\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "\n     * Gets the weight matrix of the observations.\n     *\n     * @return the weight matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.parseOptimizationData#128",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof ModelFunction) {\n                model = ((ModelFunction) data).getModelFunction();\n                continue;\n            }\n            if (data instanceof Target) {\n                target = ((Target) data).getTarget();\n                continue;\n            }\n            if (data instanceof Weight) {\n                weightMatrix = ((Weight) data).getWeight();\n                continue;\n            }\n        }\n\n        // Check input consistency.\n        checkParameters();\n    }\n",
        "begin_line": 128,
        "end_line": 152,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     *\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link ModelFunction}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModelFunction.ModelFunction#35",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunction.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction.ModelFunction(org.apache.commons.math3.analysis.MultivariateVectorFunction)",
        "snippet": "    public ModelFunction(MultivariateVectorFunction m) {\n        model = m;\n    }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "\n     * @param m Model function to be optimized.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "ModelFunction.getModelFunction#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/ModelFunction.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction.getModelFunction()",
        "snippet": "    public MultivariateVectorFunction getModelFunction() {\n        return model;\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Gets the model function to be optimized.\n     *\n     * @return the model function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.getTarget#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.getTarget()",
        "snippet": "    public double[] getTarget() {\n        return target.clone();\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Gets the observed values to be matched by the objective vector\n     * function.\n     *\n     * @return the target values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0396
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.optimize#193",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 193,
        "end_line": 198,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[])\n     * JacobianMultivariateVectorOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.parseOptimizationData#241",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.parseOptimizationData(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof Weight) {\n                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }\n",
        "begin_line": 241,
        "end_line": 256,
        "comment": "\n     * Scans the list of (required and optional) optimization data that\n     * characterize the problem.\n     * If the weight matrix is specified, the {@link #weightMatrixSqrt}\n     * field is recomputed.\n     *\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Weight}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.squareRoot#264",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.squareRoot(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }\n",
        "begin_line": 264,
        "end_line": 276,
        "comment": "\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "Weight.Weight#41",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.Weight(double[])",
        "snippet": "    public Weight(double[] weight) {\n        weightMatrix = new DiagonalMatrix(weight);\n    }\n",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "Weight.getWeight#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.getWeight()",
        "snippet": "    public RealMatrix getWeight() {\n        return weightMatrix.copy();\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Gets the initial guess.\n     *\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "Target.Target#38",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Target.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Target",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.Target.Target(double[])",
        "snippet": "    public Target(double[] observations) {\n        target = observations.clone();\n    }\n",
        "begin_line": 38,
        "end_line": 40,
        "comment": "\n     * @param observations Target values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "Target.getTarget#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Target.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Target",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.Target.getTarget()",
        "snippet": "    public double[] getTarget() {\n        return target.clone();\n    }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * Gets the initial guess.\n     *\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.optimize#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 83,
        "end_line": 88,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[])\n     * BaseMultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link ModelFunction}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.BaseMultivariateOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.checkParameters#160",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (target.length != weightMatrix.getColumnDimension()) {\n            throw new DimensionMismatchException(target.length,\n                                                 weightMatrix.getColumnDimension());\n        }\n    }\n",
        "begin_line": 160,
        "end_line": 165,
        "comment": "\n     * Check parameters consistency.\n     *\n     * @throws DimensionMismatchException if {@link #target} and\n     * {@link #weightMatrix} have inconsistent dimensions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "JacobianMultivariateVectorOptimizer.optimize#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.optimize(org.apache.commons.math3.optim.OptimizationData...)",
        "snippet": "    @Override\n    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }\n",
        "begin_line": 78,
        "end_line": 84,
        "comment": "\n     * {@inheritDoc}\n     *\n     * @param optData Optimization data. In addition to those documented in\n     * {@link MultivariateVectorOptimizer#optimize(OptimizationData...)}\n     * MultivariateOptimizer}, this method will register the following data:\n     * <ul>\n     *  <li>{@link ModelFunctionJacobian}</li>\n     * </ul>\n     * @return {@inheritDoc}\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer": "\n     * @param checker Convergence checker.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.DiagonalMatrix#50",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(int)",
        "snippet": "    public DiagonalMatrix(final int dimension)\n        throws NotStrictlyPositiveException {\n        super(dimension, dimension);\n        data = new double[dimension];\n    }\n",
        "begin_line": 50,
        "end_line": 54,
        "comment": "\n     * Creates a matrix with the supplied dimension.\n     *\n     * @param dimension Number of rows and columns in the new matrix.\n     * @throws NotStrictlyPositiveException if the dimension is\n     * not positive.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.DiagonalMatrix#63",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(double[])",
        "snippet": "    public DiagonalMatrix(final double[] d) {\n        this(d, true);\n    }\n",
        "begin_line": 63,
        "end_line": 65,
        "comment": "\n     * Creates a matrix using the input array as the underlying data.\n     * <br/>\n     * The input array is copied, not referenced.\n     *\n     * @param d Data for the new matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.DiagonalMatrix#81",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(double[], boolean)",
        "snippet": "    public DiagonalMatrix(final double[] d, final boolean copyArray)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(d);\n        data = copyArray ? d.clone() : d;\n    }\n",
        "begin_line": 81,
        "end_line": 85,
        "comment": "\n     * Creates a matrix using the input array as the underlying data.\n     * <br/>\n     * If an array is created specially in order to be embedded in a\n     * this instance and not used directly, the {@code copyArray} may be\n     * set to {@code false}.\n     * This will prevent the copying and improve performance as no new\n     * array will be built and no data will be copied.\n     *\n     * @param d Data for new matrix.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     * @exception NullArgumentException if d is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.copy#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.copy()",
        "snippet": "    @Override\n    public RealMatrix copy() {\n        return new DiagonalMatrix(data);\n    }\n",
        "begin_line": 105,
        "end_line": 108,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns a (deep) copy of this.\n     *\n     * @return matrix copy\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.getEntry#223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return row == column ? data[row] : 0;\n    }\n",
        "begin_line": 223,
        "end_line": 228,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Get the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be fetched.\n     * @param column Column index of entry to be fetched.\n     * @return the matrix entry at {@code (row, column)}.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.setEntry#233",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException, NumberIsTooLargeException {\n        if (row == column) {\n            MatrixUtils.checkRowIndex(this, row);\n            data[row] = value;\n        } else {\n            ensureZero(value);\n        }\n    }\n",
        "begin_line": 233,
        "end_line": 242,
        "comment": " {@inheritDoc}\n     * @throws NumberIsTooLargeException if {@code row != column} and value is non-zero.\n     ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Set the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be set.\n     * @param column Column index of entry to be set.\n     * @param value the new value of the entry.\n     * @throws OutOfRangeException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.getRowDimension#274",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return data.length;\n    }\n",
        "begin_line": 274,
        "end_line": 277,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of rows of this matrix.\n     *\n     * @return the number of rows.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "DiagonalMatrix.getColumnDimension#280",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java",
        "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
        "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return data.length;\n    }\n",
        "begin_line": 280,
        "end_line": 283,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": "\n     * Returns the number of columns of this matrix.\n     *\n     * @return the number of columns.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 2
    },
    {
        "name": "LUDecomposition.solve#291",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/LUDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.LUDecomposition",
        "signature": "org.apache.commons.math3.linear.LUDecomposition.Solver.solve(org.apache.commons.math3.linear.RealVector)",
        "snippet": "        public RealVector solve(RealVector b) {\n            final int m = pivot.length;\n            if (b.getDimension() != m) {\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] bp = new double[m];\n\n            // Apply permutations to b\n            for (int row = 0; row < m; row++) {\n                bp[row] = b.getEntry(pivot[row]);\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final double bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    bp[i] -= bpCol * lu[i][col];\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                bp[col] /= lu[col][col];\n                final double bpCol = bp[col];\n                for (int i = 0; i < col; i++) {\n                    bp[i] -= bpCol * lu[i][col];\n                }\n            }\n\n            return new ArrayRealVector(bp, false);\n        }\n",
        "begin_line": 291,
        "end_line": 325,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.DecompositionSolver": " Solve the linear equation A &times; X = B for matrices A.\n     * <p>The A matrix is implicit, it is provided by the underlying\n     * decomposition algorithm.</p>\n     * @param b right-hand side of the equation A &times; X = B\n     * @return a vector X that minimizes the two norm of A &times; X - B\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the matrices dimensions do not match.\n     * @throws SingularMatrixException\n     * if the decomposed matrix is singular.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecomposition.LUDecomposition#86",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/LUDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.LUDecomposition",
        "signature": "org.apache.commons.math3.linear.LUDecomposition.LUDecomposition(org.apache.commons.math3.linear.RealMatrix, double)",
        "snippet": "    public LUDecomposition(RealMatrix matrix, double singularityThreshold) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                double sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int max = col; // permutation row\n            double largest = Double.NEGATIVE_INFINITY;\n            for (int row = col; row < m; row++) {\n                final double[] luRow = lu[row];\n                double sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                // maintain best permutation choice\n                if (FastMath.abs(sum) > largest) {\n                    largest = FastMath.abs(sum);\n                    max = row;\n                }\n            }\n\n            // Singularity check\n            if (FastMath.abs(lu[max][col]) < singularityThreshold) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (max != col) {\n                double tmp = 0;\n                final double[] luMax = lu[max];\n                final double[] luCol = lu[col];\n                for (int i = 0; i < m; i++) {\n                    tmp = luMax[i];\n                    luMax[i] = luCol[i];\n                    luCol[i] = tmp;\n                }\n                int temp = pivot[max];\n                pivot[max] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n    }\n",
        "begin_line": 86,
        "end_line": 165,
        "comment": "\n     * Calculates the LU-decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @param singularityThreshold threshold (based on partial row norm)\n     * under which a matrix is considered singular\n     * @throws NonSquareMatrixException if matrix is not square\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0394
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.getDataRef#449",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDataRef()",
        "snippet": "    public double[] getDataRef() {\n        return data;\n    }\n",
        "begin_line": 449,
        "end_line": 451,
        "comment": "\n     * Get a reference to the underlying data array.\n     * This method does not make a fresh copy of the underlying data.\n     *\n     * @return the array of entries.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0388
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealMatrix.operate#671",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.operate(org.apache.commons.math3.linear.RealVector)",
        "snippet": "    @Override\n    public RealVector operate(final RealVector v)\n        throws DimensionMismatchException {\n        try {\n            return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n        } catch (ClassCastException cce) {\n            final int nRows = getRowDimension();\n            final int nCols = getColumnDimension();\n            if (v.getDimension() != nCols) {\n                throw new DimensionMismatchException(v.getDimension(), nCols);\n            }\n\n            final double[] out = new double[nRows];\n            for (int row = 0; row < nRows; ++row) {\n                double sum = 0;\n                for (int i = 0; i < nCols; ++i) {\n                    sum += getEntry(row, i) * v.getEntry(i);\n                }\n                out[row] = sum;\n            }\n\n            return new ArrayRealVector(out, false);\n        }\n    }\n",
        "begin_line": 671,
        "end_line": 694,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealLinearOperator": "\n     * Returns the result of multiplying {@code this} by the vector {@code x}.\n     *\n     * @param x the vector to operate on\n     * @return the product of {@code this} instance with {@code x}\n     * @throws DimensionMismatchException if the column dimension does not match\n     * the size of {@code x}\n     ",
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Sets the specified {@code row} of {@code this} matrix to the entries of\n     * the specified {@code vector}. Row indices start at 0.\n     *\n     * @param row Row to be set.\n     * @param vector row vector to be copied (must have the same number of\n     * column as the instance).\n     * @throws OutOfRangeException if the specified row index is invalid.\n     * @throws MatrixDimensionMismatchException if the {@code vector} dimension\n     * does not match the column dimension of {@code this} matrix.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0388
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair>)",
        "snippet": "    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0386
        },
        "num_failing_tests": 2
    },
    {
        "name": "MultivariateVectorOptimizer.MultivariateVectorOptimizer#47",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.MultivariateVectorOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair>)",
        "snippet": "    protected MultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0386
        },
        "num_failing_tests": 2
    },
    {
        "name": "JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/JacobianMultivariateVectorOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair>)",
        "snippet": "    protected JacobianMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": "\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0386
        },
        "num_failing_tests": 2
    },
    {
        "name": "GaussNewtonOptimizer.GaussNewtonOptimizer#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.GaussNewtonOptimizer(org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair>)",
        "snippet": "    public GaussNewtonOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        this(true, checker);\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n     * Simple constructor with default settings.\n     * The normal equations will be solved using LU decomposition.\n     *\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0386
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getMaximalCount#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/util/Incrementor.java",
        "class_name": "org.apache.commons.math3.util.Incrementor",
        "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
        "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Gets the upper limit of the counter.\n     *\n     * @return the counter upper limit.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.determineLMDirection#728",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.determineLMDirection(double[], double[], double[], double[])",
        "snippet": "    private void determineLMDirection(double[] qy, double[] diag,\n                                      double[] lmDiag, double[] work) {\n\n        // copy R and Qty to preserve input and initialize s\n        //  in particular, save the diagonal elements of R in lmDir\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            for (int i = j + 1; i < solvedCols; ++i) {\n                weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];\n            }\n            lmDir[j] = diagR[pj];\n            work[j]  = qy[j];\n        }\n\n        // eliminate the diagonal matrix d using a Givens rotation\n        for (int j = 0; j < solvedCols; ++j) {\n\n            // prepare the row of d to be eliminated, locating the\n            // diagonal element using p from the Q.R. factorization\n            int pj = permutation[j];\n            double dpj = diag[pj];\n            if (dpj != 0) {\n                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n            }\n            lmDiag[j] = dpj;\n\n            //  the transformations to eliminate the row of d\n            // modify only a single element of Qty\n            // beyond the first n, which is initially zero.\n            double qtbpj = 0;\n            for (int k = j; k < solvedCols; ++k) {\n                int pk = permutation[k];\n\n                // determine a Givens rotation which eliminates the\n                // appropriate element in the current row of d\n                if (lmDiag[k] != 0) {\n\n                    final double sin;\n                    final double cos;\n                    double rkk = weightedJacobian[k][pk];\n                    if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\n                        final double cotan = rkk / lmDiag[k];\n                        sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\n                        cos   = sin * cotan;\n                    } else {\n                        final double tan = lmDiag[k] / rkk;\n                        cos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\n                        sin = cos * tan;\n                    }\n\n                    // compute the modified diagonal element of R and\n                    // the modified element of (Qty,0)\n                    weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                    final double temp = cos * work[k] + sin * qtbpj;\n                    qtbpj = -sin * work[k] + cos * qtbpj;\n                    work[k] = temp;\n\n                    // accumulate the tranformation in the row of s\n                    for (int i = k + 1; i < solvedCols; ++i) {\n                        double rik = weightedJacobian[i][pk];\n                        final double temp2 = cos * rik + sin * lmDiag[i];\n                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                        weightedJacobian[i][pk] = temp2;\n                    }\n                }\n            }\n\n            // store the diagonal element of s and restore\n            // the corresponding diagonal element of R\n            lmDiag[j] = weightedJacobian[j][permutation[j]];\n            weightedJacobian[j][permutation[j]] = lmDir[j];\n        }\n\n        // solve the triangular system for z, if the system is\n        // singular, then obtain a least squares solution\n        int nSing = solvedCols;\n        for (int j = 0; j < solvedCols; ++j) {\n            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n                nSing = j;\n            }\n            if (nSing < solvedCols) {\n                work[j] = 0;\n            }\n        }\n        if (nSing > 0) {\n            for (int j = nSing - 1; j >= 0; --j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = j + 1; i < nSing; ++i) {\n                    sum += weightedJacobian[i][pj] * work[i];\n                }\n                work[j] = (work[j] - sum) / lmDiag[j];\n            }\n        }\n\n        // permute the components of z back to components of lmDir\n        for (int j = 0; j < lmDir.length; ++j) {\n            lmDir[permutation[j]] = work[j];\n        }\n    }\n",
        "begin_line": 728,
        "end_line": 827,
        "comment": "\n     * Solve a*x = b and d*x = 0 in the least squares sense.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n     * routine.</p>\n     * <p>This method sets the lmDir and lmDiag attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param diag diagonal matrix\n     * @param lmDiag diagonal elements associated with lmDir\n     * @param work work array\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "PointVectorValuePair.getValueRef#104",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/PointVectorValuePair.java",
        "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
        "signature": "org.apache.commons.math3.optim.PointVectorValuePair.getValueRef()",
        "snippet": "    public double[] getValueRef() {\n        return super.getValue();\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Gets a reference to the value of the objective function.\n     *\n     * @return a reference to the internal array storing the value of\n     * the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseOptimizer.getMaxEvaluations#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
        "signature": "org.apache.commons.math3.optim.BaseOptimizer.getMaxEvaluations()",
        "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Gets the maximal number of function evaluations.\n     *\n     * @return the maximal number of function evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecomposition.Solver#279",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/LUDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.LUDecomposition",
        "signature": "org.apache.commons.math3.linear.LUDecomposition.Solver.Solver(double[][], int[], boolean)",
        "snippet": "        private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\n            this.lu       = lu;\n            this.pivot    = pivot;\n            this.singular = singular;\n        }\n",
        "begin_line": 279,
        "end_line": 283,
        "comment": "\n         * Build a solver from decomposed matrix.\n         * @param lu entries of LU decomposition\n         * @param pivot pivot permutation associated with LU decomposition\n         * @param singular singularity indicator\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecomposition.LUDecomposition#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/LUDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.LUDecomposition",
        "signature": "org.apache.commons.math3.linear.LUDecomposition.LUDecomposition(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    public LUDecomposition(RealMatrix matrix) {\n        this(matrix, DEFAULT_TOO_SMALL);\n    }\n",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n     * Calculates the LU-decomposition of the given matrix.\n     * This constructor uses 1e-11 as default value for the singularity\n     * threshold.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws NonSquareMatrixException if matrix is not square.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "LUDecomposition.getSolver#257",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/LUDecomposition.java",
        "class_name": "org.apache.commons.math3.linear.LUDecomposition",
        "signature": "org.apache.commons.math3.linear.LUDecomposition.getSolver()",
        "snippet": "    public DecompositionSolver getSolver() {\n        return new Solver(lu, pivot, singular);\n    }\n",
        "begin_line": 257,
        "end_line": 259,
        "comment": "\n     * Get a solver for finding the A &times; X = B solution in exact linear\n     * sense.\n     * @return a solver\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.dotProduct#454",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.dotProduct(org.apache.commons.math3.linear.RealVector)",
        "snippet": "    @Override\n    public double dotProduct(RealVector v) throws DimensionMismatchException {\n        if (v instanceof ArrayRealVector) {\n            final double[] vData = ((ArrayRealVector) v).data;\n            checkVectorDimensions(vData.length);\n            double dot = 0;\n            for (int i = 0; i < data.length; i++) {\n                dot += data[i] * vData[i];\n            }\n            return dot;\n        }\n        return super.dotProduct(v);\n    }\n",
        "begin_line": 454,
        "end_line": 466,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Construct a new vector by appending a vector to this vector.\n     *\n     * @param v vector to append to this one.\n     * @return a new vector.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0369
        },
        "num_failing_tests": 2
    },
    {
        "name": "GaussNewtonOptimizer.checkParameters#175",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }\n",
        "begin_line": 175,
        "end_line": 180,
        "comment": "\n     * @throws MathUnsupportedOperationException if bounds were passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0345
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.checkVectorDimensions#755",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.checkVectorDimensions(int)",
        "snippet": "    @Override\n    protected void checkVectorDimensions(int n)\n        throws DimensionMismatchException {\n        if (data.length != n) {\n            throw new DimensionMismatchException(data.length, n);\n        }\n    }\n",
        "begin_line": 755,
        "end_line": 761,
        "comment": "\n     * Check if instance dimension is equal to some expected value.\n     *\n     * @param n Expected dimension.\n     * @throws DimensionMismatchException if the dimension is\n     * inconsistent with vector size.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0342
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleVectorValueChecker.SimpleVectorValueChecker#65",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/SimpleVectorValueChecker.java",
        "class_name": "org.apache.commons.math3.optim.SimpleVectorValueChecker",
        "signature": "org.apache.commons.math3.optim.SimpleVectorValueChecker.SimpleVectorValueChecker(double, double)",
        "snippet": "    public SimpleVectorValueChecker(final double relativeThreshold,\n                                    final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }\n",
        "begin_line": 65,
        "end_line": 69,
        "comment": "\n     * Build an instance with specified thresholds.\n     *\n     * In order to perform only relative checks, the absolute tolerance\n     * must be set to a negative value. In order to perform only absolute\n     * checks, the relative tolerance must be set to a negative value.\n     *\n     * @param relativeThreshold relative tolerance threshold\n     * @param absoluteThreshold absolute tolerance threshold\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0339
        },
        "num_failing_tests": 1
    },
    {
        "name": "GaussNewtonOptimizer.GaussNewtonOptimizer#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.GaussNewtonOptimizer(boolean, org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair>)",
        "snippet": "    public GaussNewtonOptimizer(final boolean useLU,\n                                ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n        this.useLU = useLU;\n    }\n",
        "begin_line": 72,
        "end_line": 76,
        "comment": "\n     * @param useLU If {@code true}, the normal equations will be solved\n     * using LU decomposition, otherwise they will be solved using QR\n     * decomposition.\n     * @param checker Convergence checker.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0334
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.ArrayRealVector#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[], boolean)",
        "snippet": "    public ArrayRealVector(double[] d, boolean copyArray)\n        throws NullArgumentException {\n        if (d == null) {\n            throw new NullArgumentException();\n        }\n        data = copyArray ? d.clone() :  d;\n    }\n",
        "begin_line": 103,
        "end_line": 109,
        "comment": "\n     * Create a new ArrayRealVector using the input array as the underlying\n     * data array.\n     * If an array is built specially in order to be embedded in a\n     * ArrayRealVector and not used directly, the {@code copyArray} may be\n     * set to {@code false}. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.\n     *\n     * @param d Data for the new vector.\n     * @param copyArray if {@code true}, the input array will be copied,\n     * otherwise it will be referenced.\n     * @throws NullArgumentException if {@code d} is {@code null}.\n     * @see #ArrayRealVector(double[])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0331
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.operate#1261",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.operate(double[])",
        "snippet": "    @Override\n    public double[] operate(final double[] v)\n        throws DimensionMismatchException {\n        if (v.length != columns) {\n            throw new DimensionMismatchException(v.length, columns);\n        }\n        final double[] out = new double[rows];\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    double sum = 0;\n                    int q = qStart;\n                    while (q < qEnd - 3) {\n                        sum += block[k]     * v[q]     +\n                               block[k + 1] * v[q + 1] +\n                               block[k + 2] * v[q + 2] +\n                               block[k + 3] * v[q + 3];\n                        k += 4;\n                        q += 4;\n                    }\n                    while (q < qEnd) {\n                        sum += block[k++] * v[q++];\n                    }\n                    out[p] += sum;\n                }\n            }\n        }\n\n        return out;\n    }\n",
        "begin_line": 1261,
        "end_line": 1298,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns the result of multiplying this by the vector {@code v}.\n     *\n     * @param v the vector to operate on\n     * @return {@code this * v}\n     * @throws DimensionMismatchException if the length of {@code v} does not\n     * match the column dimension of {@code this}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.0324
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer()",
        "snippet": "    public LevenbergMarquardtOptimizer() {\n        this(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * Build an optimizer for least squares problems with default values\n     * for all the tuning parameters (see the {@link\n     * #LevenbergMarquardtOptimizer(double,double,double,double,double)\n     * other contructor}.\n     * The default values for the algorithm settings are:\n     * <ul>\n     *  <li>Initial step bound factor: 100</li>\n     *  <li>Cost relative tolerance: 1e-10</li>\n     *  <li>Parameters relative tolerance: 1e-10</li>\n     *  <li>Orthogonality tolerance: 1e-10</li>\n     *  <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li>\n     * </ul>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 1
    },
    {
        "name": "BlockRealMatrix.getData#596",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            int regularPos = 0;\n            int lastPos = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                final double[] dataP = data[p];\n                int blockIndex = iBlock * blockColumns;\n                int dataPos = 0;\n                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                    dataPos += BLOCK_SIZE;\n                }\n                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n                regularPos += BLOCK_SIZE;\n                lastPos    += lastColumns;\n            }\n        }\n\n        return data;\n    }\n",
        "begin_line": 596,
        "end_line": 621,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math3.linear.RealLinearOperator": null,
            "org.apache.commons.math3.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return 2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.0282
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.qrDecomposition#853",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.qrDecomposition(org.apache.commons.math3.linear.RealMatrix)",
        "snippet": "    private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\n        // Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),\n        // hence the multiplication by -1.\n        weightedJacobian = jacobian.scalarMultiply(-1).getData();\n\n        final int nR = weightedJacobian.length;\n        final int nC = weightedJacobian[0].length;\n\n        // initializations\n        for (int k = 0; k < nC; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < nR; ++i) {\n                double akk = weightedJacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = FastMath.sqrt(norm2);\n        }\n\n        // transform the matrix column after column\n        for (int k = 0; k < nC; ++k) {\n\n            // select the column with the greatest norm on active components\n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < nC; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < nR; ++j) {\n                    double aki = weightedJacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                                                   nR, nC);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 <= qrRankingThreshold) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            // choose alpha such that Hk.u = alpha ek\n            double akk   = weightedJacobian[k][pk];\n            double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            // transform the current column\n            diagR[pk]        = alpha;\n            weightedJacobian[k][pk] -= alpha;\n\n            // transform the remaining columns\n            for (int dk = nC - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < nR; ++j) {\n                    gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < nR; ++j) {\n                    weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];\n                }\n            }\n        }\n        rank = solvedCols;\n    }\n",
        "begin_line": 853,
        "end_line": 924,
        "comment": "\n     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n     * <p>As suggested in the P. Lascaux and R. Theodor book\n     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n     * </pre>\n     * we use <sub>k</sub> non-unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n     * </pre>\n     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n     * them from the v<sub>k</sub> vectors would be costly.</p>\n     * <p>This decomposition handles rank deficient cases since the tranformations\n     * are performed in non-increasing columns norms order thanks to columns\n     * pivoting. The diagonal elements of the R matrix are therefore also in\n     * non-increasing absolute values order.</p>\n     *\n     * @param jacobian Weighted Jacobian matrix at the current point.\n     * @exception ConvergenceException if the decomposition cannot be performed\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0248
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.qTy#931",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.qTy(double[])",
        "snippet": "    private void qTy(double[] y) {\n        final int nR = weightedJacobian.length;\n        final int nC = weightedJacobian[0].length;\n\n        for (int k = 0; k < nC; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < nR; ++i) {\n                gamma += weightedJacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < nR; ++i) {\n                y[i] -= gamma * weightedJacobian[i][pk];\n            }\n        }\n    }\n",
        "begin_line": 931,
        "end_line": 946,
        "comment": "\n     * Compute the product Qt.y for some Q.R. decomposition.\n     *\n     * @param y vector to multiply (will be overwritten with the result)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.024
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.checkParameters#952",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.checkParameters()",
        "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }\n",
        "begin_line": 952,
        "end_line": 957,
        "comment": "\n     * @throws MathUnsupportedOperationException if bounds were passed to the\n     * {@link #optimize(OptimizationData[]) optimize} method.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.024
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractLeastSquaresOptimizer.getWeightSquareRoot#110",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.getWeightSquareRoot()",
        "snippet": "    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }\n",
        "begin_line": 110,
        "end_line": 112,
        "comment": "\n     * Gets the square-root of the weight matrix.\n     *\n     * @return the square-root of the weight matrix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.024
        },
        "num_failing_tests": 1
    },
    {
        "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer#269",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java",
        "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
        "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer(double, double, double, double, double)",
        "snippet": "    public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\n                                       double costRelativeTolerance,\n                                       double parRelativeTolerance,\n                                       double orthoTolerance,\n                                       double threshold) {\n        super(null); // No custom convergence criterion.\n        this.initialStepBoundFactor = initialStepBoundFactor;\n        this.costRelativeTolerance = costRelativeTolerance;\n        this.parRelativeTolerance = parRelativeTolerance;\n        this.orthoTolerance = orthoTolerance;\n        this.qrRankingThreshold = threshold;\n    }\n",
        "begin_line": 269,
        "end_line": 280,
        "comment": "\n     * The arguments control the behaviour of the default convergence checking\n     * procedure.\n     * Additional criteria can defined through the setting of a {@link\n     * ConvergenceChecker}.\n     *\n     * @param initialStepBoundFactor Positive input variable used in\n     * determining the initial step bound. This bound is set to the\n     * product of initialStepBoundFactor and the euclidean norm of\n     * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\n     * itself. In most cases factor should lie in the interval\n     * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\n     * @param costRelativeTolerance Desired relative error in the sum of\n     * squares.\n     * @param parRelativeTolerance Desired relative error in the approximate\n     * solution parameters.\n     * @param orthoTolerance Desired max cosine on the orthogonality between\n     * the function vector and the columns of the Jacobian.\n     * @param threshold Desired threshold for QR ranking. If the squared norm\n     * of a column vector is smaller or equal to this threshold during QR\n     * decomposition, it is considered to be a zero vector and hence the rank\n     * of the matrix is reduced.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0236
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrayRealVector.toArray#724",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java",
        "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
        "signature": "org.apache.commons.math3.linear.ArrayRealVector.toArray()",
        "snippet": "    @Override\n    public double[] toArray(){\n        return data.clone();\n    }\n",
        "begin_line": 724,
        "end_line": 727,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math3.linear.RealVector": "\n     * Convert the vector to an array of {@code double}s.\n     * The array is independent from this vector data: the elements\n     * are copied.\n     *\n     * @return an array containing a copy of the vector elements.\n     ",
            "java.io.Serializable": null
        },
        "susp": {
            "ochiai_susp": 0.0231
        },
        "num_failing_tests": 1
    }
]