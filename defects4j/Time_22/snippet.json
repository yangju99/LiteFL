[
    {
        "name": "FixedDateTimeZone.isFixed#60",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.isFixed()",
        "snippet": "    public boolean isFixed() {\n        return true;\n    }\n",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6325
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractDuration.toPeriod#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractDuration.java",
        "class_name": "org.joda.time.base.AbstractDuration",
        "signature": "org.joda.time.base.AbstractDuration.toPeriod()",
        "snippet": "    public Period toPeriod() {\n        return new Period(getMillis());\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * Converts this duration to a Period instance using the standard period type\n     * and the ISO chronology.\n     * <p>\n     * Only precise fields in the period type will be used. Thus, only the hour,\n     * minute, second and millisecond fields on the period will be used.\n     * The year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available field, hours in this case.\n     * <p>\n     * For example, a duration effectively equal to (365 + 60 + 5) days will be\n     * converted to ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you must pair the duration with\n     * an instant, see {@link Period#Period(ReadableInstant,ReadableDuration)}.\n     * \n     * @return a Period created using the millisecond duration from this instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "FixedDateTimeZone.getOffsetFromLocal#56",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.getOffsetFromLocal(long)",
        "snippet": "    public int getOffsetFromLocal(long instantLocal) {\n        return iWallOffset;\n    }\n",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "Period.Period#381",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Period.java",
        "class_name": "org.joda.time.Period",
        "signature": "org.joda.time.Period.Period(long)",
        "snippet": "    public Period(long duration) {\n        super(duration);\n    }\n",
        "begin_line": 381,
        "end_line": 383,
        "comment": "\n     * Creates a period from the given millisecond duration using the standard\n     * set of fields.\n     * <p>\n     * Only precise fields in the period type will be used.\n     * For the standard period type this is the time fields only.\n     * Thus the year, month, week and day fields will not be populated.\n     * <p>\n     * If the duration is small, less than one day, then this method will perform\n     * as you might expect and split the fields evenly.\n     * <p>\n     * If the duration is larger than one day then all the remaining duration will\n     * be stored in the largest available precise field, hours in this case.\n     * <p>\n     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n     * ((365 + 60 + 5) * 24) hours by this constructor.\n     * <p>\n     * For more control over the conversion process, you have two options:\n     * <ul>\n     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n     * <li>specify a period type that contains precise definitions of the day and larger\n     * fields, such as UTC\n     * </ul>\n     *\n     * @param duration  the duration, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2462
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.forOffsetHours#236",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forOffsetHours(int)",
        "snippet": "    public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\n        return forOffsetHoursMinutes(hoursOffset, 0);\n    }\n",
        "begin_line": 236,
        "end_line": 238,
        "comment": "\n     * Gets a time zone instance for the specified offset to UTC in hours.\n     * This method assumes standard length hours.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset is too large or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.forOffsetHoursMinutes#253",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forOffsetHoursMinutes(int, int)",
        "snippet": "    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n            if (hoursInMinutes < 0) {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n            } else {\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n",
        "begin_line": 253,
        "end_line": 273,
        "comment": "\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The minutes value is always positive and in the range 0 to 59.\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\n     * \n     * @param hoursOffset  the offset in hours from UTC\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.BasePeriod#221",
        "is_bug": true,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.BasePeriod(long)",
        "snippet": "    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        // bug [3264409]\n    }\n",
        "begin_line": 221,
        "end_line": 224,
        "comment": "\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.forOffsetMillis#281",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forOffsetMillis(int)",
        "snippet": "    public static DateTimeZone forOffsetMillis(int millisOffset) {\n        String id = printOffset(millisOffset);\n        return fixedOffsetZone(id, millisOffset);\n    }\n",
        "begin_line": 281,
        "end_line": 284,
        "comment": "\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     *\n     * @param millisOffset  the offset in millis from UTC\n     * @return the DateTimeZone object for the offset\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.fixedOffsetZone#348",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.fixedOffsetZone(java.lang.String, int)",
        "snippet": "    private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (iFixedOffsetCache == null) {\n            iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        DateTimeZone zone;\n        Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        zone = new FixedDateTimeZone(id, null, offset, offset);\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }\n",
        "begin_line": 348,
        "end_line": 366,
        "comment": "\n     * Gets the zone using a fixed offset amount.\n     * \n     * @param id  the zone id\n     * @param offset  the offset in millis\n     * @return the zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1703
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.printOffset#630",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.printOffset(int)",
        "snippet": "    private static String printOffset(int offset) {\n        StringBuffer buf = new StringBuffer();\n        if (offset >= 0) {\n            buf.append('+');\n        } else {\n            buf.append('-');\n            offset = -offset;\n        }\n\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, seconds, 2);\n        offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n        if (offset == 0) {\n            return buf.toString();\n        }\n\n        buf.append('.');\n        FormatUtils.appendPaddedInteger(buf, offset, 3);\n        return buf.toString();\n    }\n",
        "begin_line": 630,
        "end_line": 662,
        "comment": "\n     * Formats a timezone offset string.\n     * <p>\n     * This method is kept separate from the formatting classes to speed and\n     * simplify startup and classloading.\n     * \n     * @param offset  the offset in milliseconds\n     * @return the time zone string\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1703
        },
        "num_failing_tests": 2
    },
    {
        "name": "FixedDateTimeZone.getOffset#48",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.getOffset(long)",
        "snippet": "    public int getOffset(long instant) {\n        return iWallOffset;\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1644
        },
        "num_failing_tests": 2
    },
    {
        "name": "FieldUtils.safeMultiply#118",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeMultiply(int, int)",
        "snippet": "    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n",
        "begin_line": 118,
        "end_line": 125,
        "comment": "\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1552
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.isPrecise#293",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.isPrecise()",
        "snippet": "        public boolean isPrecise() {\n            return iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n        }\n",
        "begin_line": 293,
        "end_line": 295,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 2
    },
    {
        "name": "ImpreciseDateTimeField.isPrecise#155",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.LinkedDurationField.isPrecise()",
        "snippet": "        public boolean isPrecise() {\n            return false;\n        }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseChronology.get#275",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.get(org.joda.time.ReadablePeriod, long)",
        "snippet": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }\n",
        "begin_line": 275,
        "end_line": 290,
        "comment": "\n     * Gets the values of a period from an interval.\n     *\n     * @param period  the period instant to use\n     * @param duration  the duration to query\n     * @return the values of the period extracted from the duration\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 2
    },
    {
        "name": "Period.getYears#703",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Period.java",
        "class_name": "org.joda.time.Period",
        "signature": "org.joda.time.Period.getYears()",
        "snippet": "    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n",
        "begin_line": 703,
        "end_line": 705,
        "comment": "\n     * Gets the years field part of the period.\n     * \n     * @return the number of years in the period, zero if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 2
    },
    {
        "name": "Period.getMonths#712",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Period.java",
        "class_name": "org.joda.time.Period",
        "signature": "org.joda.time.Period.getMonths()",
        "snippet": "    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n",
        "begin_line": 712,
        "end_line": 714,
        "comment": "\n     * Gets the months field part of the period.\n     * \n     * @return the number of months in the period, zero if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 2
    },
    {
        "name": "Period.getWeeks#721",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Period.java",
        "class_name": "org.joda.time.Period",
        "signature": "org.joda.time.Period.getWeeks()",
        "snippet": "    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }\n",
        "begin_line": 721,
        "end_line": 723,
        "comment": "\n     * Gets the weeks field part of the period.\n     * \n     * @return the number of weeks in the period, zero if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getOffsetFromLocalToSubtract#353",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.getOffsetFromLocalToSubtract(long)",
        "snippet": "        private int getOffsetFromLocalToSubtract(long instant) {\n            int offset = this.iZone.getOffsetFromLocal(instant);\n            long diff = instant - offset;\n            // If there is a sign change, but the two values have different signs...\n            if ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\n                throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n            }\n            return offset;\n        }\n",
        "begin_line": 353,
        "end_line": 361,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1217
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.getDifference#124",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.getDifference(long, long)",
        "snippet": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant));\n    }\n",
        "begin_line": 124,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1122
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getDifference#329",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.getDifference(long, long)",
        "snippet": "        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            int offset = getOffsetToAdd(subtrahendInstant);\n            return iField.getDifference\n                (minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\n                 subtrahendInstant + offset);\n        }\n",
        "begin_line": 329,
        "end_line": 334,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1098
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.getField#263",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.StandardDurationFieldType.getField(org.joda.time.Chronology)",
        "snippet": "        public DurationField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n            \n            switch (iOrdinal) {\n                case ERAS:\n                    return chronology.eras();\n                case CENTURIES:\n                    return chronology.centuries();\n                case WEEKYEARS:\n                    return chronology.weekyears();\n                case YEARS:\n                    return chronology.years();\n                case MONTHS:\n                    return chronology.months();\n                case WEEKS:\n                    return chronology.weeks();\n                case DAYS:\n                    return chronology.days();\n                case HALFDAYS:\n                    return chronology.halfdays();\n                case HOURS:\n                    return chronology.hours();\n                case MINUTES:\n                    return chronology.minutes();\n                case SECONDS:\n                    return chronology.seconds();\n                case MILLIS:\n                    return chronology.millis();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }\n",
        "begin_line": 263,
        "end_line": 295,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1085
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.getDifferenceAsLong#113",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.getDifferenceAsLong(long, long)",
        "snippet": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\n        return difference / iUnitMillis;\n    }\n",
        "begin_line": 113,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDurationField.getDifference#140",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.getDifference(long, long)",
        "snippet": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n    }\n",
        "begin_line": 140,
        "end_line": 142,
        "comment": "------------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 2
    },
    {
        "name": "FieldUtils.safeSubtract#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeSubtract(long, long)",
        "snippet": "    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n",
        "begin_line": 99,
        "end_line": 107,
        "comment": "\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0988
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.add#317",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.add(long, int)",
        "snippet": "        public long add(long instant, int value) {\n            int offset = getOffsetToAdd(instant);\n            instant = iField.add(instant + offset, value);\n            return instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n        }\n",
        "begin_line": 317,
        "end_line": 321,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0935
        },
        "num_failing_tests": 2
    },
    {
        "name": "FieldUtils.safeToInt#183",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeToInt(long)",
        "snippet": "    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }\n",
        "begin_line": 183,
        "end_line": 188,
        "comment": "\n     * Casts to an int throwing an exception if overflow occurs.\n     * \n     * @param value  the value\n     * @return the value as an int\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0889
        },
        "num_failing_tests": 2
    },
    {
        "name": "FormatUtils.appendPaddedInteger#49",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/FormatUtils.java",
        "class_name": "org.joda.time.format.FormatUtils",
        "signature": "org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)",
        "snippet": "    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\n        if (value < 0) {\n            buf.append('-');\n            if (value != Integer.MIN_VALUE) {\n                value = -value;\n            } else {\n                for (; size > 10; size--) {\n                    buf.append('0');\n                }\n                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n                return;\n            }\n        }\n        if (value < 10) {\n            for (; size > 1; size--) {\n                buf.append('0');\n            }\n            buf.append((char)(value + '0'));\n        } else if (value < 100) {\n            for (; size > 2; size--) {\n                buf.append('0');\n            }\n            // Calculate value div/mod by 10 without using two expensive\n            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n            // value to correct rounding error.\n            int d = ((value + 1) * 13421772) >> 27;\n            buf.append((char) (d + '0'));\n            // Append remainder by calculating (value - d * 10).\n            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n        } else {\n            int digits;\n            if (value < 1000) {\n                digits = 3;\n            } else if (value < 10000) {\n                digits = 4;\n            } else {\n                digits = (int)(Math.log(value) / LOG_10) + 1;\n            }\n            for (; size > digits; size--) {\n                buf.append('0');\n            }\n            buf.append(Integer.toString(value));\n        }\n    }\n",
        "begin_line": 49,
        "end_line": 92,
        "comment": "\n     * Converts an integer to a string, prepended with a variable amount of '0'\n     * pad characters, and appends it to the given buffer.\n     *\n     * <p>This method is optimized for converting small values to strings.\n     *\n     * @param buf receives integer converted to a string\n     * @param value value to convert to a string\n     * @param size minumum amount of digits to append\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.getIndexedField#673",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.getIndexedField(org.joda.time.ReadablePeriod, int)",
        "snippet": "    int getIndexedField(ReadablePeriod period, int index) {\n        int realIndex = iIndices[index];\n        return (realIndex == -1 ? 0 : period.getValue(realIndex));\n    }\n",
        "begin_line": 673,
        "end_line": 676,
        "comment": "\n     * Gets the indexed field part of the period.\n     * \n     * @param period  the period to query\n     * @param index  the index to use\n     * @return the value of the field, zero if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0861
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getOffsetToAdd#343",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.getOffsetToAdd(long)",
        "snippet": "        private int getOffsetToAdd(long instant) {\n            int offset = this.iZone.getOffset(instant);\n            long sum = instant + offset;\n            // If there is a sign change, but the two values have the same sign...\n            if ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\n                throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n            }\n            return offset;\n        }\n",
        "begin_line": 343,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.getFieldType#323",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.getFieldType(int)",
        "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n",
        "begin_line": 323,
        "end_line": 325,
        "comment": "\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0773
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.getFieldType#627",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.getFieldType(int)",
        "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iTypes[index];\n    }\n",
        "begin_line": 627,
        "end_line": 629,
        "comment": "\n     * Gets the field type by index.\n     * \n     * @param index  the index to retrieve\n     * @return the field type\n     * @throws IndexOutOfBoundsException if the index is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0773
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDuration.getMillis#114",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDuration.java",
        "class_name": "org.joda.time.base.BaseDuration",
        "signature": "org.joda.time.base.BaseDuration.getMillis()",
        "snippet": "    public long getMillis() {\n        return iMillis;\n    }\n",
        "begin_line": 114,
        "end_line": 116,
        "comment": "\n     * Gets the length of this duration in milliseconds.\n     *\n     * @return the length of the duration in milliseconds.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.069
        },
        "num_failing_tests": 1
    },
    {
        "name": "Period.Period#297",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Period.java",
        "class_name": "org.joda.time.Period",
        "signature": "org.joda.time.Period.Period()",
        "snippet": "    public Period() {\n        super(0L, null, null);\n    }\n",
        "begin_line": 297,
        "end_line": 299,
        "comment": "\n     * Creates a new empty period with the standard set of fields.\n     * <p>\n     * One way to initialise a period is as follows:\n     * <pre>\n     * Period = new Period().withYears(6).withMonths(3).withSeconds(23);\n     * </pre>\n     * Bear in mind that this creates four period instances in total, three of\n     * which are immediately discarded.\n     * The alterative is more efficient, but less readable:\n     * <pre>\n     * Period = new Period(6, 3, 0, 0, 0, 0, 23, 0);\n     * </pre>\n     * The following is also slightly less wasteful:\n     * <pre>\n     * Period = Period.years(6).withMonths(3).withSeconds(23);\n     * </pre>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0689
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.getPeriodType#285",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getPeriodType(org.joda.time.PeriodType)",
        "snippet": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }\n",
        "begin_line": 285,
        "end_line": 290,
        "comment": "\n     * Gets the period type handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n     * will be returned. Otherwise, the type specified is returned.\n     * \n     * @param type  the time zone to use, null means the standard type\n     * @return the type to use, never null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.add#116",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.add(long, int)",
        "snippet": "    public long add(long instant, int value) {\n        return FieldUtils.safeAdd(instant, value);\n    }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 2
    },
    {
        "name": "Duration.Duration#175",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Duration.java",
        "class_name": "org.joda.time.Duration",
        "signature": "org.joda.time.Duration.Duration(long)",
        "snippet": "    public Duration(long duration) {\n        super(duration);\n    }\n",
        "begin_line": 175,
        "end_line": 177,
        "comment": "\n     * Creates a duration from the given millisecond duration.\n     *\n     * @param duration  the duration, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0651
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseDuration.BaseDuration#60",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDuration.java",
        "class_name": "org.joda.time.base.BaseDuration",
        "signature": "org.joda.time.base.BaseDuration.BaseDuration(long)",
        "snippet": "    protected BaseDuration(long duration) {\n        super();\n        iMillis = duration;\n    }\n",
        "begin_line": 60,
        "end_line": 63,
        "comment": "\n     * Creates a duration from the given millisecond duration.\n     *\n     * @param duration  the duration, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0648
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractDuration.AbstractDuration#43",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractDuration.java",
        "class_name": "org.joda.time.base.AbstractDuration",
        "signature": "org.joda.time.base.AbstractDuration.AbstractDuration()",
        "snippet": "    protected AbstractDuration() {\n        super();\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0648
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldUtils.safeAdd#63",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeAdd(int, int)",
        "snippet": "    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n",
        "begin_line": 63,
        "end_line": 71,
        "comment": "\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0648
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.BasePeriod#238",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.BasePeriod(long, org.joda.time.PeriodType, org.joda.time.Chronology)",
        "snippet": "    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n",
        "begin_line": 238,
        "end_line": 244,
        "comment": "\n     * Creates a period from the given millisecond duration, which is only really\n     * suitable for durations less than one day.\n     * <p>\n     * Only fields that are precise will be used.\n     * Thus the largest precise field may have a large value.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0647
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.getPeriodType#302",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.getPeriodType()",
        "snippet": "    public PeriodType getPeriodType() {\n        return iType;\n    }\n",
        "begin_line": 302,
        "end_line": 304,
        "comment": "\n     * Gets the period type.\n     *\n     * @return the period type\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0637
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.getValue#334",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.getValue(int)",
        "snippet": "    public int getValue(int index) {\n        return iValues[index];\n    }\n",
        "begin_line": 334,
        "end_line": 336,
        "comment": "\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0633
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.add#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.add(long, int)",
        "snippet": "    public long add(long instant, int value) {\n        long addition = value * iUnitMillis;  // safe\n        return FieldUtils.safeAdd(instant, addition);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0616
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.standard#101",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.standard()",
        "snippet": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"Standard\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }\n",
        "begin_line": 101,
        "end_line": 117,
        "comment": "\n     * Gets a type that defines all standard fields.\n     * <ul>\n     * <li>years\n     * <li>months\n     * <li>weeks\n     * <li>days\n     * <li>hours\n     * <li>minutes\n     * <li>seconds\n     * <li>milliseconds\n     * </ul>\n     *\n     * @return the period type\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0612
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.checkPeriodType#292",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.checkPeriodType(org.joda.time.PeriodType)",
        "snippet": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n",
        "begin_line": 292,
        "end_line": 294,
        "comment": "\n     * Validates a period type, converting nulls to a default value and\n     * checking the type is suitable for this instance.\n     * \n     * @param type  the type to check, may be null\n     * @return the validated type to use, not null\n     * @throws IllegalArgumentException if the period type is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0601
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasePeriod.size#312",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BasePeriod.java",
        "class_name": "org.joda.time.base.BasePeriod",
        "signature": "org.joda.time.base.BasePeriod.size()",
        "snippet": "    public int size() {\n        return iType.size();\n    }\n",
        "begin_line": 312,
        "end_line": 314,
        "comment": "\n     * Gets the number of fields that this period supports.\n     *\n     * @return the number of fields supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0601
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractPeriod.AbstractPeriod#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractPeriod.java",
        "class_name": "org.joda.time.base.AbstractPeriod",
        "signature": "org.joda.time.base.AbstractPeriod.AbstractPeriod()",
        "snippet": "    protected AbstractPeriod() {\n        super();\n    }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0601
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.size#616",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.size()",
        "snippet": "    public int size() {\n        return iTypes.length;\n    }\n",
        "begin_line": 616,
        "end_line": 618,
        "comment": "\n     * Gets the number of fields in the period type.\n     * \n     * @return the number of fields\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0601
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.equals#834",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof PeriodType == false) {\n            return false;\n        }\n        PeriodType other = (PeriodType) obj;\n        return (Arrays.equals(iTypes, other.iTypes));\n    }\n",
        "begin_line": 834,
        "end_line": 843,
        "comment": "\n     * Compares this type to another object.\n     * To be equal, the object must be a PeriodType with the same set of fields.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.06
        },
        "num_failing_tests": 1
    },
    {
        "name": "FieldUtils.safeAdd#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeAdd(long, long)",
        "snippet": "    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n",
        "begin_line": 81,
        "end_line": 89,
        "comment": "\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOChronology.getInstance#95",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }\n",
        "begin_line": 95,
        "end_line": 113,
        "comment": "\n     * Gets an instance of the ISOChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.053
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeriodType.PeriodType#594",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/PeriodType.java",
        "class_name": "org.joda.time.PeriodType",
        "signature": "org.joda.time.PeriodType.PeriodType(java.lang.String, org.joda.time.DurationFieldType[], int[])",
        "snippet": "    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n        super();\n        iName = name;\n        iTypes = types;\n        iIndices = indices;\n    }\n",
        "begin_line": 594,
        "end_line": 599,
        "comment": "\n     * Constructor.\n     *\n     * @param name  the name\n     * @param types  the types\n     * @param indices  the indices\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0524
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.getChronology#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getChronology(org.joda.time.Chronology)",
        "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n",
        "begin_line": 251,
        "end_line": 256,
        "comment": "\n     * Gets the chronology handling null.\n     * <p>\n     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n     * will be returned. Otherwise, the chronology is returned.\n     * \n     * @param chrono  the chronology to use, null means ISO in the default zone\n     * @return the chronology, never null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.049
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.getZone#105",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = iBase) != null) {\n            return base.getZone();\n        }\n        return null;\n    }\n",
        "begin_line": 105,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.046
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOChronology.getInstance#85",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
        "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n     * Gets an instance of the ISOChronology in the default time zone.\n     * \n     * @return a chronology in the default time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0432
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.FixedMillisProvider#414",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.FixedMillisProvider.FixedMillisProvider(long)",
        "snippet": "        FixedMillisProvider(long fixedMillis) {\n            iMillis = fixedMillis;\n        }\n",
        "begin_line": 414,
        "end_line": 416,
        "comment": "\n         * Constructor.\n         * @param offsetMillis  the millis offset\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0381
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.setCurrentMillisSystem#67",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
        "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }\n",
        "begin_line": 67,
        "end_line": 70,
        "comment": "\n     * Resets the current time to return the system time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n     * \n     * @throws SecurityException if the application does not have sufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0381
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.setCurrentMillisFixed#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
        "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }\n",
        "begin_line": 81,
        "end_line": 84,
        "comment": "\n     * Sets the current time to return a fixed millisecond time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, the same millisecond time will be returned.\n     * \n     * @param fixedMillis  the fixed millisecond time to use\n     * @throws SecurityException if the application does not have sufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0381
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeUtils.checkPermission#128",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.checkPermission()",
        "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }\n",
        "begin_line": 128,
        "end_line": 133,
        "comment": "\n     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.\n     * \n     * @throws SecurityException if the provider may not be changed\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0381
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.setDefault#173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)",
        "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n",
        "begin_line": 173,
        "end_line": 184,
        "comment": "\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0374
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOChronology.withUTC#132",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
        "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }\n",
        "begin_line": 132,
        "end_line": 134,
        "comment": "\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0364
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.getDefault#132",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefault()",
        "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n",
        "begin_line": 132,
        "end_line": 162,
        "comment": "\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0361
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnsupportedDurationField.getUnitMillis#217",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
        "snippet": "    public long getUnitMillis() {\n        return 0;\n    }\n",
        "begin_line": 217,
        "end_line": 219,
        "comment": "\n     * Always returns zero.\n     *\n     * @return zero always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ScaledDurationField.getUnitMillis#108",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
        "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.ZonedDurationField#283",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)",
        "snippet": "        ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n",
        "begin_line": 283,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getUnitMillis#297",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.getUnitMillis()",
        "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.ZonedDateTimeField#384",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "        ZonedDateTimeField(DateTimeField field,\n                           DateTimeZone zone,\n                           DurationField durationField,\n                           DurationField rangeDurationField,\n                           DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n",
        "begin_line": 384,
        "end_line": 399,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getInstance#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)",
        "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n",
        "begin_line": 55,
        "end_line": 67,
        "comment": "\n     * Create a ZonedChronology for any chronology, overriding any time zone it\n     * may already have.\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     * @throws IllegalArgumentException if chronology or time zone is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.useTimeArithmetic#69",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)",
        "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.ZonedChronology#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)",
        "snippet": "    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Restricted constructor\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.getZone#85",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.assemble#150",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n",
        "begin_line": 150,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.convertField#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n",
        "begin_line": 199,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZonedChronology.convertField#211",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n",
        "begin_line": 211,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZeroIsMaxDateTimeField.getLeapDurationField#100",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ZeroIsMaxDateTimeField.java",
        "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
        "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }\n",
        "begin_line": 100,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "ScaledDurationField.hashCode#146",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
        "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }\n",
        "begin_line": 146,
        "end_line": 152,
        "comment": "\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.hashCode#141",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
        "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }\n",
        "begin_line": 141,
        "end_line": 146,
        "comment": "\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.getType#48",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.getType()",
        "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "------------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDurationField.getWrappedField#68",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDurationField.java",
        "class_name": "org.joda.time.field.DecoratedDurationField",
        "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
        "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Gets the wrapped duration field.\n     * \n     * @return the wrapped DurationField\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDateTimeField.getLeapDurationField#725",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }\n",
        "begin_line": 725,
        "end_line": 727,
        "comment": "\n     * If this field were to leap, then it would be in units described by the\n     * returned duration. If this field doesn't ever leap, null is returned.\n     * <p>\n     * This implementation returns null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicYearDateTimeField.getLeapDurationField#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicWeekyearDateTimeField.getLeapDurationField#219",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }\n",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicMonthOfYearDateTimeField.getLeapDurationField#327",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n",
        "begin_line": 327,
        "end_line": 329,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0359
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJEraDateTimeField.getDurationField#126",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJEraDateTimeField.getRangeDurationField#130",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJDayOfWeekDateTimeField.getRangeDurationField#93",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "ImpreciseDateTimeField.getUnitMillis#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.LinkedDurationField.getUnitMillis()",
        "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.getRangeDurationField#138",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n     * Returns a scaled version of the wrapped field's unit duration field.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDateTimeField.getRangeDurationField#89",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }\n",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDurationField.getType#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.getType()",
        "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicWeekyearDateTimeField.getRangeDurationField#207",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicDayOfYearDateTimeField.getRangeDurationField#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.getParam#314",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
        "snippet": "    protected final Object getParam() {\n        return iParam;\n    }\n",
        "begin_line": 314,
        "end_line": 316,
        "comment": "\n     * Returns the same param object as passed into the constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0358
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()",
        "snippet": "    private ISOYearOfEraDateTimeField() {\n        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOYearOfEraDateTimeField.getMinimumValue#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOYearOfEraDateTimeField.getMaximumValue#90",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOChronology.ISOChronology#121",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)",
        "snippet": "    private ISOChronology(Chronology base) {\n        super(base, null);\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "ISOChronology.assemble#168",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }\n",
        "begin_line": 168,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getInstanceUTC#80",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
        "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": "\n     * Gets an instance of the GregorianChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicChronology.getZone#141",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n",
        "begin_line": 141,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDateTimeField.getRangeDurationField#121",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * Returns the range duration of this field. For example, if this field\n     * represents \"minute of hour\", then the range duration field is an hours.\n     *\n     * @return the range duration of this field, or null if field has no range\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicYearDateTimeField.getRangeDurationField#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicMonthOfYearDateTimeField.getRangeDurationField#308",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n",
        "begin_line": 308,
        "end_line": 310,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicDayOfMonthDateTimeField.getRangeDurationField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }\n",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationDateTimeField.getDurationField#140",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }\n",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"minute of hour\", then the duration field is minutes.\n     *\n     * @return the duration of this field, or UnsupportedDurationField if field\n     * has no duration\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0357
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.setFields#318",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
        "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }\n",
        "begin_line": 318,
        "end_line": 386,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0356
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getInstance#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n     * Gets an instance of the GregorianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getInstance#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)",
        "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }\n",
        "begin_line": 110,
        "end_line": 139,
        "comment": "\n     * Gets an instance of the GregorianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.GregorianChronology#147",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.assemble#190",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }\n",
        "begin_line": 190,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getMaxYear#224",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
        "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }\n",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getAverageMillisPerYear#228",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
        "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }\n",
        "begin_line": 228,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GregorianChronology.getAverageMillisPerMonth#236",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
        "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }\n",
        "begin_line": 236,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicGJChronology.BasicGJChronology#74",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }\n",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicChronology.getMaxMonth#690",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
        "snippet": "    int getMaxMonth() {\n        return 12;\n    }\n",
        "begin_line": 690,
        "end_line": 692,
        "comment": "\n     * Gets the maximum number of months.\n     * \n     * @return 12\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "FixedDateTimeZone.hashCode#101",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
        "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ZeroIsMaxDateTimeField.java",
        "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
        "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }\n",
        "begin_line": 44,
        "end_line": 49,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the field type this field will actually use\n     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnsupportedDurationField.getInstance#47",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(org.joda.time.DurationFieldType)",
        "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n",
        "begin_line": 47,
        "end_line": 60,
        "comment": "\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnsupportedDurationField.UnsupportedDurationField#70",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(org.joda.time.DurationFieldType)",
        "snippet": "    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n",
        "begin_line": 70,
        "end_line": 72,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the type to use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnsupportedDurationField.isSupported#91",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
        "snippet": "    public boolean isSupported() {\n        return false;\n    }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n     * This field is not supported.\n     *\n     * @return false always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "ScaledDurationField.ScaledDurationField#46",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, org.joda.time.DurationFieldType, int)",
        "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }\n",
        "begin_line": 46,
        "end_line": 52,
        "comment": "\n     * Constructor\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the type this field will actually use\n     * @param scalar  scalar, such as 100 years in a century\n     * @throws IllegalArgumentException if scalar is zero or one.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }\n",
        "begin_line": 50,
        "end_line": 67,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#75",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField)",
        "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }\n",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": "\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     * @param type  the field type this field actually uses\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.getMinimumValue#147",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "\n     * Get the minimum value for the field, which is always zero.\n     * \n     * @return the minimum value of zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemainderDateTimeField.getMaximumValue#157",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": "\n     * Get the maximum value for the field, which is always one less than the\n     * divisor.\n     * \n     * @return the maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.PreciseDurationField#42",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(org.joda.time.DurationFieldType, long)",
        "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the unit milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.isPrecise#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
        "snippet": "    public final boolean isPrecise() {\n        return true;\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * This field is precise.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationField.getUnitMillis#62",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return the unit size of this field, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField#47",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(org.joda.time.DateTimeFieldType, org.joda.time.DurationField)",
        "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }\n",
        "begin_line": 47,
        "end_line": 60,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unit  precise unit duration, like \"days()\".\n     * @throws IllegalArgumentException if duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationDateTimeField.getMinimumValue#149",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDurationDateTimeField.getUnitMillis#153",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }\n",
        "begin_line": 153,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "PreciseDateTimeField.PreciseDateTimeField#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(org.joda.time.DateTimeFieldType, org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }\n",
        "begin_line": 55,
        "end_line": 70,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type this field uses\n     * @param unit  precise unit duration, like \"seconds()\".\n     * @param range precise range duration, preferably a multiple of the unit,\n     * like \"minutes()\".\n     * @throws IllegalArgumentException if either duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     * or effective value range is less than two.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#71",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int, int, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }\n",
        "begin_line": 71,
        "end_line": 91,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @param minValue  minimum allowed value\n     * @param maxValue  maximum allowed value\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "OffsetDateTimeField.getMinimumValue#173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }\n",
        "begin_line": 173,
        "end_line": 175,
        "comment": "\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "OffsetDateTimeField.getMaximumValue#182",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }\n",
        "begin_line": 182,
        "end_line": 184,
        "comment": "\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.MillisDurationField#43",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.MillisDurationField()",
        "snippet": "    private MillisDurationField() {\n        super();\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.isSupported#61",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.isSupported()",
        "snippet": "    public boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "\n     * Returns true as this field is supported.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.isPrecise#70",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
        "snippet": "    public final boolean isPrecise() {\n        return true;\n    }\n",
        "begin_line": 70,
        "end_line": 72,
        "comment": "\n     * Returns true as this field is precise.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.getUnitMillis#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return one always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "ImpreciseDateTimeField.LinkedDurationField#151",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.LinkedDurationField.LinkedDurationField(org.joda.time.DurationFieldType)",
        "snippet": "        LinkedDurationField(DurationFieldType type) {\n            super(type);\n        }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "ImpreciseDateTimeField.ImpreciseDateTimeField#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(org.joda.time.DateTimeFieldType, long)",
        "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }\n",
        "begin_line": 54,
        "end_line": 58,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the average duration unit milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "ImpreciseDateTimeField.getDurationField#136",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
        "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DividedDateTimeField.DividedDateTimeField#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DividedDateTimeField.java",
        "class_name": "org.joda.time.field.DividedDateTimeField",
        "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }\n",
        "begin_line": 54,
        "end_line": 80,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field will actually use\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DividedDateTimeField.getDurationField#181",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DividedDateTimeField.java",
        "class_name": "org.joda.time.field.DividedDateTimeField",
        "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Returns a scaled version of the wrapped field's unit duration field.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDurationField.DecoratedDurationField#51",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDurationField.java",
        "class_name": "org.joda.time.field.DecoratedDurationField",
        "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, org.joda.time.DurationFieldType)",
        "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }\n",
        "begin_line": 51,
        "end_line": 60,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the type to actually use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDateTimeField.DecoratedDateTimeField#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }\n",
        "begin_line": 53,
        "end_line": 62,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     * @param type  allow type to be overridden\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDateTimeField.getWrappedField#69",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
        "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }\n",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n     * Gets the wrapped date time field.\n     * \n     * @return the wrapped DateTimeField\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DecoratedDateTimeField.getDurationField#85",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDurationField.BaseDurationField#46",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(org.joda.time.DurationFieldType)",
        "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }\n",
        "begin_line": 46,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDurationField.isSupported#65",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.isSupported()",
        "snippet": "    public final boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDateTimeField.BaseDateTimeField#49",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(org.joda.time.DateTimeFieldType)",
        "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }\n",
        "begin_line": 49,
        "end_line": 55,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDateTimeField.getType#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.getType()",
        "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDateTimeField.isSupported#68",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
        "snippet": "    public final boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField#39",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }\n",
        "begin_line": 39,
        "end_line": 42,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJYearOfEraDateTimeField.getMinimumValue#92",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 1;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJYearOfEraDateTimeField.getMaximumValue#96",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField#36",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJEraDateTimeField.GJEraDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicYearDateTimeField.BasicYearDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     * \n     * @param chronology  the chronology this field belogs to\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicYearDateTimeField.getMaximumValue#118",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }\n",
        "begin_line": 118,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField#43",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField#41",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }\n",
        "begin_line": 41,
        "end_line": 44,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(org.joda.time.chrono.BasicChronology, int)",
        "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }\n",
        "begin_line": 50,
        "end_line": 55,
        "comment": "\n     * Restricted constructor.\n     * \n     * @param leapMonth the month of year that leaps\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField#40",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField#40",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicChronology.HalfdayField#749",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.HalfdayField.HalfdayField()",
        "snippet": "        HalfdayField() {\n            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);\n        }\n",
        "begin_line": 749,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicChronology.BasicChronology#130",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }\n",
        "begin_line": 130,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BasicChronology.assemble#237",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }\n",
        "begin_line": 237,
        "end_line": 298,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseChronology.eras#659",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.eras()",
        "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }\n",
        "begin_line": 659,
        "end_line": 661,
        "comment": "\n     * Get the eras duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.Fields#436",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.Fields()",
        "snippet": "        Fields() {\n        }\n",
        "begin_line": 436,
        "end_line": 437,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.copyFieldsFrom#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.copyFieldsFrom(org.joda.time.Chronology)",
        "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }\n",
        "begin_line": 442,
        "end_line": 555,
        "comment": "\n         * Copy the supported fields from a chronology into this container.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.isSupported#557",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.isSupported(org.joda.time.DurationField)",
        "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }\n",
        "begin_line": 557,
        "end_line": 559,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.isSupported#561",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.isSupported(org.joda.time.DateTimeField)",
        "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }\n",
        "begin_line": 561,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.AssembledChronology#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)",
        "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }\n",
        "begin_line": 99,
        "end_line": 103,
        "comment": "\n     * Constructor calls the assemble method, enabling subclasses to define its\n     * supported fields. If a base chronology is supplied, the field set\n     * initially contains references to each base chronology field.\n     * <p>\n     * Other methods in this class will delegate to the base chronology, if it\n     * can be determined that the base chronology will produce the same results\n     * as AbstractChronology.\n     *\n     * @param base optional base chronology to copy initial fields from\n     * @param param optional param object avalable for assemble method\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.millis#155",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millis()",
        "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.millisOfSecond#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
        "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.millisOfDay#163",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
        "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.seconds#167",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
        "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }\n",
        "begin_line": 167,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.secondOfMinute#171",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
        "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.secondOfDay#175",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
        "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }\n",
        "begin_line": 175,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.minutes#179",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
        "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }\n",
        "begin_line": 179,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.minuteOfHour#183",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
        "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }\n",
        "begin_line": 183,
        "end_line": 185,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.minuteOfDay#187",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
        "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }\n",
        "begin_line": 187,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.hours#191",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hours()",
        "snippet": "    public final DurationField hours() {\n        return iHours;\n    }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.hourOfDay#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
        "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }\n",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.clockhourOfDay#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
        "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }\n",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.halfdays#203",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
        "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }\n",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.hourOfHalfday#207",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
        "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.clockhourOfHalfday#211",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
        "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }\n",
        "begin_line": 211,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.halfdayOfDay#215",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
        "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }\n",
        "begin_line": 215,
        "end_line": 217,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.days#219",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.days()",
        "snippet": "    public final DurationField days() {\n        return iDays;\n    }\n",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.dayOfWeek#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
        "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.dayOfMonth#227",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
        "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.dayOfYear#231",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
        "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }\n",
        "begin_line": 231,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.weeks#235",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
        "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.weekOfWeekyear#239",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
        "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }\n",
        "begin_line": 239,
        "end_line": 241,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.weekyears#243",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
        "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }\n",
        "begin_line": 243,
        "end_line": 245,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.weekyear#247",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
        "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }\n",
        "begin_line": 247,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.weekyearOfCentury#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
        "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }\n",
        "begin_line": 251,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.months#255",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.months()",
        "snippet": "    public final DurationField months() {\n        return iMonths;\n    }\n",
        "begin_line": 255,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.monthOfYear#259",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
        "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }\n",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.years#263",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.years()",
        "snippet": "    public final DurationField years() {\n        return iYears;\n    }\n",
        "begin_line": 263,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.year#267",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.year()",
        "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }\n",
        "begin_line": 267,
        "end_line": 269,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.yearOfEra#271",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
        "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.yearOfCentury#275",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
        "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }\n",
        "begin_line": 275,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.centuries#279",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
        "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }\n",
        "begin_line": 279,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.centuryOfEra#283",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
        "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }\n",
        "begin_line": 283,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.eras#287",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.eras()",
        "snippet": "    public final DurationField eras() {\n        return iEras;\n    }\n",
        "begin_line": 287,
        "end_line": 289,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.era#291",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.era()",
        "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }\n",
        "begin_line": 291,
        "end_line": 293,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "AssembledChronology.getBase#307",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
        "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }\n",
        "begin_line": 307,
        "end_line": 309,
        "comment": "\n     * Returns the same base chronology as passed into the constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.halfdays#140",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.halfdays()",
        "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }\n",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Get the halfdays field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.weekyears#168",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.weekyears()",
        "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }\n",
        "begin_line": 168,
        "end_line": 170,
        "comment": "\n     * Get the weekyears field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.centuries#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.centuries()",
        "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }\n",
        "begin_line": 195,
        "end_line": 197,
        "comment": "\n     * Get the centuries field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.eras#204",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.eras()",
        "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }\n",
        "begin_line": 204,
        "end_line": 206,
        "comment": "\n     * Get the eras field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.StandardDateTimeFieldType#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.StandardDateTimeFieldType(java.lang.String, byte, org.joda.time.DurationFieldType, org.joda.time.DurationFieldType)",
        "snippet": "        StandardDateTimeFieldType(String name, byte ordinal,\n                                  DurationFieldType unitType, DurationFieldType rangeType) {\n            super(name);\n            iOrdinal = ordinal;\n            iUnitType = unitType;\n            iRangeType = rangeType;\n        }\n",
        "begin_line": 442,
        "end_line": 448,
        "comment": "\n         * Constructor.\n         * \n         * @param name  the name to use\n         * @param ordinal  the byte value for the oridinal index\n         * @param unitType  the unit duration type\n         * @param rangeType  the range duration type\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.getDurationType#451",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getDurationType()",
        "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }\n",
        "begin_line": 451,
        "end_line": 453,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.getRangeDurationType#456",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getRangeDurationType()",
        "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }\n",
        "begin_line": 456,
        "end_line": 458,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.DateTimeFieldType#152",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(java.lang.String)",
        "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }\n",
        "begin_line": 152,
        "end_line": 155,
        "comment": "\n     * Constructor.\n     * \n     * @param name  the name to use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.millisOfSecond#163",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
        "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Get the millis of second field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.millisOfDay#172",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
        "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }\n",
        "begin_line": 172,
        "end_line": 174,
        "comment": "\n     * Get the millis of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.secondOfMinute#181",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
        "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Get the second of minute field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.secondOfDay#190",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
        "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }\n",
        "begin_line": 190,
        "end_line": 192,
        "comment": "\n     * Get the second of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.minuteOfHour#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
        "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }\n",
        "begin_line": 199,
        "end_line": 201,
        "comment": "\n     * Get the minute of hour field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.minuteOfDay#208",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
        "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }\n",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n     * Get the minute of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.hourOfDay#217",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
        "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }\n",
        "begin_line": 217,
        "end_line": 219,
        "comment": "\n     * Get the hour of day (0-23) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.clockhourOfDay#226",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
        "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }\n",
        "begin_line": 226,
        "end_line": 228,
        "comment": "\n     * Get the hour of day (offset to 1-24) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.hourOfHalfday#235",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
        "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "\n     * Get the hour of am/pm (0-11) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.clockhourOfHalfday#244",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
        "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }\n",
        "begin_line": 244,
        "end_line": 246,
        "comment": "\n     * Get the hour of am/pm (offset to 1-12) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.halfdayOfDay#253",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
        "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }\n",
        "begin_line": 253,
        "end_line": 255,
        "comment": "\n     * Get the AM(0) PM(1) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.dayOfWeek#263",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
        "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }\n",
        "begin_line": 263,
        "end_line": 265,
        "comment": "\n     * Get the day of week field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.dayOfMonth#272",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
        "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }\n",
        "begin_line": 272,
        "end_line": 274,
        "comment": "\n     * Get the day of month field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.dayOfYear#281",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
        "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }\n",
        "begin_line": 281,
        "end_line": 283,
        "comment": "\n     * Get the day of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.weekOfWeekyear#290",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
        "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }\n",
        "begin_line": 290,
        "end_line": 292,
        "comment": "\n     * Get the week of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.weekyear#299",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekyear()",
        "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }\n",
        "begin_line": 299,
        "end_line": 301,
        "comment": "\n     * Get the year of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.weekyearOfCentury#308",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
        "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }\n",
        "begin_line": 308,
        "end_line": 310,
        "comment": "\n     * Get the year of a week based year within a century field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.monthOfYear#317",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
        "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }\n",
        "begin_line": 317,
        "end_line": 319,
        "comment": "\n     * Get the month of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.year#326",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.year()",
        "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }\n",
        "begin_line": 326,
        "end_line": 328,
        "comment": "\n     * Get the year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.yearOfEra#335",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
        "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }\n",
        "begin_line": 335,
        "end_line": 337,
        "comment": "\n     * Get the year of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.yearOfCentury#344",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
        "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }\n",
        "begin_line": 344,
        "end_line": 346,
        "comment": "\n     * Get the year of century field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.centuryOfEra#353",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
        "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }\n",
        "begin_line": 353,
        "end_line": 355,
        "comment": "\n     * Get the century of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeFieldType.era#362",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.era()",
        "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }\n",
        "begin_line": 362,
        "end_line": 364,
        "comment": "\n     * Get the era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseChronology.BaseChronology#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
        "snippet": "    protected BaseChronology() {\n        super();\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0354
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.millis#104",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.millis()",
        "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Get the millis field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.035
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.months#177",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.months()",
        "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }\n",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n     * Get the months field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0349
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.years#186",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.years()",
        "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }\n",
        "begin_line": 186,
        "end_line": 188,
        "comment": "\n     * Get the years field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0349
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.weeks#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.weeks()",
        "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n     * Get the weeks field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0348
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.seconds#113",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.seconds()",
        "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Get the seconds field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0348
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.minutes#122",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.minutes()",
        "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }\n",
        "begin_line": 122,
        "end_line": 124,
        "comment": "\n     * Get the minutes field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0348
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.hours#131",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.hours()",
        "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     * Get the hours field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0348
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.days#150",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.days()",
        "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }\n",
        "begin_line": 150,
        "end_line": 152,
        "comment": "\n     * Get the days field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0348
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.StandardDurationFieldType#258",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.StandardDurationFieldType.StandardDurationFieldType(java.lang.String, byte)",
        "snippet": "        StandardDurationFieldType(String name, byte ordinal) {\n            super(name);\n            iOrdinal = ordinal;\n        }\n",
        "begin_line": 258,
        "end_line": 261,
        "comment": "\n         * Constructor.\n         * \n         * @param name  the name to use\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0336
        },
        "num_failing_tests": 2
    },
    {
        "name": "DurationFieldType.DurationFieldType#93",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.DurationFieldType(java.lang.String)",
        "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "\n     * Constructor.\n     * \n     * @param name  the name to use, which by convention, are plural.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0336
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.getZone#135",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(java.lang.String)",
        "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }\n",
        "begin_line": 135,
        "end_line": 163,
        "comment": "\n     * If an error is thrown while loading zone data, uncaughtException is\n     * called to log the error and null is returned for this and all future\n     * requests.\n     * \n     * @param id  the id to load\n     * @return the loaded zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.loadZoneData#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)",
        "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException e) {\n            uncaughtException(e);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n    }\n",
        "begin_line": 223,
        "end_line": 242,
        "comment": "\n     * Loads the time zone data for one id.\n     * \n     * @param id  the id to load\n     * @return the zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#739",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.readFrom(java.io.DataInput)",
        "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }\n",
        "begin_line": 739,
        "end_line": 741,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.Recurrence#747",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear, java.lang.String, int)",
        "snippet": "        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\n            iOfYear = ofYear;\n            iNameKey = nameKey;\n            iSaveMillis = saveMillis;\n        }\n",
        "begin_line": 747,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1339",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }\n",
        "begin_line": 1339,
        "end_line": 1377,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.PrecalculatedZone#1497",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder.DSTZone)",
        "snippet": "        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n        {\n            super(id);\n            iTransitions = transitions;\n            iWallOffsets = wallOffsets;\n            iStandardOffsets = standardOffsets;\n            iNameKeys = nameKeys;\n            iTailZone = tailZone;\n        }\n",
        "begin_line": 1497,
        "end_line": 1506,
        "comment": "\n         * Constructor used ONLY for valid input, loaded via static methods.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#481",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(java.io.DataInput)",
        "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }\n",
        "begin_line": 481,
        "end_line": 488,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.OfYear#499",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.OfYear(char, int, int, int, boolean, int)",
        "snippet": "        OfYear(char mode,\n               int monthOfYear,\n               int dayOfMonth,\n               int dayOfWeek, boolean advanceDayOfWeek,\n               int millisOfDay)\n        {\n            if (mode != 'u' && mode != 'w' && mode != 's') {\n                throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n            }\n\n            iMode = mode;\n            iMonthOfYear = monthOfYear;\n            iDayOfMonth = dayOfMonth;\n            iDayOfWeek = dayOfWeek;\n            iAdvance = advanceDayOfWeek;\n            iMillisOfDay = millisOfDay;\n        }\n",
        "begin_line": 499,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1165",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }\n",
        "begin_line": 1165,
        "end_line": 1168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.DSTZone#1174",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder.Recurrence, org.joda.time.tz.DateTimeZoneBuilder.Recurrence)",
        "snippet": "        DSTZone(String id, int standardOffset,\n                Recurrence startRecurrence, Recurrence endRecurrence) {\n            super(id);\n            iStandardOffset = standardOffset;\n            iStartRecurrence = startRecurrence;\n            iEndRecurrence = endRecurrence;\n        }\n",
        "begin_line": 1174,
        "end_line": 1180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }\n",
        "begin_line": 94,
        "end_line": 100,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#109",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }\n",
        "begin_line": 109,
        "end_line": 125,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.readMillis#182",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)",
        "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }\n",
        "begin_line": 182,
        "end_line": 211,
        "comment": "\n     * Reads encoding generated by writeMillis.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "CachedDateTimeZone.forZone#67",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)",
        "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }\n",
        "begin_line": 67,
        "end_line": 72,
        "comment": "\n     * Returns a new CachedDateTimeZone unless given zone is already cached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "CachedDateTimeZone.CachedDateTimeZone#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)",
        "snippet": "    private CachedDateTimeZone(DateTimeZone zone) {\n        super(zone.getID());\n        iZone = zone;\n        iInfoCache = new Info[cInfoCacheMask + 1];\n    }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.forID#202",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forID(java.lang.String)",
        "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n",
        "begin_line": 202,
        "end_line": 224,
        "comment": "\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.getID#704",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getID()",
        "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }\n",
        "begin_line": 704,
        "end_line": 707,
        "comment": "\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)",
        "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * ZoneInfoProvider searches the given ClassLoader resource path for\n     * compiled data files. Resources are loaded from the ClassLoader that\n     * loaded this class.\n     *\n     * @throws IOException if directory or map file cannot be read\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)",
        "snippet": "    private ZoneInfoProvider(String resourcePath,\n                             ClassLoader loader, boolean favorSystemLoader) \n        throws IOException\n    {\n        if (resourcePath == null) {\n            throw new IllegalArgumentException(\"No resource path provided\");\n        }\n        if (!resourcePath.endsWith(\"/\")) {\n            resourcePath += '/';\n        }\n\n        iFileDir = null;\n        iResourcePath = resourcePath;\n\n        if (loader == null && !favorSystemLoader) {\n            loader = getClass().getClassLoader();\n        }\n\n        iLoader = loader;\n\n        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n    }\n",
        "begin_line": 103,
        "end_line": 124,
        "comment": "\n     * @param favorSystemLoader when true, use the system class loader if\n     * loader null. When false, use the current class loader if loader is null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.getAvailableIDs#170",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
        "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }\n",
        "begin_line": 170,
        "end_line": 175,
        "comment": "\n     * Gets a list of all the available zone ids.\n     * \n     * @return the zone ids\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.openResource#194",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)",
        "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuffer buf = new StringBuffer(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }\n",
        "begin_line": 194,
        "end_line": 215,
        "comment": "\n     * Opens a resource from file or classpath.\n     * \n     * @param name  the name to open\n     * @return the input stream\n     * @throws IOException if an error occurs\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.loadZoneInfoMap#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)",
        "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException e) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }\n",
        "begin_line": 251,
        "end_line": 264,
        "comment": "\n     * Loads the zone info map.\n     * \n     * @param in  the input stream\n     * @return the map\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "ZoneInfoProvider.readZoneInfoMap#272",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(java.io.DataInputStream, java.util.Map<java.lang.String, java.lang.Object>)",
        "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }\n",
        "begin_line": 272,
        "end_line": 289,
        "comment": "\n     * Reads the zone info map from file.\n     * \n     * @param din  the input stream\n     * @param zimap  gets filled with string id to string id mappings\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "FixedDateTimeZone.FixedDateTimeZone#36",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)",
        "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }\n",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "FixedDateTimeZone.equals#87",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }\n",
        "begin_line": 87,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DefaultNameProvider.DefaultNameProvider#39",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
        "snippet": "    public DefaultNameProvider() {\n    }\n",
        "begin_line": 39,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DefaultNameProvider.createCache#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
        "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.setProvider0#414",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)",
        "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n",
        "begin_line": 414,
        "end_line": 431,
        "comment": "\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.getDefaultProvider#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
        "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n",
        "begin_line": 442,
        "end_line": 474,
        "comment": "\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.setNameProvider0#513",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)",
        "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n",
        "begin_line": 513,
        "end_line": 518,
        "comment": "\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.getDefaultNameProvider#528",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
        "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n",
        "begin_line": 528,
        "end_line": 549,
        "comment": "\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZone.DateTimeZone#689",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)",
        "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n",
        "begin_line": 689,
        "end_line": 694,
        "comment": "\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0332
        },
        "num_failing_tests": 2
    }
]