[
    {
        "name": "PearsonsCorrelation.PearsonsCorrelation#67",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.PearsonsCorrelation(double[][])",
        "snippet": "    public PearsonsCorrelation(double[][] data) {\n        this(new BlockRealMatrix(data));\n    }\n",
        "begin_line": 67,
        "end_line": 69,
        "comment": "\n     * Create a PearsonsCorrelation from a rectangular array\n     * whose columns represent values of variables to be correlated.\n     *\n     * @param data rectangular array with columns representing variables\n     * @throws IllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and two columns.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 2
    },
    {
        "name": "ContinuedFraction.ContinuedFraction#45",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
        "class_name": "org.apache.commons.math.util.ContinuedFraction",
        "signature": "org.apache.commons.math.util.ContinuedFraction.ContinuedFraction()",
        "snippet": "    protected ContinuedFraction() {\n        super();\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "ContinuedFraction.evaluate#125",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/ContinuedFraction.java",
        "class_name": "org.apache.commons.math.util.ContinuedFraction",
        "signature": "org.apache.commons.math.util.ContinuedFraction.evaluate(double, double, int)",
        "snippet": "    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            boolean infinite = false;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                /*\n                 * Need to scale. Try successive powers of the larger of a or b\n                 * up to 5th power. Throw ConvergenceException if one or both\n                 * of p2, q2 still overflow.\n                 */\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = Math.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(\n                            \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                             x);\n                }\n                infinite = true;\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n                    } else if (b != 0) {\n                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                    }\n                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n                    if (!infinite) {\n                        break;\n                    }\n                }\n            }\n\n            if (infinite) {\n               // Scaling failed\n               throw new ConvergenceException(\n                 \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                  x);\n            }\n\n            double r = p2 / q2;\n\n            if (Double.isNaN(r)) {\n                throw new ConvergenceException(\n                  \"Continued fraction diverged to NaN for value {0}\",\n                  x);\n            }\n            relativeError = Math.abs(r / c - 1.0);\n\n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                \"Continued fraction convergents failed to converge for value {0}\",\n                x);\n        }\n\n        return c;\n    }\n",
        "begin_line": 125,
        "end_line": 206,
        "comment": "\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on equations 14-17 of:\n     * <ul>\n     * <li>\n     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n     *   Resource. <a target=\"_blank\"\n     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n     * </li>\n     * </ul>\n     * The recurrence relationship defined in those equations can result in\n     * very large intermediate results which can result in numerical overflow.\n     * As a means to combat these overflow conditions, the intermediate results\n     * are scaled whenever they threaten to become numerically unstable.</p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MathException if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "PearsonsCorrelation.getCorrelationPValues#160",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.getCorrelationPValues()",
        "snippet": "    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n",
        "begin_line": 160,
        "end_line": 176,
        "comment": "\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Gamma.logGamma#94",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Gamma.java",
        "class_name": "org.apache.commons.math.special.Gamma",
        "signature": "org.apache.commons.math.special.Gamma.logGamma(double)",
        "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double g = 607.0 / 128.0;\n\n            double sum = 0.0;\n            for (int i = LANCZOS.length - 1; i > 0; --i) {\n                sum = sum + (LANCZOS[i] / (x + i));\n            }\n            sum = sum + LANCZOS[0];\n\n            double tmp = x + g + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                HALF_LOG_2_PI + Math.log(sum / x);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 94,
        "end_line": 114,
        "comment": "\n     * Returns the natural logarithm of the gamma function &#915;(x).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n     * Gamma Function</a>, equation (28).</li>\n     * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n     * Lanczos Approximation</a>, equations (1) through (5).</li>\n     * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n     * the computation of the convergent Lanczos complex Gamma approximation\n     * </a></li>\n     * </ul>\n     *\n     * @param x the value.\n     * @return log(&#915;(x))\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.regularizedBeta#116",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Beta.java",
        "class_name": "org.apache.commons.math.special.Beta",
        "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double, double, double, double, int)",
        "snippet": "    public static double regularizedBeta(double x, final double a,\n        final double b, double epsilon, int maxIterations) throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n            (x > 1) || (a <= 0.0) || (b <= 0.0))\n        {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 116,
        "end_line": 157,
        "comment": "\n     * Returns the regularized beta function I(x, a, b).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n     * Regularized Beta Function</a>.</li>\n     * <li>\n     * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n     * Regularized Beta Function</a>.</li>\n     * </ul>\n     *\n     * @param x the value.\n     * @param a the a parameter.\n     * @param b the b parameter.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete.\n     * @return the regularized beta function I(x, a, b)\n     * @throws MathException if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.getB#130",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Beta.java",
        "class_name": "org.apache.commons.math.special.Beta",
        "signature": "org.apache.commons.math.special.Beta.Anonymous-4bd64ae2-e104-4a67-9c36-59d59c24d3ba.getB(int, double)",
        "snippet": "                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n",
        "begin_line": 130,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.getA#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Beta.java",
        "class_name": "org.apache.commons.math.special.Beta",
        "signature": "org.apache.commons.math.special.Beta.Anonymous-f8eb0be1-9fe7-4bf8-8e1d-0c69c653eeb5.getA(int, double)",
        "snippet": "                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.regularizedBeta#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Beta.java",
        "class_name": "org.apache.commons.math.special.Beta",
        "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double, double, double)",
        "snippet": "    public static double regularizedBeta(double x, double a, double b)\n        throws MathException\n    {\n        return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 51,
        "end_line": 55,
        "comment": "\n     * Returns the\n     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n     * regularized beta function</a> I(x, a, b).\n     *\n     * @param x the value.\n     * @param a the a parameter.\n     * @param b the b parameter.\n     * @return the regularized beta function I(x, a, b)\n     * @throws MathException if the algorithm fails to converge.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "Beta.logBeta#187",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/special/Beta.java",
        "class_name": "org.apache.commons.math.special.Beta",
        "signature": "org.apache.commons.math.special.Beta.logBeta(double, double, double, int)",
        "snippet": "    public static double logBeta(double a, double b, double epsilon,\n        int maxIterations) {\n\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n                Gamma.logGamma(a + b);\n        }\n\n        return ret;\n    }\n",
        "begin_line": 187,
        "end_line": 200,
        "comment": "\n     * Returns the natural logarithm of the beta function B(a, b).\n     *\n     * The implementation of this method is based on:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n     * Beta Function</a>, equation (1).</li>\n     * </ul>\n     *\n     * @param a the a parameter.\n     * @param b the b parameter.\n     * @param epsilon When the absolute value of the nth item in the\n     *                series is less than epsilon the approximation ceases\n     *                to calculate further elements in the series.\n     * @param maxIterations Maximum number of \"iterations\" to complete.\n     * @return log(B(a, b))\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "TDistributionImpl.cumulativeProbability#126",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java",
        "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
        "signature": "org.apache.commons.math.distribution.TDistributionImpl.cumulativeProbability(double)",
        "snippet": "    public double cumulativeProbability(double x) throws MathException{\n        double ret;\n        if (x == 0.0) {\n            ret = 0.5;\n        } else {\n            double t =\n                Beta.regularizedBeta(\n                    degreesOfFreedom / (degreesOfFreedom + (x * x)),\n                    0.5 * degreesOfFreedom,\n                    0.5);\n            if (x < 0.0) {\n                ret = 0.5 * t;\n            } else {\n                ret = 1.0 - 0.5 * t;\n            }\n        }\n\n        return ret;\n    }\n",
        "begin_line": 126,
        "end_line": 144,
        "comment": "\n     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluated at <code>x</code>.\n     * @throws MathException if the cumulative probability can not be\n     *            computed due to convergence or other numerical errors.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5345
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.getEntry#1234",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            return blocks[iBlock * blockColumns + jBlock][k];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 1234,
        "end_line": 1248,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be fetched\n     * @param column  column location of entry to be fetched\n     * @return matrix entry in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     "
        },
        "susp": {
            "ochiai_susp": 0.4714
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.getSlope#297",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getSlope()",
        "snippet": "    public double getSlope() {\n        if (n < 2) {\n            return Double.NaN; //not enough data\n        }\n        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n            return Double.NaN; //not enough variation in x\n        }\n        return sumXY / sumXX;\n    }\n",
        "begin_line": 297,
        "end_line": 305,
        "comment": "\n    * Returns the slope of the estimated regression line.\n    * <p>\n    * The least squares estimate of the slope is computed using the\n    * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n    * The slope is sometimes denoted b1.</p>\n    * <p>\n    * <strong>Preconditions</strong>: <ul>\n    * <li>At least two observations (with at least two different x values)\n    * must have been added before invoking this method. If this method is\n    * invoked before a model can be estimated, <code>Double.NaN</code> is\n    * returned.\n    * </li></ul></p>\n    *\n    * @return the slope of the regression line\n    ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "PearsonsCorrelation.PearsonsCorrelation#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.PearsonsCorrelation(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    public PearsonsCorrelation(RealMatrix matrix) {\n        checkSufficientData(matrix);\n        nObs = matrix.getRowDimension();\n        correlationMatrix = computeCorrelationMatrix(matrix);\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Create a PearsonsCorrelation from a RealMatrix whose columns\n     * represent variables to be correlated.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "PearsonsCorrelation.computeCorrelationMatrix#186",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.computeCorrelationMatrix(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n              outMatrix.setEntry(i, j, corr);\n              outMatrix.setEntry(j, i, corr);\n            }\n            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }\n",
        "begin_line": 186,
        "end_line": 198,
        "comment": "\n     * Computes the correlation matrix for the columns of the\n     * input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "PearsonsCorrelation.checkSufficientData#272",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.checkSufficientData(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    private void checkSufficientData(final RealMatrix matrix) {\n        int nRows = matrix.getRowDimension();\n        int nCols = matrix.getColumnDimension();\n        if (nRows < 2 || nCols < 2) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"insufficient data: only {0} rows and {1} columns.\",\n                    nRows, nCols);\n        }\n    }\n",
        "begin_line": 272,
        "end_line": 280,
        "comment": "\n     * Throws IllegalArgumentException of the matrix does not have at least\n     * two columns and two rows\n     *\n     * @param matrix matrix to check for sufficiency\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.setEntry#1251",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.setEntry(int, int, double)",
        "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            blocks[iBlock * blockColumns + jBlock][k] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 1251,
        "end_line": 1265,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Set the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy\n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     *\n     * @param row  row location of entry to be set\n     * @param column  column location of entry to be set\n     * @param value matrix entry to be set in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     * @since 2.0\n     "
        },
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "MatrixUtils.checkColumnIndex#542",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(org.apache.commons.math.linear.AnyMatrix, int)",
        "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws MatrixIndexException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }\n",
        "begin_line": 542,
        "end_line": 548,
        "comment": "\n     * Check if a column index is valid.\n     * @param m matrix containing the submatrix\n     * @param column column index to check\n     * @exception MatrixIndexException if index is not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int, int)",
        "snippet": "    public BlockRealMatrix(final int rows, final int columns)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n\n    }\n",
        "begin_line": 95,
        "end_line": 109,
        "comment": "\n     * Create a new matrix with the supplied row and column dimensions.\n     *\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.createBlocksLayout#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.createBlocksLayout(int, int)",
        "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n\n    }\n",
        "begin_line": 265,
        "end_line": 287,
        "comment": "\n     * Create a data array in blocks layout.\n     * <p>\n     * This method can be used to create the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @return a new data array in blocks layout\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.getColumn#1181",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumn(int)",
        "snippet": "    @Override\n    public double[] getColumn(final int column)\n        throws MatrixIndexException {\n\n        MatrixUtils.checkColumnIndex(this, column);\n        final double[] out = new double[rows];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  = column / BLOCK_SIZE;\n        final int jColumn = column - jBlock * BLOCK_SIZE;\n        final int jWidth  = blockWidth(jBlock);\n        int outIndex      = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            final double[] block = blocks[iBlock * blockColumns + jBlock];\n            for (int i = 0; i < iHeight; ++i) {\n                out[outIndex++] = block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n\n    }\n",
        "begin_line": 1181,
        "end_line": 1203,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the entries in column number <code>col</code> as an array.\n     * <p>\n     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n     * unless <code>0 <= column < columnDimension.</code></p>\n     *\n     * @param column the column to be fetched\n     * @return array of entries in the column\n     * @throws MatrixIndexException if the specified column index is not valid\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.addData#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.addData(double, double)",
        "snippet": "    public void addData(double x, double y) {\n        if (n == 0) {\n            xbar = x;\n            ybar = y;\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (n + 1d);\n            sumYY += dy * dy * (double) n / (n + 1d);\n            sumXY += dx * dy * (double) n / (n + 1d);\n            xbar += dx / (n + 1.0);\n            ybar += dy / (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n\n        if (n > 2) {\n            distribution.setDegreesOfFreedom(n - 2);\n        }\n    }\n",
        "begin_line": 121,
        "end_line": 141,
        "comment": "\n     * Adds the observation (x,y) to the regression data set.\n     * <p>\n     * Uses updating formulas for means and sums of squares defined in\n     * \"Algorithms for Computing the Sample Variance: Analysis and\n     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985.</p>\n     *\n     *\n     * @param x independent variable value\n     * @param y dependent variable value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.getSumSquaredErrors#336",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getSumSquaredErrors()",
        "snippet": "    public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n    }\n",
        "begin_line": 336,
        "end_line": 338,
        "comment": "\n     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n     * sum of squared errors</a> (SSE) associated with the regression\n     * model.\n     * <p>\n     * The sum is computed using the computational formula</p>\n     * <p>\n     * <code>SSE = SYY - (SXY * SXY / SXX)</code></p>\n     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * </p><p>\n     * The sums are accumulated using the updating algorithm referenced in\n     * {@link #addData}.</p>\n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to\n     * rounding errors the computational formula returns a negative result,\n     * 0 is returned.</p>\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is\n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul></p>\n     *\n     * @return sum of squared errors associated with the regression model\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.getTotalSumSquares#350",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getTotalSumSquares()",
        "snippet": "    public double getTotalSumSquares() {\n        if (n < 2) {\n            return Double.NaN;\n        }\n        return sumYY;\n    }\n",
        "begin_line": 350,
        "end_line": 355,
        "comment": "\n     * Returns the sum of squared deviations of the y values about their mean.\n     * <p>\n     * This is defined as SSTO\n     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.</p>\n     * <p>\n     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>\n     *\n     * @return sum of squared deviations of y values\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.getR#431",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getR()",
        "snippet": "    public double getR() {\n        double b1 = getSlope();\n        double result = Math.sqrt(getRSquare());\n        if (b1 < 0) {\n            result = -result;\n        }\n        return result;\n    }\n",
        "begin_line": 431,
        "end_line": 438,
        "comment": "\n     * Returns <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">\n     * Pearson's product moment correlation coefficient</a>,\n     * usually denoted r.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is\n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul></p>\n     *\n     * @return Pearson's r\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.getRSquare#454",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getRSquare()",
        "snippet": "    public double getRSquare() {\n        double ssto = getTotalSumSquares();\n        return (ssto - getSumSquaredErrors()) / ssto;\n    }\n",
        "begin_line": 454,
        "end_line": 457,
        "comment": "\n     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\">\n     * coefficient of determination</a>,\n     * usually denoted r-square.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is\n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul></p>\n     *\n     * @return r-square\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "PearsonsCorrelation.correlation#224",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java",
        "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
        "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.correlation(double[], double[])",
        "snippet": "    public double correlation(final double[] xArray, final double[] yArray) throws IllegalArgumentException {\n        SimpleRegression regression = new SimpleRegression();\n        if(xArray.length == yArray.length && xArray.length > 1) {\n            for(int i=0; i<xArray.length; i++) {\n                regression.addData(xArray[i], yArray[i]);\n            }\n            return regression.getR();\n        }\n        else {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n                    xArray.length, yArray.length);\n        }\n    }\n",
        "begin_line": 224,
        "end_line": 237,
        "comment": "\n     * Computes the Pearson's product-moment correlation coefficient between the two arrays.\n     *\n     * </p>Throws IllegalArgumentException if the arrays do not have the same length\n     * or their common length is less than 2</p>\n     *\n     * @param xArray first data array\n     * @param yArray second data array\n     * @return Returns Pearson's correlation coefficient for the two arrays\n     * @throws  IllegalArgumentException if the arrays lengths do not match or\n     * there is insufficient data\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(double[][])",
        "snippet": "    public BlockRealMatrix(final double[][] rawData)\n        throws IllegalArgumentException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }\n",
        "begin_line": 124,
        "end_line": 127,
        "comment": "\n     * Create a new dense matrix copying entries from raw layout data.\n     * <p>The input array <em>must</em> already be in raw layout.</p>\n     * <p>Calling this constructor is equivalent to call:\n     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n     *                                   toBlocksLayout(rawData), false);</pre>\n     * </p>\n     * @param rawData data for new matrix, in raw layout\n     *\n     * @exception IllegalArgumentException if <code>blockData</code> shape is\n     * inconsistent with block layout\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.BlockRealMatrix#144",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int, int, double[][], boolean)",
        "snippet": "    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"wrong array shape (block length = {0}, expected {1})\",\n                            blockData[index].length, iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n\n    }\n",
        "begin_line": 144,
        "end_line": 179,
        "comment": "\n     * Create a new dense matrix copying entries from block layout data.\n     * <p>The input array <em>must</em> already be in blocks layout.</p>\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @param blockData data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     *\n     * @exception IllegalArgumentException if <code>blockData</code> shape is\n     * inconsistent with block layout\n     * @see #createBlocksLayout(int, int)\n     * @see #toBlocksLayout(double[][])\n     * @see #BlockRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.toBlocksLayout#203",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.toBlocksLayout(double[][])",
        "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws IllegalArgumentException {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"some rows have length {0} while others have length {1}\",\n                        columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n\n                ++blockIndex;\n\n            }\n        }\n\n        return blocks;\n\n    }\n",
        "begin_line": 203,
        "end_line": 251,
        "comment": "\n     * Convert a data array from raw layout to blocks layout.\n     * <p>\n     * Raw layout is the straightforward layout where element at row i and\n     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n     * is split in square blocks (except at right and bottom side where blocks may\n     * be rectangular to fit matrix size) and each block is stored in a flattened\n     * one-dimensional array.\n     * </p>\n     * <p>\n     * This method creates an array in blocks layout from an input array in raw layout.\n     * It can be used to provide the array argument of the {@link\n     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rawData data array in raw layout\n     * @return a new data array containing the same entries but in blocks layout\n     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n     *  (not all rows have the same length)\n     * @see #createBlocksLayout(int, int)\n     * @see #BlockRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.getRowDimension#1343",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }\n",
        "begin_line": 1343,
        "end_line": 1346,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.getColumnDimension#1349",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }\n",
        "begin_line": 1349,
        "end_line": 1352,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.blockHeight#1674",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockHeight(int)",
        "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1674,
        "end_line": 1676,
        "comment": "\n     * Get the height of a block.\n     * @param blockRow row index (in block sense) of the block\n     * @return height (number of rows) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "BlockRealMatrix.blockWidth#1683",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
        "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockWidth(int)",
        "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1683,
        "end_line": 1685,
        "comment": "\n     * Get the width of a block.\n     * @param blockColumn column index (in block sense) of the block\n     * @return width (number of columns) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }\n",
        "begin_line": 54,
        "end_line": 67,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "TDistributionImpl.setDegreesOfFreedom#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java",
        "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
        "signature": "org.apache.commons.math.distribution.TDistributionImpl.setDegreesOfFreedom(double)",
        "snippet": "    @Deprecated\n    public void setDegreesOfFreedom(double degreesOfFreedom) {\n        setDegreesOfFreedomInternal(degreesOfFreedom);\n    }\n",
        "begin_line": 79,
        "end_line": 82,
        "comment": "\n     * Modify the degrees of freedom.\n     * @param degreesOfFreedom the new degrees of freedom.\n     * @deprecated as of 2.1 (class will become immutable in 3.0)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3922
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.SimpleRegression#93",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.SimpleRegression()",
        "snippet": "    public SimpleRegression() {\n        this(new TDistributionImpl(1.0));\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "\n     * Create an empty SimpleRegression instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.SimpleRegression#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.SimpleRegression(org.apache.commons.math.distribution.TDistribution)",
        "snippet": "    public SimpleRegression(TDistribution t) {\n        super();\n        setDistribution(t);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "\n     * Create an empty SimpleRegression using the given distribution object to\n     * compute inference statistics.\n     * @param t the distribution used to compute inference statistics.\n     * @since 1.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "SimpleRegression.setDistribution#613",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java",
        "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
        "signature": "org.apache.commons.math.stat.regression.SimpleRegression.setDistribution(org.apache.commons.math.distribution.TDistribution)",
        "snippet": "    public void setDistribution(TDistribution value) {\n        distribution = value;\n\n        // modify degrees of freedom\n        if (n > 2) {\n            distribution.setDegreesOfFreedom(n - 2);\n        }\n    }\n",
        "begin_line": 613,
        "end_line": 620,
        "comment": "\n     * Modify the distribution used to compute inference statistics.\n     * @param value the new distribution\n     * @since 1.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "TDistributionImpl.TDistributionImpl#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java",
        "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
        "signature": "org.apache.commons.math.distribution.TDistributionImpl.TDistributionImpl(double, double)",
        "snippet": "    public TDistributionImpl(double degreesOfFreedom, double inverseCumAccuracy) {\n        super();\n        setDegreesOfFreedomInternal(degreesOfFreedom);\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }\n",
        "begin_line": 60,
        "end_line": 64,
        "comment": "\n     * Create a t distribution using the given degrees of freedom and the\n     * specified inverse cumulative probability absolute accuracy.\n     *\n     * @param degreesOfFreedom the degrees of freedom.\n     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n     * @since 2.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "TDistributionImpl.TDistributionImpl#70",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java",
        "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
        "signature": "org.apache.commons.math.distribution.TDistributionImpl.TDistributionImpl(double)",
        "snippet": "    public TDistributionImpl(double degreesOfFreedom) {\n        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }\n",
        "begin_line": 70,
        "end_line": 72,
        "comment": "\n     * Create a t distribution using the given degrees of freedom.\n     * @param degreesOfFreedom the degrees of freedom.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "TDistributionImpl.setDegreesOfFreedomInternal#87",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java",
        "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
        "signature": "org.apache.commons.math.distribution.TDistributionImpl.setDegreesOfFreedomInternal(double)",
        "snippet": "    private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {\n        if (newDegreesOfFreedom <= 0.0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"degrees of freedom must be positive ({0})\",\n                  newDegreesOfFreedom);\n        }\n        this.degreesOfFreedom = newDegreesOfFreedom;\n    }\n",
        "begin_line": 87,
        "end_line": 94,
        "comment": "\n     * Modify the degrees of freedom.\n     * @param newDegreesOfFreedom the new degrees of freedom.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractDistribution.AbstractDistribution#38",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java",
        "class_name": "org.apache.commons.math.distribution.AbstractDistribution",
        "signature": "org.apache.commons.math.distribution.AbstractDistribution.AbstractDistribution()",
        "snippet": "    protected AbstractDistribution() {\n        super();\n    }\n",
        "begin_line": 38,
        "end_line": 40,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractContinuousDistribution.AbstractContinuousDistribution#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java",
        "class_name": "org.apache.commons.math.distribution.AbstractContinuousDistribution",
        "signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution.AbstractContinuousDistribution()",
        "snippet": "    protected AbstractContinuousDistribution() {\n        super();\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 2
    }
]