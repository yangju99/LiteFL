[
    {
        "name": "Node.toString#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.ObjectPropListItem.toString()",
        "snippet": "    @Override\n    public String toString() {\n      return objectValue == null ? \"null\" : objectValue.toString();\n    }\n",
        "begin_line": 309,
        "end_line": 312,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.NodeMismatch#2126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.NodeMismatch.NodeMismatch(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    NodeMismatch(Node nodeA, Node nodeB) {\n      this.nodeA = nodeA;\n      this.nodeB = nodeB;\n    }\n",
        "begin_line": 2126,
        "end_line": 2129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toString#341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.toString()",
        "snippet": "    @Override\n    public String toString() {\n      return String.valueOf(intValue);\n    }\n",
        "begin_line": 341,
        "end_line": 344,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.propToString#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.propToString(int)",
        "snippet": "  private static final String propToString(int propType) {\n      switch (propType) {\n        case VAR_ARGS_NAME:      return \"var_args_name\";\n\n        case JSDOC_INFO_PROP:    return \"jsdoc_info\";\n\n        case INCRDECR_PROP:      return \"incrdecr\";\n        case QUOTED_PROP:        return \"quoted\";\n        case OPT_ARG_NAME:       return \"opt_arg\";\n\n        case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n        case EMPTY_BLOCK:        return \"empty_block\";\n        case ORIGINALNAME_PROP:  return \"originalname\";\n        case SIDE_EFFECT_FLAGS:  return \"side_effect_flags\";\n\n        case IS_CONSTANT_NAME:   return \"is_constant_name\";\n        case IS_NAMESPACE:       return \"is_namespace\";\n        case IS_DISPATCHER:      return \"is_dispatcher\";\n        case DIRECTIVES:         return \"directives\";\n        case DIRECT_EVAL:        return \"direct_eval\";\n        case FREE_CALL:          return \"free_call\";\n        case STATIC_SOURCE_FILE:    return \"source_file\";\n        case INPUT_ID:  return \"input_id\";\n        case LENGTH:    return \"length\";\n        case SLASH_V:   return \"slash_v\";\n        case INFERRED_FUNCTION:   return \"inferred\";\n        default:\n          throw new IllegalStateException(\"unexpect prop id \" + propType);\n      }\n  }\n",
        "begin_line": 111,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getSortedPropTypes#859",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getSortedPropTypes()",
        "snippet": "  private int[] getSortedPropTypes() {\n    int count = 0;\n    for (PropListItem x = propListHead; x != null; x = x.getNext()) {\n      count++;\n    }\n\n    int[] keys = new int[count];\n    for (PropListItem x = propListHead; x != null; x = x.getNext()) {\n      count--;\n      keys[count] = x.getType();\n    }\n\n    Arrays.sort(keys);\n    return keys;\n  }\n",
        "begin_line": 859,
        "end_line": 873,
        "comment": " Gets all the property types, in sorted order.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toString#915",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return toString(true, true, true);\n  }\n",
        "begin_line": 915,
        "end_line": 918,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toString#929",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toString(java.lang.StringBuilder, boolean, boolean, boolean)",
        "snippet": "  private void toString(\n      StringBuilder sb,\n      boolean printSource,\n      boolean printAnnotations,\n      boolean printType) {\n    sb.append(Token.name(type));\n    if (this instanceof StringNode) {\n      sb.append(' ');\n      sb.append(getString());\n    } else if (type == Token.FUNCTION) {\n      sb.append(' ');\n      // In the case of JsDoc trees, the first child is often not a string\n      // which causes exceptions to be thrown when calling toString or\n      // toStringTree.\n      if (first == null || first.getType() != Token.NAME) {\n        sb.append(\"<invalid>\");\n      } else {\n        sb.append(first.getString());\n      }\n    } else if (type == Token.NUMBER) {\n      sb.append(' ');\n      sb.append(getDouble());\n    }\n    if (printSource) {\n      int lineno = getLineno();\n      if (lineno != -1) {\n        sb.append(' ');\n        sb.append(lineno);\n      }\n    }\n\n    if (printAnnotations) {\n      int[] keys = getSortedPropTypes();\n      for (int i = 0; i < keys.length; i++) {\n        int type = keys[i];\n        PropListItem x = lookupProperty(type);\n        sb.append(\" [\");\n        sb.append(propToString(type));\n        sb.append(\": \");\n        String value;\n        switch (type) {\n          default:\n            value = x.toString();\n            break;\n        }\n        sb.append(value);\n        sb.append(']');\n      }\n    }\n\n    if (printType) {\n      if (jsType != null) {\n        String jsTypeString = jsType.toString();\n        if (jsTypeString != null) {\n          sb.append(\" : \");\n          sb.append(jsTypeString);\n        }\n      }\n    }\n  }\n",
        "begin_line": 929,
        "end_line": 988,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toStringTree#991",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toStringTree()",
        "snippet": "  public String toStringTree() {\n    return toStringTreeImpl();\n  }\n",
        "begin_line": 991,
        "end_line": 993,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toStringTreeImpl#995",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toStringTreeImpl()",
        "snippet": "  private String toStringTreeImpl() {\n    try {\n      StringBuilder s = new StringBuilder();\n      appendStringTree(s);\n      return s.toString();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Should not happen\\n\" + e);\n    }\n  }\n",
        "begin_line": 995,
        "end_line": 1003,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.appendStringTree#1005",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.appendStringTree(java.lang.Appendable)",
        "snippet": "  public void appendStringTree(Appendable appendable) throws IOException {\n    toStringTreeHelper(this, 0, appendable);\n  }\n",
        "begin_line": 1005,
        "end_line": 1007,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toStringTreeHelper#1009",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toStringTreeHelper(com.google.javascript.rhino.Node, int, java.lang.Appendable)",
        "snippet": "  private static void toStringTreeHelper(Node n, int level, Appendable sb)\n      throws IOException {\n    for (int i = 0; i != level; ++i) {\n      sb.append(\"    \");\n    }\n    sb.append(n.toString());\n    sb.append('\\n');\n    for (Node cursor = n.getFirstChild();\n         cursor != null;\n         cursor = cursor.getNext()) {\n      toStringTreeHelper(cursor, level + 1, sb);\n    }\n  }\n",
        "begin_line": 1009,
        "end_line": 1021,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.checkTreeEquals#1408",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.checkTreeEquals(com.google.javascript.rhino.Node)",
        "snippet": "  public String checkTreeEquals(Node node2) {\n      NodeMismatch diff = checkTreeEqualsImpl(node2);\n      if (diff != null) {\n        return \"Node tree inequality:\" +\n            \"\\nTree1:\\n\" + toStringTree() +\n            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n      }\n      return null;\n  }\n",
        "begin_line": 1408,
        "end_line": 1418,
        "comment": "\n   * Checks if the subtree under this node is the same as another subtree.\n   * Returns null if it's equal, or a message describing the differences.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.checkTreeEqualsImpl#1425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.checkTreeEqualsImpl(com.google.javascript.rhino.Node)",
        "snippet": "  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n        return res;\n      }\n    }\n    return res;\n  }\n",
        "begin_line": 1425,
        "end_line": 1444,
        "comment": "\n   * Compare this node to node2 recursively and return the first pair of nodes\n   * that differs doing a preorder depth-first traversal. Package private for\n   * testing. Returns null if the nodes are equivalent.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "InputId.toString#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return \"InputId: \" + getIdName();\n  }\n",
        "begin_line": 72,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.toString#301",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return fileName;\n  }\n",
        "begin_line": 301,
        "end_line": 304,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.toString#920",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.toString(boolean, boolean, boolean)",
        "snippet": "  public String toString(\n      boolean printSource,\n      boolean printAnnotations,\n      boolean printType) {\n    StringBuilder sb = new StringBuilder();\n    toString(sb, printSource, printAnnotations, printType);\n    return sb.toString();\n  }\n",
        "begin_line": 920,
        "end_line": 927,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.9428
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.removeUnreferencedFunctionArgs#369",
        "is_bug": true,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.removeUnreferencedFunctionArgs(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n",
        "begin_line": 369,
        "end_line": 406,
        "comment": "\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6489
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.interpretAssigns#721",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.interpretAssigns()",
        "snippet": "  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          boolean maybeEscaped = false;\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n          }\n\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n",
        "begin_line": 721,
        "end_line": 770,
        "comment": "\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3849
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isEquivalentTo#1489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isEquivalentTo(com.google.javascript.rhino.Node, boolean, boolean)",
        "snippet": "  boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING || type == Token.STRING_KEY) {\n      if (type == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(QUOTED_PROP);\n        int quoted2 = node.getIntProp(QUOTED_PROP);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n\n      int slashV1 = this.getIntProp(SLASH_V);\n      int slashV2 = node.getIntProp(SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (type == Token.CALL) {\n      if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n        return false;\n      }\n    }\n\n    if (recurse) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(n2, compareJsType, true)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n",
        "begin_line": 1489,
        "end_line": 1538,
        "comment": "\n   * @param compareJsType Whether to compare the JSTypes of the nodes.\n   * @param recurse Whether to compare the children of the current node, if\n   *    not only the the count of the children are compared.\n   * @return Whether this node is equivalent semantically to the provided node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3621
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionType.toStringHelper#416",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.toStringHelper(boolean)",
        "snippet": "  @Override String toStringHelper(boolean forAnnotations) {\n    StringBuilder result = new StringBuilder();\n    boolean firstAlternate = true;\n\n    result.append(\"(\");\n    SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA);\n    sorted.addAll(alternates);\n    for (JSType t : sorted) {\n      if (!firstAlternate) {\n        result.append(\"|\");\n      }\n      result.append(t.toStringHelper(forAnnotations));\n      firstAlternate = false;\n    }\n    result.append(\")\");\n    return result.toString();\n  }\n",
        "begin_line": 416,
        "end_line": 432,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrototypeObjectType.toStringHelper#226",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n\n        ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }\n",
        "begin_line": 226,
        "end_line": 270,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrototypeObjectType.isPrettyPrint#276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPrettyPrint()",
        "snippet": "  boolean isPrettyPrint() {\n    return prettyPrint;\n  }\n",
        "begin_line": 276,
        "end_line": 278,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.getOwnPropertyNames#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getOwnPropertyNames()",
        "snippet": "  Set<String> getOwnPropertyNames() {\n    return properties.keySet();\n  }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getOwnPropertyNames#462",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyNames()",
        "snippet": "  public Set<String> getOwnPropertyNames() {\n    return getPropertyMap().getOwnPropertyNames();\n  }\n",
        "begin_line": 462,
        "end_line": 464,
        "comment": "\n   * Returns the names of all the properties directly on this type.\n   *\n   * Overridden by FunctionType to add \"prototype\".\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.toStringHelper#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return reference;\n  }\n",
        "begin_line": 155,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.handleUnresolvedType#338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.handleUnresolvedType(com.google.javascript.rhino.ErrorReporter, boolean)",
        "snippet": "  private void handleUnresolvedType(\n      ErrorReporter t, boolean ignoreForwardReferencedTypes) {\n    if (registry.isLastGeneration()) {\n      boolean isForwardDeclared =\n          ignoreForwardReferencedTypes &&\n          registry.isForwardDeclaredType(reference);\n      if (!isForwardDeclared && registry.isLastGeneration()) {\n        t.warning(\"Bad type annotation. Unknown type \" + reference,\n            sourceName, lineno, charno);\n      } else {\n        setReferencedType(\n            registry.getNativeObjectType(\n                JSTypeNative.NO_RESOLVED_TYPE));\n\n        if (registry.isLastGeneration() && validator != null) {\n          validator.apply(getReferencedType());\n        }\n      }\n\n      setResolvedTypeInternal(getReferencedType());\n    } else {\n      setResolvedTypeInternal(this);\n    }\n  }\n",
        "begin_line": 338,
        "end_line": 361,
        "comment": " type name.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.compare#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.Anonymous-2a7558cf-1ccd-487e-a74e-de07ce57f4a3.compare(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    @Override\n    public int compare(JSType t1, JSType t2) {\n      return t1.toString().compareTo(t2.toString());\n    }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.toStringHelper#924",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (!isPrettyPrint() ||\n        this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n      return \"Function\";\n    }\n\n    setPrettyPrint(false);\n\n    StringBuilder b = new StringBuilder(32);\n    b.append(\"function (\");\n    int paramNum = call.parameters.getChildCount();\n    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);\n    if (hasKnownTypeOfThis) {\n      if (isConstructor()) {\n        b.append(\"new:\");\n      } else {\n        b.append(\"this:\");\n      }\n      b.append(typeOfThis.toStringHelper(forAnnotations));\n    }\n    if (paramNum > 0) {\n      if (hasKnownTypeOfThis) {\n        b.append(\", \");\n      }\n      Node p = call.parameters.getFirstChild();\n      appendArgString(b, p, forAnnotations);\n\n      p = p.getNext();\n      while (p != null) {\n        b.append(\", \");\n        appendArgString(b, p, forAnnotations);\n        p = p.getNext();\n      }\n    }\n    b.append(\"): \");\n    b.append(call.returnType.toStringHelper(forAnnotations));\n\n    setPrettyPrint(true);\n    return b.toString();\n  }\n",
        "begin_line": 924,
        "end_line": 964,
        "comment": "\n   * Informally, a function is represented by\n   * {@code function (params): returnType} where the {@code params} is a comma\n   * separated list of types, the first one being a special\n   * {@code this:T} if the function expects a known type for {@code this}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.appendArgString#966",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.appendArgString(java.lang.StringBuilder, com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private void appendArgString(\n      StringBuilder b, Node p, boolean forAnnotations) {\n    if (p.isVarArgs()) {\n      appendVarArgsString(b, p.getJSType(), forAnnotations);\n    } else if (p.isOptionalArg()) {\n      appendOptionalArgString(b, p.getJSType(), forAnnotations);\n    } else {\n      b.append(p.getJSType().toStringHelper(forAnnotations));\n    }\n  }\n",
        "begin_line": 966,
        "end_line": 975,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "TokenStream.isKeyword#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/TokenStream.java",
        "class_name": "com.google.javascript.rhino.TokenStream",
        "signature": "com.google.javascript.rhino.TokenStream.isKeyword(java.lang.String)",
        "snippet": "    public static boolean isKeyword(String name) {\n        boolean id = false;\n        String s = name;\n        complete: {\n            String X = null;\n            int c;\n            partial: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') {\n                  if (s.charAt(0)=='i') {id=true; break complete;}\n                } else if (c=='n') {\n                  if (s.charAt(0)=='i') {id=true; break complete;}\n                } else if (c=='o') {\n                  if (s.charAt(0)=='d') {id=true; break complete;}\n                }\n                break partial;\n            case 3: switch (s.charAt(0)) {\n                case 'f':\n                  if (s.charAt(2)=='r' && s.charAt(1)=='o') {\n                    id=true; break complete;\n                  } break partial;\n                case 'i':\n                  if (s.charAt(2)=='t' && s.charAt(1)=='n') {\n                    id=true; break complete;\n                  } break partial;\n                case 'n':\n                  if (s.charAt(2)=='w' && s.charAt(1)=='e') {\n                    id=true; break complete;\n                  } break partial;\n                case 't':\n                  if (s.charAt(2)=='y' && s.charAt(1)=='r') {\n                    id=true; break complete;\n                  } break partial;\n                case 'v':\n                  if (s.charAt(2)=='r' && s.charAt(1)=='a') {\n                    id=true; break complete;\n                  } break partial;\n                } break partial;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=true; break partial;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {\n                            id=true; break complete;} }\n                    else if (c=='r') {\n                      if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n                        id=true; break complete;\n                      }\n                    }\n                    break partial;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {\n                            id=true; break complete;} }\n                    else if (c=='m') {\n                      if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n                            id=true; break complete;} }\n                    break partial;\n                case 'g': X=\"goto\";id=true; break partial;\n                case 'l': X=\"long\";id=true; break partial;\n                case 'n': X=\"null\";id=true; break partial;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {\n                            id=true; break complete;} }\n                    else if (c=='s') {\n                      if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n                            id=true; break complete;} }\n                    break partial;\n                case 'v': X=\"void\";id=true; break partial;\n                case 'w': X=\"with\";id=true; break partial;\n                } break partial;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=true; break partial;\n                case 'e': X=\"break\";id=true; break partial;\n                case 'i': X=\"while\";id=true; break partial;\n                case 'l': X=\"false\";id=true; break partial;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=true; }\n                    else if (c=='f') { X=\"final\";id=true; }\n                    break partial;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=true; }\n                    else if (c=='s') { X=\"short\";id=true; }\n                    break partial;\n                case 'p': X=\"super\";id=true; break partial;\n                case 'r': X=\"throw\";id=true; break partial;\n                case 't': X=\"catch\";id=true; break partial;\n                } break partial;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=true; break partial;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=true; }\n                    else if (c=='r') { X=\"return\";id=true; }\n                    break partial;\n                case 'h': X=\"throws\";id=true; break partial;\n                case 'm': X=\"import\";id=true; break partial;\n                case 'o': X=\"double\";id=true; break partial;\n                case 't': X=\"static\";id=true; break partial;\n                case 'u': X=\"public\";id=true; break partial;\n                case 'w': X=\"switch\";id=true; break partial;\n                case 'x': X=\"export\";id=true; break partial;\n                case 'y': X=\"typeof\";id=true; break partial;\n                } break partial;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=true; break partial;\n                case 'e': X=\"default\";id=true; break partial;\n                case 'i': X=\"finally\";id=true; break partial;\n                case 'o': X=\"boolean\";id=true; break partial;\n                case 'r': X=\"private\";id=true; break partial;\n                case 'x': X=\"extends\";id=true; break partial;\n                } break partial;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=true; break partial;\n                case 'c': X=\"continue\";id=true; break partial;\n                case 'd': X=\"debugger\";id=true; break partial;\n                case 'f': X=\"function\";id=true; break partial;\n                case 'v': X=\"volatile\";id=true; break partial;\n                } break partial;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=true; }\n                else if (c=='p') { X=\"protected\";id=true; }\n                else if (c=='t') { X=\"transient\";id=true; }\n                break partial;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=true; }\n                else if (c=='n') { X=\"instanceof\";id=true; }\n                break partial;\n            case 12: X=\"synchronized\";id=true; break partial;\n            }\n            // partial match validate the entire string the one possibility\n            if (X!=null && X!=s && !X.equals(s)) return false;\n        }\n        return id;\n    }\n",
        "begin_line": 57,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.toString#1247",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return \"JSDocInfo\";\n  }\n",
        "begin_line": 1247,
        "end_line": 1250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "ShadowVariables.visit#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.GatherReferenceInfo.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Skipping over non-name nodes and empty function names.\n      if (!NodeUtil.isReferenceName(n)) {\n        return;\n      }\n\n      // We focus on shadowing local variables as their name occurs much more\n      // than global names.\n      // TODO(user): Alternatively, we could experiment with using a local\n      // name to shadow a global variable.\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      Var var = t.getScope().getVar(n.getString());\n      if (var == null) {\n        // extern name or undefined name.\n        return;\n      }\n\n      if (var.getScope().isGlobal()) {\n        // We will not shadow a global variable name.\n        return;\n      }\n\n      // Using the definition of upward referencing, fill in the map.\n      if (var.getScope() != t.getScope()) {\n        for (Scope s = t.getScope();\n            s != var.getScope() && s.isLocal(); s = s.getParent()) {\n          scopeUpRefMap.put(s.getRootNode(), var.name);\n        }\n      }\n\n      if (var.getScope() == t.getScope()) {\n        scopeUpRefMap.put(t.getScopeRoot(), var.name);\n      }\n\n      // Find in the usage map that tracks a var and all of its usage.\n      varToNameUsage.put(var, n);\n    }\n",
        "begin_line": 128,
        "end_line": 168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.apply#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustDefJoin.apply(com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef, com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef)",
        "snippet": "    @Override\n    public MustDef apply(MustDef a, MustDef b) {\n      MustDef result = new MustDef();\n      Map<Var, Definition> resultMap = result.reachingDef;\n\n      // Take the join of all variables that are not TOP in this.\n      for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) {\n        Var var = varEntry.getKey();\n        Definition aDef = varEntry.getValue();\n\n        if (aDef == null) {\n          // \"a\" is BOTTOM implies that the variable has more than one possible\n          // definition. We set the join of this to be BOTTOM regardless of what\n          // \"b\" might be.\n          resultMap.put(var, null);\n          continue;\n        }\n\n        Node aNode = aDef.node;\n\n        if (b.reachingDef.containsKey(var)) {\n          Definition bDef = b.reachingDef.get(var);\n\n          if (aDef.equals(bDef)) {\n            resultMap.put(var, aDef);\n          } else {\n            resultMap.put(var, null);\n          }\n        } else {\n          resultMap.put(var, aDef);\n        }\n      }\n\n      // Take the join of all variables that are not TOP in other but it is TOP\n      // in this.\n      for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) {\n        Var var = entry.getKey();\n        if (!a.reachingDef.containsKey(var)) {\n          resultMap.put(var, entry.getValue());\n        }\n      }\n      return result;\n    }\n",
        "begin_line": 148,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "MustBeReachingVariableDef.equals#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.Definition.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object other) {\n      if (!(other instanceof Definition)) {\n        return false;\n      }\n      Definition otherDef = (Definition) other;\n      // If the var has the same definition node we can assume they have the\n      // same depends set.\n      return otherDef.node == node;\n    }\n",
        "begin_line": 77,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "MustBeReachingVariableDef.computeMustDef#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.computeMustDef(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef, boolean)",
        "snippet": "  private void computeMustDef(\n      Node n, Node cfgNode, MustDef output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMustDef(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMustDef(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName()) {\n            addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.HOOK:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeMustDef(c.getFirstChild(), cfgNode, output, conditional);\n            addToDefIfLocal(c.getString(), conditional ? null : cfgNode,\n                c.getFirstChild(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n          if (n.getFirstChild().isName()) {\n            Node name = n.getFirstChild();\n            computeMustDef(name.getNext(), cfgNode, output, conditional);\n            addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n              n.getLastChild(), output);\n            return;\n          } else if (NodeUtil.isGet(n.getFirstChild())) {\n            // Treat all assignments to arguments as redefining the\n            // parameters itself.\n            Node obj = n.getFirstChild().getFirstChild();\n            if (obj.isName() && \"arguments\".equals(obj.getString())) {\n              // TODO(user): More accuracy can be introduced\n              // i.e. We know exactly what arguments[x] is if x is a constant\n              // number.\n              escapeParameters(output);\n            }\n          }\n        }\n\n        if (n.isName() && \"arguments\".equals(n.getString())) {\n          escapeParameters(output);\n        }\n\n        // DEC and INC actually defines the variable.\n        if (n.isDec() || n.isInc()) {\n          Node target = n.getFirstChild();\n          if (target.isName()) {\n            addToDefIfLocal(target.getString(),\n                conditional ? null : cfgNode, null, output);\n            return;\n          }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeMustDef(c, cfgNode, output, conditional);\n        }\n    }\n  }\n",
        "begin_line": 225,
        "end_line": 318,
        "comment": "\n   * @param n The node in question.\n   * @param cfgNode The node to add\n   * @param conditional true if the definition is not always executed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.apply#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUsesJoinOp.apply(java.util.List<com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses>)",
        "snippet": "    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n      ReachingUses result = new ReachingUses();\n      for (ReachingUses uses : from) {\n        result.mayUseMap.putAll(uses.mayUseMap);\n      }\n      return result;\n    }\n",
        "begin_line": 121,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaybeReachingVariableUse.computeMayUse#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.computeMayUse(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses, boolean)",
        "snippet": "  private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName() && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!n.isAssign()) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }\n  }\n",
        "begin_line": 169,
        "end_line": 254,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.enterScope#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    // Global scope _SHOULD_ work, however, liveness won't finish without\n    // -Xmx1024 in closure. We might have to look at coding conventions for\n    // exported variables as well.\n    if (scope.isGlobal()) {\n      return;\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // We are not going to do any dead assignment elimination in when there is\n    // at least one inner function because in most browsers, when there is a\n    // closure, ALL the variables are saved (escaped).\n    Node fnBlock = t.getScopeRoot().getLastChild();\n    if (NodeUtil.containsFunction(fnBlock)) {\n      return;\n    }\n\n    // We don't do any dead assignment elimination if there are no assigns\n    // to eliminate. :)\n    if (!NodeUtil.has(fnBlock, matchRemovableAssigns,\n            Predicates.<Node>alwaysTrue())) {\n      return;\n    }\n\n    // Computes liveness information first.\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    tryRemoveDeadAssignments(t, cfg);\n  }\n",
        "begin_line": 70,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.visit#552",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.Anonymous-e8cbd3a6-fd90-443b-91ef-d367e552d84a.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (jsScope == t.getScope() || !n.isName()\n            || parent.isFunction()) {\n          return;\n        }\n        String name = n.getString();\n        Var var = t.getScope().getVar(name);\n        if (var != null && var.scope == jsScope) {\n          escaped.add(jsScope.getVar(name));\n        }\n      }\n",
        "begin_line": 552,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.joinInputs#286",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.joinInputs(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "  protected void joinInputs(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      if (cfg.getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else {\n        List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedPredNodes(node);\n        if (inNodes.size() == 1) {\n          FlowState<L> inNodeState = inNodes.get(0).getAnnotation();\n          state.setIn(inNodeState.getOut());\n        } else if (inNodes.size() > 1) {\n          List<L> values = new ArrayList<L>(inNodes.size());\n          for (DiGraphNode<N, Branch> currentNode : inNodes) {\n            FlowState<L> currentNodeState = currentNode.getAnnotation();\n            values.add(currentNodeState.getOut());\n          }\n          state.setIn(joinOp.apply(values));\n        }\n      }\n    } else {\n      List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedSuccNodes(node);\n      if (inNodes.size() == 1) {\n        DiGraphNode<N, Branch> inNode = inNodes.get(0);\n        if (inNode == cfg.getImplicitReturn()) {\n          state.setOut(createEntryLattice());\n        } else {\n          FlowState<L> inNodeState = inNode.getAnnotation();\n          state.setOut(inNodeState.getIn());\n        }\n      } else if (inNodes.size() > 1) {\n        List<L> values = new ArrayList<L>(inNodes.size());\n        for (DiGraphNode<N, Branch> currentNode : inNodes) {\n          FlowState<L> currentNodeState = currentNode.getAnnotation();\n          values.add(currentNodeState.getIn());\n        }\n        state.setOut(joinOp.apply(values));\n      }\n    }\n  }\n",
        "begin_line": 286,
        "end_line": 324,
        "comment": "\n   * Computes the new flow state at a given node's entry by merging the\n   * output (input) lattice of the node's predecessor (successor).\n   *\n   * @param node Node to compute new join.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.apply#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.ReachablePredicate.apply(com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    public boolean apply(EdgeTuple<Node, Branch> input) {\n      Branch branch = input.edge;\n      if (!branch.isConditional()) {\n        return true;\n      }\n      Node predecessor = input.sourceNode;\n      Node condition = NodeUtil.getConditionExpression(predecessor);\n\n      // TODO(user): Handle more complicated expression like true == true,\n      // etc....\n      if (condition != null) {\n        TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n        if (val != TernaryValue.UNKNOWN) {\n          return val.toBoolean(true) == (branch == Branch.ON_TRUE);\n        }\n      }\n      return true;\n    }\n",
        "begin_line": 93,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSuspiciousCode.checkMissingSemicolon#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSuspiciousCode.java",
        "class_name": "com.google.javascript.jscomp.CheckSuspiciousCode",
        "signature": "com.google.javascript.jscomp.CheckSuspiciousCode.checkMissingSemicolon(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkMissingSemicolon(NodeTraversal t, Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n        Node trueCase = n.getFirstChild().getNext();\n        reportIfWasEmpty(t, trueCase);\n        Node elseCase = trueCase.getNext();\n        if (elseCase != null) {\n          reportIfWasEmpty(t, elseCase);\n        }\n        break;\n\n      case Token.WHILE:\n      case Token.FOR:\n        reportIfWasEmpty(t, NodeUtil.getLoopCodeBlock(n));\n        break;\n    }\n  }\n",
        "begin_line": 57,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 4
    },
    {
        "name": "RemoveUnusedVars.traverseNode#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        // If this function is a removable var, then create a continuation\n        // for it instead of traversing immediately.\n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          // Put this in the assign map. It might count as a reference,\n          // but we won't know that until we have an index of all assigns.\n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              // If the var is unreferenced and performing this assign has\n              // no secondary side effects, then we can create a continuation\n              // for it instead of traversing immediately.\n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        // Look for calls to inheritance-defining calls (such as goog.inherits).\n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          // Look for calls to addSingletonGetter calls.\n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        // Don't try to track the inheritance calls for non-globals. It would\n        // be more correct to only not track when the subclass does not\n        // reference a constructor, but checking that it is a global is\n        // easier and mostly the same.\n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          // Save a reference to the EXPR node.\n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            // If the var is unreferenced and creating its value has no side\n            // effects, then we can create a continuation for it instead\n            // of traversing immediately.\n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          // If arguments is escaped, we just assume the worst and continue\n          // on all the parameters.\n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          // All name references that aren't declarations or assigns\n          // are references to other vars.\n          if (var != null) {\n            // If that var hasn't already been marked referenced, then\n            // start tracking it.  If this is an assign, do nothing\n            // for now.\n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }\n",
        "begin_line": 192,
        "end_line": 305,
        "comment": "\n   * Traverses everything in the current scope and marks variables that\n   * are referenced.\n   *\n   * During traversal, we identify subtrees that will only be\n   * referenced if their enclosing variables are referenced. Instead of\n   * traversing those subtrees, we create a continuation for them,\n   * and traverse them lazily.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3266
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.removeAllAssigns#775",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.removeAllAssigns(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private void removeAllAssigns(Var var) {\n    for (Assign assign : assignsByVar.get(var)) {\n      assign.remove();\n      compiler.reportCodeChange();\n    }\n  }\n",
        "begin_line": 775,
        "end_line": 780,
        "comment": "\n   * Remove all assigns to a var.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3086
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.removeUnreferencedVars#801",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.removeUnreferencedVars()",
        "snippet": "  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      // Remove calls to inheritance-defining functions where the unreferenced\n      // class is the subclass.\n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      // Regardless of what happens to the original declaration,\n      // we need to remove all assigns, because they may contain references\n      // to other unreferenced variables.\n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        // Don't remove function arguments here. That's a special case\n        // that's taken care of in removeUnreferencedFunctionArgs.\n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        // Don't remove bleeding functions.\n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        // foreach iterations have 3 children. Leave them alone.\n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        // If this is a single var declaration, we can at least remove the\n        // declaration itself and just leave the value, e.g.,\n        // var a = foo(); => foo();\n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        // For var declarations with multiple names (i.e. var a, b, c),\n        // only remove the unreferenced name\n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n",
        "begin_line": 801,
        "end_line": 867,
        "comment": "\n   * Removes any vars in the scope that were not referenced. Removes any\n   * assignments to those variables as well.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3086
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.collectMaybeUnreferencedVars#354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.collectMaybeUnreferencedVars(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }\n",
        "begin_line": 354,
        "end_line": 361,
        "comment": "\n   * For each variable in this scope that we haven't found a reference\n   * for yet, add it to the list of variables to check later.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2965
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.getFunctionArgList#412",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.getFunctionArgList(com.google.javascript.rhino.Node)",
        "snippet": "  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }\n",
        "begin_line": 412,
        "end_line": 414,
        "comment": "\n   * @return the LP node containing the function parameters.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2857
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.traverseAndRemoveUnusedReferences#168",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseAndRemoveUnusedReferences(com.google.javascript.rhino.Node)",
        "snippet": "  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }\n",
        "begin_line": 168,
        "end_line": 181,
        "comment": "\n   * Traverses a node recursively. Call this once per pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2843
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.traverseFunction#334",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseFunction(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }\n",
        "begin_line": 334,
        "end_line": 348,
        "comment": "\n   * Traverses a function, which creates a new scope in JavaScript.\n   *\n   * Note that CATCH blocks also create a new scope, but only for the\n   * catch variable. Declarations within the block actually belong to the\n   * enclosing scope. Because we don't remove catch variables, there's\n   * no need to treat CATCH blocks differently like we do functions.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2843
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isGetOrSetKey#2136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isGetOrSetKey(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isGetOrSetKey(Node node) {\n    switch (node.getType()) {\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 2136,
        "end_line": 2143,
        "comment": "\n   * Determines whether a node represents an object literal get or set key\n   * (e.g. key1 in {get key1() {}, set key2(a){}).\n   *\n   * @param node A node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2843
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.isRemovableVar#307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.isRemovableVar(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private boolean isRemovableVar(Var var) {\n    // Global variables are off-limits if the user might be using them.\n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    // Referenced variables are off-limits.\n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    // Exported variables are off-limits.\n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }\n",
        "begin_line": 307,
        "end_line": 324,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.282
        },
        "num_failing_tests": 8
    },
    {
        "name": "NamedType.finishPropertyContinuations#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.finishPropertyContinuations()",
        "snippet": "  private void finishPropertyContinuations() {\n    ObjectType referencedObjType = getReferencedObjTypeInternal();\n    if (referencedObjType != null && !referencedObjType.isUnknownType()) {\n      if (propertyContinuations != null) {\n        for (PropertyContinuation c : propertyContinuations) {\n          c.commit(this);\n        }\n      }\n    }\n    propertyContinuations = null;\n  }\n",
        "begin_line": 133,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.lookupViaProperties#266",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.lookupViaProperties(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private JSType lookupViaProperties( ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n    String[] componentNames = reference.split(\"\\\\.\", -1);\n    if (componentNames[0].length() == 0) {\n      return null;\n    }\n    StaticSlot<JSType> slot = enclosing.getSlot(componentNames[0]);\n    if (slot == null) {\n      return null;\n    }\n    // If the first component has a type of 'Unknown', then any type\n    // names using it should be regarded as silently 'Unknown' rather than be\n    // noisy about it.\n    JSType slotType = slot.getType();\n    if (slotType == null || slotType.isAllType() || slotType.isNoType()) {\n      return null;\n    }\n    JSType value = getTypedefType(t, slot, componentNames[0]);\n    if (value == null) {\n      return null;\n    }\n\n    // resolving component by component\n    for (int i = 1; i < componentNames.length; i++) {\n      ObjectType parentClass = ObjectType.cast(value);\n      if (parentClass == null) {\n        return null;\n      }\n      if (componentNames[i].length() == 0) {\n        return null;\n      }\n      value = parentClass.getPropertyType(componentNames[i]);\n    }\n    return value;\n  }\n",
        "begin_line": 266,
        "end_line": 300,
        "comment": "\n   * Resolves a type by looking up its first component in the scope, and\n   * subsequent components as properties. The scope must have been fully\n   * parsed and a symbol table constructed.\n   * @return The type of the symbol, or null if the type could not be found.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "StatementFusion.optimizeSubtree#36",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StatementFusion.java",
        "class_name": "com.google.javascript.jscomp.StatementFusion",
        "signature": "com.google.javascript.jscomp.StatementFusion.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node n) {\n    // The block of a function body always need { }.\n    if (!n.getParent().isFunction() && canFuseIntoOneStatement(n)) {\n      fuseIntoOneStatement(n);\n      reportCodeChange();\n    }\n    return n;\n  }\n",
        "begin_line": 36,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "StatementFusion.canFuseIntoOneStatement#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StatementFusion.java",
        "class_name": "com.google.javascript.jscomp.StatementFusion",
        "signature": "com.google.javascript.jscomp.StatementFusion.canFuseIntoOneStatement(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean canFuseIntoOneStatement(Node block) {\n    // Fold only statement block. NOT scripts block.\n    if (!block.isBlock()) {\n      return false;\n    }\n\n    // Nothing to do here.\n    if (!block.hasChildren() || block.hasOneChild()) {\n      return false;\n    }\n\n    Node last = block.getLastChild();\n\n    for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n      if (!c.isExprResult() && c != last) {\n        return false;\n      }\n    }\n\n    // TODO(user): Support more control statement for fusion.\n    // FOR\n    switch(last.getType()) {\n      case Token.IF:\n      case Token.THROW:\n      case Token.SWITCH:\n      case Token.EXPR_RESULT:\n        return true;\n      case Token.RETURN:\n        // We don't want to add a new return value.\n        return last.hasChildren();\n      case Token.FOR:\n        return NodeUtil.isForIn(last) &&\n            // Avoid cases where we have for(var x = foo() in a) { ....\n            !mayHaveSideEffects(last.getFirstChild());\n    }\n\n    return false;\n  }\n",
        "begin_line": 46,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "StatementFusion.fuseIntoOneStatement#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StatementFusion.java",
        "class_name": "com.google.javascript.jscomp.StatementFusion",
        "signature": "com.google.javascript.jscomp.StatementFusion.fuseIntoOneStatement(com.google.javascript.rhino.Node)",
        "snippet": "  private void fuseIntoOneStatement(Node block) {\n    Node cur = block.removeFirstChild();\n\n    // Starts building a tree.\n    Node commaTree = cur.removeFirstChild();\n\n\n    while (block.hasMoreThanOneChild()) {\n      Node next = block.removeFirstChild().removeFirstChild();\n      commaTree = fuseExpressionIntoExpression(commaTree, next);\n    }\n\n    Preconditions.checkState(block.hasOneChild());\n    Node last = block.getLastChild();\n\n    // Now we are just left with two statements. The comma tree of the first\n    // n - 1 statements (which can be used in an expression) and the last\n    // statement. We perform specific fusion based on the last statement's type.\n    switch(last.getType()) {\n      case Token.IF:\n      case Token.RETURN:\n      case Token.THROW:\n      case Token.SWITCH:\n      case Token.EXPR_RESULT:\n        fuseExpresssonIntoFirstChild(commaTree, last);\n        return;\n      case Token.FOR:\n        if (NodeUtil.isForIn(last)) {\n          fuseExpresssonIntoSecondChild(commaTree, last);\n        }\n        return ;\n      default:\n        throw new IllegalStateException(\"Statement fusion missing.\");\n    }\n  }\n",
        "begin_line": 85,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "StatementFusion.fuseExpressionIntoExpression#122",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StatementFusion.java",
        "class_name": "com.google.javascript.jscomp.StatementFusion",
        "signature": "com.google.javascript.jscomp.StatementFusion.fuseExpressionIntoExpression(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private static Node fuseExpressionIntoExpression(Node exp1, Node exp2) {\n    Node comma = new Node(Token.COMMA, exp1);\n    comma.copyInformationFrom(exp2);\n\n    // We can just join the new comma expression with another comma but\n    // lets keep all the comma's in a straight line. That way we can use\n    // tree comparison.\n    if (exp2.isComma()) {\n      Node leftMostChild = exp2;\n      while(leftMostChild.isComma()) {\n        leftMostChild = leftMostChild.getFirstChild();\n      }\n      Node parent = leftMostChild.getParent();\n      comma.addChildToBack(leftMostChild.detachFromParent());\n      parent.addChildToFront(comma);\n      return exp2;\n    } else {\n      comma.addChildToBack(exp2);\n      return comma;\n    }\n  }\n",
        "begin_line": 122,
        "end_line": 142,
        "comment": " exp1, exp1",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "StatementFusion.fuseExpresssonIntoFirstChild#144",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StatementFusion.java",
        "class_name": "com.google.javascript.jscomp.StatementFusion",
        "signature": "com.google.javascript.jscomp.StatementFusion.fuseExpresssonIntoFirstChild(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private static void fuseExpresssonIntoFirstChild(Node exp, Node stmt) {\n    Node val = stmt.removeFirstChild();\n    Node comma = fuseExpressionIntoExpression(exp, val);\n    stmt.addChildToFront(comma);\n  }\n",
        "begin_line": 144,
        "end_line": 148,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "ShadowVariables.enterScope#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.DoShadowVariables.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Scope s = t.getScope();\n      if (!s.isLocal()) {\n        return;\n      }\n\n      // Since we don't shadow global, there is nothing to be done in the\n      // first immediate local scope as well.\n      if (s.getParent().isGlobal()) {\n        return;\n      }\n\n      for (Iterator<Var> vars = s.getVars(); vars.hasNext();) {\n        Var var = vars.next();\n\n        // Don't shadow variables that is bleed-out to fix an IE bug.\n        if (var.isBleedingFunction()) {\n          continue;\n        }\n\n        // Don't shadow an exported local.\n        if (compiler.getCodingConvention().isExported(var.name, s.isLocal())) {\n          continue;\n        }\n\n        // Try to look for the best shadow for the current candidate.\n        Assignment bestShadow = findBestShadow(s, var);\n        if (bestShadow == null) {\n          continue;\n        }\n\n        // The name assignment being shadowed.\n        Assignment localAssignment = assignments.get(var.getName());\n\n        // Only shadow if this increases the number of occurrences of the\n        // shadowed variable.\n        if (bestShadow.count < localAssignment.count) {\n          continue; // Hope the next local variable would have a smaller count.\n        }\n\n        doShadow(localAssignment, bestShadow, var);\n\n        if (oldPseudoNameMap != null) {\n          String targetPseudoName =\n            oldPseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n          for (Node use : varToNameUsage.get(var)) {\n            deltaPseudoNameMap.put(use, targetPseudoName);\n          }\n        }\n      }\n    }\n",
        "begin_line": 174,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.optimizeSubtree#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.RETURN: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        result = tryReplaceExitWithBreak(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReduceReturn(node);\n      }\n\n      case Token.THROW: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReplaceExitWithBreak(node);\n      }\n\n      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n      // with MinimizeExitPoints.\n\n      case Token.NOT:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeNot(node);\n\n      case Token.IF:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeIf(node);\n\n      case Token.EXPR_RESULT:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.HOOK:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.WHILE:\n      case Token.DO:\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        return node;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(node)) {\n          tryJoinForCondition(node);\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        }\n        return node;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (!node.isCall()) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldSimpleFunctionCall(node);\n          if (result == node) {\n            result = tryFoldImmediateCallToBoundFunction(node);\n          }\n        }\n        return result;\n\n      case Token.COMMA:\n        return trySplitComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.BLOCK:\n        return tryReplaceIf(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }\n",
        "begin_line": 78,
        "end_line": 169,
        "comment": "\n   * Tries apply our various peephole minimizations on the passed in node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.trySplitComma#275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.trySplitComma(com.google.javascript.rhino.Node)",
        "snippet": "  private Node trySplitComma(Node n) {\n    if (late) {\n      return n;\n    }\n    Node parent = n.getParent();\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n\n    if (parent.isExprResult()\n        && !parent.getParent().isLabel()) {\n      // split comma\n      n.detachChildren();\n      // Replace the original expression with the left operand.\n      parent.replaceChild(n, left);\n      // Add the right expression afterward.\n      Node newStatement = IR.exprResult(right);\n      newStatement.copyInformationFrom(n);\n\n      //This modifies outside the subtree, which is not\n      //desirable in a peephole optimization.\n      parent.getParent().addChildAfter(newStatement, parent);\n      reportCodeChange();\n      return left;\n    } else {\n      return n;\n    }\n  }\n",
        "begin_line": 275,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.isReturnBlock#971",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isReturnBlock(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isReturnBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        return first.isReturn();\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 971,
        "end_line": 980,
        "comment": "\n   * @return Whether the node is a block with a single statement that is\n   *     an return with or without an expression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeRemoveDeadCode.optimizeSubtree#40",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.ASSIGN:\n        return tryFoldAssignment(subtree);\n      case Token.COMMA:\n        return tryFoldComma(subtree);\n      case Token.SCRIPT:\n      case Token.BLOCK:\n        return tryOptimizeBlock(subtree);\n      case Token.EXPR_RESULT:\n        subtree = tryFoldExpr(subtree);\n        return subtree;\n      case Token.HOOK:\n        return tryFoldHook(subtree);\n      case Token.SWITCH:\n        return tryOptimizeSwitch(subtree);\n      case Token.IF:\n        return tryFoldIf(subtree);\n      case Token.WHILE:\n        return tryFoldWhile(subtree);\n       case Token.FOR: {\n          Node condition = NodeUtil.getConditionExpression(subtree);\n          if (condition != null) {\n            tryFoldForCondition(condition);\n          }\n        }\n        return tryFoldFor(subtree);\n      case Token.DO:\n        return tryFoldDo(subtree);\n      case Token.TRY:\n        return tryFoldTry(subtree);\n      default:\n          return subtree;\n    }\n  }\n",
        "begin_line": 40,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.trySimplifyUnusedResult#170",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.trySimplifyUnusedResult(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n    Node result = n;\n\n    // Simplify the results of conditional expressions\n    switch (n.getType()) {\n      case Token.HOOK:\n        Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext());\n        Node falseNode = trySimplifyUnusedResult(n.getLastChild());\n        // If one or more of the conditional children were removed,\n        // transform the HOOK to an equivalent operation:\n        //    x() ? foo() : 1 --> x() && foo()\n        //    x() ? 1 : foo() --> x() || foo()\n        //    x() ? 1 : 1 --> x()\n        //    x ? 1 : 1 --> null\n        if (trueNode == null && falseNode != null) {\n          n.setType(Token.OR);\n          Preconditions.checkState(n.getChildCount() == 2);\n        } else if (trueNode != null && falseNode == null) {\n          n.setType(Token.AND);\n          Preconditions.checkState(n.getChildCount() == 2);\n        } else if (trueNode == null && falseNode == null) {\n          result = trySimplifyUnusedResult(n.getFirstChild());\n        } else {\n          // The structure didn't change.\n          result = n;\n        }\n        break;\n      case Token.AND:\n      case Token.OR:\n        // Try to remove the second operand from a AND or OR operations:\n        //    x() || f --> x()\n        //    x() && f --> x()\n        Node conditionalResultNode = trySimplifyUnusedResult(\n            n.getLastChild());\n        if (conditionalResultNode == null) {\n          Preconditions.checkState(n.hasOneChild());\n          // The conditionally executed code was removed, so\n          // replace the AND/OR with its LHS or remove it if it isn't useful.\n          result = trySimplifyUnusedResult(n.getFirstChild());\n        }\n        break;\n      case Token.FUNCTION:\n        // A function expression isn't useful if it isn't used, remove it and\n        // don't bother to look at its children.\n        result = null;\n        break;\n      case Token.COMMA:\n        // We rewrite other operations as COMMA expressions (which will later\n        // get split into individual EXPR_RESULT statement, if possible), so\n        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n        // nodes.\n        Node left = trySimplifyUnusedResult(n.getFirstChild());\n        Node right = trySimplifyUnusedResult(n.getLastChild());\n        if (left == null && right == null) {\n          result = null;\n        } else if (left == null) {\n          result = right;\n        } else if (right == null){\n          result = left;\n        } else {\n          // The structure didn't change.\n          result = n;\n        }\n        break;\n      default:\n        if (!nodeTypeMayHaveSideEffects(n)) {\n          // This is the meat of this function. The node itself doesn't generate\n          // any side-effects but preserve any side-effects in the children.\n          Node resultList = null;\n          for (Node next, c = n.getFirstChild(); c != null; c = next) {\n            next = c.getNext();\n            c = trySimplifyUnusedResult(c);\n            if (c != null) {\n              c.detachFromParent();\n              if (resultList == null)  {\n                // The first side-effect can be used stand-alone.\n                resultList = c;\n              } else {\n                // Leave the side-effects in-place, simplifying it to a COMMA\n                // expression.\n                resultList = IR.comma(resultList, c).srcref(c);\n              }\n            }\n          }\n          result = resultList;\n        }\n    }\n\n    // Fix up the AST, replace or remove the an unused node (if requested).\n    if (n != result) {\n      Node parent = n.getParent();\n      if (result == null) {\n        if (removeUnused) {\n          parent.removeChild(n);\n        } else {\n          result = IR.empty().srcref(n);\n          parent.replaceChild(n, result);\n        }\n      } else {\n        // A new COMMA expression may not have an existing parent.\n        if (result.getParent() != null) {\n          result.detachFromParent();\n        }\n        n.getParent().replaceChild(n, result);\n      }\n      reportCodeChange();\n    }\n\n    return result;\n  }\n",
        "begin_line": 170,
        "end_line": 279,
        "comment": "\n   * General cascading unused operation node removal.\n   * @param n The root of the expression to simplify.\n   * @param removeUnused If true, the node is removed from the AST if\n   *     it is not useful, otherwise it replaced with an EMPTY node.\n   * @return The replacement node, or null if the node was is not useful.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeepholeRemoveDeadCode.tryFoldComma#489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldComma(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldComma(Node n) {\n    // If the left side does nothing replace the comma with the result.\n    Node parent = n.getParent();\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n\n    left = trySimplifyUnusedResult(left);\n    if (left == null || !mayHaveSideEffects(left)) {\n      // Fold it!\n      n.removeChild(right);\n      parent.replaceChild(n, right);\n      reportCodeChange();\n      return right;\n    }\n    return n;\n  }\n",
        "begin_line": 489,
        "end_line": 504,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "OptimizeArgumentsArray.enterScope#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This optimization is valid only within a function so we are going to\n    // skip over the initial entry to the global scope.\n    Node function = traversal.getScopeRoot();\n    if (!function.isFunction()) {\n      return;\n    }\n\n    // Introduces a new access list and stores the access list of the outer\n    // scope in the stack if necessary.\n    if (currentArgumentsAccess != null) {\n      argumentsAccessStack.push(currentArgumentsAccess);\n    }\n    currentArgumentsAccess = Lists.newLinkedList();\n  }\n",
        "begin_line": 93,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.exitScope#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This is the case when we are exiting the global scope where we had never\n    // collected argument access list. Since we do not perform this optimization\n    // for the global scope, we will skip this exit point.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Attempt to replace the argument access and if the AST has been change,\n    // report back to the compiler.\n    if (tryReplaceArguments(traversal.getScope())) {\n      traversal.getCompiler().reportCodeChange();\n    }\n\n    // After the attempt to replace the arguments. The currentArgumentsAccess\n    // is stale and as we exit the Scope, no longer holds all the access to the\n    // current scope anymore. We'll pop the access list from the outer scope\n    // and set it as currentArgumentsAcess if the outer scope is not the global\n    // scope.\n    if (!argumentsAccessStack.isEmpty()) {\n      currentArgumentsAccess = argumentsAccessStack.pop();\n    } else {\n      currentArgumentsAccess = null;\n    }\n  }\n",
        "begin_line": 112,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.apply#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableJoinOp.apply(java.util.List<com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice>)",
        "snippet": "    @Override\n    public LiveVariableLattice apply(List<LiveVariableLattice> in) {\n      LiveVariableLattice result = new LiveVariableLattice(in.get(0));\n      for (int i = 1; i < in.size(); i++) {\n        result.liveSet.or(in.get(i).liveSet);\n      }\n      return result;\n    }\n",
        "begin_line": 60,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "LiveVariablesAnalysis.computeGenKill#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.computeGenKill(com.google.javascript.rhino.Node, java.util.BitSet, java.util.BitSet, boolean)",
        "snippet": "  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            // for(var x in y) {...}\n            lhs = lhs.getLastChild();\n          }\n\n          if (lhs.isName()) {\n            addToSetIfLocal(lhs, kill);\n            addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n\n          // rhs is executed only once so we don't go into it every loop.\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!n.isAssign()) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }\n",
        "begin_line": 184,
        "end_line": 275,
        "comment": "\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.getNameForObjLitKey#456",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.getNameForObjLitKey(com.google.javascript.rhino.Node)",
        "snippet": "    String getNameForObjLitKey(Node n) {\n      Node parent = n.getParent();\n      Preconditions.checkState(parent.isObjectLit());\n\n      Node gramps = parent.getParent();\n      if (gramps == null) {\n        return null;\n      }\n\n      Node greatGramps = gramps.getParent();\n      String name;\n      switch (gramps.getType()) {\n        case Token.NAME:\n          // VAR\n          //   NAME (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps == null || !greatGramps.isVar()) {\n            return null;\n          }\n          name = gramps.getString();\n          break;\n        case Token.ASSIGN:\n          // ASSIGN (gramps)\n          //   NAME|GETPROP\n          //   OBJLIT (parent)\n          //     STRING (n)\n          Node lvalue = gramps.getFirstChild();\n          name = lvalue.getQualifiedName();\n          break;\n        case Token.STRING_KEY:\n          // OBJLIT\n          //   STRING (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps != null &&\n              greatGramps.isObjectLit()) {\n            name = getNameForObjLitKey(gramps);\n          } else {\n            return null;\n          }\n          break;\n        default:\n          return null;\n      }\n      if (name != null) {\n        String key = n.getString();\n        if (TokenStream.isJSIdentifier(key)) {\n          return name + '.' + key;\n        }\n      }\n      return null;\n    }\n",
        "begin_line": 456,
        "end_line": 508,
        "comment": "\n     * Gets the fully qualified name corresponding to an object literal key,\n     * as long as it and its prefix property names are valid JavaScript\n     * identifiers. The object literal may be nested inside of other object\n     * literals.\n     *\n     * For example, if called with node {@code n} representing \"z\" in any of\n     * the following expressions, the result would be \"w.x.y.z\":\n     * <code> var w = {x: {y: {z: 0}}}; </code>\n     * <code> w.x = {y: {z: 0}}; </code>\n     * <code> w.x.y = {'a': 0, 'z': 0}; </code>\n     *\n     * @param n A child of an OBJLIT node\n     * @return The global name, or null if {@code n} doesn't correspond to the\n     *   key of an object literal that can be named\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowGraph.isEnteringNewCfgNode#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // bleeds into the local scope and parameters are assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body, represented by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // These control structures are represented by a node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n\n      case Token.FOR:\n        // The FOR(;;) node differs from other control structures in that\n        // it has an initialization and an increment statement. Those\n        // two statements have corresponding CFG nodes to represent them.\n        // The FOR node only represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          // TODO(user): Investigate how we should handle the case where\n          // we have a very complex expression inside the FOR-IN header.\n          return n != parent.getFirstChild();\n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 159,
        "end_line": 205,
        "comment": "\n   * @return True if n should be represented by a new CFG node in the control\n   * flow graph.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 3
    },
    {
        "name": "ControlFlowAnalysis.computeFollowNode#692",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowAnalysis)",
        "snippet": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n",
        "begin_line": 692,
        "end_line": 789,
        "comment": "\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSuspiciousCode.reportIfWasEmpty#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSuspiciousCode.java",
        "class_name": "com.google.javascript.jscomp.CheckSuspiciousCode",
        "signature": "com.google.javascript.jscomp.CheckSuspiciousCode.reportIfWasEmpty(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void reportIfWasEmpty(NodeTraversal t, Node block) {\n    Preconditions.checkState(block.isBlock());\n\n    // A semicolon is distinguished from a block without children by\n    // annotating it with EMPTY_BLOCK.  Blocks without children are\n    // usually intentional, especially with loops.\n    if (!block.hasChildren() && block.wasEmptyNode()) {\n        t.getCompiler().report(\n            t.makeError(block, SUSPICIOUS_SEMICOLON));\n    }\n  }\n",
        "begin_line": 75,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.isGlobal#191",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isGlobal()",
        "snippet": "    public boolean isGlobal() {\n      return scope.isGlobal();\n    }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": "\n     * Returns whether this is a global variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2265
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.removeChild#690",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeChild(com.google.javascript.rhino.Node)",
        "snippet": "  public void removeChild(Node child) {\n    Node prev = getChildBefore(child);\n    if (prev == null)\n        first = first.next;\n    else\n        prev.next = child.next;\n    if (child == last) last = prev;\n    child.next = null;\n    child.parent = null;\n  }\n",
        "begin_line": 690,
        "end_line": 699,
        "comment": "\n   * Detach a child from its parent and siblings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2209
        },
        "num_failing_tests": 8
    },
    {
        "name": "LinkedUndirectedGraph.newSubGraph#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.newSubGraph()",
        "snippet": "  @Override\n  public SubGraph<N, E> newSubGraph() {\n    return new SimpleSubGraph<N, E>(this);\n  }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedUndirectedGraph.create#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.create()",
        "snippet": "  public static <N, E> LinkedUndirectedGraph<N, E> create() {\n    return new LinkedUndirectedGraph<N, E>(true, true);\n  }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedUndirectedGraph.getNodes#250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.getNodes()",
        "snippet": "  @Override\n  public Collection<GraphNode<N, E>> getNodes() {\n    return Collections.<GraphNode<N, E>> unmodifiableCollection(nodes.values());\n  }\n",
        "begin_line": 250,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "Graph.SimpleSubGraph#310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.SimpleSubGraph.SimpleSubGraph(com.google.javascript.jscomp.graph.Graph<N, E>)",
        "snippet": "    SimpleSubGraph(Graph<N, E> graph) {\n      this.graph = graph;\n    }\n",
        "begin_line": 310,
        "end_line": 312,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.shouldOptimizeScope#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.shouldOptimizeScope(com.google.javascript.jscomp.Scope)",
        "snippet": "  private static boolean shouldOptimizeScope(Scope scope) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    if (scope.isGlobal()) {\n      return false;\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        scope.getVarCount()) {\n      return false;\n    }\n\n    return true;\n  }\n",
        "begin_line": 91,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.enterScope#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (!shouldOptimizeScope(scope)) {\n      return;\n    }\n\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n      liveness.markAllParametersEscaped();\n    }\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }\n",
        "begin_line": 108,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.exitScope#139",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!shouldOptimizeScope(t.getScope())) {\n      return;\n    }\n    colorings.pop();\n  }\n",
        "begin_line": 139,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.computeVariableNamesInterferenceGraph#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.computeVariableNamesInterferenceGraph(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, java.util.Set<com.google.javascript.jscomp.Scope.Var>)",
        "snippet": "  private UndiGraph<Var, Void> computeVariableNamesInterferenceGraph(\n      NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) {\n    UndiGraph<Var, Void> interferenceGraph =\n        LinkedUndirectedGraph.create();\n    Scope scope = t.getScope();\n\n    // First create a node for each non-escaped variable.\n    for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (!escaped.contains(v)) {\n\n        // TODO(user): In theory, we CAN coalesce function names just like\n        // any variables. Our Liveness analysis captures this just like it as\n        // described in the specification. However, we saw some zipped and\n        // and unzipped size increase after this. We are not totally sure why\n        // that is but, for now, we will respect the dead functions and not play\n        // around with it.\n        if (!v.getParentNode().isFunction()) {\n          interferenceGraph.createNode(v);\n        }\n      }\n    }\n\n    // Go through each variable and try to connect them.\n    for (Iterator<Var> i1 = scope.getVars(); i1.hasNext();) {\n      Var v1 = i1.next();\n\n      NEXT_VAR_PAIR:\n      for (Iterator<Var> i2 = scope.getVars(); i2.hasNext();) {\n        Var v2 = i2.next();\n\n        // Skip duplicate pairs.\n        if (v1.index >= v2.index) {\n          continue;\n        }\n\n        if (!interferenceGraph.hasNode(v1) ||\n            !interferenceGraph.hasNode(v2)) {\n          // Skip nodes that were not added. They are globals and escaped\n          // locals. Also avoid merging a variable with itself.\n          continue NEXT_VAR_PAIR;\n        }\n\n        if (v1.getParentNode().isParamList() &&\n            v2.getParentNode().isParamList()) {\n          interferenceGraph.connectIfNotFound(v1, null, v2);\n          continue NEXT_VAR_PAIR;\n        }\n\n        // Go through every CFG node in the program and look at\n        // this variable pair. If they are both live at the same\n        // time, add an edge between them and continue to the next pair.\n        NEXT_CROSS_CFG_NODE:\n        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n          if (cfg.isImplicitReturn(cfgNode)) {\n            continue NEXT_CROSS_CFG_NODE;\n          }\n\n          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n          // Check the live states and add edge when possible.\n          if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) ||\n              (state.getOut().isLive(v1) && state.getOut().isLive(v2))) {\n            interferenceGraph.connectIfNotFound(v1, null, v2);\n            continue NEXT_VAR_PAIR;\n          }\n        }\n\n        // v1 and v2 might not have an edge between them! woohoo. there's\n        // one last sanity check that we have to do: we have to check\n        // if there's a collision *within* the cfg node.\n        NEXT_INTRA_CFG_NODE:\n        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n          if (cfg.isImplicitReturn(cfgNode)) {\n            continue NEXT_INTRA_CFG_NODE;\n          }\n\n          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n          boolean v1OutLive = state.getOut().isLive(v1);\n          boolean v2OutLive = state.getOut().isLive(v2);\n          CombinedLiveRangeChecker checker = new CombinedLiveRangeChecker(\n              new LiveRangeChecker(v1, v2OutLive ? null : v2),\n              new LiveRangeChecker(v2, v1OutLive ? null : v1));\n          NodeTraversal.traverse(\n              compiler,\n              cfgNode.getValue(),\n              checker);\n          if (checker.connectIfCrossed(interferenceGraph)) {\n            continue NEXT_VAR_PAIR;\n          }\n        }\n      }\n    }\n    return interferenceGraph;\n  }\n",
        "begin_line": 212,
        "end_line": 305,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2157
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedUndirectedGraph.LinkedUndirectedGraph#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.LinkedUndirectedGraph(boolean, boolean)",
        "snippet": "  protected LinkedUndirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }\n",
        "begin_line": 68,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.getEscapedLocals#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.getEscapedLocals()",
        "snippet": "  public Set<Var> getEscapedLocals() {\n    return escaped;\n  }\n",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2132
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.getChildBefore#543",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getChildBefore(com.google.javascript.rhino.Node)",
        "snippet": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }\n",
        "begin_line": 543,
        "end_line": 555,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2114
        },
        "num_failing_tests": 8
    },
    {
        "name": "LiveVariablesAnalysis.LiveVariableLattice#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice.LiveVariableLattice(int)",
        "snippet": "    private LiveVariableLattice(int numVars) {\n      this.liveSet = new BitSet(numVars);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * @param numVars Number of all local variables.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.LiveVariableLattice#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice.LiveVariableLattice(com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice)",
        "snippet": "    private LiveVariableLattice(LiveVariableLattice other) {\n      Preconditions.checkNotNull(other);\n      this.liveSet = (BitSet) other.liveSet.clone();\n    }\n",
        "begin_line": 85,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.equals#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object other) {\n      Preconditions.checkNotNull(other);\n      return (other instanceof LiveVariableLattice) &&\n          this.liveSet.equals(((LiveVariableLattice) other).liveSet);\n    }\n",
        "begin_line": 90,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.LiveVariablesAnalysis#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariablesAnalysis(com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  LiveVariablesAnalysis(ControlFlowGraph<Node> cfg, Scope jsScope,\n      AbstractCompiler compiler) {\n    super(cfg, new LiveVariableJoinOp());\n    this.jsScope = jsScope;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }\n",
        "begin_line": 121,
        "end_line": 127,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.isForward#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.isForward()",
        "snippet": "  @Override\n  boolean isForward() {\n    return false;\n  }\n",
        "begin_line": 137,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.createEntryLattice#142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.createEntryLattice()",
        "snippet": "  @Override\n  LiveVariableLattice createEntryLattice() {\n    return new LiveVariableLattice(jsScope.getVarCount());\n  }\n",
        "begin_line": 142,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.createInitialEstimateLattice#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.createInitialEstimateLattice()",
        "snippet": "  @Override\n  LiveVariableLattice createInitialEstimateLattice() {\n    return new LiveVariableLattice(jsScope.getVarCount());\n  }\n",
        "begin_line": 147,
        "end_line": 150,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "LiveVariablesAnalysis.flowThrough#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.flowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariableLattice)",
        "snippet": "  @Override\n  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\n    final BitSet gen = new BitSet(input.liveSet.size());\n    final BitSet kill = new BitSet(input.liveSet.size());\n\n    // Make kills conditional if the node can end abruptly by an exception.\n    boolean conditional = false;\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\n      if (Branch.ON_EX.equals(edge.getValue())) {\n        conditional = true;\n      }\n    }\n    computeGenKill(node, gen, kill, conditional);\n    LiveVariableLattice result = new LiveVariableLattice(input);\n    // L_in = L_out - Kill + Gen\n    result.liveSet.andNot(kill);\n    result.liveSet.or(gen);\n    return result;\n  }\n",
        "begin_line": 152,
        "end_line": 171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2108
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.apply#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.Anonymous-069c98f6-a1c8-4e31-baa3-4b2bd0ad13f8.apply(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean apply(Node n) {\n      return (NodeUtil.isAssignmentOp(n) &&\n              n.getFirstChild().isName()) ||\n          n.isInc() || n.isDec();\n    }\n",
        "begin_line": 51,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.containsFunction#1540",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.containsFunction(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }\n",
        "begin_line": 1540,
        "end_line": 1542,
        "comment": "\n   * Determines if the given node contains a function statement or function\n   * expression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2063
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeGenerator.add#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.add(com.google.javascript.rhino.Node, com.google.javascript.jscomp.CodeGenerator.Context)",
        "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
        "begin_line": 103,
        "end_line": 756,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2047
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.endFunction#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endFunction(boolean)",
        "snippet": "  void endFunction(boolean statementContext) {\n    sawFunction = true;\n    if (statementContext) {\n      endLine();\n    }\n  }\n",
        "begin_line": 167,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2047
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.containsType#2229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.containsType(com.google.javascript.rhino.Node, int)",
        "snippet": "  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }\n",
        "begin_line": 2229,
        "end_line": 2231,
        "comment": "\n   * @return true if n or any of its children are of the specified type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnionType.resolveInternal#538",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this); // for circularly defined types.\n\n    boolean changed = false;\n    ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder();\n    for (JSType alternate : alternates) {\n      JSType newAlternate = alternate.resolve(t, scope);\n      changed |= (alternate != newAlternate);\n      resolvedTypes.add(alternate);\n    }\n    if (changed) {\n      Collection<JSType> newAlternates = resolvedTypes.build();\n      Preconditions.checkState(\n          newAlternates.hashCode() == this.hashcode);\n      alternates = newAlternates;\n    }\n    return this;\n  }\n",
        "begin_line": 538,
        "end_line": 556,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.resolveViaProperties#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.resolveViaProperties(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private void resolveViaProperties(ErrorReporter t,\n                                    StaticScope<JSType> enclosing) {\n    JSType value = lookupViaProperties(t, enclosing);\n    // last component of the chain\n    if (value != null && value.isFunctionType() &&\n        (value.isConstructor() || value.isInterface())) {\n      FunctionType functionType = value.toMaybeFunctionType();\n      setReferencedAndResolvedType(\n          functionType.getInstanceType(), t, enclosing);\n    } else if (value != null && value.isNoObjectType()) {\n      setReferencedAndResolvedType(\n          registry.getNativeFunctionType(\n              JSTypeNative.NO_OBJECT_TYPE).getInstanceType(), t, enclosing);\n    } else if (value instanceof EnumType) {\n      setReferencedAndResolvedType(\n          ((EnumType) value).getElementsType(), t, enclosing);\n    } else {\n      // We've been running into issues where people forward-declare\n      // non-named types. (This is legitimate...our dependency management\n      // code doubles as our forward-declaration code.)\n      //\n      // So if the type does resolve to an actual value, but it's not named,\n      // then don't respect the forward declaration.\n      handleUnresolvedType(t, value == null || value.isUnknownType());\n    }\n  }\n",
        "begin_line": 233,
        "end_line": 258,
        "comment": "\n   * Resolves a named type by looking up its first component in the scope, and\n   * subsequent components as properties. The scope must have been fully\n   * parsed and a symbol table constructed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.isForwardDeclaredType#865",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.isForwardDeclaredType(java.lang.String)",
        "snippet": "  public boolean isForwardDeclaredType(String name) {\n    return forwardDeclaredTypes.contains(name);\n  }\n",
        "begin_line": 865,
        "end_line": 867,
        "comment": "\n   * Whether this is a forward-declared type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.and#351",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.and(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n",
        "begin_line": 351,
        "end_line": 353,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.getDeclaredType#1283",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getDeclaredType(java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n",
        "begin_line": 1283,
        "end_line": 1337,
        "comment": "\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.isPropertyAssignmentInExpression#1101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isPropertyAssignmentInExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isPropertyAssignmentInExpression(Node n) {\n    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n        new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return (input.isGetProp() &&\n            input.getParent().isAssign());\n      }\n    };\n\n    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }\n",
        "begin_line": 1101,
        "end_line": 1113,
        "comment": "\n   * Does the expression contain a property assignment?\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.apply#1104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.Anonymous-87c1a915-c876-4106-b9da-cfc20f9bab88.apply(com.google.javascript.rhino.Node)",
        "snippet": "      @Override\n      public boolean apply(Node input) {\n        return (input.isGetProp() &&\n            input.getParent().isAssign());\n      }\n",
        "begin_line": 1104,
        "end_line": 1108,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryMinimizeIf#636",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryMinimizeIf(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }\n",
        "begin_line": 636,
        "end_line": 868,
        "comment": "\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.isFoldableExpressBlock#926",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isFoldableExpressBlock(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.isExprResult()) {\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n          if (maybeExpr.getFirstChild().isCall()) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (calledFn.isGetElem()) {\n              return false;\n            } else if (calledFn.isGetProp() &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        return false;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 926,
        "end_line": 957,
        "comment": "\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "Normalize.moveNamedFunctions#644",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.moveNamedFunctions(com.google.javascript.rhino.Node)",
        "snippet": "    private void moveNamedFunctions(Node functionBody) {\n      Preconditions.checkState(\n          functionBody.getParent().isFunction());\n      Node previous = null;\n      Node current = functionBody.getFirstChild();\n      // Skip any declarations at the beginning of the function body, they\n      // are already in the right place.\n      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n        previous = current;\n        current = current.getNext();\n      }\n\n      // Find any remaining declarations and move them.\n      Node insertAfter = previous;\n      while (current != null) {\n        // Save off the next node as the current node maybe removed.\n        Node next = current.getNext();\n        if (NodeUtil.isFunctionDeclaration(current)) {\n          // Remove the declaration from the body.\n          Preconditions.checkNotNull(previous);\n          functionBody.removeChildAfter(previous);\n\n          // Read the function at the top of the function body (after any\n          // previous declarations).\n          insertAfter = addToFront(functionBody, current, insertAfter);\n          reportCodeChange(\"Move function declaration not at top of function\");\n        } else {\n          // Update the previous only if the current node hasn't been moved.\n          previous = current;\n        }\n        current = next;\n      }\n    }\n",
        "begin_line": 644,
        "end_line": 676,
        "comment": "\n     * Move all the functions that are valid at the execution of the first\n     * statement of the function to the beginning of the function definition.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.precedence#1173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.precedence(int)",
        "snippet": "  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.CALL:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      // Data values\n      case Token.ARRAYLIT:\n      case Token.EMPTY:  // TODO(johnlenz): remove this.\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n      case Token.CAST:\n        return 16;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Token.name(type) +\n                               \" (type \" + type + \")\");\n    }\n  }\n",
        "begin_line": 1173,
        "end_line": 1248,
        "comment": "\n   *  0 comma ,\n   *  1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |=\n   *  2 conditional ?:\n   *  3 logical-or ||\n   *  4 logical-and &&\n   *  5 bitwise-or |\n   *  6 bitwise-xor ^\n   *  7 bitwise-and &\n   *  8 equality == !=\n   *  9 relational < <= > >=\n   * 10 bitwise shift << >> >>>\n   * 11 addition/subtraction + -\n   * 12 multiply/divide * / %\n   * 13 negation/increment ! ~ - ++ --\n   * 14 call, member () [] .\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.getConditionExpression#1724",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getConditionExpression(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getConditionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n      case Token.WHILE:\n        return n.getFirstChild();\n      case Token.DO:\n        return n.getLastChild();\n      case Token.FOR:\n        switch (n.getChildCount()) {\n          case 3:\n            return null;\n          case 4:\n            return n.getFirstChild().getNext();\n        }\n        throw new IllegalArgumentException(\"malformed 'for' statement \" + n);\n      case Token.CASE:\n        return null;\n    }\n    throw new IllegalArgumentException(n + \" does not have a condition.\");\n  }\n",
        "begin_line": 1724,
        "end_line": 1743,
        "comment": "\n   * Gets the condition of an ON_TRUE / ON_FALSE CFG edge.\n   * @param n a node with an outgoing conditional CFG edge\n   * @return the condition node or null if the condition is not obviously a node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.collectAliasCandidates#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.collectAliasCandidates(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    private void collectAliasCandidates(NodeTraversal t,\n        ReferenceMap referenceMap) {\n      if (mode != Mode.CONSTANTS_ONLY) {\n        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n          Var v = it.next();\n          ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n          // NOTE(nicksantos): Don't handle variables that are never used.\n          // The tests are much easier to write if you don't, and there's\n          // another pass that handles unused variables much more elegantly.\n          if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n              referenceInfo.isWellDefined() &&\n              referenceInfo.isAssignedOnceInLifetime()) {\n            Reference init = referenceInfo.getInitializingReference();\n            Node value = init.getAssignedValue();\n            if (value != null && value.isName()) {\n              aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n            }\n          }\n        }\n      }\n    }\n",
        "begin_line": 167,
        "end_line": 188,
        "comment": "\n     * If any of the variables are well-defined and alias other variables,\n     * mark them as aliasing candidates.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.AliasCandidate#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.AliasCandidate.AliasCandidate(com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection)",
        "snippet": "    AliasCandidate(Var alias, ReferenceCollection refInfo) {\n      this.alias = alias;\n      this.refInfo = refInfo;\n    }\n",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineObjectLiterals.isInlinableObject#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InliningBehavior.isInlinableObject(java.util.List<com.google.javascript.jscomp.ReferenceCollectingCallback.Reference>)",
        "snippet": "    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n          if (gramps.isDelProp()) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n",
        "begin_line": 155,
        "end_line": 256,
        "comment": "\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExploitAssigns.collapseAssignEqualTo#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
        "class_name": "com.google.javascript.jscomp.ExploitAssigns",
        "signature": "com.google.javascript.jscomp.ExploitAssigns.collapseAssignEqualTo(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 108,
        "end_line": 199,
        "comment": "\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.visit#294",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n",
        "begin_line": 294,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.handleIf#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleIf(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n",
        "begin_line": 357,
        "end_line": 370,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "CommandLineRunner.parseArguments#460",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.BooleanOptionHandler.parseArguments(org.kohsuke.args4j.spi.Parameters)",
        "snippet": "      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {}\n\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }\n",
        "begin_line": 460,
        "end_line": 482,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 2
    },
    {
        "name": "CodeConsumer.appendBlockStart#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockStart()",
        "snippet": "  void appendBlockStart() {\n    append(\"{\");\n  }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.appendBlockEnd#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockEnd()",
        "snippet": "  void appendBlockEnd() {\n    append(\"}\");\n  }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.beginBlock#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.beginBlock()",
        "snippet": "  void beginBlock() {\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n    }\n    appendBlockStart();\n\n    endLine();\n    statementNeedsEnded = false;\n  }\n",
        "begin_line": 100,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.endBlock#115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endBlock(boolean)",
        "snippet": "  void endBlock(boolean shouldEndLine) {\n    appendBlockEnd();\n    if (shouldEndLine) {\n      endLine();\n    }\n    statementNeedsEnded = false;\n  }\n",
        "begin_line": 115,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.breakAfterBlockFor#307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.breakAfterBlockFor(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  boolean breakAfterBlockFor(Node n, boolean statementContext) {\n    return statementContext;\n  }\n",
        "begin_line": 307,
        "end_line": 309,
        "comment": "\n   * @return Whether the a line break can be added after the specified BLOCK.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 8
    },
    {
        "name": "GraphColoring.color#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphColoring.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
        "signature": "com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring.color()",
        "snippet": "    @Override\n    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\n          return result == 0 && tieBreaker != null ?\n              tieBreaker.compare(o1.getValue(), o2.getValue()) : result;\n        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }\n",
        "begin_line": 130,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphColoring.GreedyGraphColoring#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphColoring.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
        "signature": "com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring.GreedyGraphColoring(com.google.javascript.jscomp.graph.AdjacencyGraph<N, E>, java.util.Comparator<N>)",
        "snippet": "    public GreedyGraphColoring(\n        AdjacencyGraph<N, E> graph, Comparator<N> tieBreaker) {\n      super(graph);\n      this.tieBreaker = tieBreaker;\n    }\n",
        "begin_line": 124,
        "end_line": 128,
        "comment": "\n     * @param tieBreaker In case of a tie between two nodes of the same degree,\n     *     this comparator will determine which node should be colored first.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphColoring.Color#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphColoring.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
        "signature": "com.google.javascript.jscomp.graph.GraphColoring.Color.Color(int)",
        "snippet": "    Color(int value) {\n      this.value = value;\n    }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphColoring.GraphColoring#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphColoring.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
        "signature": "com.google.javascript.jscomp.graph.GraphColoring.GraphColoring(com.google.javascript.jscomp.graph.AdjacencyGraph<N, E>)",
        "snippet": "  public GraphColoring(AdjacencyGraph<N, E> graph) {\n    this.graph = graph;\n  }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.202
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.addToDebugLog#2141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.addToDebugLog(java.lang.String)",
        "snippet": "  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n",
        "begin_line": 2141,
        "end_line": 2146,
        "comment": " Called from the compiler passes, adds debug info ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2015
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.process#139",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      // For testing, allow the SimpleDefinitionFinder to be build now.\n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }\n",
        "begin_line": 139,
        "end_line": 150,
        "comment": "\n   * Traverses the root, removing all unused variables. Multiple traversals\n   * may occur to ensure all unused variables are removed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1995
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.RemoveUnusedVars#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.RemoveUnusedVars(com.google.javascript.jscomp.AbstractCompiler, boolean, boolean, boolean)",
        "snippet": "  RemoveUnusedVars(\n      AbstractCompiler compiler,\n      boolean removeGlobals,\n      boolean preserveFunctionExpressionNames,\n      boolean modifyCallSites) {\n    this.compiler = compiler;\n    this.codingConvention = compiler.getCodingConvention();\n    this.removeGlobals = removeGlobals;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.modifyCallSites = modifyCallSites;\n  }\n",
        "begin_line": 123,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.198
        },
        "num_failing_tests": 8
    },
    {
        "name": "RemoveUnusedVars.process#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.SimpleDefinitionFinder)",
        "snippet": "  @Override\n  public void process(\n      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }\n",
        "begin_line": 152,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.198
        },
        "num_failing_tests": 8
    },
    {
        "name": "OptimizeArgumentsArray.tryReplaceArguments#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.tryReplaceArguments(com.google.javascript.jscomp.Scope)",
        "snippet": "  private boolean tryReplaceArguments(Scope scope) {\n\n    Node parametersList = scope.getRootNode().getFirstChild().getNext();\n    Preconditions.checkState(parametersList.isParamList());\n\n    // Keep track of rather this function modified the AST and needs to be\n    // reported back to the compiler later.\n    boolean changed = false;\n\n    // Number of parameter that can be accessed without using the arguments\n    // array.\n    int numNamedParameter = parametersList.getChildCount();\n\n    // We want to guess what the highest index that has been access from the\n    // arguments array. We will guess that it does not use anything index higher\n    // than the named parameter list first until we see other wise.\n    int highestIndex = numNamedParameter - 1;\n\n    // Iterate through all the references to arguments array in the function to\n    // determine the real highestIndex.\n    for (Node ref : currentArgumentsAccess) {\n\n      Node getElem = ref.getParent();\n\n      // Bail on anything but argument[c] access where c is a constant.\n      // TODO(user): We might not need to bail out all the time, there might\n      // be more cases that we can cover.\n      if (!getElem.isGetElem()) {\n        return false;\n      }\n\n      Node index = ref.getNext();\n\n      // We have something like arguments[x] where x is not a constant. That\n      // means at least one of the access is not known.\n      if (!index.isNumber()) {\n        // TODO(user): Its possible not to give up just yet. The type\n        // inference did a 'semi value propagation'. If we know that string\n        // is never a subclass of the type of the index. We'd know that\n        // it is never 'callee'.\n        return false; // Give up.\n      }\n\n      Node getElemParent = getElem.getParent();\n      // When we have argument[0](), replacing it with a() is semantically\n      // different if argument[0] is a function call that refers to 'this'\n      if (getElemParent.isCall() &&\n          getElemParent.getFirstChild() == getElem) {\n        // TODO(user): We can consider using .call() if aliasing that\n        // argument allows shorter alias for other arguments.\n        return false;\n      }\n\n      // Replace the highest index if we see an access that has a higher index\n      // than all the one we saw before.\n      int value = (int) index.getDouble();\n      if (value > highestIndex) {\n        highestIndex = value;\n      }\n    }\n\n    // Number of extra arguments we need.\n    // For example: function() { arguments[3] } access index 3 so\n    // it will need 4 extra named arguments to changed into:\n    // function(a,b,c,d) { d }.\n    int numExtraArgs = highestIndex - numNamedParameter + 1;\n\n    // Temporary holds the new names as string for quick access later.\n    String[] argNames = new String[numExtraArgs];\n\n    // Insert the formal parameter to the method's signature.\n    // Example: function() --> function(r0, r1, r2)\n    for (int i = 0; i < numExtraArgs; i++) {\n      String name = getNewName();\n      argNames[i] = name;\n      parametersList.addChildrenToBack(IR.name(name));\n      changed = true;\n    }\n\n    // This loop performs the replacement of arguments[x] -> a if x is known.\n    for (Node ref : currentArgumentsAccess) {\n      Node index = ref.getNext();\n\n      // Skip if it is unknown.\n      if (!index.isNumber()) {\n        continue;\n      }\n      int value = (int) index.getDouble();\n\n      // Unnamed parameter.\n      if (value >= numNamedParameter) {\n        ref.getParent().getParent().replaceChild(ref.getParent(),\n            IR.name(argNames[value - numNamedParameter]));\n      } else {\n\n        // Here, for no apparent reason, the user is accessing a named parameter\n        // with arguments[idx]. We can replace it with the actual name for them.\n        Node name = parametersList.getFirstChild();\n\n        // This is a linear search for the actual name from the signature.\n        // It is not necessary to make this fast because chances are the user\n        // will not deliberately write code like this.\n        for (int i = 0; i < value; i++) {\n          name = name.getNext();\n        }\n        ref.getParent().getParent().replaceChild(ref.getParent(),\n            IR.name(name.getString()));\n      }\n      changed = true;\n    }\n\n    return changed;\n  }\n",
        "begin_line": 177,
        "end_line": 289,
        "comment": "\n   * Tries to optimize all the arguments array access in this scope by assigning\n   * a name to each element.\n   *\n   * @param scope scope of the function\n   * @return true if any modification has been done to the AST\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.198
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.exitScope#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n\n    // Computes the control flow graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, scope.getRootNode());\n    ControlFlowGraph<Node> cfg = cfa.getCfg();\n\n    new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n        .compute(cfg.getEntry().getValue());\n\n    Node root = scope.getRootNode();\n    if (scope.isLocal()) {\n      root = root.getLastChild();\n    }\n    NodeTraversal.traverse(\n        compiler, root, new EliminationPass(cfg));\n  }\n",
        "begin_line": 60,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.visit#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    Preconditions.checkNotNull(traversal);\n    Preconditions.checkNotNull(node);\n\n\n    // Searches for all the references to the arguments array.\n\n    // We don't have an arguments list set up for this scope. This implies we\n    // are currently in the global scope so we will not record any arguments\n    // array access.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Otherwise, we are in a function scope and we should record if the current\n    // name is referring to the implicit arguments array.\n    if (node.isName() && ARGUMENTS.equals(node.getString())) {\n      currentArgumentsAccess.add(node);\n    }\n  }\n",
        "begin_line": 148,
        "end_line": 168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getRootNode#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
        "snippet": "  @Override\n  public Node getRootNode() {\n    return rootNode;\n  }\n",
        "begin_line": 431,
        "end_line": 434,
        "comment": "\n   * Gets the container node of the scope. This is typically the FUNCTION\n   * node or the global BLOCK/SCRIPT node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1929
        },
        "num_failing_tests": 8
    },
    {
        "name": "InlineFunctions.findNamedFunctions#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.FindCandidateFunctions.findNamedFunctions(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isStatement(n)) {\n        // There aren't any interesting functions here.\n        return;\n      }\n\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   var fooFn = function(x) { return ... }\n        case Token.VAR:\n          Preconditions.checkState(n.hasOneChild());\n          Node nameNode = n.getFirstChild();\n          if (nameNode.isName() && nameNode.hasChildren()\n              && nameNode.getFirstChild().isFunction()) {\n            maybeAddFunction(new FunctionVar(n), t.getModule());\n          }\n          break;\n\n        // Named functions\n        // function Foo(x) { return ... }\n        case Token.FUNCTION:\n          Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n              || parent.isLabel());\n          if (!NodeUtil.isFunctionExpression(n)) {\n            Function fn = new NamedFunction(n);\n            maybeAddFunction(fn, t.getModule());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 175,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.IRFactory#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.IRFactory(java.lang.String, com.google.javascript.rhino.jstype.StaticSourceFile, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  private IRFactory(String sourceString,\n                    StaticSourceFile sourceFile,\n                    Config config,\n                    ErrorReporter errorReporter) {\n    this.sourceString = sourceString;\n    this.sourceFile = sourceFile;\n\n    // Sometimes this will be null in tests.\n    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n\n    this.config = config;\n    this.errorReporter = errorReporter;\n    this.transformDispatcher = new TransformDispatcher();\n    // The template node properties are applied to all nodes in this transform.\n    this.templateNode = createTemplateNode();\n\n    switch (config.languageMode) {\n      case ECMASCRIPT3:\n        // Reserved words are handled by the Rhino parser.\n        reservedKeywords = null;\n        break;\n      case ECMASCRIPT5:\n        reservedKeywords = ES5_RESERVED_KEYWORDS;\n        break;\n      case ECMASCRIPT5_STRICT:\n        reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS;\n        break;\n      default:\n        throw new IllegalStateException(\"unknown language mode\");\n    }\n  }\n",
        "begin_line": 137,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1921
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getParserConfig#2022",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
        "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n",
        "begin_line": 2022,
        "end_line": 2047,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1921
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodingConventions.isExported#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.isExported(java.lang.String)",
        "snippet": "    @Override\n    public final boolean isExported(String name) {\n      return isExported(name, false) || isExported(name, true);\n    }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1894
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.getParentNode#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getParentNode()",
        "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Gets the parent of the name node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 8
    },
    {
        "name": "MinimizeExitPoints.visit#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        tryMinimizeExits(\n            n.getLastChild(), Token.BREAK, n.getFirstChild().getString());\n        break;\n\n      case Token.FOR:\n      case Token.WHILE:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n        break;\n\n      case Token.DO:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n\n        Node cond = NodeUtil.getConditionExpression(n);\n        if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {\n          // Normally, we wouldn't be able to optimize BREAKs inside a loop\n          // but as we know the condition will always false, we can treat them\n          // as we would a CONTINUE.\n          tryMinimizeExits(\n              n.getFirstChild(), Token.BREAK, null);\n        }\n        break;\n\n      case Token.FUNCTION:\n        tryMinimizeExits(\n            n.getLastChild(), Token.RETURN, null);\n        break;\n    }\n  }\n",
        "begin_line": 51,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1873
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineFunctions.visit#165",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.FindCandidateFunctions.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((t.inGlobalScope() && inlineGlobalFunctions)\n          || (!t.inGlobalScope() && inlineLocalFunctions)) {\n        findNamedFunctions(t, n, parent);\n\n        findFunctionExpressions(t, n);\n      }\n    }\n",
        "begin_line": 165,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1873
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineFunctions.findFunctionExpressions#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.FindCandidateFunctions.findFunctionExpressions(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "    public void findFunctionExpressions(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   (function(){})();\n        case Token.CALL:\n          Node fnNode = null;\n          if (n.getFirstChild().isFunction()) {\n            fnNode = n.getFirstChild();\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n            if (fnIdentifingNode.isFunction()) {\n              fnNode = fnIdentifingNode;\n            }\n          }\n\n          // If a interesting function was discovered, add it.\n          if (fnNode != null) {\n            Function fn = new FunctionExpression(fnNode, callsSeen++);\n            maybeAddFunction(fn, t.getModule());\n            anonFns.put(fnNode, fn.getName());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 212,
        "end_line": 235,
        "comment": "\n     * Find function expressions that are called directly in the form of\n     *   (function(a,b,...){...})(a,b,...)\n     * or\n     *   (function(a,b,...){...}).call(this,a,b, ...)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1873
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodingConventions.isExported#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.isExported(java.lang.String, boolean)",
        "snippet": "    @Override\n    public boolean isExported(String name, boolean local) {\n      return nextConvention.isExported(name, local);\n    }\n",
        "begin_line": 87,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1869
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodingConventions.isExported#281",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.isExported(java.lang.String, boolean)",
        "snippet": "    @Override\n    public boolean isExported(String name, boolean local) {\n      return local && name.startsWith(\"$super\");\n    }\n",
        "begin_line": 281,
        "end_line": 284,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1869
        },
        "num_failing_tests": 8
    },
    {
        "name": "MinimizeExitPoints.tryMinimizeExits#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.tryMinimizeExits(com.google.javascript.rhino.Node, int, java.lang.String)",
        "snippet": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n",
        "begin_line": 114,
        "end_line": 205,
        "comment": "\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 4
    },
    {
        "name": "MinimizeExitPoints.matchingExitNode#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.matchingExitNode(com.google.javascript.rhino.Node, int, java.lang.String)",
        "snippet": "  static private boolean matchingExitNode(Node n, int type, String labelName) {\n    if (n.getType() == type) {\n      if (type == Token.RETURN) {\n        // only returns without expressions.\n        return !n.hasChildren();\n      } else {\n        if (labelName == null) {\n          return !n.hasChildren();\n        } else {\n          return n.hasChildren()\n            && labelName.equals(n.getFirstChild().getString());\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 284,
        "end_line": 299,
        "comment": "\n   * Determines if n matches the type and name for the following types of\n   * \"exits\":\n   *    - return without values\n   *    - continues and breaks with or without names.\n   * @param n The node to inspect.\n   * @param type The Token type to look for.\n   * @param labelName The name that must be associated with the exit type.\n   * @nullable labelName non-null only for breaks associated with labels.\n   * @return Whether the node matches the specified block-exit type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeGenerator.addList#918",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.addList(com.google.javascript.rhino.Node)",
        "snippet": "  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }\n",
        "begin_line": 918,
        "end_line": 920,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1853
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.addList#926",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.addList(com.google.javascript.rhino.Node, boolean, com.google.javascript.jscomp.CodeGenerator.Context)",
        "snippet": "  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      boolean isFirst = n == firstInList;\n      if (isFirst) {\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n      } else {\n        cc.listSeparator();\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, Context.OTHER);\n      }\n    }\n  }\n",
        "begin_line": 926,
        "end_line": 937,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1826
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isCatch#2189",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCatch()",
        "snippet": "  public boolean isCatch() {\n    return this.getType() == Token.CATCH;\n  }\n",
        "begin_line": 2189,
        "end_line": 2191,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1825
        },
        "num_failing_tests": 7
    },
    {
        "name": "Scope.getName#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getName()",
        "snippet": "    @Override\n    public String getName() {\n      return name;\n    }\n",
        "begin_line": 134,
        "end_line": 137,
        "comment": "\n     * Gets the name of the variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1822
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeChangeHandler.reset#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeChangeHandler.java",
        "class_name": "com.google.javascript.jscomp.CodeChangeHandler",
        "signature": "com.google.javascript.jscomp.CodeChangeHandler.RecentChange.reset()",
        "snippet": "    void reset() {\n      hasChanged = false;\n    }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1818
        },
        "num_failing_tests": 8
    },
    {
        "name": "VoidType.VoidType#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "VoidType.toStringHelper#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 94,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "VoidType.getDisplayName#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/VoidType.java",
        "class_name": "com.google.javascript.rhino.jstype.VoidType",
        "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }\n",
        "begin_line": 99,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ValueType.ValueType#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ValueType.java",
        "class_name": "com.google.javascript.rhino.jstype.ValueType",
        "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnknownType.UnknownType#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(com.google.javascript.rhino.jstype.JSTypeRegistry, boolean)",
        "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.UnionTypeBuilder#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.UnionTypeBuilder#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry, int)",
        "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.addAlternate#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate.isUnionType()) {\n        UnionType union = alternate.toMaybeUnionType();\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Function types are special, because they have their\n        // own bizarre sub-lattice. See the comments on\n        // FunctionType#supAndInf helper and above at functionTypePosition.\n        if (alternate.isFunctionType() && functionTypePosition != -1) {\n          // See the comments on functionTypePosition above.\n          FunctionType other =\n              alternates.get(functionTypePosition).toMaybeFunctionType();\n          FunctionType supremum =\n              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n          alternates.set(functionTypePosition, supremum);\n          result = null;\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        int currentIndex = 0;\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          boolean removeCurrent = false;\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType() ||\n              alternate.hasAnyTemplateTypes() ||\n              current.hasAnyTemplateTypes()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n\n            // Because \"Foo\" and \"Foo.<?>\" are roughly equivalent\n            // parameterized types, special care is needed when building the\n            // union. For example:\n            //   Object is consider a subtype of Object.<string>\n            // but we want to leave \"Object\" not \"Object.<string>\" when\n            // building the subtype.\n            //\n\n            if (alternate.isParameterizedType() || current.isParameterizedType()) {\n              // Cases:\n              // 1) alternate:Array.<string> and current:Object ==> Object\n              // 2) alternate:Array.<string> and current:Array ==> Array\n              // 3) alternate:Object.<string> and\n              //    current:Array ==> Array|Object.<string>\n              // 4) alternate:Object and current:Array.<string> ==> Object\n              // 5) alternate:Array and current:Array.<string> ==> Array\n              // 6) alternate:Array and\n              //    current:Object.<string> ==> Array|Object.<string>\n              // 7) alternate:Array.<string> and\n              //    current:Array.<number> ==> Array.<?>\n              // 8) alternate:Array.<string> and\n              //    current:Array.<string> ==> Array.<string>\n              // 9) alternate:Array.<string> and\n              //    current:Object.<string> ==> Object.<string>|Array.<string>\n\n              if (!current.isParameterizedType()) {\n                if (alternate.isSubtype(current)) {\n                  // case 1, 2\n                  return this;\n                }\n                // case 3: leave current, add alternate\n              } else if (!alternate.isParameterizedType()) {\n                if (current.isSubtype(alternate)) {\n                  // case 4, 5\n                  removeCurrent = true;\n                }\n                // case 6: leave current, add alternate\n              } else {\n                Preconditions.checkState(current.isParameterizedType()\n                    && alternate.isParameterizedType());\n                ParameterizedType parameterizedAlternate = alternate.toMaybeParameterizedType();\n                ParameterizedType parameterizedCurrent = current.toMaybeParameterizedType();\n\n                if (parameterizedCurrent.wrapsSameRawType(parameterizedAlternate)) {\n                  JSType alternateTypeParameter = parameterizedAlternate.getParameterType();\n                  JSType currentTypeParameter = parameterizedCurrent.getParameterType();\n                  if (currentTypeParameter.isEquivalentTo(parameterizedCurrent)) {\n                    // case 8\n                    return this;\n                  } else {\n                    // TODO(johnlenz): should we leave both types?\n                    // case 7: add a merged alternate\n                    // We currently merge to the parameterized types to \"unknown\"\n                    // which is equivalent to the raw type.\n                    JSType merged = parameterizedCurrent\n                        .getReferencedObjTypeInternal();\n                    return addAlternate(merged);\n                  }\n                }\n                // case 9: leave current, add alternate\n              }\n              // Otherwise leave both parameterized types.\n            } else if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              removeCurrent = true;\n            }\n          }\n\n          if (removeCurrent) {\n            it.remove();\n\n            if (currentIndex == functionTypePosition) {\n              functionTypePosition = -1;\n            } else if (currentIndex < functionTypePosition) {\n              functionTypePosition--;\n              currentIndex--;\n            }\n          }\n          currentIndex++;\n        }\n\n        if (alternate.isFunctionType()) {\n          // See the comments on functionTypePosition above.\n          Preconditions.checkState(functionTypePosition == -1);\n          functionTypePosition = alternates.size();\n        }\n\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }\n",
        "begin_line": 120,
        "end_line": 281,
        "comment": "\n   * Adds an alternate to the union type under construction. Returns this\n   * for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion#288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
        "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }\n",
        "begin_line": 288,
        "end_line": 309,
        "comment": "\n   * Reduce the alternates into a non-union type.\n   * If the alternates can't be accurately represented with a non-union\n   * type, return null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.build#316",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
        "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }\n",
        "begin_line": 316,
        "end_line": 324,
        "comment": "\n   * Creates a union.\n   * @return A UnionType if it has two or more alternates, the\n   *    only alternate if it has one and otherwise {@code NO_TYPE}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionTypeBuilder.getAlternateListCopy#326",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
        "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
        "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }\n",
        "begin_line": 326,
        "end_line": 328,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "UnionType.UnionType#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.util.Collection<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }\n",
        "begin_line": 81,
        "end_line": 85,
        "comment": "\n   * Creates a union type.\n   *\n   * @param alternates the alternates of the union\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "StringType.StringType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.StringType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "StringType.toStringHelper#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 90,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "StringType.getDisplayName#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.PrototypeObjectType#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false, null, null);\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "\n   * Creates an object type.\n   *\n   * @param className the name of the class.  May be {@code null} to\n   *        denote an anonymous class.\n   *\n   * @param implicitPrototype the implicit prototype\n   *        (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the\n   *        implicit prototype is {@code null} the implicit prototype will be\n   *        set to the {@link JSTypeNative#OBJECT_TYPE}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.PrototypeObjectType#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.jstype.ObjectType, boolean, com.google.common.collect.ImmutableList<java.lang.String>, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType,\n      ImmutableList<String> templateKeys,\n      ImmutableList<JSType> templatizedTypes) {\n    super(registry, templateKeys, templatizedTypes);\n    this.properties = new PropertyMap();\n    this.properties.setParentSource(this);\n\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }\n",
        "begin_line": 112,
        "end_line": 128,
        "comment": "\n   * Creates an object type, allowing specification of the implicit prototype,\n   * whether the object is native, and any templatized types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.setPrettyPrint#272",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPrettyPrint(boolean)",
        "snippet": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }\n",
        "begin_line": 272,
        "end_line": 274,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.getImplicitPrototype#285",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }\n",
        "begin_line": 285,
        "end_line": 288,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.setImplicitPrototype#296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }\n",
        "begin_line": 296,
        "end_line": 299,
        "comment": "\n   * This should only be reset on the FunctionPrototypeType, only to fix an\n   * incorrectly established prototype chain due to the user having a mismatch\n   * in super class declaration, and only before properties on that type are\n   * processed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.getReferenceName#301",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 301,
        "end_line": 310,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.hasReferenceName#312",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
        "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }\n",
        "begin_line": 312,
        "end_line": 315,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.isSubtype#317",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    } else if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return thatObj != null && isImplicitPrototype(thatObj);\n  }\n",
        "begin_line": 317,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown#366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
        "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }\n",
        "begin_line": 366,
        "end_line": 375,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.hasCachedValues#377",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
        "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }\n",
        "begin_line": 377,
        "end_line": 380,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.isNativeObjectType#383",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
        "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }\n",
        "begin_line": 383,
        "end_line": 386,
        "comment": " Whether this is a built-in object. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.setOwnerFunction#388",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setOwnerFunction(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  @Override\n  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }\n",
        "begin_line": 388,
        "end_line": 392,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.getOwnerFunction#394",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnerFunction()",
        "snippet": "  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }\n",
        "begin_line": 394,
        "end_line": 397,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.getCtorExtendedInterfaces#406",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorExtendedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n",
        "begin_line": 406,
        "end_line": 411,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PropertyMap.PropertyMap#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.PropertyMap()",
        "snippet": "  PropertyMap() {\n    this(Maps.<String, Property>newTreeMap());\n  }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PropertyMap.PropertyMap#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.PropertyMap(java.util.Map<java.lang.String, com.google.javascript.rhino.jstype.Property>)",
        "snippet": "  private PropertyMap(Map<String, Property> underlyingMap) {\n    this.properties = underlyingMap;\n  }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "PropertyMap.setParentSource#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.setParentSource(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  void setParentSource(ObjectType ownerType) {\n    if (this != EMPTY_MAP) {\n      this.parentSource = ownerType;\n    }\n  }\n",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Property.Property#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.Property(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  Property(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n    this.propertyNode = propertyNode;\n  }\n",
        "begin_line": 79,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Property.getType#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getType()",
        "snippet": "  @Override\n      public JSType getType() {\n    return type;\n  }\n",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.ObjectType#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.ObjectType#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.common.collect.ImmutableList<java.lang.String>, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  ObjectType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n      ImmutableList<JSType> templatizedTypes) {\n    super(registry, templateKeys, templatizedTypes);\n  }\n",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.isUnknownType#558",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }\n",
        "begin_line": 558,
        "end_line": 578,
        "comment": "\n   * We treat this as the unknown type if any of its implicit prototype\n   * properties is unknown.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.hasCachedValues#590",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
        "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }\n",
        "begin_line": 590,
        "end_line": 592,
        "comment": "\n   * Returns true if any cached values have been set for this type.  If true,\n   * then the prototype chain should not be changed, as it might invalidate the\n   * cached values.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.isFunctionPrototypeType#614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isFunctionPrototypeType()",
        "snippet": "  @Override\n  public final boolean isFunctionPrototypeType() {\n    return getOwnerFunction() != null;\n  }\n",
        "begin_line": 614,
        "end_line": 617,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NumberType.NumberType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NumberType.toStringHelper#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NumberType.getDisplayName#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NumberType.java",
        "class_name": "com.google.javascript.rhino.jstype.NumberType",
        "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }\n",
        "begin_line": 100,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NullType.NullType#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.NullType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NullType.toStringHelper#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NullType.getDisplayName#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }\n",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NoType.NoType#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoType",
        "signature": "com.google.javascript.rhino.jstype.NoType.NoType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NoType.isNoType#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoType",
        "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
        "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }\n",
        "begin_line": 73,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NoResolvedType.NoResolvedType#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoResolvedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
        "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "NoObjectType.NoObjectType#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }\n",
        "begin_line": 66,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.initializeBuiltInTypes#244",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
        "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    UnknownType checkedUnknownType = new UnknownType(this, true);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, checkedUnknownType);\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true, null, null);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (null,void)\n    JSType NULL_VOID =\n        createUnionType(NULL_TYPE, VOID_TYPE);\n    registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the Unknown type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            UNKNOWN_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }\n",
        "begin_line": 244,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.JSTypeRegistry#203",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(com.google.javascript.rhino.ErrorReporter, boolean)",
        "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }\n",
        "begin_line": 203,
        "end_line": 210,
        "comment": "\n   * Constructs a new type registry populated with the built-in types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.resetForTypeCheck#235",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
        "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }\n",
        "begin_line": 235,
        "end_line": 242,
        "comment": "\n   * Reset to run the TypeCheck pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.initializeRegistry#565",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
        "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }\n",
        "begin_line": 565,
        "end_line": 589,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.register#591",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }\n",
        "begin_line": 591,
        "end_line": 593,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.register#595",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(com.google.javascript.rhino.jstype.JSType, java.lang.String)",
        "snippet": "  private void register(JSType type, String name) {\n    Preconditions.checkArgument(\n        !name.contains(\"<\"), \"Type names cannot contain template annotations.\");\n\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }\n",
        "begin_line": 595,
        "end_line": 606,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.registerNativeType#608",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(com.google.javascript.rhino.jstype.JSTypeNative, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }\n",
        "begin_line": 608,
        "end_line": 610,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.registerPropertyOnType#624",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }\n",
        "begin_line": 624,
        "end_line": 636,
        "comment": "\n   * Tells the type system that {@code owner} may have a property named\n   * {@code propertyName}. This allows the registry to keep track of what\n   * types a property is defined upon.\n   *\n   * This is NOT the same as saying that {@code owner} must have a property\n   * named type. ObjectType#hasProperty attempts to minimize false positives\n   * (\"if we're not sure, then don't type check this property\"). The type\n   * registry, on the other hand, should attempt to minimize false negatives\n   * (\"if this property is assigned anywhere in the program, it must\n   * show up in the type registry\").\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty#638",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }\n",
        "begin_line": 638,
        "end_line": 657,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.getNativeType#890",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }\n",
        "begin_line": 890,
        "end_line": 892,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.getNativeObjectType#894",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }\n",
        "begin_line": 894,
        "end_line": 896,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.getNativeFunctionType#898",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }\n",
        "begin_line": 898,
        "end_line": 900,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createOptionalType#971",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }\n",
        "begin_line": 971,
        "end_line": 977,
        "comment": "\n   * Creates a type representing optional values of the given type.\n   * @return the union of the type and the void type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createUnionType#1015",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1015,
        "end_line": 1021,
        "comment": "\n   * Creates a union type whose variants are the arguments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createArrowType#1051",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }\n",
        "begin_line": 1051,
        "end_line": 1053,
        "comment": "\n   * Creates an arrow type, an abstract representation of the parameters\n   * and return value of a function.\n   *\n   * @param parametersNode the parameters' types, formatted as a Node with\n   *     param names and optionality info.\n   * @param returnType the function's return type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createArrowType#1061",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(com.google.javascript.rhino.Node)",
        "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }\n",
        "begin_line": 1061,
        "end_line": 1063,
        "comment": "\n   * Creates an arrow type with an unknown return type.\n   *\n   * @param parametersNode the parameters' types, formatted as a Node with\n   *     param names and optionality info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createFunctionTypeWithVarArgs#1107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }\n",
        "begin_line": 1107,
        "end_line": 1111,
        "comment": "\n   * Creates a function type. The last parameter type of the function is\n   * considered a variable length argument.\n   *\n   * @param returnType the function's return type\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createNativeFunctionTypeWithVarArgs#1120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionTypeWithVarArgs(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  private FunctionType createNativeFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createNativeFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }\n",
        "begin_line": 1120,
        "end_line": 1124,
        "comment": "\n   * Creates a function type. The last parameter type of the function is\n   * considered a variable length argument.\n   *\n   * @param returnType the function's return type\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createParametersWithVarArgs#1228",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }\n",
        "begin_line": 1228,
        "end_line": 1230,
        "comment": "\n   * Creates a tree hierarchy representing a typed argument list. The last\n   * parameter type is considered a variable length argument.\n   *\n   * @param parameterTypes the parameter types. The last element of this array\n   *     is considered a variable length argument.\n   * @return a tree hierarchy representing a typed argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createOptionalParameters#1236",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }\n",
        "begin_line": 1236,
        "end_line": 1240,
        "comment": "\n   * Creates a tree hierarchy representing a typed parameter list in which\n   * every parameter is optional.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createParameters#1252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1252,
        "end_line": 1263,
        "comment": "\n   * Creates a tree hierarchy representing a typed argument list.\n   *\n   * @param lastVarArgs whether the last type should considered as a variable\n   *     length argument.\n   * @param parameterTypes the parameter types. The last element of this array\n   *     is considered a variable length argument is {@code lastVarArgs} is\n   *     {@code true}.\n   * @return a tree hierarchy representing a typed argument list\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createFunctionType#1272",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }\n",
        "begin_line": 1272,
        "end_line": 1279,
        "comment": "\n   * Creates a function type.\n   * @param returnType the function's return type\n   * @param lastVarArgs whether the last parameter type should be considered as\n   * an extensible var_args parameter\n   * @param parameterTypes the parameters' types\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createFunctionType#1315",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }\n",
        "begin_line": 1315,
        "end_line": 1321,
        "comment": "\n   * @param parameters the function's parameters or {@code null}\n   *        to indicate that the parameter types are unknown.\n   * @param returnType the function's return type or {@code null} to indicate\n   *        that the return type is unknown.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSTypeRegistry.createNativeFunctionType#1323",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNativeFunctionType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  private FunctionType createNativeFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .forNativeType()\n        .build();\n  }\n",
        "begin_line": 1323,
        "end_line": 1330,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.JSType#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.JSType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  JSType(JSTypeRegistry registry) {\n    this(registry, null, null);\n  }\n",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.JSType#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.JSType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.common.collect.ImmutableList<java.lang.String>, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  JSType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n      ImmutableList<JSType> templatizedTypes) {\n    this.registry = registry;\n\n    // Do sanity checking on the specified keys and templatized types.\n    int keysLength = templateKeys == null ? 0 : templateKeys.size();\n    int typesLength = templatizedTypes == null ? 0 : templatizedTypes.size();\n    if (typesLength > keysLength) {\n      throw new IllegalArgumentException(\n          \"Cannot have more templatized types than template keys\");\n    } else if (typesLength < keysLength) {\n      // If there are fewer templatized types than keys, extend the templatized\n      // types list to match the number of keys, using UNKNOWN_TYPE for the\n      // unspecified types.\n      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n      if (typesLength > 0) {\n        builder.addAll(templatizedTypes);\n      }\n      for (int i = 0; i < keysLength - typesLength; i++) {\n        builder.add(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n      }\n      templatizedTypes = builder.build();\n    } else if (keysLength == 0 && typesLength == 0) {\n      // Ensure that both lists are non-null.\n      templateKeys = ImmutableList.of();\n      templatizedTypes = ImmutableList.of();\n    }\n\n    this.templateKeys = templateKeys;\n    this.templatizedTypes = templatizedTypes;\n  }\n",
        "begin_line": 114,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.getNativeType#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n   * Utility method for less verbose code.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isNoType#188",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
        "snippet": "  public boolean isNoType() {\n    return false;\n  }\n",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isNoResolvedType#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
        "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }\n",
        "begin_line": 192,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isNoObjectType#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
        "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }\n",
        "begin_line": 196,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isEmptyType#200",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
        "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }\n",
        "begin_line": 200,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isAllType#277",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
        "snippet": "  public boolean isAllType() {\n    return false;\n  }\n",
        "begin_line": 277,
        "end_line": 279,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isUnknownType#281",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
        "snippet": "  public boolean isUnknownType() {\n    return false;\n  }\n",
        "begin_line": 281,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isUnionType#289",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isUnionType()",
        "snippet": "  public final boolean isUnionType() {\n    return toMaybeUnionType() != null;\n  }\n",
        "begin_line": 289,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toMaybeUnionType#348",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeUnionType()",
        "snippet": "  public UnionType toMaybeUnionType() {\n    return null;\n  }\n",
        "begin_line": 348,
        "end_line": 350,
        "comment": "\n   * Downcasts this to a UnionType, or returns null if this is not a UnionType.\n   *\n   * Named in honor of Haskell's Maybe type constructor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isFunctionType#358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionType()",
        "snippet": "  public final boolean isFunctionType() {\n    return toMaybeFunctionType() != null;\n  }\n",
        "begin_line": 358,
        "end_line": 360,
        "comment": " Returns true if toMaybeFunctionType returns a non-null FunctionType. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toMaybeFunctionType#374",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType()",
        "snippet": "  public FunctionType toMaybeFunctionType() {\n    return null;\n  }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": "\n   * Downcasts this to a FunctionType, or returns null if this is not\n   * a function.\n   *\n   * For the purposes of this function, we define a MaybeFunctionType as any\n   * type in the sub-lattice\n   * { x | LEAST_FUNCTION_TYPE <= x <= GREATEST_FUNCTION_TYPE }\n   * This definition excludes bottom types like NoType and NoObjectType.\n   *\n   * This definition is somewhat arbitrary and axiomatic, but this is the\n   * definition that makes the most sense for the most callers.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isRecordType#411",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isRecordType()",
        "snippet": "  public boolean isRecordType() {\n    return toMaybeRecordType() != null;\n  }\n",
        "begin_line": 411,
        "end_line": 413,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toMaybeRecordType#419",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeRecordType()",
        "snippet": "  RecordType toMaybeRecordType() {\n    return null;\n  }\n",
        "begin_line": 419,
        "end_line": 421,
        "comment": "\n   * Downcasts this to a RecordType, or returns null if this is not\n   * a RecordType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isParameterizedType#423",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isParameterizedType()",
        "snippet": "  public final boolean isParameterizedType() {\n    return toMaybeParameterizedType() != null;\n  }\n",
        "begin_line": 423,
        "end_line": 425,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toMaybeParameterizedType#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeParameterizedType()",
        "snippet": "  public ParameterizedType toMaybeParameterizedType() {\n    return null;\n  }\n",
        "begin_line": 431,
        "end_line": 433,
        "comment": "\n   * Downcasts this to a ParameterizedType, or returns null if this is not\n   * a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.hasAnyTemplateTypes#461",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplateTypes()",
        "snippet": "  public boolean hasAnyTemplateTypes() {\n    if (!this.inTemplatedCheckVisit) {\n      this.inTemplatedCheckVisit = true;\n      boolean result = hasAnyTemplateTypesInternal();\n      this.inTemplatedCheckVisit = false;\n      return result;\n    } else {\n      // prevent infinite recursion, this is \"not yet\".\n      return false;\n    }\n  }\n",
        "begin_line": 461,
        "end_line": 471,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.hasAnyTemplateTypesInternal#473",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hasAnyTemplateTypesInternal()",
        "snippet": "  boolean hasAnyTemplateTypesInternal() {\n    if (isTemplatized()) {\n      for (JSType templatizedType : templatizedTypes) {\n        if (templatizedType.hasAnyTemplateTypes()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 473,
        "end_line": 482,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isTemplatized#487",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isTemplatized()",
        "snippet": "  public boolean isTemplatized() {\n    return !templateKeys.isEmpty();\n  }\n",
        "begin_line": 487,
        "end_line": 489,
        "comment": "\n   * Returns true if this type is templatized; false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.getTemplateKeys#494",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getTemplateKeys()",
        "snippet": "  public ImmutableList<String> getTemplateKeys() {\n    return templateKeys;\n  }\n",
        "begin_line": 494,
        "end_line": 496,
        "comment": "\n   * Returns the template keys associated with this type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.getTemplatizedTypes#498",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.getTemplatizedTypes()",
        "snippet": "  public ImmutableList<JSType> getTemplatizedTypes() {\n    return templatizedTypes;\n  }\n",
        "begin_line": 498,
        "end_line": 500,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isNominalType#570",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
        "snippet": "  public boolean isNominalType() {\n    return false;\n  }\n",
        "begin_line": 570,
        "end_line": 572,
        "comment": "\n   * Whether this type is a nominal type (a named instance object or\n   * a named enum).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isEquivalentTo#625",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public final boolean isEquivalentTo(JSType that) {\n    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);\n  }\n",
        "begin_line": 625,
        "end_line": 627,
        "comment": "\n   * Checks if two types are equivalent.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.checkEquivalenceHelper#654",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.checkEquivalenceHelper(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {\n    if (this == that) {\n      return true;\n    }\n\n    boolean thisUnknown = isUnknownType();\n    boolean thatUnknown = that.isUnknownType();\n    if (thisUnknown || thatUnknown) {\n      if (eqMethod == EquivalenceMethod.INVARIANT) {\n        // If we're checking for invariance, the unknown type is invariant\n        // with everyone.\n        return true;\n      } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {\n        // If we're checking data flow, then two types are the same if they're\n        // both unknown.\n        return thisUnknown && thatUnknown;\n      } else if (thisUnknown && thatUnknown &&\n          (isNominalType() ^ that.isNominalType())) {\n        // If they're both unknown, but one is a nominal type and the other\n        // is not, then we should fail out immediately. This ensures that\n        // we won't unbox the unknowns further down.\n        return false;\n      }\n    }\n\n    if (isUnionType() && that.isUnionType()) {\n      return toMaybeUnionType().checkUnionEquivalenceHelper(\n          that.toMaybeUnionType(), eqMethod);\n    }\n\n    if (isFunctionType() && that.isFunctionType()) {\n      return toMaybeFunctionType().checkFunctionEquivalenceHelper(\n          that.toMaybeFunctionType(), eqMethod);\n    }\n\n    if (isRecordType() && that.isRecordType()) {\n      return toMaybeRecordType().checkRecordEquivalenceHelper(\n          that.toMaybeRecordType(), eqMethod);\n    }\n\n    ParameterizedType thisParamType = toMaybeParameterizedType();\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\n    if (thisParamType != null || thatParamType != null) {\n      // Check if one type is parameterized, but the other is not.\n      boolean paramsMatch = false;\n      if (thisParamType != null && thatParamType != null) {\n        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n            thatParamType.getParameterType(), eqMethod);\n      } else if (eqMethod == EquivalenceMethod.IDENTITY) {\n        paramsMatch = false;\n      } else {\n        // If one of the type parameters is unknown, but the other is not,\n        // then we consider these the same for the purposes of data flow\n        // and invariance.\n        paramsMatch = true;\n      }\n\n      JSType thisRootType = thisParamType == null ?\n          this : thisParamType.getReferencedTypeInternal();\n      JSType thatRootType = thatParamType == null ?\n          that : thatParamType.getReferencedTypeInternal();\n      return paramsMatch &&\n          thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);\n    }\n\n    if (isNominalType() && that.isNominalType()) {\n      return toObjectType().getReferenceName().equals(\n          that.toObjectType().getReferenceName());\n    }\n\n    // Unbox other proxies.\n    if (this instanceof ProxyObjectType) {\n      return ((ProxyObjectType) this)\n          .getReferencedTypeInternal().checkEquivalenceHelper(\n              that, eqMethod);\n    }\n\n    if (that instanceof ProxyObjectType) {\n      return checkEquivalenceHelper(\n          ((ProxyObjectType) that).getReferencedTypeInternal(),\n          eqMethod);\n    }\n\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == that;\n  }\n",
        "begin_line": 654,
        "end_line": 742,
        "comment": "\n   * An equivalence visitor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.hashCode#755",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }\n",
        "begin_line": 755,
        "end_line": 758,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toObjectType#875",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
        "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }\n",
        "begin_line": 875,
        "end_line": 877,
        "comment": "\n   * Casts this to an ObjectType, or returns null if this is not an ObjectType.\n   * If this is a scalar type, it will *not* be converted to an object type.\n   * If you want to simulate JS autoboxing or dereferencing, you should use\n   * autoboxesTo() or dereference().\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isSubtype#1332",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean isSubtype(JSType that) {\n    return isSubtypeHelper(this, that);\n  }\n",
        "begin_line": 1332,
        "end_line": 1334,
        "comment": "\n   * Checks whether {@code this} is a subtype of {@code that}.<p>\n   *\n   * Subtyping rules:\n   * <ul>\n   * <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li>\n   * <li>(no) &mdash; the No type is a subtype of every type.</li>\n   * <li>(no-object) &mdash; the NoObject type is a subtype of every object\n   * type (i.e. subtypes of the Object type).</li>\n   * <li>(ref) &mdash; a type is a subtype of itself.</li>\n   * <li>(union-l) &mdash; A union type is a subtype of a type U if all the\n   * union type's constituents are a subtype of U. Formally<br>\n   * {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only\n   * {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li>\n   * <li>(union-r) &mdash; A type U is a subtype of a union type if it is a\n   * subtype of one of the union type's constituents. Formally<br>\n   * {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only\n   * if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li>\n   * <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype\n   * of an object {@code O<sub>2</sub>} if it has more properties\n   * than {@code O<sub>2</sub>} and all common properties are\n   * pairwise subtypes.</li>\n   * </ul>\n   *\n   * @return {@code this &lt;: that}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.isSubtypeHelper#1340",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isSubtypeHelper(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  static boolean isSubtypeHelper(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // unions\n    if (thatType.isUnionType()) {\n      UnionType union = thatType.toMaybeUnionType();\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // parameterized types.\n    if (thisType.isParameterizedType()) {\n      return thisType.toMaybeParameterizedType().isParameterizeSubtypeOf(\n          thatType);\n    }\n\n    // proxy types\n    if (thatType instanceof ProxyObjectType) {\n      return thisType.isSubtype(\n          ((ProxyObjectType) thatType).getReferencedTypeInternal());\n    }\n    return false;\n  }\n",
        "begin_line": 1340,
        "end_line": 1376,
        "comment": "\n   * A generic implementation meant to be used as a helper for common subtyping\n   * cases.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSType.toString#1488",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return toStringHelper(false);\n  }\n",
        "begin_line": 1488,
        "end_line": 1491,
        "comment": "\n   * A string representation of this type, suitable for printing\n   * in warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.InstanceObjectType#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.FunctionType, boolean, com.google.common.collect.ImmutableList<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType,\n                     ImmutableList<JSType> templatizedTypes) {\n    super(registry, null, null, isNativeType, constructor.getTemplateKeys(),\n        templatizedTypes);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }\n",
        "begin_line": 60,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.getReferenceName#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
        "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }\n",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.hasReferenceName#74",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
        "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }\n",
        "begin_line": 74,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.getImplicitPrototype#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }\n",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.getConstructor#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
        "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.toStringHelper#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (constructor.hasReferenceName()) {\n      String typeString = constructor.getReferenceName();\n\n      ImmutableList<JSType> templatizedTypes = getTemplatizedTypes();\n      if (!templatizedTypes.isEmpty()) {\n        typeString += \".<\" + Joiner.on(\",\").join(templatizedTypes) + \">\";\n      }\n\n      return typeString;\n    } else {\n      return super.toStringHelper(forAnnotations);\n    }\n  }\n",
        "begin_line": 99,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.isNominalType#162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
        "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }\n",
        "begin_line": 162,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.hashCode#171",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }\n",
        "begin_line": 171,
        "end_line": 178,
        "comment": "\n   * If this is equal to a NamedType object, its hashCode must be equal\n   * to the hashCode of the NamedType object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "InstanceObjectType.getCtorExtendedInterfaces#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }\n",
        "begin_line": 185,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.FunctionType#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.JSType, com.google.common.collect.ImmutableList<java.lang.String>, boolean, boolean)",
        "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n               ArrowType arrowType, JSType typeOfThis,\n               ImmutableList<String> templateKeys,\n               boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType, templateKeys, null);\n    setPrettyPrint(true);\n\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    if (isConstructor) {\n      this.kind = Kind.CONSTRUCTOR;\n      this.propAccess = PropAccess.ANY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType, null);\n    } else {\n      this.kind = Kind.ORDINARY;\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n  }\n",
        "begin_line": 134,
        "end_line": 159,
        "comment": " Creates an instance for a function that might be a constructor. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.isConstructor#189",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
        "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }\n",
        "begin_line": 189,
        "end_line": 192,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.isInterface#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
        "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }\n",
        "begin_line": 194,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.toMaybeFunctionType#252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.toMaybeFunctionType()",
        "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return this;\n  }\n",
        "begin_line": 252,
        "end_line": 255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.getInternalArrowType#329",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
        "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }\n",
        "begin_line": 329,
        "end_line": 331,
        "comment": " Gets the internal arrow type. For use by subclasses only. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.getPrototype#363",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
        "snippet": "  public ObjectType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototypeSlot == null) {\n      String refName = getReferenceName();\n      if (refName == null) {\n        // Someone is trying to access the prototype of a structural function.\n        // We don't want to give real properties to this prototype, because\n        // then it would propagate to all structural functions.\n        setPrototypeNoCheck(\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),\n           null);\n      } else {\n        setPrototype(\n            new PrototypeObjectType(\n                registry,\n                getReferenceName() + \".prototype\",\n                registry.getNativeObjectType(OBJECT_TYPE),\n                isNativeObjectType(), null, null),\n            null);\n      }\n    }\n    return (ObjectType) prototypeSlot.getType();\n  }\n",
        "begin_line": 363,
        "end_line": 385,
        "comment": "\n   * Gets the {@code prototype} property of this function type. This is\n   * equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.setPrototypeBasedOn#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    setPrototypeBasedOn(baseType, null);\n  }\n",
        "begin_line": 392,
        "end_line": 394,
        "comment": "\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.setPrototypeBasedOn#396",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n      baseType = new PrototypeObjectType(\n          registry, getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype(baseType, propertyNode);\n  }\n",
        "begin_line": 396,
        "end_line": 421,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.setPrototype#428",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  boolean setPrototype(ObjectType prototype, Node propertyNode) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n    return setPrototypeNoCheck(prototype, propertyNode);\n  }\n",
        "begin_line": 428,
        "end_line": 437,
        "comment": "\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.setPrototypeNoCheck#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeNoCheck(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.Node)",
        "snippet": "  private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) {\n    ObjectType oldPrototype = prototypeSlot == null\n        ? null : (ObjectType) prototypeSlot.getType();\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n        propertyNode == null ? source : propertyNode);\n    prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
        "begin_line": 440,
        "end_line": 475,
        "comment": " Set the prototype without doing any sanity checks. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.getExtendedInterfaces#566",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }\n",
        "begin_line": 566,
        "end_line": 568,
        "comment": " Returns interfaces directly extended by an interface ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.getSuperClassConstructor#831",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
        "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }\n",
        "begin_line": 831,
        "end_line": 838,
        "comment": "\n   * Given a constructor or an interface type, get its superclass constructor\n   * or {@code null} if none exists.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.getInstanceType#1061",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
        "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis.toObjectType();\n  }\n",
        "begin_line": 1061,
        "end_line": 1064,
        "comment": "\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.setInstanceType#1070",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }\n",
        "begin_line": 1070,
        "end_line": 1072,
        "comment": "\n   * Sets the instance type. This should only be used for special\n   * native types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.hasInstanceType#1077",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
        "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }\n",
        "begin_line": 1077,
        "end_line": 1079,
        "comment": "\n   * Returns whether this function type has an instance type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.addSubType#1116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }\n",
        "begin_line": 1116,
        "end_line": 1121,
        "comment": " Adds a type to the list of subtypes for this type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionType.hasCachedValues#1153",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
        "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototypeSlot != null || super.hasCachedValues();\n  }\n",
        "begin_line": 1153,
        "end_line": 1156,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.FunctionParamBuilder#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.addRequiredParams#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }\n",
        "begin_line": 62,
        "end_line": 71,
        "comment": "\n   * Add parameters of the given type to the end of the param list.\n   * @return False if this is called after optional params are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.addOptionalParams#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(com.google.javascript.rhino.jstype.JSType...)",
        "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }\n",
        "begin_line": 79,
        "end_line": 88,
        "comment": "\n   * Add optional parameters of the given type to the end of the param list.\n   * @param types Types for each optional parameter. The builder will make them\n   *     undefine-able.\n   * @return False if this is called after var args are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.addVarArgs#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }\n",
        "begin_line": 94,
        "end_line": 109,
        "comment": "\n   * Add variable arguments to the end of the parameter list.\n   * @return False if this is called after var args are added.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.newParameter#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }\n",
        "begin_line": 134,
        "end_line": 139,
        "comment": " Add a parameter to the list with the given type.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.build#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
        "snippet": "  public Node build() {\n    return root;\n  }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.hasOptionalOrVarArgs#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
        "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }\n",
        "begin_line": 145,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionParamBuilder.hasVarArgs#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
        "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }\n",
        "begin_line": 151,
        "end_line": 154,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionBuilder.FunctionBuilder#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionBuilder.withParamsNode#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }\n",
        "begin_line": 90,
        "end_line": 93,
        "comment": "\n   * Set the parameters of the function type with a specially-formatted node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionBuilder.withReturnType#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }\n",
        "begin_line": 96,
        "end_line": 99,
        "comment": " Set the return type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionBuilder.forNativeType#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.forNativeType()",
        "snippet": "  FunctionBuilder forNativeType() {\n    this.isNativeType = true;\n    return this;\n  }\n",
        "begin_line": 141,
        "end_line": 144,
        "comment": " Make this a native type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "FunctionBuilder.build#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
        "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateKeys, isConstructor, isNativeType);\n  }\n",
        "begin_line": 160,
        "end_line": 164,
        "comment": " Construct a new function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ErrorFunctionType.ErrorFunctionType#50",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ErrorFunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
        "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String)",
        "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }\n",
        "begin_line": 50,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "BooleanType.BooleanType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "BooleanType.toStringHelper#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.toStringHelper(boolean)",
        "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }\n",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "BooleanType.getDisplayName#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/BooleanType.java",
        "class_name": "com.google.javascript.rhino.jstype.BooleanType",
        "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
        "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ArrowType.ArrowType#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }\n",
        "begin_line": 62,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "ArrowType.ArrowType#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }\n",
        "begin_line": 67,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "AllType.AllType#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.AllType(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "AllType.isAllType#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
        "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setJSType#1812",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setJSType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }\n",
        "begin_line": 1812,
        "end_line": 1814,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setVarArgs#1867",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
        "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }\n",
        "begin_line": 1867,
        "end_line": 1869,
        "comment": "\n   * Sets whether this node is a variable length argument node. This\n   * method is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setOptionalArg#1885",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
        "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }\n",
        "begin_line": 1885,
        "end_line": 1887,
        "comment": "\n   * Sets whether this node is an optional argument node. This\n   * method is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getTypeRegistry#1184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
        "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n",
        "begin_line": 1184,
        "end_line": 1190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.18
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.endLine#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endLine()",
        "snippet": "  void endLine() {\n  }\n",
        "begin_line": 94,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1782
        },
        "num_failing_tests": 8
    },
    {
        "name": "PeepholeRemoveDeadCode.tryOptimizeBlock#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryOptimizeBlock(com.google.javascript.rhino.Node)",
        "snippet": "  Node tryOptimizeBlock(Node n) {\n    // Remove any useless children\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // save c.next, since 'c' may be removed\n      if (!isUnremovableNode(c) && !mayHaveSideEffects(c)) {\n        // TODO(johnlenz): determine what this is actually removing. Candidates\n        //    include: EMPTY nodes, control structures without children\n        //    (removing infinite loops), empty try blocks.  What else?\n        n.removeChild(c);  // lazy kids\n        reportCodeChange();\n      } else {\n        tryOptimizeConditionalAfterAssign(c);\n      }\n      c = next;\n    }\n\n    if (n.isSyntheticBlock() ||  n.getParent() == null) {\n      return n;\n    }\n\n    // Try to remove the block.\n    if (NodeUtil.tryMergeBlock(n)) {\n      reportCodeChange();\n      return null;\n    }\n\n    return n;\n  }\n",
        "begin_line": 509,
        "end_line": 536,
        "comment": "\n   * Try removing unneeded block nodes and their useless children\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.tryMergeBlock#1870",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.tryMergeBlock(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean tryMergeBlock(Node block) {\n    Preconditions.checkState(block.isBlock());\n    Node parent = block.getParent();\n    // Try to remove the block if its parent is a block/script or if its\n    // parent is label and it has exactly one child.\n    if (isStatementBlock(parent)) {\n      Node previous = block;\n      while (block.hasChildren()) {\n        Node child = block.removeFirstChild();\n        parent.addChildAfter(child, previous);\n        previous = child;\n      }\n      parent.removeChild(block);\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 1870,
        "end_line": 1887,
        "comment": "\n   * Merge a block with its parent block.\n   * @return Whether the block was removed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 4
    },
    {
        "name": "TernaryValue.toBoolean#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TernaryValue.java",
        "class_name": "com.google.javascript.rhino.jstype.TernaryValue",
        "signature": "com.google.javascript.rhino.jstype.TernaryValue.toBoolean(boolean)",
        "snippet": "    @Override\n    public boolean toBoolean(boolean unknown) {\n      return false;\n    }\n",
        "begin_line": 81,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.transformTokenType#1239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
        "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.rhino.head.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.rhino.head.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.rhino.head.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.rhino.head.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.rhino.head.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.rhino.head.Token.NE:\n        return Token.NE;\n      case com.google.javascript.rhino.head.Token.LT:\n        return Token.LT;\n      case com.google.javascript.rhino.head.Token.LE:\n        return Token.LE;\n      case com.google.javascript.rhino.head.Token.GT:\n        return Token.GT;\n      case com.google.javascript.rhino.head.Token.GE:\n        return Token.GE;\n      case com.google.javascript.rhino.head.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.rhino.head.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.rhino.head.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.rhino.head.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.rhino.head.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.rhino.head.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.rhino.head.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.rhino.head.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.rhino.head.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.rhino.head.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.rhino.head.Token.POS:\n        return Token.POS;\n      case com.google.javascript.rhino.head.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.rhino.head.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.rhino.head.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.rhino.head.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.rhino.head.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.rhino.head.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.rhino.head.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.rhino.head.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.rhino.head.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.rhino.head.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.rhino.head.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.rhino.head.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.rhino.head.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.rhino.head.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.rhino.head.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.rhino.head.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.rhino.head.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.rhino.head.Token.IN:\n        return Token.IN;\n      case com.google.javascript.rhino.head.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.rhino.head.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.rhino.head.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.rhino.head.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.rhino.head.Token.LP:\n        return Token.PARAM_LIST;\n      case com.google.javascript.rhino.head.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.rhino.head.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.rhino.head.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.rhino.head.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.rhino.head.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.rhino.head.Token.OR:\n        return Token.OR;\n      case com.google.javascript.rhino.head.Token.AND:\n        return Token.AND;\n      case com.google.javascript.rhino.head.Token.INC:\n        return Token.INC;\n      case com.google.javascript.rhino.head.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.rhino.head.Token.IF:\n        return Token.IF;\n      case com.google.javascript.rhino.head.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.rhino.head.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.rhino.head.Token.DEFAULT:\n        return Token.DEFAULT_CASE;\n      case com.google.javascript.rhino.head.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.rhino.head.Token.DO:\n        return Token.DO;\n      case com.google.javascript.rhino.head.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.rhino.head.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.rhino.head.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.rhino.head.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.rhino.head.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.rhino.head.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.rhino.head.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.rhino.head.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.rhino.head.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.rhino.head.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.rhino.head.Token.EXPR_VOID:\n      case com.google.javascript.rhino.head.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.rhino.head.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.rhino.head.Token.GET:\n        return Token.GETTER_DEF;\n      case com.google.javascript.rhino.head.Token.SET:\n        return Token.SETTER_DEF;\n      case com.google.javascript.rhino.head.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.rhino.head.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }\n",
        "begin_line": 1239,
        "end_line": 1419,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 8
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.isLowerPrecedenceInExpression#1072",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isLowerPrecedenceInExpression(com.google.javascript.rhino.Node, int)",
        "snippet": "  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return NodeUtil.precedence(input.getType()) < precedence;\n      }\n    };\n\n    return NodeUtil.has(n, isLowerPrecedencePredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }\n",
        "begin_line": 1072,
        "end_line": 1083,
        "comment": "\n   * Does the expression contain an operator with lower precedence than\n   * the argument?\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.apply#1075",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.Anonymous-458a6ff6-12dd-4185-93b6-05e92920d064.apply(com.google.javascript.rhino.Node)",
        "snippet": "      @Override\n      public boolean apply(Node input) {\n        return NodeUtil.precedence(input.getType()) < precedence;\n      }\n",
        "begin_line": 1075,
        "end_line": 1078,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.apply#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.Anonymous-3a9ad280-9c4a-4518-a17e-8632b13af21c.apply(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean apply(Node input) {\n      return !input.isFunction();\n    }\n",
        "begin_line": 58,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryReplaceIf#306",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReplaceIf(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryReplaceIf(Node n) {\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()){\n      if (child.isIf()){\n        Node cond = child.getFirstChild();\n        Node thenBranch = cond.getNext();\n        Node elseBranch = thenBranch.getNext();\n        Node nextNode = child.getNext();\n\n        if (nextNode != null && elseBranch == null\n            && isReturnBlock(thenBranch)\n            && nextNode.isIf()) {\n          Node nextCond = nextNode.getFirstChild();\n          Node nextThen = nextCond.getNext();\n          Node nextElse = nextThen.getNext();\n          if (thenBranch.isEquivalentToTyped(nextThen)) {\n            // Transform\n            //   if (x) return 1; if (y) return 1;\n            // to\n            //   if (x||y) return 1;\n            child.detachFromParent();\n            child.detachChildren();\n            Node newCond = new Node(Token.OR, cond);\n            nextNode.replaceChild(nextCond, newCond);\n            newCond.addChildToBack(nextCond);\n            reportCodeChange();\n          } else if (nextElse != null\n              && thenBranch.isEquivalentToTyped(nextElse)) {\n            // Transform\n            //   if (x) return 1; if (y) foo() else return 1;\n            // to\n            //   if (!x&&y) foo() else return 1;\n            child.detachFromParent();\n            child.detachChildren();\n            Node newCond = new Node(Token.AND,\n                IR.not(cond).srcref(cond));\n            nextNode.replaceChild(nextCond, newCond);\n            newCond.addChildToBack(nextCond);\n            reportCodeChange();\n          }\n        } else if (nextNode != null && elseBranch == null &&\n            isReturnBlock(thenBranch) && isReturnExpression(nextNode)) {\n          Node thenExpr = null;\n          // if(x)return; return 1 -> return x?void 0:1\n          if (isReturnExpressBlock(thenBranch)) {\n            thenExpr = getBlockReturnExpression(thenBranch);\n            thenExpr.detachFromParent();\n          } else {\n            thenExpr = NodeUtil.newUndefinedNode(child);\n          }\n\n          Node elseExpr = nextNode.getFirstChild();\n\n          cond.detachFromParent();\n          elseExpr.detachFromParent();\n\n          Node returnNode = IR.returnNode(\n                                IR.hook(cond, thenExpr, elseExpr)\n                                    .srcref(child));\n          n.replaceChild(child, returnNode);\n          n.removeChild(nextNode);\n          reportCodeChange();\n        } else if (elseBranch != null && statementMustExitParent(thenBranch)) {\n          child.removeChild(elseBranch);\n          n.addChildAfter(elseBranch, child);\n          reportCodeChange();\n        }\n      }\n    }\n    return n;\n  }\n",
        "begin_line": 306,
        "end_line": 377,
        "comment": "\n   * Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\"\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.getBlockExpression#962",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.getBlockExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private Node getBlockExpression(Node n) {\n    Preconditions.checkState(isFoldableExpressBlock(n));\n    return n.getFirstChild();\n  }\n",
        "begin_line": 962,
        "end_line": 965,
        "comment": "\n   * @return The expression node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryMinimizeCondition#1129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryMinimizeCondition(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryMinimizeCondition(Node n) {\n    Node parent = n.getParent();\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // NOT children are handled below.\n              return newRoot;\n            }\n          case Token.AND:\n          case Token.OR: {\n              // !(!x && !y) --> x || y\n              // !(!x || !y) --> x && y\n              // !(!x && y) --> x || !y\n              // !(!x || y) --> x && !y\n              // !(x && !y) --> !x || y\n              // !(x || !y) --> !x && y\n              // !(x && y) --> !x || !y\n              // !(x || y) --> !x && !y\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              Node left, right;\n\n              // Check special case when such transformation cannot reduce\n              // due to the added ()\n              // It only occurs when both of expressions are not NOT expressions\n              if (!leftParent.isNot()\n                  && !rightParent.isNot()) {\n                // If an expression has higher precedence than && or ||,\n                // but lower precedence than NOT, an additional () is needed\n                // Thus we do not preceed\n                int op_precedence = NodeUtil.precedence(first.getType());\n                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(leftParent, op_precedence))\n                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(rightParent, op_precedence))) {\n                  return n;\n                }\n              }\n\n              if (leftParent.isNot()) {\n                left = leftParent.removeFirstChild();\n              } else {\n                leftParent.detachFromParent();\n                left = IR.not(leftParent).srcref(leftParent);\n              }\n              if (rightParent.isNot()) {\n                right = rightParent.removeFirstChild();\n              } else {\n                rightParent.detachFromParent();\n                right = IR.not(rightParent).srcref(rightParent);\n              }\n\n              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // AND and OR children below.\n              return newRoot;\n            }\n\n           default:\n             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n             if (nVal != TernaryValue.UNKNOWN) {\n               boolean result = nVal.not().toBoolean(true);\n               int equivalentResult = result ? 1 : 0;\n               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n        }\n        // No need to traverse, tryMinimizeCondition is called on the NOT\n        // children in the general case in the main post-order traversal.\n        return n;\n\n      case Token.OR:\n      case Token.AND: {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the children, this can't be done in the general case.\n        left = tryMinimizeCondition(left);\n        right = tryMinimizeCondition(right);\n\n        // Remove useless conditionals\n        // Handle four cases:\n        //   x || false --> x\n        //   x || true  --> true\n        //   x && true --> x\n        //   x && false  --> false\n        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n          int type = n.getType();\n          Node replacement = null;\n          boolean rval = rightVal.toBoolean(true);\n\n          // (x || FALSE) => x\n          // (x && TRUE) => x\n          if (type == Token.OR && !rval ||\n              type == Token.AND && rval) {\n            replacement = left;\n          } else if (!mayHaveSideEffects(left)) {\n            replacement = right;\n          }\n\n          if (replacement != null) {\n            n.detachChildren();\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n        return n;\n      }\n\n      case Token.HOOK: {\n        Node condition = n.getFirstChild();\n        Node trueNode = n.getFirstChild().getNext();\n        Node falseNode = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the result children, this can't be done in the general case.\n        // The condition is handled in the general case in #optimizeSubtree\n        trueNode = tryMinimizeCondition(trueNode);\n        falseNode = tryMinimizeCondition(falseNode);\n\n        // Handle four cases:\n        //   x ? true : false --> x\n        //   x ? false : true --> !x\n        //   x ? true : y     --> x || y\n        //   x ? y : false    --> x && y\n        Node replacement = null;\n        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n        if (trueNodeVal == TernaryValue.TRUE\n            && falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = condition;\n        } else if (trueNodeVal == TernaryValue.FALSE\n            && falseNodeVal == TernaryValue.TRUE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = IR.not(condition);\n        } else if (trueNodeVal == TernaryValue.TRUE) {\n          // Remove useless true case.\n          n.detachChildren();\n          replacement = IR.or(condition, falseNode);\n        } else if (falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless false case\n          n.detachChildren();\n          replacement = IR.and(condition, trueNode);\n        }\n\n        if (replacement != null) {\n          parent.replaceChild(n, replacement);\n          n = replacement;\n          reportCodeChange();\n        }\n\n        return n;\n      }\n\n      default:\n        // while(true) --> while(1)\n        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n        if (nVal != TernaryValue.UNKNOWN) {\n          boolean result = nVal.toBoolean(true);\n          int equivalentResult = result ? 1 : 0;\n          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return n;\n    }\n  }\n",
        "begin_line": 1129,
        "end_line": 1309,
        "comment": "\n   * Try to minimize conditions expressions, as there are additional\n   * assumptions that can be made when it is known that the final result\n   * is a boolean.\n   *\n   * The following transformations are done recursively:\n   *   !(x||y) --> !x&&!y\n   *   !(x&&y) --> !x||!y\n   *   !!x     --> x\n   * Thus:\n   *   !(x&&!y) --> !x||!!y --> !x||y\n   *\n   *   Returns the replacement for n, or the original if no change was made\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeepholeRemoveDeadCode.tryFoldIf#672",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldIf(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldIf(Node n) {\n    Preconditions.checkState(n.isIf());\n    Node parent = n.getParent();\n    Preconditions.checkNotNull(parent);\n    int type = n.getType();\n    Node cond = n.getFirstChild();\n    Node thenBody = cond.getNext();\n    Node elseBody = thenBody.getNext();\n\n    // if (x) { .. } else { } --> if (x) { ... }\n    if (elseBody != null && !mayHaveSideEffects(elseBody)) {\n      n.removeChild(elseBody);\n      elseBody = null;\n      reportCodeChange();\n    }\n\n    // if (x) { } else { ... } --> if (!x) { ... }\n    if (!mayHaveSideEffects(thenBody) && elseBody != null) {\n      n.removeChild(elseBody);\n      n.replaceChild(thenBody, elseBody);\n      Node notCond = new Node(Token.NOT);\n      n.replaceChild(cond, notCond);\n      notCond.addChildToFront(cond);\n      cond = notCond;\n      thenBody = cond.getNext();\n      elseBody = null;\n      reportCodeChange();\n    }\n\n    // if (x()) { }\n    if (!mayHaveSideEffects(thenBody) && elseBody == null) {\n      if (mayHaveSideEffects(cond)) {\n        // x() has side effects, just leave the condition on its own.\n        n.removeChild(cond);\n        Node replacement = NodeUtil.newExpr(cond);\n        parent.replaceChild(n, replacement);\n        reportCodeChange();\n        return replacement;\n      } else {\n        // x() has no side effects, the whole tree is useless now.\n        NodeUtil.removeChild(parent, n);\n        reportCodeChange();\n        return null;\n      }\n    }\n\n    // Try transforms that apply to both IF and HOOK.\n    TernaryValue condValue = NodeUtil.getImpureBooleanValue(cond);\n    if (condValue == TernaryValue.UNKNOWN) {\n      return n;  // We can't remove branches otherwise!\n    }\n\n    if (mayHaveSideEffects(cond)) {\n      // Transform \"if (a = 2) {x =2}\" into \"if (true) {a=2;x=2}\"\n      boolean newConditionValue = condValue == TernaryValue.TRUE;\n      // Add an elseBody if it is needed.\n      if (!newConditionValue && elseBody == null) {\n        elseBody = IR.block().srcref(n);\n        n.addChildToBack(elseBody);\n      }\n      Node newCond = NodeUtil.booleanNode(newConditionValue);\n      n.replaceChild(cond, newCond);\n      Node branchToKeep = newConditionValue ? thenBody : elseBody;\n      branchToKeep.addChildToFront(IR.exprResult(cond).srcref(cond));\n      reportCodeChange();\n      cond = newCond;\n    }\n\n    boolean condTrue = condValue.toBoolean(true);\n    if (n.getChildCount() == 2) {\n      Preconditions.checkState(type == Token.IF);\n\n      if (condTrue) {\n        // Replace \"if (true) { X }\" with \"X\".\n        Node thenStmt = n.getFirstChild().getNext();\n        n.removeChild(thenStmt);\n        parent.replaceChild(n, thenStmt);\n        reportCodeChange();\n        return thenStmt;\n      } else {\n        // Remove \"if (false) { X }\" completely.\n        NodeUtil.redeclareVarsInsideBranch(n);\n        NodeUtil.removeChild(parent, n);\n        reportCodeChange();\n        return null;\n      }\n    } else {\n      // Replace \"if (true) { X } else { Y }\" with X, or\n      // replace \"if (false) { X } else { Y }\" with Y.\n      Node trueBranch = n.getFirstChild().getNext();\n      Node falseBranch = trueBranch.getNext();\n      Node branchToKeep = condTrue ? trueBranch : falseBranch;\n      Node branchToRemove = condTrue ? falseBranch : trueBranch;\n      NodeUtil.redeclareVarsInsideBranch(branchToRemove);\n      n.removeChild(branchToKeep);\n      parent.replaceChild(n, branchToKeep);\n      reportCodeChange();\n      return branchToKeep;\n    }\n  }\n",
        "begin_line": 672,
        "end_line": 771,
        "comment": "\n   * Try folding IF nodes by removing dead branches.\n   * @return the replacement node, if changed, or the original if not\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "MinimizeExitPoints.tryMinimizeIfBlockExits#220",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.tryMinimizeIfBlockExits(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, int, java.lang.String)",
        "snippet": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\n      if (!srcBlock.hasChildren()) {\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n    }\n\n    // Get rid of the \"exit\", replace with an empty item if needed.\n    NodeUtil.removeChild(exitNodeParent, exitNode);\n\n    compiler.reportCodeChange();\n  }\n",
        "begin_line": 220,
        "end_line": 271,
        "comment": "\n   * Look for exits (returns, breaks, or continues, depending on the context) at\n   * the end of a block and removes them by moving the if node's siblings,\n   * if any, into the opposite condition block.\n   *\n   * @param srcBlock The block to inspect.\n   * @param destBlock The block to move sibling nodes into.\n   * @param ifNode The if node to work with.\n   * @param exitType The type of exit to look for.\n   * @param labelName The name associated with the exit, if any.\n   * @nullable labelName null for anything excepted for named-break associated\n   *           with a label.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.isValidInitialization#646",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isValidInitialization(com.google.javascript.jscomp.ReferenceCollectingCallback.Reference)",
        "snippet": "    private boolean isValidInitialization(Reference initialization) {\n      if (initialization == null) {\n        return false;\n      } else if (initialization.isDeclaration()) {\n        // The reference is a FUNCTION declaration or normal VAR declaration\n        // with a value.\n        if (!NodeUtil.isFunctionDeclaration(initialization.getParent())\n            && initialization.getNode().getFirstChild() == null) {\n          return false;\n        }\n      } else {\n        Node parent = initialization.getParent();\n        Preconditions.checkState(\n            parent.isAssign()\n            && parent.getFirstChild() == initialization.getNode());\n      }\n\n      Node n = initialization.getAssignedValue();\n      if (n.isFunction()) {\n        return compiler.getCodingConvention().isInlinableFunction(n);\n      }\n\n      return true;\n    }\n",
        "begin_line": 646,
        "end_line": 669,
        "comment": "\n     * @return Whether there is a initial value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.isImmutableAndWellDefinedVariable#683",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isImmutableAndWellDefinedVariable(com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection)",
        "snippet": "    private boolean isImmutableAndWellDefinedVariable(Var v,\n        ReferenceCollection refInfo) {\n      List<Reference> refSet = refInfo.references;\n      int startingReadRef = 1;\n      Reference refDecl = refSet.get(0);\n      if (!isValidDeclaration(refDecl)) {\n        return false;\n      }\n\n      boolean isNeverAssigned = refInfo.isNeverAssigned();\n      // For values that are never assigned, only the references need to be\n      // checked.\n      if (!isNeverAssigned) {\n        Reference refInit = refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n          return false;\n        }\n\n        if (refDecl != refInit) {\n          Preconditions.checkState(refInit == refSet.get(1));\n          startingReadRef = 2;\n        }\n\n        if (!refInfo.isWellDefined()) {\n          return false;\n        }\n\n        Node value = refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n\n        boolean isImmutableValueWorthInlining =\n            NodeUtil.isImmutableValue(value) &&\n            (!value.isString() ||\n                isStringWorthInlining(v, refInfo.references));\n        boolean isInlinableThisAlias =\n            value.isThis() &&\n            !refInfo.isEscaped();\n        if (!isImmutableValueWorthInlining && !isInlinableThisAlias) {\n          return false;\n        }\n      }\n\n      for (int i = startingReadRef; i < refSet.size(); i++) {\n        Reference ref = refSet.get(i);\n        if (!isValidReference(ref)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
        "begin_line": 683,
        "end_line": 733,
        "comment": "\n     * Determines whether the reference collection describes a variable that\n     * is initialized to an immutable value, never modified, and defined before\n     * every reference.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.explicitReturnExpected#150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.explicitReturnExpected(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType explicitReturnExpected(Node scope) {\n    FunctionType scopeType = JSType.toMaybeFunctionType(scope.getJSType());\n\n    if (scopeType == null) {\n      return null;\n    }\n\n    if (isEmptyFunction(scope)) {\n      return null;\n    }\n\n    JSType returnType = scopeType.getReturnType();\n\n    if (returnType == null) {\n      return null;\n    }\n\n    if (!isVoidOrUnknown(returnType)) {\n      return returnType;\n    }\n\n    return null;\n  }\n",
        "begin_line": 150,
        "end_line": 172,
        "comment": "\n   * Determines if the given scope should explicitly return. All functions\n   * with non-void or non-unknown return types must have explicit returns.\n   * @return If a return type is expected, returns it. Otherwise, returns null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1768
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isTry#2357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isTry()",
        "snippet": "  public boolean isTry() {\n    return this.getType() == Token.TRY;\n  }\n",
        "begin_line": 2357,
        "end_line": 2359,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1759
        },
        "num_failing_tests": 7
    },
    {
        "name": "CompilerOptions.setLanguageIn#1464",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setLanguageIn(com.google.javascript.jscomp.CompilerOptions.LanguageMode)",
        "snippet": "  public void setLanguageIn(LanguageMode languageIn) {\n    this.languageIn = languageIn;\n    this.languageOut = languageIn;\n  }\n",
        "begin_line": 1464,
        "end_line": 1467,
        "comment": "\n   * Sets how goog.tweak calls are processed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1759
        },
        "num_failing_tests": 7
    },
    {
        "name": "PhaseOptimizer.process#322",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.Loop.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n      loopMutex = true;\n      if (randomizeLoops) {\n        randomizePasses();\n      } else {\n        optimizePasses();\n      }\n\n      // Contains a pass iff it made changes the last time it was run.\n      Set<NamedPass> madeChanges = new HashSet<NamedPass>();\n      // Contains a pass iff it was run during the last inner loop.\n      Set<NamedPass> runInPrevIter = new HashSet<NamedPass>();\n      State s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n      boolean lastIterMadeChanges;\n      int count = 0;\n\n      try {\n        while (true) {\n          if (count++ > MAX_LOOPS) {\n            compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null);\n          }\n          lastIterMadeChanges = false;\n          for (NamedPass pass : myPasses) {\n            recentChange.reset();\n            if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER &&\n                !runInPrevIter.contains(pass)) ||\n                (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER &&\n                    madeChanges.contains(pass))) {\n              pass.process(externs, root);\n              runInPrevIter.add(pass);\n              if (hasHaltingErrors()) {\n                return;\n              } else if (recentChange.hasCodeChanged()) {\n                madeChanges.add(pass);\n                lastIterMadeChanges = true;\n              } else {\n                madeChanges.remove(pass);\n              }\n            } else {\n              runInPrevIter.remove(pass);\n            }\n          }\n          if (s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) {\n            if (lastIterMadeChanges) {\n              s = State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER;\n            } else {\n              return;\n            }\n          } else if (!lastIterMadeChanges) {\n            s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;\n          }\n        }\n      } finally {\n        loopMutex = false;\n      }\n    }\n",
        "begin_line": 322,
        "end_line": 379,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1754
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateParameters#366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateParameters(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateParameters(Node n) {\n    validateNodeType(Token.PARAM_LIST, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateName(c);\n    }\n  }\n",
        "begin_line": 366,
        "end_line": 371,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1744
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.shouldTraverse#105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.PARAM_LIST: {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // Add the function parameters\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n          }\n\n          // Add the function body declarations\n          Node functionBody = n.getNext();\n          findDeclaredNames(functionBody, null, renamer);\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }\n",
        "begin_line": 105,
        "end_line": 156,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1734
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isAnd#2153",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isAnd()",
        "snippet": "  public boolean isAnd() {\n    return this.getType() == Token.AND;\n  }\n",
        "begin_line": 2153,
        "end_line": 2155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1718
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isCast#2185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCast()",
        "snippet": "  public boolean isCast() {\n    return this.getType() == Token.CAST;\n  }\n",
        "begin_line": 2185,
        "end_line": 2187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1718
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isHook#2253",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isHook()",
        "snippet": "  public boolean isHook() {\n    return this.getType() == Token.HOOK;\n  }\n",
        "begin_line": 2253,
        "end_line": 2255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1718
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isOr#2309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isOr()",
        "snippet": "  public boolean isOr() {\n    return this.getType() == Token.OR;\n  }\n",
        "begin_line": 2309,
        "end_line": 2311,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1718
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.getBestJSDocInfo#3046",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestJSDocInfo(com.google.javascript.rhino.Node)",
        "snippet": "  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return parent.getJSDocInfo();\n      } else if (isObjectLitKey(parent, parent.getParent())) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isCast()) {\n        return parent.getJSDocInfo();\n      }\n    }\n    return info;\n  }\n",
        "begin_line": 3046,
        "end_line": 3074,
        "comment": " Find the best JSDoc for the given node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1718
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isEquivalentTo#1471",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isEquivalentTo(com.google.javascript.rhino.Node)",
        "snippet": "  public boolean isEquivalentTo(Node node) {\n    return isEquivalentTo(node, false, true);\n  }\n",
        "begin_line": 1471,
        "end_line": 1473,
        "comment": " Returns true if this node is equivalent semantically to another ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1717
        },
        "num_failing_tests": 5
    },
    {
        "name": "CodePrinter.maybeCutLine#489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.maybeCutLine()",
        "snippet": "    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        // Use the preferred position provided it will break the line.\n        if (preferredBreakPosition > lineStartPosition &&\n            preferredBreakPosition < lineStartPosition + lineLength) {\n          int position = preferredBreakPosition;\n          code.insert(position, '\\n');\n          prevCutPosition = position;\n          reportLineCut(lineIndex, position - lineStartPosition, true);\n          lineIndex++;\n          lineLength -= (position - lineStartPosition);\n          lineStartPosition = position + 1;\n        } else {\n          startNewLine();\n        }\n      }\n    }\n",
        "begin_line": 489,
        "end_line": 506,
        "comment": "\n     * This may start a new line if the current line is longer than the line\n     * length threshold.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1715
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.initOptions#274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initOptions(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n",
        "begin_line": 274,
        "end_line": 337,
        "comment": "\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1709
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessClosurePrimitives.visit#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.isExprResult();\n        Node left = n.getFirstChild();\n        if (left.isGetProp()) {\n          Node name = left.getFirstChild();\n          if (name.isName() &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.isString()) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, IR.number(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n\n      case Token.EXPR_RESULT:\n        handleTypedefDefinition(t, n, parent);\n        break;\n\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hoisted functions will explode if they're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().isName() &&\n            !parent.isCall() &&\n            !parent.isAssign() &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }\n",
        "begin_line": 172,
        "end_line": 259,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1703
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.addDeclaredName#461",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.addDeclaredName(java.lang.String)",
        "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }\n",
        "begin_line": 461,
        "end_line": 478,
        "comment": "\n     * Adds a name to the map of names declared in this scope.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1696
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.incrementNameCount#496",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.incrementNameCount(java.lang.String)",
        "snippet": "    private int incrementNameCount(String name) {\n      return nameUsage.add(name, 1);\n    }\n",
        "begin_line": 496,
        "end_line": 498,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1696
        },
        "num_failing_tests": 8
    },
    {
        "name": "ScopedAliases.shouldTraverse#267",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction() && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }\n",
        "begin_line": 267,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeConsumer.add#181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.add(java.lang.String)",
        "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n      append(\" \");\n    }\n\n    append(newcode);\n  }\n",
        "begin_line": 181,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.scanRoot#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.isFunction()) {\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n        // TODO(johnlenz): inputId maybe null if the FUNCTION node is detached\n        // from the AST.\n        // Is it meaningful to build a scope for detached FUNCTION node?\n      }\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.isParamList());\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.isName());\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }\n",
        "begin_line": 84,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1687
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.reportCodeChange#1982",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.reportCodeChange()",
        "snippet": "  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n",
        "begin_line": 1982,
        "end_line": 1987,
        "comment": "\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1675
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeChangeHandler.reportChange#38",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeChangeHandler.java",
        "class_name": "com.google.javascript.jscomp.CodeChangeHandler",
        "signature": "com.google.javascript.jscomp.CodeChangeHandler.RecentChange.reportChange()",
        "snippet": "    @Override\n    public void reportChange() {\n      hasChanged = true;\n    }\n",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1675
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.addExpr#907",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.addExpr(com.google.javascript.rhino.Node, int, com.google.javascript.jscomp.CodeGenerator.Context)",
        "snippet": "  private void addExpr(Node n, int minPrecedence, Context context) {\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) && n.isIn())){\n      add(\"(\");\n      add(n, Context.OTHER);\n      add(\")\");\n    } else {\n      add(n, context);\n    }\n  }\n",
        "begin_line": 907,
        "end_line": 916,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1658
        },
        "num_failing_tests": 8
    },
    {
        "name": "LineNumberCheck.visit#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LineNumberCheck.java",
        "class_name": "com.google.javascript.jscomp.LineNumberCheck",
        "signature": "com.google.javascript.jscomp.LineNumberCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isScript()) {\n      requiresLineNumbers = false;\n    } else if (requiresLineNumbers) {\n      if (n.getLineno() == -1) {\n        // The tree version of the node is really the best diagnostic\n        // info we have to offer here.\n        compiler.report(\n            t.makeError(n, MISSING_LINE_INFO,\n                n.toStringTree()));\n      }\n    }\n  }\n",
        "begin_line": 67,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1655
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isEquivalentTo#224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.isEquivalentTo(com.google.javascript.rhino.Node, boolean, boolean)",
        "snippet": "    @Override\n    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n      return (super.isEquivalentTo(node, compareJsType, recurse)\n          && this.str.equals(((StringNode) node).str));\n    }\n",
        "begin_line": 224,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1652
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.getLastChar#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.MappedCodePrinter.getLastChar()",
        "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }\n",
        "begin_line": 205,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1641
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.addIdentifier#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.addIdentifier(java.lang.String)",
        "snippet": "  void addIdentifier(String identifier) {\n    add(identifier);\n  }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1641
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.append#442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.append(java.lang.String)",
        "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }\n",
        "begin_line": 442,
        "end_line": 446,
        "comment": "\n     * Appends a string to the code, keeping track of the current line length.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1638
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.notePreferredLineBreak#508",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.notePreferredLineBreak()",
        "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }\n",
        "begin_line": 508,
        "end_line": 511,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1638
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.add#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.add(java.lang.String)",
        "snippet": "  void add(String str) {\n    cc.add(str);\n  }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1638
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.addIdentifier#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.addIdentifier(java.lang.String)",
        "snippet": "  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1633
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.identifierEscape#1165",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.identifierEscape(java.lang.String)",
        "snippet": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-Latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }\n",
        "begin_line": 1165,
        "end_line": 1185,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1633
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processFunctionNode#709",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processFunctionNode(com.google.javascript.rhino.head.ast.FunctionNode)",
        "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        Node paramNode = transform(param);\n        // When in ideMode Rhino can generate a param list with only a single\n        // ErrorNode. This is transformed into an EMPTY node. Drop this node in\n        // ideMode to keep the AST in a valid state.\n        if (paramNode.isName()) {\n          lp.addChildToBack(paramNode);\n        } else {\n          // We expect this in ideMode or when there is an error handling\n          // destructuring parameter assignments which aren't supported\n          // (an error has already been reported).\n          Preconditions.checkState(\n              config.isIdeMode\n              || paramNode.isObjectLit()\n              || paramNode.isArrayLit());\n        }\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n",
        "begin_line": 709,
        "end_line": 791,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.163
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.maybeEndStatement#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
        "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }\n",
        "begin_line": 152,
        "end_line": 161,
        "comment": "\n   * This is to be called when we're in a statement. If the prev statement\n   * needs to be ended, add a ';'.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.163
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.isWordChar#286",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
        "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }\n",
        "begin_line": 286,
        "end_line": 290,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.163
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isLatin#2428",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isLatin(java.lang.String)",
        "snippet": "  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 2428,
        "end_line": 2437,
        "comment": " Test if all characters in the string are in the Basic Latin (aka ASCII)\n   * character set - that they have UTF-16 values equal to or below 0x7f.\n   * This check can find which identifiers with Unicode characters need to be\n   * escaped in order to allow resulting files to be processed by non-Unicode\n   * aware UNIX tools and editors.\n   * *\n   * See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode\n   * for more on Basic Latin.\n   *\n   * @param s The string to be checked for ASCII-goodness.\n   *\n   * @return True if all characters in the string are in Basic Latin set.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1628
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.getVars#566",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getVars()",
        "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }\n",
        "begin_line": 566,
        "end_line": 568,
        "comment": "\n   * Return an iterator over all of the variables declared in this scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.MatchNodeType#2606",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.MatchNodeType.MatchNodeType(int)",
        "snippet": "    MatchNodeType(int type){\n      this.type = type;\n    }\n",
        "begin_line": 2606,
        "end_line": 2608,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.apply#2610",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.MatchNodeType.apply(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean apply(Node n) {\n      return n.getType() == type;\n    }\n",
        "begin_line": 2610,
        "end_line": 2613,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.containsType#2220",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.containsType(com.google.javascript.rhino.Node, int, com.google.common.base.Predicate<com.google.javascript.rhino.Node>)",
        "snippet": "  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNodeType(type), traverseChildrenPred);\n  }\n",
        "begin_line": 2220,
        "end_line": 2224,
        "comment": "\n   * @return true if n or any of its children are of the specified type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.toSource#1793",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.toSource(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n",
        "begin_line": 1793,
        "end_line": 1797,
        "comment": "\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.162
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.initCompilerOptionsIfTesting#1573",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initCompilerOptionsIfTesting()",
        "snippet": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n",
        "begin_line": 1573,
        "end_line": 1579,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1617
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isComma#2193",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isComma()",
        "snippet": "  public boolean isComma() {\n    return this.getType() == Token.COMMA;\n  }\n",
        "begin_line": 2193,
        "end_line": 2195,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1589
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.visit#295",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.VerifyConstants.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          CodingConvention convention = compiler.getCodingConvention();\n          if (NodeUtil.isConstantName(n)\n              || NodeUtil.isConstantByConvention(convention, n, parent)) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name %s is not annotated as constant.\", name);\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name %s should not be annotated as constant.\", name);\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name %s is not consistently annotated as constant.\", name);\n        }\n      }\n    }\n",
        "begin_line": 295,
        "end_line": 343,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProxyObjectType.ProxyObjectType#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n    super(registry);\n    setReferencedType(referencedType);\n  }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.getReferencedTypeInternal#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getReferencedTypeInternal()",
        "snippet": "  JSType getReferencedTypeInternal() {\n    return referencedType;\n  }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.getReferencedObjTypeInternal#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getReferencedObjTypeInternal()",
        "snippet": "  ObjectType getReferencedObjTypeInternal() {\n    return referencedObjType;\n  }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.setReferencedType#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.setReferencedType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setReferencedType(JSType referencedType) {\n    this.referencedType = referencedType;\n    if (referencedType instanceof ObjectType) {\n      this.referencedObjType = (ObjectType) referencedType;\n    } else {\n      this.referencedObjType = null;\n    }\n  }\n",
        "begin_line": 80,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.isNoType#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isNoType()",
        "snippet": "  @Override\n  public boolean isNoType() {\n    return referencedType.isNoType();\n  }\n",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.isUnknownType#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    return referencedType.isUnknownType();\n  }\n",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.isAllType#181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.isAllType()",
        "snippet": "  @Override\n  public boolean isAllType() {\n    return referencedType.isAllType();\n  }\n",
        "begin_line": 181,
        "end_line": 184,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.toMaybeUnionType#207",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeUnionType()",
        "snippet": "  @Override\n  public UnionType toMaybeUnionType() {\n    return referencedType.toMaybeUnionType();\n  }\n",
        "begin_line": 207,
        "end_line": 210,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.toMaybeFunctionType#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeFunctionType()",
        "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return referencedType.toMaybeFunctionType();\n  }\n",
        "begin_line": 212,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.getCtorImplementedInterfaces#238",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getCtorImplementedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return referencedObjType == null ? Collections.<ObjectType>emptyList() :\n        referencedObjType.getCtorImplementedInterfaces();\n  }\n",
        "begin_line": 238,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.getImplicitPrototype#254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return referencedObjType == null ? null :\n        referencedObjType.getImplicitPrototype();\n  }\n",
        "begin_line": 254,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.resolveInternal#325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setReferencedType(referencedType.resolve(t, scope));\n    return this;\n  }\n",
        "begin_line": 325,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.toMaybeParameterizedType#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeParameterizedType()",
        "snippet": "  @Override\n  public ParameterizedType toMaybeParameterizedType() {\n    return referencedType.toMaybeParameterizedType();\n  }\n",
        "begin_line": 357,
        "end_line": 360,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProxyObjectType.toMaybeTemplateType#362",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ProxyObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
        "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.toMaybeTemplateType()",
        "snippet": "  @Override\n  public TemplateType toMaybeTemplateType() {\n    return referencedType.toMaybeTemplateType();\n  }\n",
        "begin_line": 362,
        "end_line": 365,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.detectImplicitPrototypeCycle#170",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.detectImplicitPrototypeCycle()",
        "snippet": "  final boolean detectImplicitPrototypeCycle() {\n    // detecting cycle\n    this.visited = true;\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.visited) {\n        return true;\n      } else {\n        p.visited = true;\n      }\n      p = p.getImplicitPrototype();\n    }\n\n    // clean up\n    p = this;\n    do {\n      p.visited = false;\n      p = p.getImplicitPrototype();\n    } while (p != null);\n    return false;\n  }\n",
        "begin_line": 170,
        "end_line": 190,
        "comment": "\n   * Detects a cycle in the implicit prototype chain. This method accesses\n   * the {@link #getImplicitPrototype()} method and must therefore be\n   * invoked only after the object is sufficiently initialized to respond to\n   * calls to this method.<p>\n   *\n   * @return True iff an implicit prototype cycle was detected.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.detectInheritanceCycle#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.detectInheritanceCycle()",
        "snippet": "  final boolean detectInheritanceCycle() {\n    // TODO(user): This should get moved to preventing cycles in FunctionTypeBuilder\n    // rather than removing them here after they have been created.\n    // Also, this doesn't do the right thing for extended interfaces, though that is\n    // masked by another bug.\n    return detectImplicitPrototypeCycle()\n        || Iterables.contains(this.getCtorImplementedInterfaces(), this)\n        || Iterables.contains(this.getCtorExtendedInterfaces(), this);\n  }\n",
        "begin_line": 198,
        "end_line": 206,
        "comment": "\n   * Detects cycles in either the implicit prototype chain, or the implemented/extended\n   * interfaces.<p>\n   *\n   * @return True iff a cycle was detected.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getCtorImplementedInterfaces#631",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getCtorImplementedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return ImmutableSet.of();\n  }\n",
        "begin_line": 631,
        "end_line": 633,
        "comment": "\n   * Gets the interfaces implemented by the ctor associated with this type.\n   * Intended to be overridden by subclasses.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getCtorExtendedInterfaces#639",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getCtorExtendedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return ImmutableSet.of();\n  }\n",
        "begin_line": 639,
        "end_line": 641,
        "comment": "\n   * Gets the interfaces extended by the interface associated with this type.\n   * Intended to be overridden by subclasses.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NoObjectType.getImplicitPrototype#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.NamedType#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.NamedType(com.google.javascript.rhino.jstype.JSTypeRegistry, java.lang.String, java.lang.String, int, int)",
        "snippet": "  NamedType(JSTypeRegistry registry, String reference,\n      String sourceName, int lineno, int charno) {\n    super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n\n    Preconditions.checkNotNull(reference);\n    this.reference = reference;\n    this.sourceName = sourceName;\n    this.lineno = lineno;\n    this.charno = charno;\n  }\n",
        "begin_line": 103,
        "end_line": 112,
        "comment": "\n   * Create a named type based on the reference.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.getReferencedType#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.getReferencedType()",
        "snippet": "  public JSType getReferencedType() {\n    return getReferencedTypeInternal();\n  }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": " Returns the type to which this refers (which is unknown if unresolved). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.hashCode#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return reference.hashCode();\n  }\n",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.resolveInternal#183",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n",
        "begin_line": 183,
        "end_line": 212,
        "comment": "\n   * Resolve the referenced type within the enclosing scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NamedType.resolveViaRegistry#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NamedType.java",
        "class_name": "com.google.javascript.rhino.jstype.NamedType",
        "signature": "com.google.javascript.rhino.jstype.NamedType.resolveViaRegistry(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private boolean resolveViaRegistry(\n      ErrorReporter t, StaticScope<JSType> enclosing) {\n    JSType type = registry.getType(reference);\n    if (type != null) {\n      setReferencedAndResolvedType(type, t, enclosing);\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 218,
        "end_line": 226,
        "comment": "\n   * Resolves a named type by looking it up in the registry.\n   * @return True if we resolved successfully.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.isLastGeneration#795",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.isLastGeneration()",
        "snippet": "  boolean isLastGeneration() {\n    return lastGeneration;\n  }\n",
        "begin_line": 795,
        "end_line": 797,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.getType#914",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.lang.String, java.lang.String, int, int)",
        "snippet": "  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno) {\n    JSType type = getType(jsTypeName);\n    if (type == null) {\n      // TODO(user): Each instance should support named type creation using\n      // interning.\n      NamedType namedType =\n          new NamedType(this, jsTypeName, sourceName, lineno, charno);\n      unresolvedNamedTypes.put(scope, namedType);\n      type = namedType;\n    }\n    return type;\n  }\n",
        "begin_line": 914,
        "end_line": 926,
        "comment": "\n   * Looks up a type by name. To allow for forward references to types, an\n   * unrecognized string has to be bound to a NamedType object that will be\n   * resolved later.\n   *\n   * @param scope A scope for doing type name resolution.\n   * @param jsTypeName The name string.\n   * @param sourceName The name of the source file where this reference appears.\n   * @param lineno The line number of the reference.\n   * @return a NamedType if the string argument is not one of the known types,\n   *     otherwise the corresponding JSType object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.resolveTypesInScope#941",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resolveTypesInScope(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public void resolveTypesInScope(StaticScope<JSType> scope) {\n    for (NamedType type : unresolvedNamedTypes.get(scope)) {\n      type.resolve(reporter, scope);\n    }\n\n    resolvedNamedTypes.putAll(scope, unresolvedNamedTypes.removeAll(scope));\n\n    if (scope != null && scope.getParentScope() == null) {\n      // By default, the global \"this\" type is just an anonymous object.\n      // If the user has defined a Window type, make the Window the\n      // implicit prototype of \"this\".\n      PrototypeObjectType globalThis = (PrototypeObjectType) getNativeType(\n          JSTypeNative.GLOBAL_THIS);\n      JSType windowType = getType(\"Window\");\n      if (globalThis.isUnknownType()) {\n        ObjectType windowObjType = ObjectType.cast(windowType);\n        if (windowObjType != null) {\n          globalThis.setImplicitPrototype(windowObjType);\n        } else {\n          globalThis.setImplicitPrototype(\n              getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n        }\n      }\n    }\n  }\n",
        "begin_line": 941,
        "end_line": 965,
        "comment": "\n   * Resolve all the unresolved types in the given scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isResolved#1445",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isResolved()",
        "snippet": "  public final boolean isResolved() {\n    return resolved;\n  }\n",
        "begin_line": 1445,
        "end_line": 1447,
        "comment": " Whether the type has been resolved. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isNot#2293",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isNot()",
        "snippet": "  public boolean isNot() {\n    return this.getType() == Token.NOT;\n  }\n",
        "begin_line": 2293,
        "end_line": 2295,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.transformBlock#224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformBlock(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (!irNode.isBlock()) {\n      if (irNode.isEmpty()) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        maybeSetLengthFrom(newBlock, node);\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }\n",
        "begin_line": 224,
        "end_line": 239,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isInitializingAssignmentAt#374",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.isInitializingAssignmentAt(int)",
        "snippet": "    private boolean isInitializingAssignmentAt(int index) {\n      if (index < references.size() && index > 0) {\n        Reference maybeDecl = references.get(index-1);\n        if (maybeDecl.isVarDeclaration()) {\n          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n          Reference maybeInit = references.get(index);\n          if (maybeInit.isSimpleAssignmentToName()) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n",
        "begin_line": 374,
        "end_line": 386,
        "comment": "\n     * @param index The index into the references array to look for an\n     * initialized assignment reference. That is, an assignment immediately\n     * follow a variable declaration that itself does not initialize the\n     * variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.getInitializingReference#395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.getInitializingReference()",
        "snippet": "    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }\n",
        "begin_line": 395,
        "end_line": 402,
        "comment": "\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.opToStr#2153",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.opToStr(int)",
        "snippet": "  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }\n",
        "begin_line": 2153,
        "end_line": 2198,
        "comment": "\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation or {@code null} if the token value is\n   * not an operator\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.exitScope#313",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        handleScopeVar(v);\n      }\n\n      // Merge any names that were referenced but not declared in the current\n      // scope.\n      Set<String> current = referencedNames;\n      referencedNames = referenceStack.pop();\n      // If there isn't anything left in the stack we will be going into the\n      // global scope: don't try to build a set of referenced names for the\n      // global scope.\n      if (!referenceStack.isEmpty()) {\n        referencedNames.addAll(current);\n      }\n    }\n",
        "begin_line": 313,
        "end_line": 334,
        "comment": "\n     * Rename vars for the current scope, and merge any referenced\n     * names into the parent scope reference set.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.canInline#519",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.canInline(com.google.javascript.jscomp.ReferenceCollectingCallback.Reference, com.google.javascript.jscomp.ReferenceCollectingCallback.Reference, com.google.javascript.jscomp.ReferenceCollectingCallback.Reference)",
        "snippet": "    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      // Do not inline into a call node. This would change\n      // the context in which it was being called. For example,\n      //   var a = b.c;\n      //   a();\n      // should not be inlined, because it calls a in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is OK.\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          // Bug 2388531: Don't inline subclass definitions into class defining\n          // calls as this confused class removing logic.\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n\n          // issue 668: Don't inline singleton getter methods\n          // calls as this confused class removing logic.\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n",
        "begin_line": 519,
        "end_line": 583,
        "comment": "\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.shouldTraverse#217",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 217,
        "end_line": 292,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 4
    },
    {
        "name": "CollapseVariableDeclarations.isNamedParameter#209",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.isNamedParameter(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private boolean isNamedParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n",
        "begin_line": 209,
        "end_line": 211,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1581
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateStatement#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateStatement(com.google.javascript.rhino.Node)",
        "snippet": "  public void validateStatement(Node n) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        validateLabel(n);\n        return;\n      case Token.BLOCK:\n        validateBlock(n);\n        return;\n      case Token.FUNCTION:\n        validateFunctionStatement(n);\n        return;\n      case Token.WITH:\n        validateWith(n);\n        return;\n      case Token.FOR:\n        validateFor(n);\n        return;\n      case Token.WHILE:\n        validateWhile(n);\n        return;\n      case Token.DO:\n        validateDo(n);\n        return;\n      case Token.SWITCH:\n        validateSwitch(n);\n        return;\n      case Token.IF:\n        validateIf(n);\n        return;\n      case Token.VAR:\n        validateVar(n);\n        return;\n      case Token.EXPR_RESULT:\n        validateExprStmt(n);\n        return;\n      case Token.RETURN:\n        validateReturn(n);\n        return;\n      case Token.THROW:\n        validateThrow(n);\n        return;\n      case Token.TRY:\n        validateTry(n);\n        return;\n      case Token.BREAK:\n        validateBreak(n);\n        return;\n      case Token.CONTINUE:\n        validateContinue(n);\n        return;\n      case Token.EMPTY:\n        validateChildless(n);\n        return;\n      case Token.DEBUGGER:\n        validateChildless(n);\n        return;\n      default:\n        violation(\"Expected statement but was \"\n            + Token.name(n.getType()) + \".\", n);\n    }\n  }\n",
        "begin_line": 92,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1576
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateFunctionStatement#350",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionStatement(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateFunctionStatement(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }\n",
        "begin_line": 350,
        "end_line": 356,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1576
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateMinimumChildCount#790",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateMinimumChildCount(com.google.javascript.rhino.Node, int)",
        "snippet": "  private void validateMinimumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = n.hasChildren();\n    } else if (i == 2) {\n      valid = n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() >= i;\n    }\n\n    if (!valid) {\n      violation(\n          \"Expected at least \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }\n",
        "begin_line": 790,
        "end_line": 805,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1576
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.hasChild#1395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasChild(com.google.javascript.rhino.Node)",
        "snippet": "  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 1395,
        "end_line": 1402,
        "comment": " Intended for testing and verification only.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1575
        },
        "num_failing_tests": 5
    },
    {
        "name": "CompilerOptions.getOutputCharset#1446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getOutputCharset()",
        "snippet": "  Charset getOutputCharset() {\n    return outputCharset == null ? null : Charset.forName(outputCharset);\n  }\n",
        "begin_line": 1446,
        "end_line": 1448,
        "comment": "\n   * Gets the output charset as a rich object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.getLanguageOut#1473",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageOut()",
        "snippet": "  public LanguageMode getLanguageOut() {\n    return languageOut;\n  }\n",
        "begin_line": 1473,
        "end_line": 1475,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.clone#1488",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.clone()",
        "snippet": "  @Override\n  public Object clone() throws CloneNotSupportedException {\n    CompilerOptions clone = (CompilerOptions) super.clone();\n    // TODO(bolinfest): Add relevant custom cloning.\n    return clone;\n  }\n",
        "begin_line": 1488,
        "end_line": 1493,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.toSource#1802",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.toSource(com.google.javascript.rhino.Node, com.google.javascript.jscomp.SourceMap, boolean)",
        "snippet": "  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setCompilerOptions(options);\n    builder.setSourceMap(sourceMap);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    return builder.build();\n  }\n",
        "begin_line": 1802,
        "end_line": 1809,
        "comment": "\n   * Generates JavaScript source code for an AST.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.MappedCodePrinter#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.MappedCodePrinter.MappedCodePrinter(int, boolean, com.google.javascript.jscomp.SourceMap.DetailLevel)",
        "snippet": "    MappedCodePrinter(\n        int lineLengthThreshold,\n        boolean createSrcMap,\n        SourceMap.DetailLevel sourceMapDetailLevel) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      this.lineLengthThreshold = lineLengthThreshold <= 0 ? Integer.MAX_VALUE :\n        lineLengthThreshold;\n      this.createSrcMap = createSrcMap;\n      this.sourceMapDetailLevel = sourceMapDetailLevel;\n      this.mappings = createSrcMap ? new ArrayDeque<Mapping>() : null;\n      this.allMappings = createSrcMap ? new ArrayList<Mapping>() : null;\n    }\n",
        "begin_line": 57,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.startSourceMapping#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.MappedCodePrinter.startSourceMapping(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      Preconditions.checkState(node != null);\n      if (createSrcMap\n          && node.getSourceFileName() != null\n          && node.getLineno() > 0\n          && sourceMapDetailLevel.apply(node)) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        Mapping mapping = new Mapping();\n        mapping.node = node;\n        mapping.start = new FilePosition(line, index);\n        mappings.push(mapping);\n        allMappings.add(mapping);\n      }\n    }\n",
        "begin_line": 89,
        "end_line": 106,
        "comment": "\n     * Starts the source mapping for the given\n     * node at the current position.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.endSourceMapping#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.MappedCodePrinter.endSourceMapping(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) {\n        Mapping mapping = mappings.pop();\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        mapping.end = new FilePosition(line, index);\n      }\n    }\n",
        "begin_line": 112,
        "end_line": 121,
        "comment": "\n     * Finishes the source mapping for the given\n     * node at the current position.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.getCode#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.MappedCodePrinter.getCode()",
        "snippet": "    public String getCode() {\n      return code.toString();\n    }\n",
        "begin_line": 201,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.CompactCodePrinter#431",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.CompactCodePrinter(boolean, boolean, int, boolean, com.google.javascript.jscomp.SourceMap.DetailLevel)",
        "snippet": "    private CompactCodePrinter(boolean lineBreak,\n        boolean preferLineBreakAtEndOfFile, int lineLengthThreshold,\n        boolean createSrcMap, SourceMap.DetailLevel sourceMapDetailLevel) {\n      super(lineLengthThreshold, createSrcMap, sourceMapDetailLevel);\n      this.lineBreak = lineBreak;\n      this.preferLineBreakAtEndOfFile = preferLineBreakAtEndOfFile;\n    }\n",
        "begin_line": 431,
        "end_line": 437,
        "comment": "\n   * @param lineBreak break the lines a bit more aggressively\n   * @param lineLengthThreshold The length of a line after which we force\n   *                            a newline when possible.\n   * @param createSrcMap Whether to gather source position\n   *                            mapping information when printing.\n   * @param sourceMapDetailLevel A filter to control which nodes get mapped into\n   *     the source map.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.endFile#513",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.endFile()",
        "snippet": "    @Override\n    void endFile() {\n      super.endFile();\n      if (!preferLineBreakAtEndOfFile) {\n        return;\n      }\n      if (lineLength > lineLengthThreshold / 2) {\n        // Add an extra break at end of file.\n        append(\";\");\n        startNewLine();\n      } else if (prevCutPosition > 0) {\n        // Shift the previous break to end of file by replacing it with a\n        // <space> and adding a new break at end of file. Adding the space\n        // handles cases like instanceof\\nfoo. (it would be nice to avoid this)\n        code.setCharAt(prevCutPosition, ' ');\n        lineStartPosition = prevLineStartPosition;\n        lineLength = code.length() - lineStartPosition;\n        reportLineCut(lineIndex, prevCutPosition + 1, false);\n        lineIndex--;\n        prevCutPosition = 0;\n        prevLineStartPosition = 0;\n        append(\";\");\n        startNewLine();\n      } else {\n        // A small file with no line breaks. We do nothing in this case to\n        // avoid excessive line breaks. It's not ideal if a lot of these pile\n        // up, but that is reasonably unlikely.\n      }\n    }\n",
        "begin_line": 513,
        "end_line": 541,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.Builder#556",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.Builder.Builder(com.google.javascript.rhino.Node)",
        "snippet": "    Builder(Node node) {\n      root = node;\n    }\n",
        "begin_line": 556,
        "end_line": 558,
        "comment": "\n     * Sets the root node from which to generate the source code.\n     * @param node The root node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.setCompilerOptions#563",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.Builder.setCompilerOptions(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "    Builder setCompilerOptions(CompilerOptions options) {\n      try {\n        this.options = (CompilerOptions) options.clone();\n      } catch (CloneNotSupportedException e) {\n        throw Throwables.propagate(e);\n      }\n      return this;\n    }\n",
        "begin_line": 563,
        "end_line": 570,
        "comment": "\n     * Sets the output options from compiler options.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.setSourceMap#605",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.Builder.setSourceMap(com.google.javascript.jscomp.SourceMap)",
        "snippet": "    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }\n",
        "begin_line": 605,
        "end_line": 608,
        "comment": "\n     * Sets the source map to which to write the metadata about\n     * the generated source code.\n     *\n     * @param sourceMap The source map.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.setTagAsStrict#613",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.Builder.setTagAsStrict(boolean)",
        "snippet": "    Builder setTagAsStrict(boolean tagAsStrict) {\n      this.tagAsStrict = tagAsStrict;\n      return this;\n    }\n",
        "begin_line": 613,
        "end_line": 616,
        "comment": "\n     * Set whether the output should be tags as ECMASCRIPT 5 Strict.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.build#621",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.Builder.build()",
        "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : options.prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, options, sourceMap, tagAsStrict);\n    }\n",
        "begin_line": 621,
        "end_line": 634,
        "comment": "\n     * Generates the source code and returns it.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodePrinter.toSource#646",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.toSource(com.google.javascript.rhino.Node, com.google.javascript.jscomp.CodePrinter.Format, com.google.javascript.jscomp.CompilerOptions, com.google.javascript.jscomp.SourceMap, boolean)",
        "snippet": "  private static String toSource(Node root, Format outputFormat,\n      CompilerOptions options, SourceMap sourceMap,  boolean tagAsStrict) {\n    Preconditions.checkState(options.sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            options.lineBreak,\n            options.preferLineBreakAtEndOfFile,\n            options.lineLengthThreshold,\n            createSourceMap,\n            options.sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            options.lineLengthThreshold,\n            createSourceMap,\n            options.sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, options)\n        : new CodeGenerator(mcp, options);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }\n",
        "begin_line": 646,
        "end_line": 682,
        "comment": "\n   * Converts a tree to JS code\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.CodeGenerator#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(com.google.javascript.jscomp.CodeConsumer, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  CodeGenerator(\n      CodeConsumer consumer,\n      CompilerOptions options) {\n    cc = consumer;\n\n    Charset outputCharset = options.getOutputCharset();\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n    this.preferSingleQuotes = options.preferSingleQuotes;\n    this.trustedStrings = options.trustedStrings;\n  }\n",
        "begin_line": 65,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.continueProcessing#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
        "snippet": "  boolean continueProcessing() {\n    return true;\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n   * Provides a means of interrupting the CodeGenerator. Derived classes should\n   * return false to stop further processing.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.endFile#312",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endFile()",
        "snippet": "  void endFile() {}\n",
        "begin_line": 312,
        "end_line": 312,
        "comment": " Called when we're at the end of a file. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateBlock#277",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateBlock(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateBlock(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }\n",
        "begin_line": 277,
        "end_line": 282,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1574
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.findDeclaredNames#212",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.MakeDeclaredNamesUnique.Renamer)",
        "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || !parent.isFunction()\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }\n",
        "begin_line": 212,
        "end_line": 229,
        "comment": "\n   * Traverses the current scope and collects declared names.  Does not\n   * decent into functions or add CATCH exceptions.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1571
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeGenerator.add#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.add(com.google.javascript.rhino.Node)",
        "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1571
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getChildAtIndex#557",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getChildAtIndex(int)",
        "snippet": "  public Node getChildAtIndex(int i) {\n    Node n = first;\n    while (i > 0) {\n      n = n.next;\n      i--;\n    }\n    return n;\n  }\n",
        "begin_line": 557,
        "end_line": 564,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.visit#380",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = IR.empty();\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n        case Token.STRING_KEY:\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n          if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n            annotateConstantsByConvention(n, parent);\n          }\n          break;\n\n        case Token.CAST:\n          parent.replaceChild(n, n.removeFirstChild());\n          break;\n      }\n    }\n",
        "begin_line": 380,
        "end_line": 413,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.normalizeFunctionDeclaration#458",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.normalizeFunctionDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "    private void normalizeFunctionDeclaration(Node n) {\n      Preconditions.checkState(n.isFunction());\n      if (!NodeUtil.isFunctionExpression(n)\n          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n        rewriteFunctionDeclaration(n);\n      }\n    }\n",
        "begin_line": 458,
        "end_line": 464,
        "comment": "\n     * Rewrite named unhoisted functions declarations to a known\n     * consistent behavior so we don't to different logic paths for the same\n     * code. From:\n     *    function f() {}\n     * to:\n     *    var f = function () {};\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.doStatementNormalizations#502",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.doStatementNormalizations(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.isLabel()) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.isLabel()) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.isFunction()) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }\n",
        "begin_line": 502,
        "end_line": 523,
        "comment": "\n     * Do normalizations that introduce new siblings or parents.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.ContextualRenamer#445",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.ContextualRenamer(com.google.common.collect.Multiset<java.lang.String>)",
        "snippet": "    private ContextualRenamer(Multiset<String> nameUsage) {\n      this.global = false;\n      this.nameUsage = nameUsage;\n    }\n",
        "begin_line": 445,
        "end_line": 448,
        "comment": "\n     * Constructor for child scopes.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.forChildScope#453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.forChildScope()",
        "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new ContextualRenamer(nameUsage);\n    }\n",
        "begin_line": 453,
        "end_line": 456,
        "comment": "\n     * Create a ContextualRenamer\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.enterScope#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used, the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          !declarationRoot.isFunction() ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (!declarationRoot.isFunction()) {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }\n",
        "begin_line": 75,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.exitScope#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }\n",
        "begin_line": 98,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.visit#158",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the Javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove the function body scope\n        nameStack.pop();\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.PARAM_LIST:\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }\n",
        "begin_line": 158,
        "end_line": 192,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateChildCount#774",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateChildCount(com.google.javascript.rhino.Node, int)",
        "snippet": "  private void validateChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 0) {\n      valid = !n.hasChildren();\n    } else if (i == 1) {\n      valid = n.hasOneChild();\n    } else {\n      valid = (n.getChildCount() == i);\n    }\n    if (!valid) {\n      violation(\n          \"Expected \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }\n",
        "begin_line": 774,
        "end_line": 788,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.defineDeclaredProperty#293",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, propertyNode);\n    // All property definitions go through this method\n    // or defineInferredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n    return result;\n  }\n",
        "begin_line": 293,
        "end_line": 302,
        "comment": "\n   * Defines a property whose type is explicitly declared by the programmer.\n   * @param propertyName the property's name\n   * @param type the type\n   * @param propertyNode the node corresponding to the declaration of property\n   *        which might later be accessed using {@code getPropertyNode}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 5
    },
    {
        "name": "JSTypeRegistry.createNullableType#999",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }\n",
        "begin_line": 999,
        "end_line": 1001,
        "comment": "\n   * Creates a type representing nullable values of the given type.\n   * @return the union of the type and the Null type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1569
        },
        "num_failing_tests": 5
    },
    {
        "name": "ParserRunner.initResourceConfig#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
        "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n    reservedVars = extractList(config.getString(\"compiler.reserved.vars\"));\n  }\n",
        "begin_line": 82,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.AstValidator#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.AstValidator()",
        "snippet": "  public AstValidator() {\n    this.violationHandler = new ViolationHandler() {\n      @Override\n      public void handleViolation(String message, Node n) {\n        throw new IllegalStateException(\n            message + \" Reference node \" + n.toString());\n      }\n    };\n  }\n",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateCodeRoot#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateCodeRoot(com.google.javascript.rhino.Node)",
        "snippet": "  public void validateCodeRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateScript(c);\n    }\n  }\n",
        "begin_line": 75,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateScript#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateScript(com.google.javascript.rhino.Node)",
        "snippet": "  public void validateScript(Node n) {\n    validateNodeType(Token.SCRIPT, n);\n    validateHasSourceName(n);\n    validateHasInputId(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }\n",
        "begin_line": 83,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateExpression#154",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateExpression(com.google.javascript.rhino.Node)",
        "snippet": "  public void validateExpression(Node n) {\n    switch (n.getType()) {\n      // Childless expressions\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        validateChildless(n);\n        return;\n\n      // General unary ops\n      case Token.DELPROP:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.INC:\n      case Token.DEC:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.BITNOT:\n      case Token.CAST:\n        validateUnaryOp(n);\n        return;\n\n      // General binary ops\n      case Token.COMMA:\n      case Token.OR:\n      case Token.AND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n        validateBinaryOp(n);\n        return;\n\n      // Assignments\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        validateAssignmentExpression(n);\n        return;\n\n      case Token.HOOK:\n        validateTrinaryOp(n);\n        return;\n\n      // Node types that require special handling\n      case Token.STRING:\n        validateString(n);\n        return;\n\n      case Token.NUMBER:\n        validateNumber(n);\n        return;\n\n      case Token.NAME:\n        validateName(n);\n        return;\n\n      case Token.GETELEM:\n        validateBinaryOp(n);\n        return;\n\n      case Token.GETPROP:\n        validateGetProp(n);\n        return;\n\n      case Token.ARRAYLIT:\n        validateArrayLit(n);\n        return;\n\n      case Token.OBJECTLIT:\n        validateObjectLit(n);\n        return;\n\n      case Token.REGEXP:\n        validateRegExpLit(n);\n        return;\n\n      case Token.CALL:\n        validateCall(n);\n        return;\n\n      case Token.NEW:\n        validateNew(n);\n        return;\n\n      case Token.FUNCTION:\n        validateFunctionExpression(n);\n        return;\n\n      default:\n        violation(\"Expected expression but was \"\n            + Token.name(n.getType()), n);\n    }\n  }\n",
        "begin_line": 154,
        "end_line": 275,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateIsSynthetic#292",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateIsSynthetic(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateIsSynthetic(Node n) {\n    if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) {\n      violation(\"Missing 'synthetic block' annotation.\", n);\n    }\n  }\n",
        "begin_line": 292,
        "end_line": 296,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateHasSourceName#298",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateHasSourceName(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateHasSourceName(Node n) {\n    String sourceName = n.getSourceFileName();\n    if (sourceName == null || sourceName.isEmpty()) {\n      violation(\"Missing 'source name' annotation.\", n);\n    }\n  }\n",
        "begin_line": 298,
        "end_line": 303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateHasInputId#305",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateHasInputId(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateHasInputId(Node n) {\n    InputId inputId = n.getInputId();\n    if (inputId == null) {\n      violation(\"Missing 'input id' annotation.\", n);\n    }\n  }\n",
        "begin_line": 305,
        "end_line": 310,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateNonEmptyString#325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateNonEmptyString(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateNonEmptyString(Node n) {\n    validateNonNullString(n);\n    if (n.getString().isEmpty()) {\n      violation(\"Expected non-empty string.\", n);\n    }\n  }\n",
        "begin_line": 325,
        "end_line": 330,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateNonNullString#332",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateNonNullString(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateNonNullString(Node n) {\n    if (n.getString() == null) {\n      violation(\"Expected non-null string.\", n);\n    }\n  }\n",
        "begin_line": 332,
        "end_line": 336,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateName#338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateName(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonEmptyString(n);\n    validateChildCount(n, 0);\n  }\n",
        "begin_line": 338,
        "end_line": 342,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "AstValidator.validateNodeType#766",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateNodeType(int, com.google.javascript.rhino.Node)",
        "snippet": "  private void validateNodeType(int type, Node n) {\n    if (n.getType() != type) {\n      violation(\n          \"Expected \" + Token.name(type) + \" but was \"\n              + Token.name(n.getType()), n);\n    }\n  }\n",
        "begin_line": 766,
        "end_line": 772,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrototypeObjectType.getPropertyMap#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyMap()",
        "snippet": "  @Override\n  PropertyMap getPropertyMap() {\n    return properties;\n  }\n",
        "begin_line": 130,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "PrototypeObjectType.defineProperty#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    properties.putProperty(name, newProp);\n    return true;\n  }\n",
        "begin_line": 135,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "PrototypeObjectType.getConstructor#280",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
        "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }\n",
        "begin_line": 280,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "PropertyMap.getOwnProperty#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getOwnProperty(java.lang.String)",
        "snippet": "  Property getOwnProperty(String propertyName) {\n    return properties.get(propertyName);\n  }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "PropertyMap.putProperty#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.putProperty(java.lang.String, com.google.javascript.rhino.jstype.Property)",
        "snippet": "  void putProperty(String name, Property newProp) {\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred JsDoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n  }\n",
        "begin_line": 192,
        "end_line": 200,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "ObjectType.getOwnSlot#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getOwnSlot(String name) {\n    return getPropertyMap().getOwnProperty(name);\n  }\n",
        "begin_line": 120,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "ObjectType.hasOwnProperty#453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnProperty(java.lang.String)",
        "snippet": "  public boolean hasOwnProperty(String propertyName) {\n    return getOwnSlot(propertyName) != null;\n  }\n",
        "begin_line": 453,
        "end_line": 455,
        "comment": "\n   * Checks whether the property whose name is given is present directly on\n   * the object.  Returns false even if it is declared on a supertype.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "ObjectType.hasOwnDeclaredProperty#485",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(java.lang.String)",
        "snippet": "  final boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }\n",
        "begin_line": 485,
        "end_line": 487,
        "comment": "\n   * Whether the given property is declared on this object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "InstanceObjectType.defineProperty#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }\n",
        "begin_line": 89,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.isLabel#2273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isLabel()",
        "snippet": "  public boolean isLabel() {\n    return this.getType() == Token.LABEL;\n  }\n",
        "begin_line": 2273,
        "end_line": 2275,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.SyntacticScopeCreator#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.SyntacticScopeCreator.RedeclarationHandler)",
        "snippet": "  SyntacticScopeCreator(\n      AbstractCompiler compiler, RedeclarationHandler redeclarationHandler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = redeclarationHandler;\n  }\n",
        "begin_line": 61,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.getJSDocInfo#249",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getJSDocInfo()",
        "snippet": "    @Override\n    public JSDocInfo getJSDocInfo() {\n      return nameNode == null ? null : NodeUtil.getBestJSDocInfo(nameNode);\n    }\n",
        "begin_line": 249,
        "end_line": 252,
        "comment": "\n     * Gets the JSDocInfo for the variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.enterScope#824",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.ScopeTicklingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }\n",
        "begin_line": 824,
        "end_line": 829,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.exitScope#831",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.ScopeTicklingCallback.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }\n",
        "begin_line": 831,
        "end_line": 834,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.shouldTraverse#836",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.ScopeTicklingCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }\n",
        "begin_line": 836,
        "end_line": 840,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.visit#842",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.ScopeTicklingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }\n",
        "begin_line": 842,
        "end_line": 845,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.PropagateConstantAnnotationsOverVars#224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.PropagateConstantAnnotationsOverVars.PropagateConstantAnnotationsOverVars(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "    PropagateConstantAnnotationsOverVars(\n        AbstractCompiler compiler, boolean forbidChanges) {\n      this.compiler = compiler;\n      this.assertOnChange = forbidChanges;\n    }\n",
        "begin_line": 224,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.process#230",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.PropagateConstantAnnotationsOverVars.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }\n",
        "begin_line": 230,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.visit#235",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.PropagateConstantAnnotationsOverVars.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.isName()) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top-level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        boolean shouldBeConstant =\n            (info != null && info.isConstant()) ||\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent);\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (shouldBeConstant && !isMarkedConstant) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }\n",
        "begin_line": 235,
        "end_line": 266,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.NormalizeStatements#360",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.NormalizeStatements(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "    NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) {\n      this.compiler = compiler;\n      this.assertOnChange = assertOnChange;\n    }\n",
        "begin_line": 360,
        "end_line": 363,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.shouldTraverse#373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }\n",
        "begin_line": 373,
        "end_line": 378,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.annotateConstantsByConvention#418",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.annotateConstantsByConvention(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.isName()\n          || n.isString()\n          || n.isStringKey()\n          || n.isGetterDef()\n          || n.isSetterDef());\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.isGetProp() &&\n           parent.getLastChild() == n);\n      if (n.isName() || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }\n",
        "begin_line": 418,
        "end_line": 448,
        "comment": "\n     * Mark names and properties that are constants by convention.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.extractForInitializer#564",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.extractForInitializer(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.isVar()) {\n                // Transform:\n                //    for (var a = 1 in b) {}\n                // to:\n                //    var a = 1; for (a in b) {};\n                Node newStatement = first;\n                // Clone just the node, to remove any initialization.\n                Node name = newStatement.getFirstChild().cloneNode();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (!c.getFirstChild().isEmpty()) {\n              Node init = c.getFirstChild();\n              Node empty = IR.empty();\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.isVar()) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }\n",
        "begin_line": 564,
        "end_line": 611,
        "comment": "\n     * Bring the initializers out of FOR loops.  These need to be placed\n     * before any associated LABEL nodes. This needs to be done from the top\n     * level label first so this is called as a pre-order callback (from\n     * shouldTraverse).\n     *\n     * @param n The node to inspect.\n     * @param before The node to insert the initializer before.\n     * @param beforeParent The parent of the node before which the initializer\n     *     will be inserted.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.splitVarDeclarations#621",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.NormalizeStatements.splitVarDeclarations(com.google.javascript.rhino.Node)",
        "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.isVar()) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = IR.var(name).srcref(n);\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }\n",
        "begin_line": 621,
        "end_line": 638,
        "comment": "\n     * Split a var node such as:\n     *   var a, b;\n     * into individual statements:\n     *   var a;\n     *   var b;\n     * @param n The whose children we should inspect.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.visit#167",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.FindExposeAnnotations.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (NodeUtil.isExprAssign(n)) {\n        Node assign = n.getFirstChild();\n        Node lhs = assign.getFirstChild();\n        if (lhs.isGetProp() && isMarkedExpose(assign)) {\n          exposedProperties.add(lhs.getLastChild().getString());\n        }\n      } else if (n.isStringKey() && isMarkedExpose(n)) {\n        exposedProperties.add(n.getString());\n      }\n    }\n",
        "begin_line": 167,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.Normalize#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.Normalize(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }\n",
        "begin_line": 79,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.process#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    FindExposeAnnotations findExposeAnnotations = new FindExposeAnnotations();\n    NodeTraversal.traverse(compiler, root, findExposeAnnotations);\n    if (!findExposeAnnotations.exposedProperties.isEmpty()) {\n      NodeTraversal.traverse(compiler, root,\n          new RewriteExposedProperties(\n              findExposeAnnotations.exposedProperties));\n    }\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.removeDuplicateDeclarations#696",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }\n",
        "begin_line": 696,
        "end_line": 702,
        "comment": "\n   * Remove duplicate VAR declarations.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isConstantByConvention#2827",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isConstantByConvention(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.isGetProp() &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }\n",
        "begin_line": 2827,
        "end_line": 2838,
        "comment": " Whether the given name is constant by coding convention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.ContextualRenamer#437",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.ContextualRenamer()",
        "snippet": "    ContextualRenamer() {\n      this.global = true;\n      nameUsage = HashMultiset.create();\n    }\n",
        "begin_line": 437,
        "end_line": 440,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.getReplacementName#480",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.getReplacementName(java.lang.String)",
        "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }\n",
        "begin_line": 480,
        "end_line": 483,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.reserveName#492",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.reserveName(java.lang.String)",
        "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }\n",
        "begin_line": 492,
        "end_line": 494,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
        "snippet": "  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }\n",
        "begin_line": 63,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique(com.google.javascript.jscomp.MakeDeclaredNamesUnique.Renamer)",
        "snippet": "  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }\n",
        "begin_line": 67,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "MakeDeclaredNamesUnique.getReplacementName#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(java.lang.String)",
        "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 198,
        "end_line": 206,
        "comment": "\n   * Walks the stack of name maps and finds the replacement name for the\n   * current scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractCompiler.isNormalized#289",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCompiler.java",
        "class_name": "com.google.javascript.jscomp.AbstractCompiler",
        "signature": "com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage.isNormalized()",
        "snippet": "    boolean isNormalized() {\n      return this == NORMALIZED || this == NORMALIZED_OBFUSCATED;\n    }\n",
        "begin_line": 289,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractCompiler.isNormalizedObfuscated#297",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCompiler.java",
        "class_name": "com.google.javascript.jscomp.AbstractCompiler",
        "signature": "com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage.isNormalizedObfuscated()",
        "snippet": "    boolean isNormalizedObfuscated() {\n      return this == NORMALIZED_OBFUSCATED;\n    }\n",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractCompiler.getLifeCycleStage#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCompiler.java",
        "class_name": "com.google.javascript.jscomp.AbstractCompiler",
        "signature": "com.google.javascript.jscomp.AbstractCompiler.getLifeCycleStage()",
        "snippet": "  LifeCycleStage getLifeCycleStage() {\n    return stage;\n  }\n",
        "begin_line": 185,
        "end_line": 187,
        "comment": "\n   * @return The current life-cycle stage of the AST we're working on.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractCompiler.setLifeCycleStage#250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCompiler.java",
        "class_name": "com.google.javascript.jscomp.AbstractCompiler",
        "signature": "com.google.javascript.jscomp.AbstractCompiler.setLifeCycleStage(com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage)",
        "snippet": "  void setLifeCycleStage(LifeCycleStage stage) {\n    this.stage = stage;\n  }\n",
        "begin_line": 250,
        "end_line": 252,
        "comment": "\n   * Set the current life-cycle state.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isDec#2205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isDec()",
        "snippet": "  public boolean isDec() {\n    return this.getType() == Token.DEC;\n  }\n",
        "begin_line": 2205,
        "end_line": 2207,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isInc#2265",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isInc()",
        "snippet": "  public boolean isInc() {\n    return this.getType() == Token.INC;\n  }\n",
        "begin_line": 2265,
        "end_line": 2267,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isStringKey#2337",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isStringKey()",
        "snippet": "  public boolean isStringKey() {\n    return this.getType() == Token.STRING_KEY;\n  }\n",
        "begin_line": 2337,
        "end_line": 2339,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1559
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverseRoots#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(com.google.javascript.rhino.Node...)",
        "snippet": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }\n",
        "begin_line": 284,
        "end_line": 286,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1559
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isVarDeclaration#1565",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isVarDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.isName() && n.getParent().isVar();\n  }\n",
        "begin_line": 1565,
        "end_line": 1569,
        "comment": "\n   * Is this node the name of a variable being declared?\n   *\n   * @param n The node\n   * @return True if {@code n} is NAME and {@code parent} is VAR\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1555
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isHoistedFunctionDeclaration#1919",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }\n",
        "begin_line": 1919,
        "end_line": 1923,
        "comment": "\n   * Is this node a hoisted function declaration? A function declaration in the\n   * scope root is hoisted to the top of the scope.\n   * See {@link #isFunctionDeclaration}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1555
        },
        "num_failing_tests": 8
    },
    {
        "name": "Normalize.VerifyConstants#278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.VerifyConstants.VerifyConstants(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n      this.compiler = compiler;\n      this.checkUserDeclarations = checkUserDeclarations;\n    }\n",
        "begin_line": 278,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1552
        },
        "num_failing_tests": 4
    },
    {
        "name": "Normalize.process#283",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.VerifyConstants.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }\n",
        "begin_line": 283,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1552
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeConsumer.addNumber#240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.addNumber(double)",
        "snippet": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n\n    if (negativeZero) {\n      addConstant(\"-0\");\n    } else if ((long) x == x) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        addConstant(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        long valueAbs = Math.abs(value);\n        if (Long.toHexString(valueAbs).length() + 2 <\n            Long.toString(valueAbs).length()) {\n          addConstant((value < 0 ? \"-\" : \"\") + \"0x\" +\n              Long.toHexString(valueAbs));\n        } else {\n          addConstant(Long.toString(value));\n        }\n      }\n    } else {\n      addConstant(String.valueOf(x).replace(\".0E\", \"E\"));\n    }\n  }\n",
        "begin_line": 240,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.155
        },
        "num_failing_tests": 5
    },
    {
        "name": "CodeConsumer.isNegativeZero#282",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.isNegativeZero(double)",
        "snippet": "  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }\n",
        "begin_line": 282,
        "end_line": 284,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.155
        },
        "num_failing_tests": 5
    },
    {
        "name": "NodeTraversal.getScopeRoot#624",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
        "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }\n",
        "begin_line": 624,
        "end_line": 630,
        "comment": " Returns the current scope's root. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1548
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getIntValue#331",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.getIntValue()",
        "snippet": "    @Override\n    public int getIntValue() {\n      return intValue;\n    }\n",
        "begin_line": 331,
        "end_line": 334,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1545
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getIntProp#816",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
        "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.getIntValue();\n  }\n",
        "begin_line": 816,
        "end_line": 822,
        "comment": "\n   * Returns the integer value for the property, or 0 if the property\n   * is not defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1545
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isExprAssign#1594",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isExprAssign(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isExprAssign(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isAssign();\n  }\n",
        "begin_line": 1594,
        "end_line": 1597,
        "comment": "\n   * Is this node an assignment expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is ASSIGN\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 8
    },
    {
        "name": "InlineVariables.apply#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.IdentifyLocals.apply(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    @Override\n    public boolean apply(Var var) {\n      return var.scope.isLocal();\n    }\n",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.getFilterForMode#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.getFilterForMode()",
        "snippet": "  private Predicate<Var> getFilterForMode() {\n    switch (mode) {\n      case ALL:\n        return Predicates.<Var>alwaysTrue();\n      case LOCALS_ONLY:\n        return new IdentifyLocals();\n      case CONSTANTS_ONLY:\n        return new IdentifyConstants();\n      default:\n        throw new IllegalStateException();\n    }\n  }\n",
        "begin_line": 89,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1604",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-6bf8f200-d41d-4a23-9827-9c55742c2afd.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      if (isInliningForbidden()) {\n        // In old renaming schemes, inlining a variable can change whether\n        // or not a property is renamed. This is bad, and those old renaming\n        // schemes need to die.\n        return new ErrorPass(compiler, CANNOT_USE_PROTOTYPE_AND_VAR);\n      } else {\n        InlineVariables.Mode mode;\n        if (options.inlineVariables) {\n          mode = InlineVariables.Mode.ALL;\n        } else if (options.inlineLocalVariables) {\n          mode = InlineVariables.Mode.LOCALS_ONLY;\n        } else {\n          throw new IllegalStateException(\"No variable inlining option set.\");\n        }\n\n        return new InlineVariables(compiler, mode, true);\n      }\n    }\n",
        "begin_line": 1604,
        "end_line": 1623,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1543
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.hasChildren#527",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasChildren()",
        "snippet": "  public boolean hasChildren() {\n    return first != null;\n  }\n",
        "begin_line": 527,
        "end_line": 529,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1541
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.hasOneChild#1372",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasOneChild()",
        "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }\n",
        "begin_line": 1372,
        "end_line": 1374,
        "comment": "\n   * Check for one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has exactly one child.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1538
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.createScope#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    inputId = null;\n    if (parent == null) {\n      scope = Scope.createGlobalScope(n);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    inputId = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }\n",
        "begin_line": 67,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1534
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.scanVars#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().isName());\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        inputId = n.getInputId();\n        Preconditions.checkNotNull(inputId);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }\n",
        "begin_line": 124,
        "end_line": 178,
        "comment": "\n   * Scans and gather variables declarations under a Node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1534
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.Scope#386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Scope(com.google.javascript.jscomp.Scope, com.google.javascript.rhino.Node)",
        "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }\n",
        "begin_line": 386,
        "end_line": 394,
        "comment": "\n   * Creates a Scope given the parent Scope and the root node of the scope.\n   * @param parent  The parent Scope. Cannot be null.\n   * @param rootNode  Typically the FUNCTION node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1534
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverseRoots#462",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(com.google.javascript.jscomp.AbstractCompiler, java.util.List<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n",
        "begin_line": 462,
        "end_line": 466,
        "comment": "\n   * Traverses a list of node trees.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1534
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.init#353",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.init(java.util.List<T1>, java.util.List<T2>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n",
        "begin_line": 353,
        "end_line": 363,
        "comment": "\n   * Initializes the instance state needed for a compile job.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1534
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isParamList#2313",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isParamList()",
        "snippet": "  public boolean isParamList() {\n    return this.getType() == Token.PARAM_LIST;\n  }\n",
        "begin_line": 2313,
        "end_line": 2315,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1532
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverseRoots#288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(java.util.List<com.google.javascript.rhino.Node>)",
        "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n",
        "begin_line": 288,
        "end_line": 311,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1532
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getBooleanProp#808",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
        "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }\n",
        "begin_line": 808,
        "end_line": 810,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1529
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.getCodingConvention#1368",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
        "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }\n",
        "begin_line": 1368,
        "end_line": 1370,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1529
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getCodingConvention#1989",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
        "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n",
        "begin_line": 1989,
        "end_line": 1994,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1529
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isFunctionDeclaration#1910",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }\n",
        "begin_line": 1910,
        "end_line": 1912,
        "comment": "\n   * Is this node a function declaration? A function declaration is a function\n   * that has a name that is added to the current scope (i.e. a function that\n   * is not part of a expression; see {@link #isFunctionExpression}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1527
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isObjectLitKey#2073",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 2073,
        "end_line": 2081,
        "comment": "\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1527
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.NodeTraversal#229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.NodeTraversal.Callback, com.google.javascript.jscomp.ScopeCreator)",
        "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }\n",
        "begin_line": 229,
        "end_line": 239,
        "comment": "\n   * Creates a node traversal using the specified callback interface\n   * and the scope creator.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1527
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.pushScope#563",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(com.google.javascript.rhino.Node)",
        "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n",
        "begin_line": 563,
        "end_line": 570,
        "comment": " Creates a new scope (e.g. when entering a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1527
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.popScope#583",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
        "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }\n",
        "begin_line": 583,
        "end_line": 593,
        "comment": " Pops back to the previous scope (e.g. when leaving a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1527
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.getScope#596",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
        "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }\n",
        "begin_line": 596,
        "end_line": 610,
        "comment": " Gets the current scope. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.inGlobalScope#635",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
        "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }\n",
        "begin_line": 635,
        "end_line": 637,
        "comment": "\n   * Determines whether the traversal is currently in the global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.getScopeDepth#639",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
        "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }\n",
        "begin_line": 639,
        "end_line": 641,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.isImplicitPrototype#538",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 538,
        "end_line": 547,
        "comment": "\n   * Checks that the prototype is an implicit prototype of this object. Since\n   * each object has an implicit prototype, an implicit prototype's\n   * implicit prototype is also this implicit prototype's.\n   *\n   * @param prototype any prototype based object\n   *\n   * @return {@code true} if {@code prototype} is {@code equal} to any\n   *         object in this object's implicit prototype chain.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "LineNumberCheck.LineNumberCheck#40",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LineNumberCheck.java",
        "class_name": "com.google.javascript.jscomp.LineNumberCheck",
        "signature": "com.google.javascript.jscomp.LineNumberCheck.LineNumberCheck(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  LineNumberCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "LineNumberCheck.process#50",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LineNumberCheck.java",
        "class_name": "com.google.javascript.jscomp.LineNumberCheck",
        "signature": "com.google.javascript.jscomp.LineNumberCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    requiresLineNumbers = false;\n\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "LineNumberCheck.shouldTraverse#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LineNumberCheck.java",
        "class_name": "com.google.javascript.jscomp.LineNumberCheck",
        "signature": "com.google.javascript.jscomp.LineNumberCheck.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    // Each JavaScript file is rooted in a script node, so we'll only\n    // have line number information inside the script node.\n    if (n.isScript()) {\n      requiresLineNumbers = true;\n    }\n    return true;\n  }\n",
        "begin_line": 57,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.handleFunction#525",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n",
        "begin_line": 525,
        "end_line": 532,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateRoot#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateRoot(com.google.javascript.rhino.Node)",
        "snippet": "  public void validateRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    validateChildCount(n, 2);\n    validateCodeRoot(n.getFirstChild());\n    validateCodeRoot(n.getLastChild());\n  }\n",
        "begin_line": 67,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1525
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getVar#528",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getVar(java.lang.String)",
        "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 528,
        "end_line": 537,
        "comment": "\n   * Returns the variable, may be null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1523
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setString#216",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.setString(java.lang.String)",
        "snippet": "    @Override\n    public void setString(String str) {\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }\n",
        "begin_line": 216,
        "end_line": 222,
        "comment": "\n     * sets the string content.\n     * @param str the new value.  Non null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.isAssign#2161",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isAssign()",
        "snippet": "  public boolean isAssign() {\n    return this.getType() == Token.ASSIGN;\n  }\n",
        "begin_line": 2161,
        "end_line": 2163,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.declareVar#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(com.google.javascript.rhino.Node)",
        "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.isName());\n\n    CompilerInput input = compiler.getInput(inputId);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }\n",
        "begin_line": 233,
        "end_line": 245,
        "comment": "\n   * Declares a variable.\n   *\n   * @param n The node corresponding to the variable name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.Var#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.Var(boolean, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.Scope, int, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "    private Var(boolean inferred, String name, Node nameNode, JSType type,\n                Scope scope, int index, CompilerInput input) {\n      this.name = name;\n      this.nameNode = nameNode;\n      this.type = type;\n      this.scope = scope;\n      this.index = index;\n      this.input = input;\n      this.typeInferred = inferred;\n    }\n",
        "begin_line": 120,
        "end_line": 129,
        "comment": "\n     * Creates a variable.\n     *\n     * @param inferred whether its type is inferred (as opposed to declared)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.Scope#402",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Scope(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private Scope(Node rootNode, boolean isBottom) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    this.isBottom = isBottom;\n    this.depth = 0;\n  }\n",
        "begin_line": 402,
        "end_line": 407,
        "comment": "\n   * Creates a empty Scope (bottom of the lattice).\n   * @param rootNode Typically a FUNCTION node or the global BLOCK node.\n   * @param isBottom Whether this is the bottom of a lattice. Otherwise,\n   *     it must be a global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.createGlobalScope#409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.createGlobalScope(com.google.javascript.rhino.Node)",
        "snippet": "  static Scope createGlobalScope(Node rootNode) {\n    return new Scope(rootNode, false);\n  }\n",
        "begin_line": 409,
        "end_line": 411,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.getParent#436",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getParent()",
        "snippet": "  public Scope getParent() {\n    return parent;\n  }\n",
        "begin_line": 436,
        "end_line": 438,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.declare#479",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.declare(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }\n",
        "begin_line": 479,
        "end_line": 481,
        "comment": "\n   * Declares a variable whose type is inferred.\n   *\n   * @param name name of the variable\n   * @param nameNode the NAME node declaring the variable\n   * @param type the variable's type\n   * @param input the input in which this variable is defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.declare#493",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.declare(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.jscomp.CompilerInput, boolean)",
        "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input);\n    vars.put(name, var);\n    return var;\n  }\n",
        "begin_line": 493,
        "end_line": 503,
        "comment": "\n   * Declares a variable.\n   *\n   * @param name name of the variable\n   * @param nameNode the NAME node declaring the variable\n   * @param type the variable's type\n   * @param input the input in which this variable is defined.\n   * @param inferred Whether this variable's type is inferred (as opposed\n   *     to declared).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.isDeclared#552",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isDeclared(java.lang.String, boolean)",
        "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }\n",
        "begin_line": 552,
        "end_line": 561,
        "comment": "\n   * Returns true if a variable is declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.isGlobal#602",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
        "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }\n",
        "begin_line": 602,
        "end_line": 604,
        "comment": "\n   * Returns whether this is the global scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Scope.isLocal#609",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.isLocal()",
        "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }\n",
        "begin_line": 609,
        "end_line": 611,
        "comment": "\n   * Returns whether this is a local scope (i.e. not the global scope).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isControlStructure#1670",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1670,
        "end_line": 1687,
        "comment": "\n   * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isStatementBlock#1748",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }\n",
        "begin_line": 1748,
        "end_line": 1750,
        "comment": "\n   * @return Whether the node is of a type that contain other statements.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1521
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isGetProp#2249",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isGetProp()",
        "snippet": "  public boolean isGetProp() {\n    return this.getType() == Token.GETPROP;\n  }\n",
        "begin_line": 2249,
        "end_line": 2251,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1518
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getInput#1044",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getInput(com.google.javascript.rhino.InputId)",
        "snippet": "  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n",
        "begin_line": 1044,
        "end_line": 1047,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1518
        },
        "num_failing_tests": 8
    },
    {
        "name": "RenameVars.visit#210",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.ProcessVars.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isName()) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      // Bleeding functions should be treated as part of their outer\n      // scope, because IE has bugs in how it handles bleeding\n      // functions.\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal() &&\n          (!var.scope.getParent().isGlobal() ||\n           !var.isBleedingFunction());\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming function expression names?\n      if (preserveFunctionExpressionNames && var != null\n          && NodeUtil.isFunctionExpression(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n        if (local) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n          String newName = MakeDeclaredNamesUnique.ContextualRenameInverter\n              .getOrginalName(name);\n          if (!newName.equals(name)) {\n            n.setString(newName);\n          }\n        }\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (pseudoNameMap != null) {\n        recordPseudoName(n);\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + getLocalVarIndex(var);\n        incCount(tempName);\n        localNameNodes.add(n);\n        n.setString(tempName);\n      } else if (var != null) { // Not an extern\n        // If it's global, increment global count\n        incCount(name);\n        globalNameNodes.add(n);\n      }\n    }\n",
        "begin_line": 210,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1516
        },
        "num_failing_tests": 4
    },
    {
        "name": "GoogleCodingConvention.isExported#139",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isExported(java.lang.String, boolean)",
        "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return super.isExported(name, local) ||\n        (!local && name.startsWith(\"_\"));\n  }\n",
        "begin_line": 139,
        "end_line": 143,
        "comment": "\n   * {@inheritDoc}\n   *\n   * <p>In Google code, any global name starting with an underscore is\n   * considered exported.\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.CodingConventions.Proxy": null
        },
        "susp": {
            "ochiai_susp": 0.1516
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.isExprResult#2225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isExprResult()",
        "snippet": "  public boolean isExprResult() {\n    return this.getType() == Token.EXPR_RESULT;\n  }\n",
        "begin_line": 2225,
        "end_line": 2227,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.151
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isVar#2365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isVar()",
        "snippet": "  public boolean isVar() {\n    return this.getType() == Token.VAR;\n  }\n",
        "begin_line": 2365,
        "end_line": 2367,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.151
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.getInputId#2890",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getInputId(com.google.javascript.rhino.Node)",
        "snippet": "  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }\n",
        "begin_line": 2890,
        "end_line": 2896,
        "comment": "\n   * @param n The node.\n   * @return The InputId property on the node or its ancestors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.151
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.shouldTraverse#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n",
        "begin_line": 130,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1503
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroupWarningsGuard.enables#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 48,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1501
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.hoistExterns#1409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.hoistExterns(com.google.javascript.rhino.Node)",
        "snippet": "  private void hoistExterns(Node externsRoot) {\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (options.dependencyOptions.needsManagement()) {\n        // If we're doing scanning dependency info anyway, use that\n        // information to skip sources that obviously aren't externs.\n        if (!input.getProvides().isEmpty() || !input.getRequires().isEmpty()) {\n          continue;\n        }\n      }\n\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST on a parse error.\n      if (n == null) {\n        continue;\n      }\n\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.isExterns()) {\n        // If the input file is explicitly marked as an externs file, then\n        // assume the programmer made a mistake and throw it into\n        // the externs pile anyways.\n        externsRoot.addChildToBack(n);\n        input.setIsExtern(true);\n\n        input.getModule().remove(input);\n\n        externs.add(input);\n        staleInputs = true;\n      }\n    }\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n  }\n",
        "begin_line": 1409,
        "end_line": 1445,
        "comment": "\n   * Hoists inputs with the @externs annotation into the externs list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1499
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getString#207",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.getString()",
        "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }\n",
        "begin_line": 207,
        "end_line": 210,
        "comment": "\n     * returns the string content.\n     * @return non null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1497
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getLastChild#535",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getLastChild()",
        "snippet": "  public Node getLastChild() {\n    return last;\n  }\n",
        "begin_line": 535,
        "end_line": 537,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1497
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.setWarningLevel#1124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(com.google.javascript.jscomp.DiagnosticGroup, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }\n",
        "begin_line": 1124,
        "end_line": 1126,
        "comment": "\n   * Configure the given type of warning to the given level.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1497
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.parseInputs#1282",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
        "snippet": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement()) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n",
        "begin_line": 1282,
        "end_line": 1404,
        "comment": "\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1495
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.addWarningsGuard#1150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }\n",
        "begin_line": 1150,
        "end_line": 1152,
        "comment": "\n   * Add a guard to the set of warnings guards.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1493
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getErrorCount#2111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
        "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n",
        "begin_line": 2111,
        "end_line": 2113,
        "comment": "\n   * Gets the number of errors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1493
        },
        "num_failing_tests": 8
    },
    {
        "name": "TypeSafeDispatcher.process#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java",
        "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
        "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return (node instanceof EmptyExpression) ?\n            processEmptyExpression((EmptyExpression) node) :\n            processEmptyStatement((EmptyStatement) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }\n",
        "begin_line": 120,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processGeneric#474",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processGeneric(com.google.javascript.rhino.head.Node)",
        "snippet": "    private Node processGeneric(\n        com.google.javascript.rhino.head.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.rhino.head.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }\n",
        "begin_line": 474,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processBlock#579",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processBlock(com.google.javascript.rhino.head.ast.Block)",
        "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n",
        "begin_line": 579,
        "end_line": 582,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.visit#132",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }\n",
        "begin_line": 132,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.annotateDispatchers#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.annotateDispatchers(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.isFunction());\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.isAssign()) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }\n",
        "begin_line": 179,
        "end_line": 188,
        "comment": "\n     * Translate dispatcher info into the property expected node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isFunctionExpression#1948",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }\n",
        "begin_line": 1948,
        "end_line": 1950,
        "comment": "\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverseBranch#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }\n",
        "begin_line": 477,
        "end_line": 506,
        "comment": "\n   * Traverses a branch.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverseFunction#511",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }\n",
        "begin_line": 511,
        "end_line": 546,
        "comment": "\n   * Traverses a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isStatement#1755",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }\n",
        "begin_line": 1755,
        "end_line": 1757,
        "comment": "\n   * @return Whether the node is used as a statement.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1489
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.isStatementParent#1759",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1759,
        "end_line": 1772,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1489
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.makeCompilerInput#424",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(java.util.List<T>, boolean)",
        "snippet": "  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n",
        "begin_line": 424,
        "end_line": 431,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1487
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.initInputsByIdMap#518",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initInputsByIdMap()",
        "snippet": "  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n",
        "begin_line": 518,
        "end_line": 534,
        "comment": "\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1487
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getErrors#983",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
        "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n",
        "begin_line": 983,
        "end_line": 985,
        "comment": "\n   * Returns the array of errors (never null).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1487
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getWarnings#990",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
        "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n",
        "begin_line": 990,
        "end_line": 992,
        "comment": "\n   * Returns the array of warnings (never null).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1487
        },
        "num_failing_tests": 8
    },
    {
        "name": "BasicErrorManager.getWarnings#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
        "snippet": "  @Override\n  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }\n",
        "begin_line": 89,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1487
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.setCodingConvention#1364",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }\n",
        "begin_line": 1364,
        "end_line": 1366,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.initModules#381",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initModules(java.util.List<T>, java.util.List<com.google.javascript.jscomp.JSModule>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n",
        "begin_line": 381,
        "end_line": 411,
        "comment": "\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.hoistNoCompileFiles#1450",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.hoistNoCompileFiles()",
        "snippet": "  private void hoistNoCompileFiles() {\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST on a parse error.\n      if (n == null) {\n        continue;\n      }\n\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.isNoCompile()) {\n        input.getModule().remove(input);\n        staleInputs = true;\n      }\n    }\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n  }\n",
        "begin_line": 1450,
        "end_line": 1470,
        "comment": "\n   * Hoists inputs with the @nocompiler annotation out of the inputs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "BasicErrorManager.getWarningCount#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
        "snippet": "  @Override\n  public int getWarningCount() {\n    return warningCount;\n  }\n",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "BasicErrorManager.getErrors#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
        "snippet": "  @Override\n  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "BasicErrorManager.toArray#104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }\n",
        "begin_line": 104,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1485
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getChildCount#1386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getChildCount()",
        "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }\n",
        "begin_line": 1386,
        "end_line": 1392,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isBlock#2169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isBlock()",
        "snippet": "  public boolean isBlock() {\n    return this.getType() == Token.BLOCK;\n  }\n",
        "begin_line": 2169,
        "end_line": 2171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isFunction#2237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFunction()",
        "snippet": "  public boolean isFunction() {\n    return this.getType() == Token.FUNCTION;\n  }\n",
        "begin_line": 2237,
        "end_line": 2239,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "ParserRunner.createConfig#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean, com.google.javascript.jscomp.parsing.Config.LanguageMode, boolean, java.util.Set<java.lang.String>)",
        "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }\n",
        "begin_line": 61,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processAstRoot#534",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processAstRoot(com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.rhino.head.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }\n",
        "begin_line": 534,
        "end_line": 542,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.isDirective#570",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.isDirective(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n",
        "begin_line": 570,
        "end_line": 577,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processName#851",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processName(com.google.javascript.rhino.head.ast.Name)",
        "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }\n",
        "begin_line": 851,
        "end_line": 854,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.processName#856",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processName(com.google.javascript.rhino.head.ast.Name, boolean)",
        "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }\n",
        "begin_line": 856,
        "end_line": 868,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.isReservedKeyword#873",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.isReservedKeyword(java.lang.String)",
        "snippet": "    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }\n",
        "begin_line": 873,
        "end_line": 875,
        "comment": "\n     * @return Whether the\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.newStringNode#1442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int, java.lang.String)",
        "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1442,
        "end_line": 1444,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSModule.add#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.add(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public void add(SourceFile file) {\n    add(new CompilerInput(file));\n  }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": " Adds a source file input to this module. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "BasicErrorManager.getErrorCount#74",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
        "snippet": "  @Override\n  public int getErrorCount() {\n    return errorCount;\n  }\n",
        "begin_line": 74,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.148
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.StringNode#187",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.StringNode(int, java.lang.String)",
        "snippet": "    StringNode(int type, String str) {\n      super(type);\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }\n",
        "begin_line": 187,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.chain#346",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.chain(com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }\n",
        "begin_line": 346,
        "end_line": 349,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.newString#507",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(int, java.lang.String)",
        "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }\n",
        "begin_line": 507,
        "end_line": 509,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getNext#539",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getNext()",
        "snippet": "  public Node getNext() {\n    return next;\n  }\n",
        "begin_line": 539,
        "end_line": 541,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.addChildToBack#599",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.addChildToBack(com.google.javascript.rhino.Node)",
        "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }\n",
        "begin_line": 599,
        "end_line": 610,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.clonePropsFrom#765",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.clonePropsFrom(com.google.javascript.rhino.Node)",
        "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }\n",
        "begin_line": 765,
        "end_line": 770,
        "comment": "\n   * Clone the properties from the provided node without copying\n   * the property object.  The receiving node may not have any\n   * existing properties.\n   * @param other The node to clone properties from.\n   * @return this node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.removeProp#772",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeProp(int)",
        "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }\n",
        "begin_line": 772,
        "end_line": 777,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.removeProp#785",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeProp(com.google.javascript.rhino.Node.PropListItem, int)",
        "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }\n",
        "begin_line": 785,
        "end_line": 798,
        "comment": "\n   * @param item The item to inspect\n   * @param propType The property to look for\n   * @return The replacement list if the property was removed, or\n   *   'item' otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getLineno#1121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getLineno()",
        "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }\n",
        "begin_line": 1121,
        "end_line": 1123,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setCharno#1153",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setCharno(int)",
        "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }\n",
        "begin_line": 1153,
        "end_line": 1155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.extractLineno#1190",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
        "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }\n",
        "begin_line": 1190,
        "end_line": 1196,
        "comment": "\n   * Extracts the line number and character number from a merged line char\n   * number (see {@link #mergeLineCharNo(int, int)}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getParent#1304",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getParent()",
        "snippet": "  public Node getParent() {\n    return parent;\n  }\n",
        "begin_line": 1304,
        "end_line": 1306,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getJsDocBuilderForNode#1816",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
        "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }\n",
        "begin_line": 1816,
        "end_line": 1818,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isName#2281",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isName()",
        "snippet": "  public boolean isName() {\n    return this.getType() == Token.NAME;\n  }\n",
        "begin_line": 2281,
        "end_line": 2283,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isObjectLit#2305",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isObjectLit()",
        "snippet": "  public boolean isObjectLit() {\n    return this.getType() == Token.OBJECTLIT;\n  }\n",
        "begin_line": 2305,
        "end_line": 2307,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "InputId.getIdName#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.getIdName()",
        "snippet": "  public String getIdName() {\n    return id;\n  }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IR.block#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.block()",
        "snippet": "  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IR.block#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.block(com.google.javascript.rhino.Node...)",
        "snippet": "  public static Node block(Node ... stmts) {\n    Node block = block();\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n",
        "begin_line": 102,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IR.mayBeStatementNoReturn#499",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.mayBeStatementNoReturn(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean mayBeStatementNoReturn(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 499,
        "end_line": 528,
        "comment": "\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IR.mayBeStatement#534",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.mayBeStatement(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean mayBeStatement(Node n) {\n    if (!mayBeStatementNoReturn(n)) {\n      return n.isReturn();\n    }\n    return true;\n  }\n",
        "begin_line": 534,
        "end_line": 539,
        "comment": "\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "ParserRunner.ParseResult#163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.ParseResult.ParseResult(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "    public ParseResult(Node ast, AstRoot oldAst) {\n      this.ast = ast;\n      this.oldAst = oldAst;\n    }\n",
        "begin_line": 163,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "ParserRunner.extractList#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(java.lang.String)",
        "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }\n",
        "begin_line": 93,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "ParserRunner.parse#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(com.google.javascript.rhino.jstype.StaticSourceFile, java.lang.String, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter, java.util.logging.Logger)",
        "snippet": "  public static ParseResult parse(StaticSourceFile sourceFile,\n                                  String sourceString,\n                                  Config config,\n                                  ErrorReporter errorReporter,\n                                  Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    // Do our own identifier check for ECMASCRIPT 5\n    boolean acceptEs5 =\n        config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;\n    compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return new ParseResult(root, astRoot);\n  }\n",
        "begin_line": 111,
        "end_line": 154,
        "comment": "\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.parseDirectives#553",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.parseDirectives(com.google.javascript.rhino.Node)",
        "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }\n",
        "begin_line": 553,
        "end_line": 568,
        "comment": "\n     * Parse the directives, encode them in the AST, and remove their nodes.\n     *\n     * For information on ES5 directives, see section 14.1 of\n     * ECMA-262, Edition 5.\n     *\n     * It would be nice if Rhino would eventually take care of this for\n     * us, but right now their directive-processing is a one-off.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.createTemplateNode#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
        "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }\n",
        "begin_line": 172,
        "end_line": 177,
        "comment": " This reduces the cost of these properties to O(nodes) to O(files).",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.transformTree#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(com.google.javascript.rhino.head.ast.AstRoot, com.google.javascript.rhino.jstype.StaticSourceFile, java.lang.String, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }\n",
        "begin_line": 179,
        "end_line": 202,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.setFileOverviewJsDoc#204",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(com.google.javascript.rhino.Node)",
        "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo();\n    if (rootNodeJsDoc != null) {\n      irNode.setJSDocInfo(rootNodeJsDoc);\n      rootNodeJsDoc.setAssociatedNode(irNode);\n    }\n\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n      fileOverviewInfo.setAssociatedNode(irNode);\n    }\n  }\n",
        "begin_line": 204,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.handleJsDoc#273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(com.google.javascript.rhino.head.ast.AstNode, com.google.javascript.rhino.Node)",
        "snippet": "  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node, irNode);\n        }\n        return info;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 273,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.transform#353",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
        "begin_line": 353,
        "end_line": 362,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.setSourceInfo#406",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    if (irNode.getLineno() == -1) {\n      // If we didn't already set the line, then set it now. This avoids\n      // cases like ParenthesizedExpression where we just return a previous\n      // node, but don't want the new node to get its parent's line number.\n      int lineno = node.getLineno();\n      irNode.setLineno(lineno);\n      int charno = position2charno(node.getAbsolutePosition());\n      irNode.setCharno(charno);\n      maybeSetLengthFrom(irNode, node);\n    }\n  }\n",
        "begin_line": 406,
        "end_line": 417,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.maybeSetLengthFrom#453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(com.google.javascript.rhino.Node, com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }\n",
        "begin_line": 453,
        "end_line": 457,
        "comment": " Set the length on the node if we're in IDE mode.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.position2charno#459",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
        "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }\n",
        "begin_line": 459,
        "end_line": 467,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.justTransform#469",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }\n",
        "begin_line": 469,
        "end_line": 471,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "IRFactory.newNode#1422",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
        "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1422,
        "end_line": 1424,
        "comment": " Simple helper to create nodes and set the initial node properties.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Config.Config#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/Config.java",
        "class_name": "com.google.javascript.jscomp.parsing.Config",
        "signature": "com.google.javascript.jscomp.parsing.Config.Config(java.util.Set<java.lang.String>, java.util.Set<java.lang.String>, boolean, com.google.javascript.jscomp.parsing.Config.LanguageMode, boolean)",
        "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }\n",
        "begin_line": 73,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Config.buildAnnotationNames#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/Config.java",
        "class_name": "com.google.javascript.jscomp.parsing.Config",
        "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(java.util.Set<java.lang.String>)",
        "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }\n",
        "begin_line": 88,
        "end_line": 101,
        "comment": "\n   * Create the annotation names from the user-specified\n   * annotation whitelist.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.isInitialized#745",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.ThreadTrace.isInitialized()",
        "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }\n",
        "begin_line": 745,
        "end_line": 747,
        "comment": " Is initialized? ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.currentTimeMillis#222",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.Anonymous-cf4f2380-3831-495d-adaf-6cb8a6c80b98.currentTimeMillis()",
        "snippet": "    @Override\n    public long currentTimeMillis() {\n      return System.currentTimeMillis();\n    }\n",
        "begin_line": 222,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.Tracer#235",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.Tracer(java.lang.String, java.lang.String)",
        "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }\n",
        "begin_line": 235,
        "end_line": 278,
        "comment": "\n   * Create and start a tracer.\n   * Both type and comment may be null. See class comment for usage.\n   *\n   * @param type The type for totaling\n   * @param comment Comment about this tracer\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.stop#407",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
        "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than\n      // extraTracingStatistics.size() because a new statistic may\n      // have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }\n",
        "begin_line": 407,
        "end_line": 434,
        "comment": "\n   * Stop the trace.\n   * This may only be done once and must be done from the same thread\n   * that started it.\n   * @param silence_threshold Traces for time less than silence_threshold\n   * ms will be left out of the trace report. A value of -1 indicates\n   * that the current ThreadTrace silence_threshold should be used.\n   * @return The time that this trace actually ran\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.stop#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.stop()",
        "snippet": "  long stop() {\n    return stop(-1);\n  }\n",
        "begin_line": 440,
        "end_line": 442,
        "comment": " Stop the trace using the default silence_threshold\n   *\n   * @return  The time that this trace actually ran.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Tracer.getThreadTrace#958",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Tracer.java",
        "class_name": "com.google.javascript.jscomp.Tracer",
        "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
        "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }\n",
        "begin_line": 958,
        "end_line": 966,
        "comment": "\n   * Get the ThreadTrace for the current thread, creating one if necessary.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.getCode#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
        "snippet": "  public String getCode() throws IOException {\n    return code;\n  }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n   * Gets all the code in this source file.\n   * @throws IOException\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.setIsExtern#185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
        "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }\n",
        "begin_line": 185,
        "end_line": 187,
        "comment": " Sets that this is an extern. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.PrepareAnnotations#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.PrepareAnnotations()",
        "snippet": "    PrepareAnnotations() {\n    }\n",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.shouldTraverse#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }\n",
        "begin_line": 124,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.PrepareAst#39",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }\n",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.PrepareAst#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "PrepareAst.process#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations());\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations());\n      }\n    }\n  }\n",
        "begin_line": 54,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JsAst.JsAst#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.JsAst(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.inputId = new InputId(sourceFile.getName());\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }\n",
        "begin_line": 43,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JsAst.getAstRoot#49",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n      root.setInputId(inputId);\n    }\n    return root;\n  }\n",
        "begin_line": 49,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JsAst.getInputId#67",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getInputId()",
        "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }\n",
        "begin_line": 67,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JsAst.getSourceFile#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
        "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }\n",
        "begin_line": 72,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JsAst.parse#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JsAst.java",
        "class_name": "com.google.javascript.jscomp.JsAst",
        "signature": "com.google.javascript.jscomp.JsAst.parse(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  private void parse(AbstractCompiler compiler) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceFile.getName());\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
        "begin_line": 83,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSModule.JSModule#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.JSModule(java.lang.String)",
        "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }\n",
        "begin_line": 62,
        "end_line": 65,
        "comment": "\n   * Creates an instance.\n   *\n   * @param name A unique name for the module\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSModule.add#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.add(com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": " Adds a source code input to this module. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "JSModule.getInputs#204",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
        "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }\n",
        "begin_line": 204,
        "end_line": 206,
        "comment": "\n   * Gets this module's list of source code inputs.\n   *\n   * @return A list that may be empty but not null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "DependencyOptions.needsManagement#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.needsManagement()",
        "snippet": "  boolean needsManagement() {\n    return sortDependencies || pruneDependencies;\n  }\n",
        "begin_line": 119,
        "end_line": 121,
        "comment": " Returns whether re-ordering of files is needed. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.isOn#2081",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.TracerMode.isOn()",
        "snippet": "    boolean isOn() {\n      return this != OFF;\n    }\n",
        "begin_line": 2081,
        "end_line": 2083,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.CompilerInput#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceAst, boolean)",
        "snippet": "  public CompilerInput(SourceAst ast, boolean isExtern) {\n    this(ast, ast.getInputId(), isExtern);\n  }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.CompilerInput#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceAst, com.google.javascript.rhino.InputId, boolean)",
        "snippet": "  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n    this.ast = ast;\n    this.id = inputId;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }\n",
        "begin_line": 72,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.CompilerInput#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceFile)",
        "snippet": "  public CompilerInput(SourceFile file) {\n    this(file, false);\n  }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.CompilerInput#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(com.google.javascript.jscomp.SourceFile, boolean)",
        "snippet": "  public CompilerInput(SourceFile file, boolean isExtern) {\n    this(new JsAst(file), isExtern);\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.getName#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
        "snippet": "  @Override\n  public String getName() {\n    return id.getIdName();\n  }\n",
        "begin_line": 98,
        "end_line": 101,
        "comment": " Returns a name for this input. Must be unique across all inputs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.setModule#324",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.setModule(com.google.javascript.jscomp.JSModule)",
        "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }\n",
        "begin_line": 324,
        "end_line": 329,
        "comment": " Sets the module to which the input belongs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.acceptEcmaScript5#2001",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.acceptEcmaScript5()",
        "snippet": "  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n      case ECMASCRIPT3:\n        return false;\n    }\n    throw new IllegalStateException(\"unexpected language mode\");\n  }\n",
        "begin_line": 2001,
        "end_line": 2011,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.initBasedOnOptions#416",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
        "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n",
        "begin_line": 416,
        "end_line": 422,
        "comment": "\n   * Do any initialization that is dependent on the compiler options.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.checkFirstModule#445",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n",
        "begin_line": 445,
        "end_line": 453,
        "comment": "\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.fillEmptyModules#467",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n",
        "begin_line": 467,
        "end_line": 474,
        "comment": "\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getAllInputsFromModules#490",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n",
        "begin_line": 490,
        "end_line": 506,
        "comment": "\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.newTracer#946",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.newTracer(java.lang.String)",
        "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n",
        "begin_line": 946,
        "end_line": 953,
        "comment": "\n   * Returns a new tracer for the given pass name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.stopTracer#955",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.stopTracer(com.google.javascript.jscomp.Tracer, java.lang.String)",
        "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n",
        "begin_line": 955,
        "end_line": 960,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getDefaultErrorReporter#1599",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
        "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n",
        "begin_line": 1599,
        "end_line": 1602,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.prepareAst#1940",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.prepareAst(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n",
        "begin_line": 1940,
        "end_line": 1944,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.acceptConstKeyword#2017",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
        "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n",
        "begin_line": 2017,
        "end_line": 2020,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.hasErrors#2136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
        "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n",
        "begin_line": 2136,
        "end_line": 2138,
        "comment": "\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.setOldParseTree#2541",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setOldParseTree(java.lang.String, com.google.javascript.rhino.head.ast.AstRoot)",
        "snippet": "  @Override\n  public void setOldParseTree(String sourceName, AstRoot oldAst) {\n  }\n",
        "begin_line": 2541,
        "end_line": 2543,
        "comment": "\n   * {@inheritDoc}\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.AbstractCompiler": "\n    * Stores the \"new\" Rhino parse tree for a given source file.\n    * @param sourceName The source file name.\n    * @param astRoot The \"new\" Rhino parse tree.\n    "
        },
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeChangeHandler.hasCodeChanged#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeChangeHandler.java",
        "class_name": "com.google.javascript.jscomp.CodeChangeHandler",
        "signature": "com.google.javascript.jscomp.CodeChangeHandler.RecentChange.hasCodeChanged()",
        "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1478
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.ObjectPropListItem#294",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.ObjectPropListItem.ObjectPropListItem(int, java.lang.Object, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    ObjectPropListItem(int propType, Object objectValue, PropListItem next) {\n      super(propType, next);\n      this.objectValue = objectValue;\n    }\n",
        "begin_line": 294,
        "end_line": 297,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getObjectValue#304",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.ObjectPropListItem.getObjectValue()",
        "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }\n",
        "begin_line": 304,
        "end_line": 307,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.IntPropListItem#326",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.IntPropListItem.IntPropListItem(int, int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    IntPropListItem(int propType, int intValue, PropListItem next) {\n      super(propType, next);\n      this.intValue = intValue;\n    }\n",
        "begin_line": 326,
        "end_line": 329,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.AbstractPropListItem#268",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.AbstractPropListItem(int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "    AbstractPropListItem(int propType, PropListItem next) {\n      this.propType = propType;\n      this.next = next;\n    }\n",
        "begin_line": 268,
        "end_line": 271,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getType#273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.getType()",
        "snippet": "    @Override\n    public int getType() {\n      return propType;\n    }\n",
        "begin_line": 273,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getNext#278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.AbstractPropListItem.getNext()",
        "snippet": "    @Override\n    public PropListItem getNext() {\n      return next;\n    }\n",
        "begin_line": 278,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.Node#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int)",
        "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 352,
        "end_line": 356,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getType#519",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getType()",
        "snippet": "  public int getType() {\n    return type;\n  }\n",
        "begin_line": 519,
        "end_line": 521,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getFirstChild#531",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getFirstChild()",
        "snippet": "  public Node getFirstChild() {\n    return first;\n  }\n",
        "begin_line": 531,
        "end_line": 533,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.lookupProperty#749",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
        "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }\n",
        "begin_line": 749,
        "end_line": 756,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getProp#800",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getProp(int)",
        "snippet": "  public Object getProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }\n",
        "begin_line": 800,
        "end_line": 806,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.putProp#832",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putProp(int, java.lang.Object)",
        "snippet": "  public void putProp(int propType, Object value) {\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }\n",
        "begin_line": 832,
        "end_line": 837,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.putBooleanProp#839",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putBooleanProp(int, boolean)",
        "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }\n",
        "begin_line": 839,
        "end_line": 841,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.putIntProp#843",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.putIntProp(int, int)",
        "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }\n",
        "begin_line": 843,
        "end_line": 848,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.createProp#850",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.createProp(int, java.lang.Object, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }\n",
        "begin_line": 850,
        "end_line": 852,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.createProp#854",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.createProp(int, int, com.google.javascript.rhino.Node.PropListItem)",
        "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }\n",
        "begin_line": 854,
        "end_line": 856,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setStaticSourceFile#1075",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(com.google.javascript.rhino.jstype.StaticSourceFile)",
        "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }\n",
        "begin_line": 1075,
        "end_line": 1077,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getSourceFileName#1084",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
        "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }\n",
        "begin_line": 1084,
        "end_line": 1087,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getStaticSourceFile#1090",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
        "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }\n",
        "begin_line": 1090,
        "end_line": 1092,
        "comment": " Returns the source file associated with this input. May be null ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setInputId#1097",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setInputId(com.google.javascript.rhino.InputId)",
        "snippet": "  public void setInputId(InputId inputId) {\n    this.putProp(INPUT_ID, inputId);\n  }\n",
        "begin_line": 1097,
        "end_line": 1099,
        "comment": "\n   * @param inputId\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getInputId#1104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getInputId()",
        "snippet": "  public InputId getInputId() {\n    return ((InputId) this.getProp(INPUT_ID));\n  }\n",
        "begin_line": 1104,
        "end_line": 1106,
        "comment": "\n   * @return The Id of the CompilerInput associated with this Node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getCharno#1125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getCharno()",
        "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }\n",
        "begin_line": 1125,
        "end_line": 1127,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setLineno#1145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setLineno(int)",
        "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 1145,
        "end_line": 1151,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.mergeLineCharNo#1176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int, int)",
        "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }\n",
        "begin_line": 1176,
        "end_line": 1184,
        "comment": "\n   * Merges the line number and character number in one integer. The Character\n   * number takes the first 12 bits and the line number takes the rest. If\n   * the character number is greater than <code>2<sup>12</sup>-1</code> it is\n   * adjusted to <code>2<sup>12</sup>-1</code>.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.extractCharno#1202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
        "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }\n",
        "begin_line": 1202,
        "end_line": 1208,
        "comment": "\n   * Extracts the character number and character number from a merged line\n   * char number (see {@link #mergeLineCharNo(int, int)}).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.getJSDocInfo#1850",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
        "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }\n",
        "begin_line": 1850,
        "end_line": 1852,
        "comment": "\n   * Get the {@link JSDocInfo} attached to this node.\n   * @return the information or {@code null} if no JSDoc is attached to this\n   * node\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.setIsSyntheticBlock#1902",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
        "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }\n",
        "begin_line": 1902,
        "end_line": 1904,
        "comment": "\n   * Sets whether this is a synthetic block that should not be considered\n   * a real source block.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Node.isScript#2325",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isScript()",
        "snippet": "  public boolean isScript() {\n    return this.getType() == Token.SCRIPT;\n  }\n",
        "begin_line": 2325,
        "end_line": 2327,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "InputId.InputId#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.InputId(java.lang.String)",
        "snippet": "  public InputId(String id) {\n    this.id = id;\n  }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "InputId.hashCode#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/InputId.java",
        "class_name": "com.google.javascript.rhino.InputId",
        "signature": "com.google.javascript.rhino.InputId.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }\n",
        "begin_line": 59,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "SyntacticScopeCreator.SyntacticScopeCreator#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "\n   * Creates a ScopeCreator.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.getName#173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.getName()",
        "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }\n",
        "begin_line": 173,
        "end_line": 176,
        "comment": " Returns a unique name for the source file. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.NodeTraversal#221",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }\n",
        "begin_line": 221,
        "end_line": 223,
        "comment": "\n   * Creates a node traversal using the specified callback interface.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverse#271",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(com.google.javascript.rhino.Node)",
        "snippet": "  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n",
        "begin_line": 271,
        "end_line": 282,
        "comment": "\n   * Traverses a parse tree recursively.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.traverse#453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }\n",
        "begin_line": 453,
        "end_line": 457,
        "comment": "\n   * Traverses a node recursively.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeTraversal.getSourceName#655",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(com.google.javascript.rhino.Node)",
        "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }\n",
        "begin_line": 655,
        "end_line": 658,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.getInputId#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getInputId()",
        "snippet": "  @Override\n  public InputId getInputId() {\n    return id;\n  }\n",
        "begin_line": 92,
        "end_line": 95,
        "comment": " Returns a name for this input. Must be unique across all inputs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.getAstRoot#114",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    Node root = ast.getAstRoot(compiler);\n    // The root maybe null if the AST can not be created.\n    if (root != null) {\n      Preconditions.checkState(root.isScript());\n      Preconditions.checkNotNull(root.getInputId());\n    }\n    return root;\n  }\n",
        "begin_line": 114,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerInput.setCompiler#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.setCompiler(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public void setCompiler(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": " Sets an abstract compiler for doing parsing. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.putCompilerInput#1080",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.putCompilerInput(com.google.javascript.rhino.InputId, com.google.javascript.jscomp.CompilerInput)",
        "snippet": "  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n",
        "begin_line": 1080,
        "end_line": 1083,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.isIdeMode#1996",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
        "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n",
        "begin_line": 1996,
        "end_line": 1999,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.hasHaltingErrors#2122",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
        "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n",
        "begin_line": 2122,
        "end_line": 2125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1476
        },
        "num_failing_tests": 8
    },
    {
        "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard#40",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(java.util.Map<java.lang.String, com.google.javascript.jscomp.DiagnosticGroup>)",
        "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressibleGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressibleGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }\n",
        "begin_line": 40,
        "end_line": 49,
        "comment": "\n   * The suppressible groups, indexed by name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "SuppressDocWarningsGuard.getPriority#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
        "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }\n",
        "begin_line": 95,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "LightweightMessageFormatter.LightweightMessageFormatter#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
        "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider)",
        "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "LightweightMessageFormatter.LightweightMessageFormatter#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
        "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider, com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt)",
        "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }\n",
        "begin_line": 48,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ErrorFormat.toFormatter#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ErrorFormat.java",
        "class_name": "com.google.javascript.jscomp.ErrorFormat",
        "signature": "com.google.javascript.jscomp.ErrorFormat.toFormatter(com.google.javascript.jscomp.SourceExcerptProvider, boolean)",
        "snippet": "    @Override\n    public MessageFormatter toFormatter(\n        SourceExcerptProvider source, boolean colorize) {\n      LightweightMessageFormatter formatter = new LightweightMessageFormatter(\n          source);\n      formatter.setColorize(colorize);\n      return formatter;\n    }\n",
        "begin_line": 35,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.getRegisteredGroups#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
        "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }\n",
        "begin_line": 63,
        "end_line": 65,
        "comment": " Get the registered diagnostic groups, indexed by name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroup.matches#109",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(com.google.javascript.jscomp.DiagnosticType)",
        "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n   * Returns whether the given type matches a type in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroup.getTypes#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
        "snippet": "  public Iterable<DiagnosticType> getTypes() {\n    return types;\n  }\n",
        "begin_line": 128,
        "end_line": 130,
        "comment": "\n   * Returns an iterable over all the types in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.compare#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.GuardComparator.compare(com.google.javascript.jscomp.WarningsGuard, com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }\n",
        "begin_line": 61,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.addGuard#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(com.google.javascript.jscomp.WarningsGuard)",
        "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      ComposeWarningsGuard composeGuard = (ComposeWarningsGuard) guard;\n      if (composeGuard.demoteErrors) {\n        this.demoteErrors = composeGuard.demoteErrors;\n      }\n\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(Lists.newArrayList(composeGuard.guards.descendingSet()));\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }\n",
        "begin_line": 87,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.addGuards#104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(java.lang.Iterable<com.google.javascript.jscomp.WarningsGuard>)",
        "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }\n",
        "begin_line": 104,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.enables#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 148,
        "end_line": 159,
        "comment": "\n   * Determines whether this guard will \"elevate\" the status of any disabled\n   * diagnostic type in the group to a warning or an error.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.enables#1109",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }\n",
        "begin_line": 1109,
        "end_line": 1111,
        "comment": "\n   * Whether the warnings guard in this Options object enables the given\n   * group of warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.getWarningsGuard#1128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
        "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }\n",
        "begin_line": 1128,
        "end_line": 1130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.shouldColorizeErrorOutput#1327",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
        "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }\n",
        "begin_line": 1327,
        "end_line": 1329,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.getLanguageIn#1469",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
        "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }\n",
        "begin_line": 1469,
        "end_line": 1471,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.setErrorManager#255",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(com.google.javascript.jscomp.ErrorManager)",
        "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n",
        "begin_line": 255,
        "end_line": 259,
        "comment": "\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.createMessageFormatter#265",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
        "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n",
        "begin_line": 265,
        "end_line": 268,
        "comment": "\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "CheckLevel.isOn#29",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckLevel.java",
        "class_name": "com.google.javascript.jscomp.CheckLevel",
        "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
        "snippet": "  boolean isOn() {\n    return this != OFF;\n  }\n",
        "begin_line": 29,
        "end_line": 31,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractMessageFormatter.AbstractMessageFormatter#32",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
        "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(com.google.javascript.jscomp.SourceExcerptProvider)",
        "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }\n",
        "begin_line": 32,
        "end_line": 34,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "AbstractMessageFormatter.setColorize#36",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractMessageFormatter.java",
        "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
        "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
        "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1474
        },
        "num_failing_tests": 8
    },
    {
        "name": "ObjectType.createDelegateSuffix#246",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(java.lang.String)",
        "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }\n",
        "begin_line": 246,
        "end_line": 248,
        "comment": "\n   * Creates a suffix for a proxy delegate.\n   * @see #getNormalizedReferenceName\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ScriptRuntime.getMessage0#366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/ScriptRuntime.java",
        "class_name": "com.google.javascript.rhino.ScriptRuntime",
        "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(java.lang.String)",
        "snippet": "    public static String getMessage0(String messageId) {\n        return getMessage(messageId, null);\n    }\n",
        "begin_line": 366,
        "end_line": 368,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ScriptRuntime.getMessage#379",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/ScriptRuntime.java",
        "class_name": "com.google.javascript.rhino.ScriptRuntime",
        "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(java.lang.String, java.lang.Object[])",
        "snippet": "    public static String getMessage(String messageId, Object[] arguments) {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Locale locale = Locale.getDefault();\n\n        // ResourceBundle does caching.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }\n",
        "begin_line": 379,
        "end_line": 404,
        "comment": " OPT there's a noticeable delay for the first error!  Maybe it'd\n     * make sense to use a ListResourceBundle instead of a properties\n     * file to avoid (synchronized) text parsing.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "WarningsGuard.Priority#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.Priority.Priority(int)",
        "snippet": "    Priority(int value) {\n      this.value = value;\n    }\n",
        "begin_line": 58,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "WarningsGuard.getPriority#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
        "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "\n   * The priority in which warnings guards are applied. Lower means the\n   * guard will be applied sooner. Expressed on a scale of 1 to 100.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.OldRhinoErrorReporter#143",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.OldRhinoErrorReporter.OldRhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    private OldRhinoErrorReporter(AbstractCompiler compiler) {\n      super(compiler);\n    }\n",
        "begin_line": 143,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.NewRhinoErrorReporter#163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.NewRhinoErrorReporter.NewRhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    private NewRhinoErrorReporter(AbstractCompiler compiler) {\n      super(compiler);\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.replacePlaceHolders#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(java.lang.String)",
        "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }\n",
        "begin_line": 70,
        "end_line": 73,
        "comment": "\n   * For each message such as \"Not a good use of {0}\", replace the place\n   * holder {0} with a wild card that matches all possible strings.\n   * Also put the any non-place-holder in quotes for regex matching later.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.RhinoErrorReporter#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.RhinoErrorReporter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  private RhinoErrorReporter(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    typeMap = ImmutableMap.of(\n        // Trailing comma\n        replacePlaceHolders(\n            com.google.javascript.rhino.head.ScriptRuntime\n              .getMessage0(\"msg.extra.trailing.comma\")),\n        TRAILING_COMMA,\n\n        // Duplicate parameter\n        replacePlaceHolders(\n            com.google.javascript.rhino.head.ScriptRuntime\n              .getMessage0(\"msg.dup.parms\")),\n        DUPLICATE_PARAM,\n\n        // Unknown @annotations.\n        replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n        BAD_JSDOC_ANNOTATION,\n\n        Pattern.compile(\"^Type annotations are not allowed here.*\"),\n        MISPLACED_TYPE_ANNOTATION,\n\n        // Type annotation errors.\n        Pattern.compile(\"^Bad type annotation.*\"),\n        TYPE_PARSE_ERROR\n        );\n  }\n",
        "begin_line": 75,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.forNewRhino#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public static com.google.javascript.rhino.head.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "RhinoErrorReporter.forOldRhino#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RhinoErrorReporter.java",
        "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
        "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.TweakFunction#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String)",
        "snippet": "    TweakFunction(String name) {\n      this(name, null, Token.ERROR, Token.ERROR, null);\n    }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.TweakFunction#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA) {\n      this(name, expectedTypeName, validNodeTypeA, Token.ERROR, null);\n    }\n",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.TweakFunction#132",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int, int)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA, int validNodeTypeB) {\n      this(name, expectedTypeName, validNodeTypeA, validNodeTypeB, null);\n    }\n",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.TweakFunction#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, com.google.javascript.jscomp.ProcessTweaks.TweakFunction)",
        "snippet": "    TweakFunction(String name, TweakFunction registerFunction) {\n      this(name, null, Token.ERROR, Token.ERROR, registerFunction);\n    }\n",
        "begin_line": 137,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.TweakFunction#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.TweakFunction(java.lang.String, java.lang.String, int, int, com.google.javascript.jscomp.ProcessTweaks.TweakFunction)",
        "snippet": "    TweakFunction(String name, String expectedTypeName,\n        int validNodeTypeA, int validNodeTypeB,\n        TweakFunction registerFunction) {\n      this.name = name;\n      this.expectedTypeName = expectedTypeName;\n      this.validNodeTypeA = validNodeTypeA;\n      this.validNodeTypeB = validNodeTypeB;\n      this.registerFunction = registerFunction;\n    }\n",
        "begin_line": 141,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ProcessTweaks.getName#164",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessTweaks.java",
        "class_name": "com.google.javascript.jscomp.ProcessTweaks",
        "signature": "com.google.javascript.jscomp.ProcessTweaks.TweakFunction.getName()",
        "snippet": "    String getName() {\n      return name;\n    }\n",
        "begin_line": 164,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "PassFactory.PassFactory#37",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassFactory.java",
        "class_name": "com.google.javascript.jscomp.PassFactory",
        "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(java.lang.String, boolean)",
        "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": "\n   * @param name The name of the pass that this factory creates.\n   * @param isOneTimePass If true, the pass produced by this factory can\n   *     only be run once.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.warning#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.warning(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.WARNING\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.disabled#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }\n",
        "begin_line": 75,
        "end_line": 78,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.OFF\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.equals#113",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }\n",
        "begin_line": 113,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.hashCode#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
        "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }\n",
        "begin_line": 119,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.DiagnosticGroups#33",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
        "snippet": "  public DiagnosticGroups() {}\n",
        "begin_line": 33,
        "end_line": 33,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.registerDeprecatedGroup#38",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerDeprecatedGroup(java.lang.String)",
        "snippet": "  static DiagnosticGroup registerDeprecatedGroup(String name) {\n    return registerGroup(name, new DiagnosticGroup(name, UNUSED));\n  }\n",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.registerGroup#42",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 42,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.registerGroup#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 48,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroups.registerGroup#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroups.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
        "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup...)",
        "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }\n",
        "begin_line": 55,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard#32",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(com.google.javascript.jscomp.DiagnosticGroup, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }\n",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n   * Create a group that matches all errors of the given types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(com.google.javascript.jscomp.DiagnosticType...)",
        "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n   * Create a group that matches all errors of the given types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(java.lang.String, com.google.javascript.jscomp.DiagnosticGroup...)",
        "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }\n",
        "begin_line": 87,
        "end_line": 96,
        "comment": "\n   * Create a composite group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.GuardComparator#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.GuardComparator.GuardComparator(java.util.Map<com.google.javascript.jscomp.WarningsGuard, java.lang.Integer>)",
        "snippet": "    private GuardComparator(Map<WarningsGuard, Integer> orderOfAddition) {\n      this.orderOfAddition = orderOfAddition;\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.ComposeWarningsGuard#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(java.util.List<com.google.javascript.jscomp.WarningsGuard>)",
        "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ComposeWarningsGuard.ComposeWarningsGuard#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(com.google.javascript.jscomp.WarningsGuard...)",
        "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "CompilerOptions.CompilerOptions#841",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
        "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    inlineProperties = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedClassProperties = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    jqueryPass = false;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    cssRenamingWhitelist = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n    propertyInvalidationErrors = Maps.newHashMap();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    preferLineBreakAtEndOfFile = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n    errorHandler = null;\n  }\n",
        "begin_line": 841,
        "end_line": 980,
        "comment": "\n   * Initializes compiler options. All options are disabled by default.\n   *\n   * Command-line frontends to the compiler should set these properties\n   * like a builder.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.Compiler#237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Compiler(java.io.PrintStream)",
        "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n",
        "begin_line": 237,
        "end_line": 240,
        "comment": "\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.addChangeHandler#1967",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(com.google.javascript.jscomp.CodeChangeHandler)",
        "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n",
        "begin_line": 1967,
        "end_line": 1970,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "Compiler.getDiagnosticGroups#2063",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
        "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n",
        "begin_line": 2063,
        "end_line": 2065,
        "comment": "\n   * The warning classes that are available from the command-line, and\n   * are suppressible by the {@code @suppress} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodingConventions.Proxy#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.Proxy(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "    protected Proxy(CodingConvention convention) {\n      this.nextConvention = convention;\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodingConventions.getIndirectlyDeclaredProperties#465",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getIndirectlyDeclaredProperties()",
        "snippet": "    @Override\n    public Collection<String> getIndirectlyDeclaredProperties() {\n      return ImmutableList.of();\n    }\n",
        "begin_line": 465,
        "end_line": 468,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ClosureCodingConvention.ClosureCodingConvention#49",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention()",
        "snippet": "  public ClosureCodingConvention() {\n    this(CodingConventions.getDefault());\n  }\n",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "ClosureCodingConvention.ClosureCodingConvention#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public ClosureCodingConvention(CodingConvention wrapped) {\n    super(wrapped);\n\n    Set<String> props = Sets.newHashSet(\n        \"superClass_\",\n        \"instance_\",\n        \"getInstance\");\n    props.addAll(wrapped.getIndirectlyDeclaredProperties());\n    indirectlyDeclaredProperties = ImmutableSet.copyOf(props);\n  }\n",
        "begin_line": 53,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "AnonymousFunctionNamingPolicy.AnonymousFunctionNamingPolicy#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AnonymousFunctionNamingPolicy.java",
        "class_name": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy",
        "signature": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy.AnonymousFunctionNamingPolicy(char[])",
        "snippet": "  AnonymousFunctionNamingPolicy(char[] reservedCharacters) {\n    this.reservedCharacters = reservedCharacters;\n  }\n",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.147
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.Preloaded#421",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Preloaded.Preloaded(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "    Preloaded(String fileName, String originalPath, String code) {\n      super(fileName);\n      super.setOriginalPath(originalPath);\n      super.setCode(code);\n    }\n",
        "begin_line": 421,
        "end_line": 425,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.Builder#368",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Builder.Builder()",
        "snippet": "    public Builder() {}\n",
        "begin_line": 368,
        "end_line": 368,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.buildFromCode#390",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.Builder.buildFromCode(java.lang.String, java.lang.String)",
        "snippet": "    public SourceFile buildFromCode(String fileName, String code) {\n      return new Preloaded(fileName, originalPath, code);\n    }\n",
        "begin_line": 390,
        "end_line": 392,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.setCode#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setCode(java.lang.String)",
        "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.setOriginalPath#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(java.lang.String)",
        "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.fromCode#322",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.fromCode(java.lang.String, java.lang.String)",
        "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return builder().buildFromCode(fileName, code);\n  }\n",
        "begin_line": 322,
        "end_line": 324,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "SourceFile.builder#354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.builder()",
        "snippet": "  public static Builder builder() {\n    return new Builder();\n  }\n",
        "begin_line": 354,
        "end_line": 356,
        "comment": " Create a new builder for source files. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.error#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.error(java.lang.String, java.lang.String)",
        "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n   * Create a DiagnosticType at level CheckLevel.ERROR\n   *\n   * @param name An identifier\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.make#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.make(java.lang.String, com.google.javascript.jscomp.CheckLevel, java.lang.String)",
        "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }\n",
        "begin_line": 88,
        "end_line": 92,
        "comment": "\n   * Create a DiagnosticType at a given CheckLevel.\n   *\n   * @param name An identifier\n   * @param level Either CheckLevel.ERROR or CheckLevel.WARNING\n   * @param descriptionFormat A format string\n   * @return A new DiagnosticType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "DiagnosticType.DiagnosticType#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticType.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticType",
        "signature": "com.google.javascript.jscomp.DiagnosticType.DiagnosticType(java.lang.String, com.google.javascript.jscomp.CheckLevel, java.text.MessageFormat)",
        "snippet": "  private DiagnosticType(String key, CheckLevel level, MessageFormat format) {\n    this.key = key;\n    this.defaultLevel = level;\n    this.format = format;\n\n    this.level = this.defaultLevel;\n  }\n",
        "begin_line": 97,
        "end_line": 103,
        "comment": "\n   * Create a DiagnosticType. Private to force use of static factory methods.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodingConventions.getDefault#41",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.getDefault()",
        "snippet": "  public static CodingConvention getDefault() {\n    return new DefaultCodingConvention();\n  }\n",
        "begin_line": 41,
        "end_line": 43,
        "comment": " Gets the default coding convention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 8
    },
    {
        "name": "CodeConsumer.addConstant#278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.addConstant(java.lang.String)",
        "snippet": "  void addConstant(String newcode) {\n    add(newcode);\n  }\n",
        "begin_line": 278,
        "end_line": 280,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1468
        },
        "num_failing_tests": 5
    },
    {
        "name": "SourceFile.SourceFile#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(java.lang.String)",
        "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n  }\n",
        "begin_line": 81,
        "end_line": 86,
        "comment": "\n   * Construct a new abstract source file.\n   *\n   * @param fileName The file name of the source file. It does not necessarily\n   *     need to correspond to a real path. But it should be unique. Will\n   *     appear in warning messages emitted by the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1466
        },
        "num_failing_tests": 8
    },
    {
        "name": "NodeUtil.has#2688",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.has(com.google.javascript.rhino.Node, com.google.common.base.Predicate<com.google.javascript.rhino.Node>, com.google.common.base.Predicate<com.google.javascript.rhino.Node>)",
        "snippet": "  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 2688,
        "end_line": 2706,
        "comment": "\n   * @return Whether the predicate is true for the node or any of its children.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1466
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getMainOptimizationLoop#682",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getMainOptimizationLoop()",
        "snippet": "  private List<PassFactory> getMainOptimizationLoop() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.inlineGetters) {\n      passes.add(inlineSimpleMethods);\n    }\n\n    passes.addAll(getCodeRemovingPasses());\n\n    if (options.inlineFunctions || options.inlineLocalFunctions) {\n      passes.add(inlineFunctions);\n    }\n\n    if (options.inlineProperties) {\n      passes.add(inlineProperties);\n    }\n\n    boolean runOptimizeCalls = options.optimizeCalls\n        || options.optimizeParameters\n        || options.optimizeReturns;\n\n    if (options.removeUnusedVars || options.removeUnusedLocalVars) {\n      if (options.deadAssignmentElimination) {\n        passes.add(deadAssignmentsElimination);\n      }\n      if (!runOptimizeCalls) {\n        passes.add(removeUnusedVars);\n      }\n    }\n    if (runOptimizeCalls) {\n      passes.add(optimizeCallsAndRemoveUnusedVars);\n    }\n    assertAllLoopablePasses(passes);\n    return passes;\n  }\n",
        "begin_line": 682,
        "end_line": 715,
        "comment": " Creates the passes for the main optimization loop. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeConsumer.addOp#210",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.addOp(java.lang.String, boolean)",
        "snippet": "  void addOp(String op, boolean binOp) {\n    maybeEndStatement();\n\n    char first = op.charAt(0);\n    char prev = getLastChar();\n\n    if ((first == '+' || first == '-') && prev == first) {\n      // This is not pretty printing. This is to prevent misparsing of\n      // things like \"x + ++y\" or \"x++ + ++y\"\n      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formatting around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }\n",
        "begin_line": 210,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1457
        },
        "num_failing_tests": 6
    },
    {
        "name": "GraphReachability.EdgeTuple#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphReachability.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
        "signature": "com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple.EdgeTuple(N, E, N)",
        "snippet": "    public EdgeTuple(N sourceNode, E edge, N destNode) {\n      this.sourceNode = sourceNode;\n      this.edge = edge;\n      this.destNode = destNode;\n    }\n",
        "begin_line": 92,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1214",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-77e86a94-6fbd-4486-848c-a89f650f33c2.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      List<Callback> callbacks = Lists.newArrayList();\n      if (options.checkUnreachableCode.isOn()) {\n        callbacks.add(\n            new CheckUnreachableCode(compiler, options.checkUnreachableCode));\n      }\n      if (options.checkMissingReturn.isOn() && options.checkTypes) {\n        callbacks.add(\n            new CheckMissingReturn(compiler, options.checkMissingReturn));\n      }\n      return combineChecks(compiler, callbacks);\n    }\n",
        "begin_line": 1214,
        "end_line": 1226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.CheckUnreachableCode#41",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.CheckUnreachableCode(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  CheckUnreachableCode(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.enterScope#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    initScope(t.getControlFlowGraph());\n  }\n",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.shouldTraverse#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    GraphNode<Node, Branch> gNode = t.getControlFlowGraph().getNode(n);\n    if (gNode != null && gNode.getAnnotation() != GraphReachability.REACHABLE) {\n\n      // Only report error when there are some line number informations.\n      // There are synthetic nodes with no line number informations, nodes\n      // introduce by other passes (although not likely since this pass should\n      // be executed early) or some rhino bug.\n      if (n.getLineno() != -1 &&\n          // Allow spurious semi-colons and spurious breaks.\n          !n.isEmpty() && !n.isBreak()) {\n        compiler.report(t.makeError(n, level, UNREACHABLE_CODE));\n        // From now on, we are going to assume the user fixed the error and not\n        // give more warning related to code section reachable from this node.\n        new GraphReachability<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph()).recompute(n);\n\n        // Saves time by not traversing children.\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 51,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.initScope#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.initScope(com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>)",
        "snippet": "  private void initScope(ControlFlowGraph<Node> controlFlowGraph) {\n    new GraphReachability<Node, ControlFlowGraph.Branch>(\n        controlFlowGraph, new ReachablePredicate()).compute(\n            controlFlowGraph.getEntry().getValue());\n  }\n",
        "begin_line": 76,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.exitScope#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckUnreachableCode.visit#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckUnreachableCode.java",
        "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
        "signature": "com.google.javascript.jscomp.CheckUnreachableCode.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeConsumer.endStatement#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
        "snippet": "  void endStatement() {\n    endStatement(false);\n  }\n",
        "begin_line": 134,
        "end_line": 136,
        "comment": "\n   * Indicates the end of a statement and a ';' may need to be added.\n   * But we don't add it now, in case we're at the end of a block (in which\n   * case we don't have to add the ';').\n   * See maybeEndStatement()\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 7
    },
    {
        "name": "CodeConsumer.endStatement#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
        "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }\n",
        "begin_line": 138,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1451
        },
        "num_failing_tests": 7
    },
    {
        "name": "CodeConsumer.appendOp#206",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.appendOp(java.lang.String, boolean)",
        "snippet": "  void appendOp(String op, boolean binOp) {\n    append(op);\n  }\n",
        "begin_line": 206,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.145
        },
        "num_failing_tests": 6
    },
    {
        "name": "CodeGenerator.getContextForNoInOperator#1243",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.getContextForNoInOperator(com.google.javascript.jscomp.CodeGenerator.Context)",
        "snippet": "  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }\n",
        "begin_line": 1243,
        "end_line": 1246,
        "comment": "\n   * If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the\n   * expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1447
        },
        "num_failing_tests": 6
    },
    {
        "name": "ControlFlowGraph.isConditional#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.Branch.isConditional()",
        "snippet": "    public boolean isConditional() {\n      return this == ON_TRUE || this == ON_FALSE;\n    }\n",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.CallbackWrapper#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.CallbackWrapper(com.google.javascript.jscomp.NodeTraversal.Callback)",
        "snippet": "    private CallbackWrapper(Callback callback) {\n      this.callback = callback;\n      if (callback instanceof ScopedCallback) {\n        scopedCallback = (ScopedCallback) callback;\n      } else {\n        scopedCallback = null;\n      }\n    }\n",
        "begin_line": 108,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.enterScopeIfActive#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.enterScopeIfActive(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    void enterScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.enterScope(t);\n      }\n    }\n",
        "begin_line": 135,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.exitScopeIfActive#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.exitScopeIfActive(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    void exitScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.exitScope(t);\n      }\n    }\n",
        "begin_line": 141,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.processParenthesizedExpression#952",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processParenthesizedExpression(com.google.javascript.rhino.head.ast.ParenthesizedExpression)",
        "snippet": "    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n      Node node = transform(exprNode.getExpression());\n      return node;\n    }\n",
        "begin_line": 952,
        "end_line": 956,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.isWellDefined#310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.isWellDefined()",
        "snippet": "    protected boolean isWellDefined() {\n      int size = references.size();\n      if (size == 0) {\n        return false;\n      }\n\n      // If this is a declaration that does not instantiate the variable,\n      // it's not well-defined.\n      Reference init = getInitializingReference();\n      if (init == null) {\n        return false;\n      }\n\n      Preconditions.checkState(references.get(0).isDeclaration());\n      BasicBlock initBlock = init.getBasicBlock();\n      for (int i = 1; i < size; i++) {\n        if (!initBlock.provablyExecutesBefore(\n                references.get(i).getBasicBlock())) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
        "begin_line": 310,
        "end_line": 333,
        "comment": "\n     * Determines if the variable for this reference collection is\n     * \"well-defined.\" A variable is well-defined if we can prove at\n     * compile-time that it's assigned a value before it's used.\n     *\n     * Notice that if this function returns false, this doesn't imply that the\n     * variable is used before it's assigned. It just means that we don't\n     * have enough information to make a definitive judgment.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.provablyExecutesBefore#703",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock.provablyExecutesBefore(com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock)",
        "snippet": "    boolean provablyExecutesBefore(BasicBlock thatBlock) {\n      // If thatBlock is a descendant of this block, and there are no hoisted\n      // blocks between them, then this block must start before thatBlock.\n      BasicBlock currentBlock;\n      for (currentBlock = thatBlock;\n           currentBlock != null && currentBlock != this;\n           currentBlock = currentBlock.getParent()) {\n        if (currentBlock.isHoisted) {\n          return false;\n        }\n      }\n\n      if (currentBlock == this) {\n        return true;\n      }\n      if (isGlobalScopeBlock() && thatBlock.isGlobalScopeBlock()) {\n        return true;\n      }\n      return false;\n    }\n",
        "begin_line": 703,
        "end_line": 722,
        "comment": "\n     * Determines whether this block is guaranteed to begin executing before\n     * the given block does.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeCollectPropertyAssignments.isPropertyAssignmentToName#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java",
        "class_name": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments",
        "signature": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments.isPropertyAssignmentToName(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isPropertyAssignmentToName(Node propertyCandidate) {\n    if (propertyCandidate == null) { return false; }\n    // Must be an assignment...\n    if (!NodeUtil.isExprAssign(propertyCandidate)) {\n      return false;\n    }\n\n    Node expr = propertyCandidate.getFirstChild();\n\n    // to a property...\n    Node lhs = expr.getFirstChild();\n    if (!NodeUtil.isGet(lhs)) {\n      return false;\n    }\n\n    // of a variable.\n    Node obj = lhs.getFirstChild();\n    if (!obj.isName()) {\n      return false;\n    }\n\n    return true;\n  }\n",
        "begin_line": 106,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.getAssignedValue#1575",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getAssignedValue(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getAssignedValue(Node n) {\n    Preconditions.checkState(n.isName());\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      return n.getFirstChild();\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      return n.getNext();\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 1575,
        "end_line": 1585,
        "comment": "\n   * For an assignment or variable declaration get the assigned value.\n   * @return The value node representing the new value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1443
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateNumber#648",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateNumber(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateNumber(Node n) {\n    validateNodeType(Token.NUMBER, n);\n    validateChildCount(n, 0);\n    try {\n      // Validate that getDouble doesn't throw\n      n.getDouble();\n    } catch (UnsupportedOperationException e) {\n      violation(\"Invalid NUMBER node.\", n);\n    }\n  }\n",
        "begin_line": 648,
        "end_line": 657,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.detachFromParent#1605",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.detachFromParent()",
        "snippet": "  public Node detachFromParent() {\n    Preconditions.checkState(parent != null);\n    parent.removeChild(this);\n    return this;\n  }\n",
        "begin_line": 1605,
        "end_line": 1609,
        "comment": "\n   * Removes this node from its parent. Equivalent to:\n   * node.getParent().removeChild();\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1425
        },
        "num_failing_tests": 5
    },
    {
        "name": "AstValidator.validateVar#389",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateVar(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateVar(Node n) {\n    validateNodeType(Token.VAR, n);\n    this.validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      // Don't use the validateName here as the NAME is allowed to have\n      // a child.\n      validateNodeType(Token.NAME, c);\n      validateNonEmptyString(c);\n      validateMaximumChildCount(c, 1);\n      if (c.hasChildren()) {\n        validateExpression(c.getFirstChild());\n      }\n    }\n  }\n",
        "begin_line": 389,
        "end_line": 402,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1424
        },
        "num_failing_tests": 7
    },
    {
        "name": "AstValidator.validateMaximumChildCount#807",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateMaximumChildCount(com.google.javascript.rhino.Node, int)",
        "snippet": "  private void validateMaximumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = !n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() <= i;\n    }\n    if (!valid) {\n      violation(\n          \"Expected no more than \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }\n",
        "begin_line": 807,
        "end_line": 819,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1417
        },
        "num_failing_tests": 7
    },
    {
        "name": "Node.isEmpty#2221",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isEmpty()",
        "snippet": "  public boolean isEmpty() {\n    return this.getType() == Token.EMPTY;\n  }\n",
        "begin_line": 2221,
        "end_line": 2223,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1415
        },
        "num_failing_tests": 7
    },
    {
        "name": "DefaultPassConfig.create#824",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-c55a8f96-06e6-43fe-9f9a-ac5ef809fbea.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new ControlStructureCheck(compiler);\n    }\n",
        "begin_line": 824,
        "end_line": 827,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getChecks#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getChecks()",
        "snippet": "  @Override\n  protected List<PassFactory> getChecks() {\n    List<PassFactory> checks = Lists.newArrayList();\n\n    checks.add(createEmptyPass(\"beforeStandardChecks\"));\n\n    if (options.closurePass) {\n      checks.add(closureGoogScopeAliases);\n      checks.add(closureRewriteGoogClass);\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.MAPPED) {\n        checks.add(nameMappedAnonymousFunctions);\n      } else if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.UNMAPPED) {\n        checks.add(nameUnmappedAnonymousFunctions);\n      }\n      return checks;\n    }\n\n    if (options.jqueryPass) {\n      checks.add(jqueryAliases);\n    }\n\n    checks.add(checkSideEffects);\n\n    if (options.checkSuspiciousCode ||\n        options.enables(DiagnosticGroups.GLOBAL_THIS) ||\n        options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {\n      checks.add(suspiciousCode);\n    }\n\n    if (options.checkControlStructures\n        || options.enables(DiagnosticGroups.ES5_STRICT))  {\n      checks.add(checkControlStructures);\n    }\n\n    if (options.checkRequires.isOn()) {\n      checks.add(checkRequires);\n    }\n\n    if (options.checkProvides.isOn()) {\n      checks.add(checkProvides);\n    }\n\n    // The following passes are more like \"preprocessor\" passes.\n    // It's important that they run before most checking passes.\n    // Perhaps this method should be renamed?\n    if (options.generateExports) {\n      checks.add(generateExports);\n    }\n\n    if (options.exportTestFunctions) {\n      checks.add(exportTestFunctions);\n    }\n\n    if (options.closurePass) {\n      checks.add(closurePrimitives);\n    }\n\n    if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n      checks.add(closureCheckGetCssName);\n    }\n\n    if (options.syntheticBlockStartMarker != null) {\n      // This pass must run before the first fold constants pass.\n      checks.add(createSyntheticBlocks);\n    }\n\n    checks.add(checkVars);\n    if (options.computeFunctionSideEffects) {\n      checks.add(checkRegExp);\n    }\n\n    if (options.aggressiveVarCheck.isOn()) {\n      checks.add(checkVariableReferences);\n    }\n\n    // This pass should run before types are assigned.\n    if (options.processObjectPropertyString) {\n      checks.add(objectPropertyStringPreprocess);\n    }\n\n    if (options.checkTypes || options.inferTypes) {\n      checks.add(resolveTypes);\n      checks.add(inferTypes);\n      if (options.checkTypes) {\n        checks.add(checkTypes);\n      } else {\n        checks.add(inferJsDocInfo);\n      }\n\n      // We assume that only IDE-mode clients will try to query the\n      // typed scope creator after the compile job.\n      if (!options.ideMode && !options.saveDataStructures) {\n        checks.add(clearTypedScopePass);\n      }\n    }\n\n    if (options.checkUnreachableCode.isOn() ||\n        (options.checkTypes && options.checkMissingReturn.isOn())) {\n      checks.add(checkControlFlow);\n    }\n\n    // CheckAccessControls only works if check types is on.\n    if (options.checkTypes &&\n        (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n         || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {\n      checks.add(checkAccessControls);\n    }\n\n    if (options.checkGlobalNamesLevel.isOn()) {\n      checks.add(checkGlobalNames);\n    }\n\n    if (options.enables(DiagnosticGroups.ES5_STRICT) || options.checkCaja) {\n      checks.add(checkStrictMode);\n    }\n\n    // Replace 'goog.getCssName' before processing defines but after the\n    // other checks have been done.\n    if (options.closurePass) {\n      checks.add(closureReplaceGetCssName);\n    }\n\n    // i18n\n    // If you want to customize the compiler to use a different i18n pass,\n    // you can create a PassConfig that calls replacePassFactory\n    // to replace this.\n    if (options.replaceMessagesWithChromeI18n) {\n      checks.add(replaceMessagesForChrome);\n    } else if (options.messageBundle != null) {\n      checks.add(replaceMessages);\n    }\n\n    if (options.getTweakProcessing().isOn()) {\n      checks.add(processTweaks);\n    }\n\n    // Defines in code always need to be processed.\n    checks.add(processDefines);\n\n    if (options.instrumentationTemplate != null ||\n        options.recordFunctionInformation) {\n      checks.add(computeFunctionNames);\n    }\n\n    if (options.nameReferenceGraphPath != null &&\n        !options.nameReferenceGraphPath.isEmpty()) {\n      checks.add(printNameReferenceGraph);\n    }\n\n    if (options.nameReferenceReportPath != null &&\n        !options.nameReferenceReportPath.isEmpty()) {\n      checks.add(printNameReferenceReport);\n    }\n\n    checks.add(createEmptyPass(\"afterStandardChecks\"));\n\n    assertAllOneTimePasses(checks);\n    return checks;\n  }\n",
        "begin_line": 182,
        "end_line": 345,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlStructureCheck.ControlStructureCheck#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
        "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
        "signature": "com.google.javascript.jscomp.ControlStructureCheck.ControlStructureCheck(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  ControlStructureCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlStructureCheck.process#39",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
        "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
        "signature": "com.google.javascript.jscomp.ControlStructureCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    check(root);\n  }\n",
        "begin_line": 39,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlStructureCheck.check#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlStructureCheck.java",
        "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
        "signature": "com.google.javascript.jscomp.ControlStructureCheck.check(com.google.javascript.rhino.Node)",
        "snippet": "  private void check(Node node) {\n    switch (node.getType()) {\n      case Token.WITH:\n        JSDocInfo info = node.getJSDocInfo();\n        boolean allowWith =\n            info != null && info.getSuppressions().contains(\"with\");\n        if (!allowWith) {\n          report(node, USE_OF_WITH);\n        }\n        break;\n    }\n\n    for (Node bChild = node.getFirstChild(); bChild != null;) {\n      Node next = bChild.getNext();\n      check(bChild);\n      bChild = next;\n    }\n  }\n",
        "begin_line": 54,
        "end_line": 71,
        "comment": "\n   * Reports errors for any invalid use of control structures.\n   *\n   * @param node Current node to check.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.setInlineFunctions#1216",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setInlineFunctions(com.google.javascript.jscomp.CompilerOptions.Reach)",
        "snippet": "  public void setInlineFunctions(Reach reach) {\n    switch (reach) {\n      case ALL:\n        this.inlineFunctions = true;\n        this.inlineLocalFunctions = true;\n        break;\n      case LOCAL_ONLY:\n        this.inlineFunctions = false;\n        this.inlineLocalFunctions = true;\n        break;\n      case NONE:\n        this.inlineFunctions = false;\n        this.inlineLocalFunctions = false;\n        break;\n      default:\n        throw new IllegalStateException(\"unexpected\");\n    }\n  }\n",
        "begin_line": 1216,
        "end_line": 1233,
        "comment": "\n   * Set the function inlining policy for the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilationLevel.setOptionsForCompilationLevel#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilationLevel.java",
        "class_name": "com.google.javascript.jscomp.CompilationLevel",
        "signature": "com.google.javascript.jscomp.CompilationLevel.setOptionsForCompilationLevel(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public void setOptionsForCompilationLevel(CompilerOptions options) {\n    switch (this) {\n      case WHITESPACE_ONLY:\n        applyBasicCompilationOptions(options);\n        break;\n      case SIMPLE_OPTIMIZATIONS:\n        applySafeCompilationOptions(options);\n        break;\n      case ADVANCED_OPTIMIZATIONS:\n        applyFullCompilationOptions(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown compilation level.\");\n    }\n  }\n",
        "begin_line": 53,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilationLevel.applySafeCompilationOptions#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilationLevel.java",
        "class_name": "com.google.javascript.jscomp.CompilationLevel",
        "signature": "com.google.javascript.jscomp.CompilationLevel.applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  private static void applySafeCompilationOptions(CompilerOptions options) {\n    // ReplaceIdGenerators is on by default, but should run in simple mode.\n    options.replaceIdGenerators = false;\n\n    // Does not call applyBasicCompilationOptions(options) because the call to\n    // skipAllCompilerPasses() cannot be easily undone.\n    options.dependencyOptions.setDependencySorting(true);\n    options.closurePass = true;\n    options.setRenamingPolicy(\n        VariableRenamingPolicy.LOCAL, PropertyRenamingPolicy.OFF);\n    options.shadowVariables = true;\n    options.setInlineVariables(Reach.LOCAL_ONLY);\n    options.flowSensitiveInlineVariables = true;\n    options.setInlineFunctions(Reach.LOCAL_ONLY);\n    options.checkGlobalThisLevel = CheckLevel.OFF;\n    options.foldConstants = true;\n    options.coalesceVariableNames = true;\n    options.deadAssignmentElimination = true;\n    options.collapseVariableDeclarations = true;\n    options.convertToDottedProperties = true;\n    options.labelRenaming = true;\n    options.removeDeadCode = true;\n    options.optimizeArgumentsArray = true;\n    options.setRemoveUnusedVariables(Reach.LOCAL_ONLY);\n    options.collapseObjectLiterals = true;\n    options.protectHiddenSideEffects = true;\n\n    // Allows annotations that are not standard.\n    options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n        CheckLevel.OFF);\n  }\n",
        "begin_line": 95,
        "end_line": 125,
        "comment": "\n   * Add options that are safe. Safe means options that won't break the\n   * JavaScript code even if no symbols are exported and no coding convention\n   * is used.\n   * @param options The CompilerOptions object to set the options on.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1414
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.getDouble#156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.NumberNode.getDouble()",
        "snippet": "    @Override\n    public double getDouble() {\n      return this.number;\n    }\n",
        "begin_line": 156,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1411
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.hasMoreThanOneChild#1382",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.hasMoreThanOneChild()",
        "snippet": "  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }\n",
        "begin_line": 1382,
        "end_line": 1384,
        "comment": "\n   * Check for more than one child more efficiently than by iterating over all\n   * the children as is done with Node.getChildCount().\n   *\n   * @return Whether the node more than one child.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.141
        },
        "num_failing_tests": 7
    },
    {
        "name": "DefaultPassConfig.create#787",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-fef5d9fd-c3be-4843-ab3a-3e21bb869d45.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n      List<Callback> sharedCallbacks = Lists.newArrayList();\n      if (options.checkSuspiciousCode) {\n        sharedCallbacks.add(new CheckSuspiciousCode());\n      }\n\n      if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n        sharedCallbacks.add(new CheckGlobalThis(compiler));\n      }\n\n      if (options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {\n        sharedCallbacks.add(new CheckDebuggerStatement(compiler));\n      }\n\n      return combineChecks(compiler, sharedCallbacks);\n    }\n",
        "begin_line": 787,
        "end_line": 803,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.setInlineVariables#1238",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setInlineVariables(com.google.javascript.jscomp.CompilerOptions.Reach)",
        "snippet": "  public void setInlineVariables(Reach reach) {\n    switch (reach) {\n      case ALL:\n        this.inlineVariables = true;\n        this.inlineLocalVariables = true;\n        break;\n      case LOCAL_ONLY:\n        this.inlineVariables = false;\n        this.inlineLocalVariables = true;\n        break;\n      case NONE:\n        this.inlineVariables = false;\n        this.inlineLocalVariables = false;\n        break;\n      default:\n        throw new IllegalStateException(\"unexpected\");\n    }\n  }\n",
        "begin_line": 1238,
        "end_line": 1255,
        "comment": "\n   * Set the variable inlining policy for the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.setRemoveUnusedVariables#1275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setRemoveUnusedVariables(com.google.javascript.jscomp.CompilerOptions.Reach)",
        "snippet": "  public void setRemoveUnusedVariables(Reach reach) {\n    switch (reach) {\n      case ALL:\n        this.removeUnusedVars = true;\n        this.removeUnusedLocalVars = true;\n        break;\n      case LOCAL_ONLY:\n        this.removeUnusedVars = false;\n        this.removeUnusedLocalVars = true;\n        break;\n      case NONE:\n        this.removeUnusedVars = false;\n        this.removeUnusedLocalVars = false;\n        break;\n      default:\n        throw new IllegalStateException(\"unexpected\");\n    }\n  }\n",
        "begin_line": 1275,
        "end_line": 1292,
        "comment": "\n   * Set the variable removal policy for the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSuspiciousCode.CheckSuspiciousCode#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSuspiciousCode.java",
        "class_name": "com.google.javascript.jscomp.CheckSuspiciousCode",
        "signature": "com.google.javascript.jscomp.CheckSuspiciousCode.CheckSuspiciousCode()",
        "snippet": "  CheckSuspiciousCode() {\n  }\n",
        "begin_line": 48,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSuspiciousCode.visit#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSuspiciousCode.java",
        "class_name": "com.google.javascript.jscomp.CheckSuspiciousCode",
        "signature": "com.google.javascript.jscomp.CheckSuspiciousCode.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    checkMissingSemicolon(t, n);\n    checkNaN(t, n);\n  }\n",
        "begin_line": 51,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSuspiciousCode.checkNaN#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSuspiciousCode.java",
        "class_name": "com.google.javascript.jscomp.CheckSuspiciousCode",
        "signature": "com.google.javascript.jscomp.CheckSuspiciousCode.checkNaN(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkNaN(NodeTraversal t, Node n) {\n    switch (n.getType()) {\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LT:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        reportIfNaN(t, n.getFirstChild());\n        reportIfNaN(t, n.getLastChild());\n    }\n  }\n",
        "begin_line": 87,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1407
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.cloneTree#1689",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.cloneTree()",
        "snippet": "  public Node cloneTree() {\n    Node result = cloneNode();\n    for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n      Node n2clone = n2.cloneTree();\n      n2clone.parent = result;\n      if (result.last != null) {\n        result.last.next = n2clone;\n      }\n      if (result.first == null) {\n        result.first = n2clone;\n      }\n      result.last = n2clone;\n    }\n    return result;\n  }\n",
        "begin_line": 1689,
        "end_line": 1703,
        "comment": "\n   * @return A detached clone of the Node and all its children.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.14
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeFoldConstants.tryFoldBinaryOperator#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldBinaryOperator(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldBinaryOperator(Node subtree) {\n    Node left = subtree.getFirstChild();\n\n    if (left == null) {\n      return subtree;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return subtree;\n    }\n\n    // If we've reached here, node is truly a binary operator.\n    switch(subtree.getType()) {\n      case Token.GETPROP:\n        return tryFoldGetProp(subtree, left, right);\n\n      case Token.GETELEM:\n        return tryFoldGetElem(subtree, left, right);\n\n      case Token.INSTANCEOF:\n        return tryFoldInstanceof(subtree, left, right);\n\n      case Token.AND:\n      case Token.OR:\n        return tryFoldAndOr(subtree, left, right);\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        return tryFoldShift(subtree, left, right);\n\n      case Token.ASSIGN:\n        return tryFoldAssign(subtree, left, right);\n\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return tryUnfoldAssignOp(subtree, left, right);\n\n      case Token.ADD:\n        return tryFoldAdd(subtree, left, right);\n\n      case Token.SUB:\n      case Token.DIV:\n      case Token.MOD:\n        return tryFoldArithmeticOp(subtree, left, right);\n\n      case Token.MUL:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n        Node result = tryFoldArithmeticOp(subtree, left, right);\n        if (result != subtree) {\n          return result;\n        }\n        return tryFoldLeftChildOp(subtree, left, right);\n\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return tryFoldComparison(subtree, left, right);\n\n      default:\n        return subtree;\n    }\n  }\n",
        "begin_line": 103,
        "end_line": 183,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.14
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.checkForStateChangeHelper#793",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.checkForStateChangeHelper(com.google.javascript.rhino.Node, boolean, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.CAST:\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.PARAM_LIST:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n        if (checkForNewObjects) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (checkForStateChangeHelper(\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n        }\n        return false;\n\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null) {\n          return true;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Function expressions don't have side-effects, but function\n        // declarations change the namespace. Either way, we don't need to\n        // check the children, since they aren't executed at declaration time.\n        return checkForNewObjects || !isFunctionExpression(n);\n\n      case Token.NEW:\n        if (checkForNewObjects) {\n          return true;\n        }\n\n        if (!constructorCallHasSideEffects(n)) {\n          // loop below will see if the constructor parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (!functionCallHasSideEffects(n, compiler)) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperator(n)) {\n          break;\n        }\n\n        if (isAssignmentOp(n)) {\n          Node assignTarget = n.getFirstChild();\n          if (assignTarget.isName()) {\n            return true;\n          }\n\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n\n          if (isGet(assignTarget)) {\n            // If the object being assigned to is a local object, don't\n            // consider this a side-effect as it can't be referenced\n            // elsewhere.  Don't do this recursively as the property might\n            // be an alias of another object, unlike a literal below.\n            Node current = assignTarget.getFirstChild();\n            if (evaluatesToLocalValue(current)) {\n              return false;\n            }\n\n            // A literal value as defined by \"isLiteralValue\" is guaranteed\n            // not to be an alias, or any components which are aliases of\n            // other objects.\n            // If the root object is a literal don't consider this a\n            // side-effect.\n            while (isGet(current)) {\n              current = current.getFirstChild();\n            }\n\n            return !isLiteralValue(current, true);\n          } else {\n            // TODO(johnlenz): remove this code and make this an exception. This\n            // is here only for legacy reasons, the AST is not valid but\n            // preserve existing behavior.\n            return !isLiteralValue(assignTarget, true);\n          }\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 793,
        "end_line": 938,
        "comment": "\n   * Returns true if some node in n's subtree changes application state.\n   * If {@code checkForNewObjects} is true, we assume that newly created\n   * mutable objects (like object literals) change state. Otherwise, we assume\n   * that they have no side effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.14
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getInitialValue#226",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getInitialValue()",
        "snippet": "    public Node getInitialValue() {\n      return NodeUtil.getRValueOfLValue(nameNode);\n    }\n",
        "begin_line": 226,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1393
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.getUniqueName#488",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.getUniqueName(java.lang.String, int)",
        "snippet": "    private String getUniqueName(String name, int id) {\n      return name + UNIQUE_ID_SEPARATOR + id;\n    }\n",
        "begin_line": 488,
        "end_line": 490,
        "comment": "\n     * Given a name and the associated id, create a new unique name.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1393
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.stripConstIfReplaced#500",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer.stripConstIfReplaced()",
        "snippet": "    @Override\n    public boolean stripConstIfReplaced() {\n      return false;\n    }\n",
        "begin_line": 500,
        "end_line": 503,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1393
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodePrinter.maybeLineBreak#463",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodePrinter.java",
        "class_name": "com.google.javascript.jscomp.CodePrinter",
        "signature": "com.google.javascript.jscomp.CodePrinter.CompactCodePrinter.maybeLineBreak()",
        "snippet": "    @Override\n    void maybeLineBreak() {\n      if (lineBreak) {\n        if (sawFunction) {\n          startNewLine();\n          sawFunction = false;\n        }\n      }\n\n      // Since we are at a legal line break, can we upgrade the\n      // preferred break position?  We prefer to break after a\n      // semicolon rather than before it.\n      int len = code.length();\n      if (preferredBreakPosition == len - 1) {\n        char ch = code.charAt(len - 1);\n        if (ch == ';') {\n          preferredBreakPosition = len;\n        }\n      }\n      maybeCutLine();\n    }\n",
        "begin_line": 463,
        "end_line": 483,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1381
        },
        "num_failing_tests": 6
    },
    {
        "name": "ShadowVariables.exitScope#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.DoShadowVariables.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}\n",
        "begin_line": 227,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 4
    },
    {
        "name": "ShadowVariables.visit#230",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.DoShadowVariables.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {}\n",
        "begin_line": 230,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 4
    },
    {
        "name": "ShadowVariables.ShadowVariables#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.ShadowVariables(com.google.javascript.jscomp.AbstractCompiler, java.util.Map<java.lang.String, com.google.javascript.jscomp.RenameVars.Assignment>, java.util.SortedSet<com.google.javascript.jscomp.RenameVars.Assignment>, java.util.Map<com.google.javascript.rhino.Node, java.lang.String>)",
        "snippet": "  ShadowVariables(\n      AbstractCompiler compiler,\n      Map<String, Assignment> assignments,\n      SortedSet<Assignment> varsByFrequency,\n      Map<Node, String> pseudoNameMap) {\n    this.compiler = compiler;\n    this.assignments = assignments;\n    this.varsByFrequency = varsByFrequency;\n    this.oldPseudoNameMap = pseudoNameMap;\n    this.deltaPseudoNameMap = Maps.newLinkedHashMap();\n  }\n",
        "begin_line": 96,
        "end_line": 106,
        "comment": "\n   * @param assignments Map of old variable names to its assignment Objects.\n   * @param varsByFrequency Sorted variable assignments by Frequency.\n   * @param pseudoNameMap The current pseudo name map so this pass can update\n   *     it accordingly.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 4
    },
    {
        "name": "ShadowVariables.process#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ShadowVariables.java",
        "class_name": "com.google.javascript.jscomp.ShadowVariables",
        "signature": "com.google.javascript.jscomp.ShadowVariables.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n\n    // The algorithm is divided into two stages:\n    //\n    // 1. Information gathering (variable usage, upward referencing)\n    //\n    // 2. Tries to find shadows for each variables, updates the\n    //    variable usage frequency map.\n    //\n    // 3. Updates the pseudo naming map if needed.\n    NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());\n    NodeTraversal.traverse(compiler, root, new DoShadowVariables());\n\n    if (oldPseudoNameMap != null) {\n      oldPseudoNameMap.putAll(deltaPseudoNameMap);\n    }\n  }\n",
        "begin_line": 108,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.process#323",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    assignmentLog = new StringBuilder();\n\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, externs, new ProcessVars(true));\n    NodeTraversal.traverse(compiler, root, new ProcessVars(false));\n\n    // Make sure that new names don't overlap with extern names.\n    reservedNames.addAll(externNames);\n\n    // Rename vars, sorted by frequency of occurrence to minimize code size.\n    SortedSet<Assignment> varsByFrequency =\n        new TreeSet<Assignment>(FREQUENCY_COMPARATOR);\n    varsByFrequency.addAll(assignments.values());\n\n    if (shouldShadow) {\n      new ShadowVariables(\n          compiler, assignments, varsByFrequency, pseudoNameMap).process(\n              externs, root);\n    }\n\n    // First try to reuse names from an earlier compilation.\n    if (prevUsedRenameMap != null) {\n      reusePreviouslyUsedVariableMap();\n    }\n\n    // Assign names, sorted by descending frequency to minimize code size.\n    assignNames(varsByFrequency);\n\n    boolean changed = false;\n\n    // Rename the globals!\n    for (Node n : globalNameNodes) {\n      String newName = getNewGlobalName(n);\n      // Note: if newName is null, then oldName is an extern.\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n    }\n\n    // Rename the locals!\n    int count = 0;\n    for (Node n : localNameNodes) {\n      String newName = getNewLocalName(n);\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n      count++;\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    // Lastly, write the name assignments to the debug log.\n    compiler.addToDebugLog(\"JS var assignments:\\n\" + assignmentLog);\n    assignmentLog = null;\n  }\n",
        "begin_line": 323,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1374
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.visit#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.EliminationPass.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (parent == null) {\n        return;\n      }\n      if (n.isFunction() || n.isScript()) {\n        return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n      if (gNode == null) { // Not in CFG.\n        return;\n      }\n      if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n          (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {\n        removeDeadExprStatementSafely(n);\n        return;\n      }\n\n      tryRemoveUnconditionalBranching(n);\n    }\n",
        "begin_line": 91,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1367
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineFunctions.process#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }\n",
        "begin_line": 112,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1367
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.hashCode#302",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.hashCode()",
        "snippet": "    @Override public int hashCode() {\n      return nameNode.hashCode();\n    }\n",
        "begin_line": 302,
        "end_line": 304,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1366
        },
        "num_failing_tests": 6
    },
    {
        "name": "IRFactory.processNumberLiteral#891",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processNumberLiteral(com.google.javascript.rhino.head.ast.NumberLiteral)",
        "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }\n",
        "begin_line": 891,
        "end_line": 894,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.136
        },
        "num_failing_tests": 5
    },
    {
        "name": "IRFactory.newNumberNode#1446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(java.lang.Double)",
        "snippet": "  private Node newNumberNode(Double value) {\n    return IR.number(value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1446,
        "end_line": 1448,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.136
        },
        "num_failing_tests": 5
    },
    {
        "name": "NodeUtil.isConstantName#2822",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isConstantName(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isConstantName(Node node) {\n    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n  }\n",
        "begin_line": 2822,
        "end_line": 2824,
        "comment": "\n   * Returns true if a name node represents a constant variable.\n   *\n   * <p>Determining whether a variable is constant has three steps:\n   * <ol>\n   * <li>In CodingConventionAnnotator, any name that matches the\n   *     {@link CodingConvention#isConstant(String)} is annotated with an\n   *     IS_CONSTANT_NAME property.\n   * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME\n   *     annotation and that is initialized to a constant value with\n   *     a variable name including $$constant.\n   * <li>Return true here if the variable includes $$constant in its name.\n   * </ol>\n   *\n   * @param node A NAME or STRING node\n   * @return True if the variable is constant\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1358
        },
        "num_failing_tests": 6
    },
    {
        "name": "NodeTraversal.getControlFlowGraph#613",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getControlFlowGraph()",
        "snippet": "  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }\n",
        "begin_line": 613,
        "end_line": 621,
        "comment": " Gets the control flow graph for the current JS scope. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1355
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.MustDef#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef.MustDef(java.util.Iterator<com.google.javascript.jscomp.Scope.Var>)",
        "snippet": "    public MustDef(Iterator<Var> vars) {\n      this();\n      while(vars.hasNext()) {\n        Var var = vars.next();\n        // Every variable in the scope is defined once in the beginning of the\n        // function: all the declared variables are undefined, all functions\n        // have been assigned and all arguments has its value from the caller.\n        reachingDef.put(var, new Definition(var.scope.getRootNode()));\n      }\n    }\n",
        "begin_line": 120,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1355
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.Definition#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.Definition.Definition(com.google.javascript.rhino.Node)",
        "snippet": "    Definition(Node node) {\n      this.node = node;\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1355
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.traverse#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.traverse(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, java.util.List<com.google.javascript.jscomp.NodeTraversal.Callback>)",
        "snippet": "  static void traverse(AbstractCompiler compiler, Node root,\n      List<Callback> callbacks) {\n    if (callbacks.size() == 1) {\n      NodeTraversal.traverse(compiler, root, callbacks.get(0));\n    } else {\n      (new CombinedCompilerPass(compiler, callbacks)).process(null, root);\n    }\n  }\n",
        "begin_line": 73,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1355
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.MustDef#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef.MustDef()",
        "snippet": "    public MustDef() {\n      reachingDef = Maps.newHashMap();\n    }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.MustDef#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef.MustDef(com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef)",
        "snippet": "    public MustDef(MustDef other) {\n      reachingDef = Maps.newHashMap(other.reachingDef);\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "\n     * Copy constructor.\n     *\n     * @param other The constructed object is a replicated copy of this element.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.equals#140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object other) {\n      return (other instanceof MustDef) &&\n          ((MustDef) other).reachingDef.equals(this.reachingDef);\n    }\n",
        "begin_line": 140,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.MustBeReachingVariableDef#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustBeReachingVariableDef(com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  MustBeReachingVariableDef(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n    super(cfg, new MustDefJoin());\n    this.jsScope = jsScope;\n    this.compiler = compiler;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }\n",
        "begin_line": 53,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.isForward#193",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.isForward()",
        "snippet": "  @Override\n  boolean isForward() {\n    return true;\n  }\n",
        "begin_line": 193,
        "end_line": 196,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.createEntryLattice#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.createEntryLattice()",
        "snippet": "  @Override\n  MustDef createEntryLattice() {\n    return new MustDef(jsScope.getVars());\n  }\n",
        "begin_line": 198,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.createInitialEstimateLattice#203",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.createInitialEstimateLattice()",
        "snippet": "  @Override\n  MustDef createInitialEstimateLattice() {\n    return new MustDef();\n  }\n",
        "begin_line": 203,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MustBeReachingVariableDef.flowThrough#208",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.flowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef)",
        "snippet": "  @Override\n  MustDef flowThrough(Node n, MustDef input) {\n    // TODO(user): We are doing a straight copy from input to output. There\n    // might be some opportunities to cut down overhead.\n    MustDef output = new MustDef(input);\n    // TODO(user): This must know about ON_EX edges but it should handle\n    // it better than what we did in liveness. Because we are in a forward mode,\n    // we can used the branched forward analysis.\n    computeMustDef(n, n, output, false);\n    return output;\n  }\n",
        "begin_line": 208,
        "end_line": 218,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.ReachingUses#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses.ReachingUses()",
        "snippet": "    public ReachingUses() {\n      mayUseMap = HashMultimap.create();\n    }\n",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.ReachingUses#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses.ReachingUses(com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses)",
        "snippet": "    public ReachingUses(ReachingUses other) {\n      mayUseMap = HashMultimap.create(other.mayUseMap);\n    }\n",
        "begin_line": 97,
        "end_line": 99,
        "comment": "\n     * Copy constructor.\n     *\n     * @param other The constructed object is a replicated copy of this element.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.equals#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses.equals(java.lang.Object)",
        "snippet": "    @Override\n    public boolean equals(Object other) {\n      return (other instanceof ReachingUses) &&\n          ((ReachingUses) other).mayUseMap.equals(this.mayUseMap);\n    }\n",
        "begin_line": 101,
        "end_line": 105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.MaybeReachingVariableUse#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.MaybeReachingVariableUse(com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  MaybeReachingVariableUse(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n    super(cfg, new ReachingUsesJoinOp());\n    this.jsScope = jsScope;\n    this.escaped = Sets.newHashSet();\n\n    // TODO(user): Maybe compute it somewhere else and re-use the escape\n    // local set here.\n    computeEscaped(jsScope, escaped, compiler);\n  }\n",
        "begin_line": 51,
        "end_line": 60,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.isForward#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.isForward()",
        "snippet": "  @Override\n  boolean isForward() {\n    return false;\n  }\n",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.createEntryLattice#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.createEntryLattice()",
        "snippet": "  @Override\n  ReachingUses createEntryLattice() {\n    return new ReachingUses();\n  }\n",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.createInitialEstimateLattice#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.createInitialEstimateLattice()",
        "snippet": "  @Override\n  ReachingUses createInitialEstimateLattice() {\n    return new ReachingUses();\n  }\n",
        "begin_line": 141,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.flowThrough#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.flowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses)",
        "snippet": "  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n\n    // If there's an ON_EX edge, this cfgNode may or may not get executed.\n    // We can express this concisely by just pretending this happens in\n    // a conditional.\n    boolean conditional = hasExceptionHandler(n);\n    computeMayUse(n, n, output, conditional);\n\n    return output;\n  }\n",
        "begin_line": 146,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "MaybeReachingVariableUse.hasExceptionHandler#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.hasExceptionHandler(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 159,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.visit#197",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.GatherCandiates.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        // Not a CFG node.\n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            // n.getParent() isn't null. This just the case where n is the root\n            // node that gatherCb started at.\n            if (parent == null) {\n              return;\n            }\n\n            // Make sure that the name node is purely a read.\n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Definition def = reachingDef.getDef(name, cfgNode);\n            // TODO(nicksantos): We need to add some notion of @const outer\n            // scope vars. We can inline those just fine.\n            if (def != null &&\n                !reachingDef.dependsOnOuterScopeVars(def)) {\n              candidates.add(new Candidate(name, def, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n",
        "begin_line": 197,
        "end_line": 244,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.visit#210",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.GatherCandiates.Anonymous-32a2d361-433f-4ada-9a3c-d6e97f320c9d.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            // n.getParent() isn't null. This just the case where n is the root\n            // node that gatherCb started at.\n            if (parent == null) {\n              return;\n            }\n\n            // Make sure that the name node is purely a read.\n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Definition def = reachingDef.getDef(name, cfgNode);\n            // TODO(nicksantos): We need to add some notion of @const outer\n            // scope vars. We can inline those just fine.\n            if (def != null &&\n                !reachingDef.dependsOnOuterScopeVars(def)) {\n              candidates.add(new Candidate(name, def, n, cfgNode));\n            }\n          }\n        }\n",
        "begin_line": 210,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.enterScope#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline(t.getScope())) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n",
        "begin_line": 124,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.setIn#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.FlowState.setIn(L)",
        "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }\n",
        "begin_line": 352,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.flow#267",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.flow(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "  protected boolean flow(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      L outBefore = state.out;\n      state.out = flowThrough(node.getValue(), state.in);\n      return !outBefore.equals(state.out);\n    } else {\n      L inBefore = state.in;\n      state.in = flowThrough(node.getValue(), state.out);\n      return !inBefore.equals(state.in);\n    }\n  }\n",
        "begin_line": 267,
        "end_line": 278,
        "comment": "\n   * Performs a single flow through a node.\n   *\n   * @return {@code true} if the flow state differs from the previous state.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.processVariableDeclaration#1152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processVariableDeclaration(com.google.javascript.rhino.head.ast.VariableDeclaration)",
        "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.rhino.head.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n",
        "begin_line": 1152,
        "end_line": 1164,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1346
        },
        "num_failing_tests": 7
    },
    {
        "name": "IRFactory.processVariableInitializer#1166",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processVariableInitializer(com.google.javascript.rhino.head.ast.VariableInitializer)",
        "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        Node initalizer = transform(initializerNode.getInitializer());\n        node.addChildToBack(initalizer);\n      }\n      return node;\n    }\n",
        "begin_line": 1166,
        "end_line": 1174,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1346
        },
        "num_failing_tests": 7
    },
    {
        "name": "IR.number#450",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.number(double)",
        "snippet": "  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n",
        "begin_line": 450,
        "end_line": 452,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1344
        },
        "num_failing_tests": 5
    },
    {
        "name": "WarningLevel.addDefaultWarnings#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningLevel.java",
        "class_name": "com.google.javascript.jscomp.WarningLevel",
        "signature": "com.google.javascript.jscomp.WarningLevel.addDefaultWarnings(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  private static void addDefaultWarnings(CompilerOptions options) {\n    options.checkSuspiciousCode = true;\n    options.checkUnreachableCode = CheckLevel.WARNING;\n    options.checkControlStructures = true;\n  }\n",
        "begin_line": 84,
        "end_line": 88,
        "comment": "\n   * Add the default checking pass to the compilation options.\n   * @param options The CompilerOptions object to set the options on.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.ProcessLabels#105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.ProcessLabels.ProcessLabels()",
        "snippet": "    ProcessLabels() {\n      // Create a entry for global scope.\n      namespaceStack.push(new LabelNamespace());\n    }\n",
        "begin_line": 105,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.enterScope#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.ProcessLabels.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal nodeTraversal) {\n      // Start a new namespace for label names.\n      namespaceStack.push(new LabelNamespace());\n    }\n",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.exitScope#125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.ProcessLabels.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal nodeTraversal) {\n      namespaceStack.pop();\n    }\n",
        "begin_line": 125,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.shouldTraverse#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.ProcessLabels.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node,\n        Node parent) {\n      if (node.isLabel()) {\n        // Determine the new name for this label.\n        LabelNamespace current = namespaceStack.peek();\n        int currentDepth = current.renameMap.size() + 1;\n        String name = node.getFirstChild().getString();\n\n        // Store the context for this label name.\n        LabelInfo li = new LabelInfo(currentDepth);\n        Preconditions.checkState(!current.renameMap.containsKey(name));\n        current.renameMap.put(name, li);\n\n        // Create a new name, if needed, for this depth.\n        if (names.size() < currentDepth) {\n          names.add(nameSupplier.get());\n        }\n\n        String newName = getNameForId(currentDepth);\n        compiler.addToDebugLog(\"label renamed: \" + name + \" => \" + newName);\n      }\n\n      return true;\n    }\n",
        "begin_line": 136,
        "end_line": 160,
        "comment": "\n     * shouldTraverse is call when descending into the Node tree, so it is used\n     * here to build the context for label renames.\n     *\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "com.google.javascript.jscomp.NodeTraversal.ScopedCallback": null,
            "com.google.javascript.jscomp.CompilerPass": "\n   * Process the JS with root node root.\n   * Can modify the contents of each Node tree\n   * @param externs Top of external JS tree\n   * @param root Top of JS tree\n   "
        },
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.visit#168",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.ProcessLabels.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n      switch (node.getType()) {\n        case Token.LABEL:\n          visitLabel(node, parent);\n          break;\n\n        case Token.BREAK:\n        case Token.CONTINUE:\n          visitBreakOrContinue(node);\n          break;\n      }\n    }\n",
        "begin_line": 168,
        "end_line": 180,
        "comment": "\n     * Delegate the actual processing of the node to visitLabel and\n     * visitBreakOrContinue.\n     *\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "com.google.javascript.jscomp.NodeTraversal.ScopedCallback": null,
            "com.google.javascript.jscomp.CompilerPass": "\n   * Process the JS with root node root.\n   * Can modify the contents of each Node tree\n   * @param externs Top of external JS tree\n   * @param root Top of JS tree\n   "
        },
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.RenameLabels#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.RenameLabels(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  RenameLabels(AbstractCompiler compiler) {\n    this(compiler, new DefaultNameSupplier(), true);\n  }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.RenameLabels#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.RenameLabels(com.google.javascript.jscomp.AbstractCompiler, com.google.common.base.Supplier<java.lang.String>, boolean)",
        "snippet": "  RenameLabels(\n      AbstractCompiler compiler,\n      Supplier<String> supplier,\n      boolean removeUnused) {\n    this.compiler = compiler;\n    this.nameSupplier = supplier;\n    this.removeUnused = removeUnused;\n  }\n",
        "begin_line": 80,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameLabels.process#257",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameLabels.java",
        "class_name": "com.google.javascript.jscomp.RenameLabels",
        "signature": "com.google.javascript.jscomp.RenameLabels.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, root, new ProcessLabels());\n  }\n",
        "begin_line": 257,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineFunctions.shouldTraverse#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.FindCandidateFunctions.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      // Don't traverse into function bodies\n      // if we aren't inlining local functions.\n      return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n    }\n",
        "begin_line": 157,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineFunctions.InlineFunctions#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineFunctions.java",
        "class_name": "com.google.javascript.jscomp.InlineFunctions",
        "signature": "com.google.javascript.jscomp.InlineFunctions.InlineFunctions(com.google.javascript.jscomp.AbstractCompiler, com.google.common.base.Supplier<java.lang.String>, boolean, boolean, boolean, boolean, boolean)",
        "snippet": "  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkArgument(compiler != null);\n    Preconditions.checkArgument(safeNameIdSupplier != null);\n    this.compiler = compiler;\n\n    this.inlineGlobalFunctions = inlineGlobalFunctions;\n    this.inlineLocalFunctions = inlineLocalFunctions;\n    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n\n    this.injector = new FunctionInjector(\n        compiler, safeNameIdSupplier,\n        true, assumeStrictThis, assumeMinimumCapture);\n  }\n",
        "begin_line": 76,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "FunctionInjector.FunctionInjector#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionInjector.java",
        "class_name": "com.google.javascript.jscomp.FunctionInjector",
        "signature": "com.google.javascript.jscomp.FunctionInjector.FunctionInjector(com.google.javascript.jscomp.AbstractCompiler, com.google.common.base.Supplier<java.lang.String>, boolean, boolean, boolean)",
        "snippet": "  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n    this.assumeStrictThis = assumeStrictThis;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n  }\n",
        "begin_line": 52,
        "end_line": 65,
        "comment": "\n   * @param allowDecomposition Whether an effort should be made to break down\n   * expressions into simpler expressions to allow functions to be injected\n   * where they would otherwise be disallowed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.FlowSensitiveInlineVariables#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.FlowSensitiveInlineVariables(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 120,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.exitScope#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {}\n",
        "begin_line": 172,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.process#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }\n",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "FlowSensitiveInlineVariables.visit#180",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
        "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
        "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(user): While the helpers do a subtree traversal on the AST, the\n    // compiler pass itself only traverse the AST to look for function\n    // declarations to perform dataflow analysis on. We could combine\n    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n    // time.\n  }\n",
        "begin_line": 180,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-18ba8040-a126-478a-81e4-8630180f3aa9.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new ConvertToDottedProperties(compiler);\n    }\n",
        "begin_line": 2133,
        "end_line": 2136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-01e6966e-2b14-4847-93ca-818daaedf85a.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new RenameLabels(compiler);\n    }\n",
        "begin_line": 2124,
        "end_line": 2127,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1834",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-a17523c5-167f-4ed9-ae0d-b4e1bb9af7d6.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new FlowSensitiveInlineVariables(compiler);\n    }\n",
        "begin_line": 1834,
        "end_line": 1837,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1752",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-d47d54d5-6bef-4c9b-a55f-1e3a72958890.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      boolean enableBlockInlining = !isInliningForbidden();\n      return new InlineFunctions(\n          compiler,\n          compiler.getUniqueNameIdSupplier(),\n          options.inlineFunctions,\n          options.inlineLocalFunctions,\n          enableBlockInlining,\n          options.assumeStrictThis()\n              || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT,\n          true /* assumeMinimumCapture */);\n    }\n",
        "begin_line": 1752,
        "end_line": 1764,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getOptimizations#347",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getOptimizations()",
        "snippet": "  @Override\n  protected List<PassFactory> getOptimizations() {\n    List<PassFactory> passes = Lists.newArrayList();\n    passes.add(garbageCollectChecks);\n\n    // TODO(nicksantos): The order of these passes makes no sense, and needs\n    // to be re-arranged.\n\n    if (options.runtimeTypeCheck) {\n      passes.add(runtimeTypeCheck);\n    }\n\n    passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n\n    if (options.replaceIdGenerators) {\n      passes.add(replaceIdGenerators);\n    }\n\n    // Optimizes references to the arguments variable.\n    if (options.optimizeArgumentsArray) {\n      passes.add(optimizeArgumentsArray);\n    }\n\n    // Abstract method removal works best on minimally modified code, and also\n    // only needs to run once.\n    if (options.closurePass &&\n        (options.removeAbstractMethods || options.removeClosureAsserts)) {\n      passes.add(closureCodeRemoval);\n    }\n\n    // Collapsing properties can undo constant inlining, so we do this before\n    // the main optimization loop.\n    if (options.collapseProperties) {\n      passes.add(collapseProperties);\n    }\n\n    // ReplaceStrings runs after CollapseProperties in order to simplify\n    // pulling in values of constants defined in enums structures.\n    if (!options.replaceStringsFunctionDescriptions.isEmpty()) {\n      passes.add(replaceStrings);\n    }\n\n    // Tighten types based on actual usage.\n    if (options.tightenTypes) {\n      passes.add(tightenTypesBuilder);\n    }\n\n    // Property disambiguation should only run once and needs to be done\n    // soon after type checking, both so that it can make use of type\n    // information and so that other passes can take advantage of the renamed\n    // properties.\n    if (options.disambiguateProperties) {\n      passes.add(disambiguateProperties);\n    }\n\n    if (options.computeFunctionSideEffects) {\n      passes.add(markPureFunctions);\n    } else if (options.markNoSideEffectCalls) {\n      // TODO(user) The properties that this pass adds to CALL and NEW\n      // AST nodes increase the AST's in-memory size.  Given that we are\n      // already running close to our memory limits, we could run into\n      // trouble if we end up using the @nosideeffects annotation a lot\n      // or compute @nosideeffects annotations by looking at function\n      // bodies.  It should be easy to propagate @nosideeffects\n      // annotations as part of passes that depend on this property and\n      // store the result outside the AST (which would allow garbage\n      // collection once the pass is done).\n      passes.add(markNoSideEffectCalls);\n    }\n\n    if (options.chainCalls) {\n      passes.add(chainCalls);\n    }\n\n    // Constant checking must be done after property collapsing because\n    // property collapsing can introduce new constants (e.g. enum values).\n    // TODO(johnlenz): make checkConsts namespace aware so it can be run\n    // as during the checks phase.\n    passes.add(checkConsts);\n\n    // The Caja library adds properties to Object.prototype, which breaks\n    // most for-in loops.  This adds a check to each loop that skips\n    // any property matching /___$/.\n    if (options.ignoreCajaProperties) {\n      passes.add(ignoreCajaProperties);\n    }\n\n    assertAllOneTimePasses(passes);\n\n    if (options.smartNameRemoval || options.reportPath != null) {\n      passes.addAll(getCodeRemovingPasses());\n      passes.add(smartNamePass);\n    }\n\n    // This needs to come after the inline constants pass, which is run within\n    // the code removing passes.\n    if (options.closurePass) {\n      passes.add(closureOptimizePrimitives);\n    }\n\n    // TODO(user): This forces a first crack at crossModuleCodeMotion\n    // before devirtualization. Once certain functions are devirtualized,\n    // it confuses crossModuleCodeMotion ability to recognized that\n    // it is recursive.\n\n    // TODO(user): This is meant for a temporary quick win.\n    // In the future, we might want to improve our analysis in\n    // CrossModuleCodeMotion so we don't need to do this.\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    // Method devirtualization benefits from property disambiguation so\n    // it should run after that pass but before passes that do\n    // optimizations based on global names (like cross module code motion\n    // and inline functions).  Smart Name Removal does better if run before\n    // this pass.\n    if (options.devirtualizePrototypeMethods) {\n      passes.add(devirtualizePrototypeMethods);\n    }\n\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));\n    }\n\n    passes.add(createEmptyPass(\"beforeMainOptimizations\"));\n\n    passes.addAll(getMainOptimizationLoop());\n\n    if (options.specializeInitialModule) {\n      // When specializing the initial module, we want our fixups to be\n      // as lean as possible, so we run the entire optimization loop to a\n      // fixed point before specializing, then specialize, and then run the\n      // main optimization loop again.\n\n      if (options.crossModuleCodeMotion) {\n        passes.add(crossModuleCodeMotion);\n      }\n\n      if (options.crossModuleMethodMotion) {\n        passes.add(crossModuleMethodMotion);\n      }\n\n      passes.add(specializeInitialModule);\n      passes.addAll(getMainOptimizationLoop());\n    }\n\n    passes.add(createEmptyPass(\"beforeModuleMotion\"));\n\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    if (options.crossModuleMethodMotion) {\n      passes.add(crossModuleMethodMotion);\n    }\n\n    passes.add(createEmptyPass(\"afterModuleMotion\"));\n\n    // Some optimizations belong outside the loop because running them more\n    // than once would either have no benefit or be incorrect.\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n    }\n\n    if (options.flowSensitiveInlineVariables) {\n      passes.add(flowSensitiveInlineVariables);\n\n      // After inlining some of the variable uses, some variables are unused.\n      // Re-run remove unused vars to clean it up.\n      if (options.removeUnusedVars || options.removeUnusedLocalVars) {\n        passes.add(removeUnusedVars);\n      }\n    }\n\n    // Running this pass again is required to have goog.events compile down to\n    // nothing when compiled on its own.\n    if (options.smartNameRemoval) {\n      passes.add(smartNamePass2);\n    }\n\n    if (options.collapseAnonymousFunctions) {\n      passes.add(collapseAnonymousFunctions);\n    }\n\n    // Move functions before extracting prototype member declarations.\n    if (options.moveFunctionDeclarations ||\n        // renamePrefixNamescape relies on moveFunctionDeclarations\n        // to preserve semantics.\n        options.renamePrefixNamespace != null) {\n      passes.add(moveFunctionDeclarations);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.MAPPED) {\n      passes.add(nameMappedAnonymousFunctions);\n    }\n\n    // The mapped name anonymous function pass makes use of information that\n    // the extract prototype member declarations pass removes so the former\n    // happens before the latter.\n    //\n    // Extracting prototype properties screws up the heuristic renaming\n    // policies, so never run it when those policies are requested.\n    if (options.extractPrototypeMemberDeclarations &&\n        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n         options.propertyRenaming !=\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n      passes.add(extractPrototypeMemberDeclarations);\n    }\n\n    if (options.ambiguateProperties &&\n        (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n      passes.add(ambiguateProperties);\n    }\n\n    if (options.propertyRenaming != PropertyRenamingPolicy.OFF) {\n      passes.add(renameProperties);\n    }\n\n    // Reserve global names added to the \"windows\" object.\n    if (options.reserveRawExports) {\n      passes.add(gatherRawExports);\n    }\n\n    // This comes after property renaming because quoted property names must\n    // not be renamed.\n    if (options.convertToDottedProperties) {\n      passes.add(convertToDottedProperties);\n    }\n\n    // Property renaming must happen before this pass runs since this\n    // pass may convert dotted properties into quoted properties.  It\n    // is beneficial to run before alias strings, alias keywords and\n    // variable renaming.\n    if (options.rewriteFunctionExpressions) {\n      passes.add(rewriteFunctionExpressions);\n    }\n\n    // This comes after converting quoted property accesses to dotted property\n    // accesses in order to avoid aliasing property names.\n    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n      passes.add(aliasStrings);\n    }\n\n    if (options.aliasExternals) {\n      passes.add(aliasExternals);\n    }\n\n    if (options.aliasKeywords) {\n      passes.add(aliasKeywords);\n    }\n\n    // Passes after this point can no longer depend on normalized AST\n    // assumptions.\n    passes.add(markUnnormalized);\n\n    if (options.coalesceVariableNames) {\n      passes.add(coalesceVariableNames);\n\n      // coalesceVariables creates identity assignments and more redundant code\n      // that can be removed, rerun the peephole optimizations to clean them\n      // up.\n      if (options.foldConstants) {\n        passes.add(peepholeOptimizations);\n      }\n    }\n\n    if (options.collapseVariableDeclarations) {\n      passes.add(exploitAssign);\n      passes.add(collapseVariableDeclarations);\n    }\n\n    // This pass works best after collapseVariableDeclarations.\n    passes.add(denormalize);\n\n    if (options.instrumentationTemplate != null) {\n      passes.add(instrumentFunctions);\n    }\n\n    if (options.variableRenaming != VariableRenamingPolicy.ALL) {\n      // If we're leaving some (or all) variables with their old names,\n      // then we need to undo any of the markers we added for distinguishing\n      // local variables (\"$$1\").\n      passes.add(invertContextualRenaming);\n    }\n\n    if (options.variableRenaming != VariableRenamingPolicy.OFF) {\n      passes.add(renameVars);\n    }\n\n    if (options.groupVariableDeclarations) {\n      passes.add(groupVariableDeclarations);\n    }\n\n    // This pass should run after names stop changing.\n    if (options.processObjectPropertyString) {\n      passes.add(objectPropertyStringPostprocess);\n    }\n\n    if (options.labelRenaming) {\n      passes.add(renameLabels);\n    }\n\n    if (options.foldConstants) {\n      passes.add(latePeepholeOptimizations);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.UNMAPPED) {\n      passes.add(nameUnmappedAnonymousFunctions);\n    }\n\n    passes.add(stripSideEffectProtection);\n\n    if (options.renamePrefixNamespace != null) {\n      if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(\n          options.renamePrefixNamespace).matches()) {\n        throw new IllegalArgumentException(\n            \"Illegal character in renamePrefixNamespace name: \"\n            + options.renamePrefixNamespace);\n      }\n      passes.add(rescopeGlobalSymbols);\n    }\n\n    // Safety checks\n    passes.add(sanityCheckAst);\n    passes.add(sanityCheckVars);\n\n    return passes;\n  }\n",
        "begin_line": 347,
        "end_line": 679,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.runVariableRenaming#2096",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.runVariableRenaming(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.VariableMap, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private VariableMap runVariableRenaming(\n      AbstractCompiler compiler, VariableMap prevVariableMap,\n      Node externs, Node root) {\n    char[] reservedChars =\n        options.anonymousFunctionNaming.getReservedCharacters();\n    boolean preserveAnonymousFunctionNames =\n        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n    Set<String> reservedNames = Sets.newHashSet();\n    if (exportedNames != null) {\n      reservedNames.addAll(exportedNames);\n    }\n    reservedNames.addAll(ParserRunner.getReservedVars());\n    RenameVars rn = new RenameVars(\n        compiler,\n        options.renamePrefix,\n        options.variableRenaming == VariableRenamingPolicy.LOCAL,\n        preserveAnonymousFunctionNames,\n        options.generatePseudoNames,\n        options.shadowVariables,\n        prevVariableMap,\n        reservedChars,\n        reservedNames);\n    rn.process(externs, root);\n    return rn.getVariableMap();\n  }\n",
        "begin_line": 2096,
        "end_line": 2120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvertToDottedProperties.ConvertToDottedProperties#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConvertToDottedProperties.java",
        "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
        "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.ConvertToDottedProperties(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  ConvertToDottedProperties(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvertToDottedProperties.process#39",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConvertToDottedProperties.java",
        "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
        "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 39,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConvertToDottedProperties.visit#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConvertToDottedProperties.java",
        "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
        "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n      case Token.STRING_KEY:\n        if (NodeUtil.isValidPropertyName(n.getString())) {\n          n.putBooleanProp(Node.QUOTED_PROP, false);\n          compiler.reportCodeChange();\n        }\n        break;\n\n      case Token.GETELEM:\n        Node left = n.getFirstChild();\n        Node right = left.getNext();\n        if (right.isString() &&\n            NodeUtil.isValidPropertyName(right.getString())) {\n          n.removeChild(left);\n          n.removeChild(right);\n          parent.replaceChild(n, IR.getprop(left, right));\n          compiler.reportCodeChange();\n        }\n        break;\n    }\n  }\n",
        "begin_line": 44,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.assumeStrictThis#1539",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.assumeStrictThis()",
        "snippet": "  public boolean assumeStrictThis() {\n    return assumeStrictThis;\n  }\n",
        "begin_line": 1539,
        "end_line": 1541,
        "comment": "\n   * @return Whether assumeStrictThis is set.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1342
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.NumberNode#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.NumberNode.NumberNode(double)",
        "snippet": "    NumberNode(double number) {\n      super(Token.NUMBER);\n      this.number = number;\n    }\n",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.134
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.newNumber#495",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newNumber(double)",
        "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }\n",
        "begin_line": 495,
        "end_line": 497,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.134
        },
        "num_failing_tests": 5
    },
    {
        "name": "ProcessClosurePrimitives.handleCandidateProvideDefinition#355",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.handleCandidateProvideDefinition(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void handleCandidateProvideDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      String name = null;\n      if (n.isName() && parent.isVar()) {\n        name = n.getString();\n      } else if (n.isAssign() &&\n          parent.isExprResult()) {\n        name = n.getFirstChild().getQualifiedName();\n      }\n\n      if (name != null) {\n        if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n          processProvideFromPreviousPass(t, name, parent);\n        } else {\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            pn.addDefinition(parent, t.getModule());\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 355,
        "end_line": 377,
        "comment": "\n   * Handles a candidate definition for a goog.provided name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.OptimizeArgumentsArray#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler) {\n    this(compiler, PARAMETER_PREFIX);\n  }\n",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n   * Construct this pass and use {@link #PARAMETER_PREFIX} as the prefix for\n   * all parameter names that it introduces.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.OptimizeArgumentsArray#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(com.google.javascript.jscomp.AbstractCompiler, java.lang.String)",
        "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler, String paramPrefix) {\n    this.compiler = Preconditions.checkNotNull(compiler);\n    this.paramPredix = Preconditions.checkNotNull(paramPrefix);\n  }\n",
        "begin_line": 83,
        "end_line": 86,
        "comment": "\n   * @param paramPrefix the prefix to use for all parameter names that this\n   *     pass introduces\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.process#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, Preconditions.checkNotNull(root), this);\n  }\n",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "OptimizeArgumentsArray.shouldTraverse#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/OptimizeArgumentsArray.java",
        "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
        "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node node, Node parent) {\n    // We will continuously recurse down the AST regardless of the node types.\n    return true;\n  }\n",
        "begin_line": 141,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineObjectLiterals.afterExitScope#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InliningBehavior.afterExitScope(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n          continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n          // Blacklist the object itself, as well as any other values\n          // that it refers to, since they will have been moved around.\n          staleVars.add(v);\n\n          Reference declaration = referenceInfo.references.get(0);\n          Reference init = referenceInfo.getInitializingReference();\n\n          // Split up the object into individual variables if the object\n          // is never referenced directly in full.\n          splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }\n",
        "begin_line": 83,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineObjectLiterals.isVarInlineForbidden#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InliningBehavior.isVarInlineForbidden(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is defined in the externs\n      // 2) The variable is exported,\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      // 4) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n\n      // Additionally, exclude global variables for now.\n\n      return var.isGlobal()\n          || var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }\n",
        "begin_line": 129,
        "end_line": 145,
        "comment": "\n     * Whether the given variable is forbidden from being inlined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineObjectLiterals.InlineObjectLiterals#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InlineObjectLiterals(com.google.javascript.jscomp.AbstractCompiler, com.google.common.base.Supplier<java.lang.String>)",
        "snippet": "  InlineObjectLiterals(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }\n",
        "begin_line": 56,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineObjectLiterals.process#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }\n",
        "begin_line": 63,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "ExploitAssigns.optimizeSubtree#31",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
        "class_name": "com.google.javascript.jscomp.ExploitAssigns",
        "signature": "com.google.javascript.jscomp.ExploitAssigns.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    for (Node child = subtree.getFirstChild(); child != null;) {\n      Node next = child.getNext();\n      if (NodeUtil.isExprAssign(child)) {\n        collapseAssign(child.getFirstChild(), child, subtree);\n      }\n      child = next;\n    }\n    return subtree;\n  }\n",
        "begin_line": 31,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1867",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-58342300-456f-47d2-8439-51ab0759d0b7.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new CollapseVariableDeclarations(compiler);\n    }\n",
        "begin_line": 1867,
        "end_line": 1870,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1854",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-492bcb5d-09b9-45f9-8af3-181b42f9d22e.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new PeepholeOptimizationsPass(compiler,\n          new ExploitAssigns());\n    }\n",
        "begin_line": 1854,
        "end_line": 1858,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1843",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-19cfbdd6-7854-43dc-a1a2-1a3c2b54b2e0.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n    }\n",
        "begin_line": 1843,
        "end_line": 1846,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1743",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-f467c51f-a975-48c0-a590-17ca2f106351.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new DeadAssignmentsElimination(compiler);\n    }\n",
        "begin_line": 1743,
        "end_line": 1746,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1483",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-abd69462-9e12-4190-a7ce-3e9d2d2603d4.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new InlineObjectLiterals(\n          compiler, compiler.getUniqueNameIdSupplier());\n    }\n",
        "begin_line": 1483,
        "end_line": 1487,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1435",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-62161592-b344-416c-8bd0-a8f0d6c462fe.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new OptimizeArgumentsArray(compiler);\n    }\n",
        "begin_line": 1435,
        "end_line": 1438,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.DeadAssignmentsElimination#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.DeadAssignmentsElimination(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public DeadAssignmentsElimination(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.process#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkNotNull(externs);\n    Preconditions.checkNotNull(root);\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 63,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.exitScope#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }\n",
        "begin_line": 107,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DeadAssignmentsElimination.visit#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
        "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
        "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.computeEscaped#548",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.computeEscaped(com.google.javascript.jscomp.Scope, java.util.Set<com.google.javascript.jscomp.Scope.Var>, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  static void computeEscaped(final Scope jsScope, final Set<Var> escaped,\n      AbstractCompiler compiler) {\n    // TODO(user): Very good place to store this information somewhere.\n    AbstractPostOrderCallback finder = new AbstractPostOrderCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (jsScope == t.getScope() || !n.isName()\n            || parent.isFunction()) {\n          return;\n        }\n        String name = n.getString();\n        Var var = t.getScope().getVar(name);\n        if (var != null && var.scope == jsScope) {\n          escaped.add(jsScope.getVar(name));\n        }\n      }\n    };\n\n    NodeTraversal t = new NodeTraversal(compiler, finder);\n    t.traverseAtScope(jsScope);\n\n    // 1: Remove the exception name in CATCH which technically isn't local to\n    //    begin with.\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var var = i.next();\n      if (var.getParentNode().isCatch() ||\n          compiler.getCodingConvention().isExported(var.getName())) {\n        escaped.add(var);\n      }\n    }\n  }\n",
        "begin_line": 548,
        "end_line": 578,
        "comment": "\n   * Compute set of escaped variables. When a variable is escaped in a\n   * dataflow analysis, it can be reference outside of the code that we are\n   * analyzing. A variable is escaped if any of the following is true:\n   *\n   * <p><ol>\n   * <li>It is defined as the exception name in CATCH clause so it became a\n   * variable local not to our definition of scope.</li>\n   * <li>Exported variables as they can be needed after the script terminates.\n   * </li>\n   * <li>Names of named functions because in JavaScript, <i>function foo(){}</i>\n   * does not kill <i>foo</i> in the dataflow.</li>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowGraph.shouldTraverse#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (parent == null) {\n        return true;\n      }\n      return !isEnteringNewCfgNode(n);\n    }\n",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CollapseVariableDeclarations.visit#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.GatherCollapses.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isVar()) {\n        blacklistStubVars(t, n);\n      }\n\n      // Only care about var nodes\n      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) return;\n\n      // If we've already looked at this node, skip it\n      if (nodesToCollapse.contains(n)) return;\n\n      // Adjacent VAR children of an IF node are the if and else parts and can't\n      // be collapsed\n      if (parent.isIf()) return;\n\n      Node varNode = n;\n\n      boolean hasVar = n.isVar();\n\n      // Find variable declarations that follow this one (if any)\n      n = n.getNext();\n\n      boolean hasNodesToCollapse = false;\n\n      while (n != null &&\n          (n.isVar() || canBeRedeclared(n, t.getScope()))) {\n\n        if (n.isVar()) {\n          blacklistStubVars(t, n);\n          hasVar = true;\n        }\n\n        nodesToCollapse.add(n);\n        hasNodesToCollapse = true;\n\n        n = n.getNext();\n      }\n\n      if (hasNodesToCollapse && hasVar) {\n        nodesToCollapse.add(varNode);\n        collapses.add(new Collapse(varNode, n, parent));\n      }\n    }\n",
        "begin_line": 136,
        "end_line": 179,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CollapseVariableDeclarations.canBeRedeclared#190",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.GatherCollapses.canBeRedeclared(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "    private boolean canBeRedeclared(Node n, Scope s) {\n      if (!NodeUtil.isExprAssign(n)) {\n        return false;\n      }\n      Node assign = n.getFirstChild();\n      Node lhs = assign.getFirstChild();\n\n      if (!lhs.isName()) {\n        return false;\n      }\n\n      Var var = s.getVar(lhs.getString());\n      return var != null\n          && var.getScope() == s\n          && !isNamedParameter(var)\n          && !blacklistedVars.contains(var);\n    }\n",
        "begin_line": 190,
        "end_line": 206,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CollapseVariableDeclarations.CollapseVariableDeclarations#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.CollapseVariableDeclarations(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  CollapseVariableDeclarations(AbstractCompiler compiler) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n    this.compiler = compiler;\n  }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CollapseVariableDeclarations.process#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root, new GatherCollapses());\n\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n      compiler.reportCodeChange();\n    }\n  }\n",
        "begin_line": 108,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.CoalesceVariableNames#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.CoalesceVariableNames(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n\n    this.compiler = compiler;\n    colorings = Lists.newLinkedList();\n    this.usePseudoNames = usePseudoNames;\n  }\n",
        "begin_line": 78,
        "end_line": 84,
        "comment": "\n   * @param usePseudoNames For debug purposes, when merging variable foo and bar\n   * to foo, rename both variable to foo_bar.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.process#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "CoalesceVariableNames.visit#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
        "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
        "signature": "com.google.javascript.jscomp.CoalesceVariableNames.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (colorings.isEmpty() || !n.isName() ||\n        parent.isFunction()) {\n      // Don't rename named functions.\n      return;\n    }\n    Var var = t.getScope().getVar(n.getString());\n    GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var);\n    if (vNode == null) {\n      // This is not a local.\n      return;\n    }\n    Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n\n    if (!usePseudoNames) {\n      if (vNode.getValue().equals(coalescedVar)) {\n        // The coalesced name is itself, nothing to do.\n        return;\n      }\n\n      // Rename.\n      n.setString(coalescedVar.name);\n      compiler.reportCodeChange();\n\n      if (parent.isVar()) {\n        removeVarDeclaration(n);\n      }\n    } else {\n      // This code block is slow but since usePseudoName is for debugging,\n      // we should not sacrifice performance for non-debugging compilation to\n      // make this fast.\n      String pseudoName = null;\n      Set<String> allMergedNames = Sets.newTreeSet();\n      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n        Var iVar = i.next();\n\n        // Look for all the variables that can be merged (in the graph by now)\n        // and it is merged with the current coalescedVar.\n        if (colorings.peek().getGraph().getNode(iVar) != null &&\n            coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n          allMergedNames.add(iVar.name);\n        }\n      }\n\n      // Keep its original name.\n      if (allMergedNames.size() == 1) {\n        return;\n      }\n\n      pseudoName = Joiner.on(\"_\").join(allMergedNames);\n\n      while (t.getScope().isDeclared(pseudoName, true)) {\n        pseudoName += \"$\";\n      }\n\n      n.setString(pseudoName);\n      compiler.reportCodeChange();\n\n      if (!vNode.getValue().equals(coalescedVar) && parent.isVar()) {\n        removeVarDeclaration(n);\n      }\n    }\n  }\n",
        "begin_line": 147,
        "end_line": 210,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "TernaryValue.toBoolean#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TernaryValue.java",
        "class_name": "com.google.javascript.rhino.jstype.TernaryValue",
        "signature": "com.google.javascript.rhino.jstype.TernaryValue.toBoolean(boolean)",
        "snippet": "    @Override\n    public boolean toBoolean(boolean unknown) {\n      return true;\n    }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.not#359",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.not(com.google.javascript.rhino.Node)",
        "snippet": "  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n",
        "begin_line": 359,
        "end_line": 361,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.binaryOp#472",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.binaryOp(int, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n",
        "begin_line": 472,
        "end_line": 476,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isLhsOfForInExpression#606",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isLhsOfForInExpression(com.google.javascript.rhino.Node)",
        "snippet": "    private static boolean isLhsOfForInExpression(Node n) {\n      Node parent = n.getParent();\n      if (parent.isVar()) {\n        return isLhsOfForInExpression(parent);\n      }\n      return NodeUtil.isForIn(parent) && parent.getFirstChild() == n;\n    }\n",
        "begin_line": 606,
        "end_line": 612,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isBlockBoundary#207",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.isBlockBoundary(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean isBlockBoundary(Node n, Node parent) {\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DO:\n        case Token.FOR:\n        case Token.TRY:\n        case Token.WHILE:\n        case Token.WITH:\n          // NOTE: TRY has up to 3 child blocks:\n          // TRY\n          //   BLOCK\n          //   BLOCK\n          //     CATCH\n          //   BLOCK\n          // Note that there is an explicit CATCH token but no explicit\n          // FINALLY token. For simplicity, we consider each BLOCK\n          // a separate basic BLOCK.\n          return true;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.OR:\n          // The first child of a conditional is not a boundary,\n          // but all the rest of the children are.\n          return n != parent.getFirstChild();\n\n      }\n    }\n\n    return n.isCase();\n  }\n",
        "begin_line": 207,
        "end_line": 237,
        "comment": "\n   * @return true if this node marks the start of a new basic block\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.maybeReplaceChildWithNumber#1317",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.maybeReplaceChildWithNumber(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, int)",
        "snippet": "  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n    Node newNode = IR.number(num);\n    if (!newNode.isEquivalentTo(n)) {\n      parent.replaceChild(n, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return n;\n  }\n",
        "begin_line": 1317,
        "end_line": 1327,
        "comment": "\n   * Replaces a node with a number node if the new number node is not equivalent\n   * to the current node.\n   *\n   * Returns the replacement for n if it was replaced, otherwise returns n.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.reduceTrueFalse#1512",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.reduceTrueFalse(com.google.javascript.rhino.Node)",
        "snippet": "  private Node reduceTrueFalse(Node n) {\n    if (late) {\n      Node not = IR.not(IR.number(n.isTrue() ? 0 : 1));\n      not.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, not);\n      reportCodeChange();\n      return not;\n    }\n    return n;\n  }\n",
        "begin_line": 1512,
        "end_line": 1521,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeFoldConstants.tryFoldUnaryOperator#338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldUnaryOperator(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldUnaryOperator(Node n) {\n    Preconditions.checkState(n.hasOneChild());\n\n    Node left = n.getFirstChild();\n    Node parent = n.getParent();\n\n    if (left == null) {\n      return n;\n    }\n\n    TernaryValue leftVal = NodeUtil.getPureBooleanValue(left);\n    if (leftVal == TernaryValue.UNKNOWN) {\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.NOT:\n        // Don't fold !0 and !1 back to false.\n        if (late && left.isNumber()) {\n          double numValue = left.getDouble();\n          if (numValue == 0 || numValue == 1) {\n            return n;\n          }\n        }\n        Node replacementNode = NodeUtil.booleanNode(!leftVal.toBoolean(true));\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      case Token.POS:\n        if (NodeUtil.isNumericResult(left)) {\n          // POS does nothing to numeric values.\n          parent.replaceChild(n, left.detachFromParent());\n          reportCodeChange();\n          return left;\n        }\n        return n;\n      case Token.NEG:\n        if (left.isName()) {\n          if (left.getString().equals(\"Infinity\")) {\n            // \"-Infinity\" is valid and a literal, don't modify it.\n            return n;\n          } else if (left.getString().equals(\"NaN\")) {\n            // \"-NaN\" is \"NaN\".\n            n.removeChild(left);\n            parent.replaceChild(n, left);\n            reportCodeChange();\n            return left;\n          }\n        }\n\n        if (left.isNumber()) {\n          double negNum = -left.getDouble();\n\n          Node negNumNode = IR.number(negNum);\n          parent.replaceChild(n, negNumNode);\n          reportCodeChange();\n          return negNumNode;\n        } else {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          report(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n      case Token.BITNOT:\n        try {\n          double val = left.getDouble();\n          if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n            int intVal = (int) val;\n            if (intVal == val) {\n              Node notIntValNode = IR.number(~intVal);\n              parent.replaceChild(n, notIntValNode);\n              reportCodeChange();\n              return notIntValNode;\n            } else {\n              report(FRACTIONAL_BITWISE_OPERAND, left);\n              return n;\n            }\n          } else {\n            report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n          }\n        } catch (UnsupportedOperationException ex) {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          report(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n        default:\n          return n;\n    }\n  }\n",
        "begin_line": 338,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1336
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.RenameVars#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.RenameVars(com.google.javascript.jscomp.AbstractCompiler, java.lang.String, boolean, boolean, boolean, boolean, com.google.javascript.jscomp.VariableMap, char[], java.util.Set<java.lang.String>)",
        "snippet": "  RenameVars(AbstractCompiler compiler, String prefix,\n      boolean localRenamingOnly, boolean preserveFunctionExpressionNames,\n      boolean generatePseudoNames, boolean shouldShadow,\n      VariableMap prevUsedRenameMap,\n      @Nullable char[] reservedCharacters,\n      @Nullable Set<String> reservedNames) {\n    this.compiler = compiler;\n    this.prefix = prefix == null ? \"\" : prefix;\n    this.localRenamingOnly = localRenamingOnly;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    if (generatePseudoNames) {\n      this.pseudoNameMap = Maps.newHashMap();\n    } else {\n      this.pseudoNameMap = null;\n    }\n    this.prevUsedRenameMap = prevUsedRenameMap;\n    this.reservedCharacters = reservedCharacters;\n    this.shouldShadow = shouldShadow;\n    if (reservedNames == null) {\n      this.reservedNames = Sets.newHashSet();\n    } else {\n      this.reservedNames = Sets.newHashSet(reservedNames);\n    }\n  }\n",
        "begin_line": 136,
        "end_line": 159,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeTraversal.traverseAtScope#351",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseAtScope(com.google.javascript.jscomp.Scope)",
        "snippet": "  void traverseAtScope(Scope s) {\n    Node n = s.getRootNode();\n    if (n.isFunction()) {\n      // We need to do some extra magic to make sure that the scope doesn't\n      // get re-created when we dive into the function.\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n      }\n      sourceName = getSourceName(n);\n      curNode = n;\n      pushScope(s);\n\n      Node args = n.getFirstChild().getNext();\n      Node body = args.getNext();\n      traverseBranch(args, n);\n      traverseBranch(body, n);\n\n      popScope();\n    } else {\n      traverseWithScope(n, s);\n    }\n  }\n",
        "begin_line": 351,
        "end_line": 372,
        "comment": "\n   * Traverses a parse tree recursively with a scope, starting at that scope's\n   * root.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.doInlinesForScope#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.doInlinesForScope(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n\n      boolean maybeModifiedArguments =\n          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n        }\n      }\n    }\n",
        "begin_line": 194,
        "end_line": 222,
        "comment": "\n     * For all variables in this scope, see if they are only used once.\n     * If it looks safe to do so, inline them.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getCodeRemovingPasses#718",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getCodeRemovingPasses()",
        "snippet": "  private List<PassFactory> getCodeRemovingPasses() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.collapseObjectLiterals && !isInliningForbidden()) {\n      passes.add(collapseObjectLiterals);\n    }\n\n    if (options.inlineVariables || options.inlineLocalVariables) {\n      passes.add(inlineVariables);\n    } else if (options.inlineConstantVars) {\n      passes.add(inlineConstants);\n    }\n\n    if (options.foldConstants) {\n      // These used to be one pass.\n      passes.add(minimizeExitPoints);\n      passes.add(peepholeOptimizations);\n    }\n\n    if (options.removeDeadCode) {\n      passes.add(removeUnreachableCode);\n    }\n\n    if (options.removeUnusedPrototypeProperties) {\n      passes.add(removeUnusedPrototypeProperties);\n    }\n\n    if (options.removeUnusedClassProperties && !isInliningForbidden()) {\n      passes.add(removeUnusedClassProperties);\n    }\n\n    assertAllLoopablePasses(passes);\n    return passes;\n  }\n",
        "begin_line": 718,
        "end_line": 750,
        "comment": " Creates several passes aimed at removing code. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.FlowState#341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.FlowState.FlowState(L, L)",
        "snippet": "    private FlowState(L inState, L outState) {\n      Preconditions.checkNotNull(inState);\n      Preconditions.checkNotNull(outState);\n      this.in = inState;\n      this.out = outState;\n    }\n",
        "begin_line": 341,
        "end_line": 346,
        "comment": "\n     * Private constructor. No other classes should create new states.\n     *\n     * @param inState Input.\n     * @param outState Output.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.getIn#348",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.FlowState.getIn()",
        "snippet": "    L getIn() {\n      return in;\n    }\n",
        "begin_line": 348,
        "end_line": 350,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.getOut#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.FlowState.getOut()",
        "snippet": "    L getOut() {\n      return out;\n    }\n",
        "begin_line": 357,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.setOut#361",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.FlowState.setOut(L)",
        "snippet": "    void setOut(L out) {\n      Preconditions.checkNotNull(out);\n      this.out = out;\n    }\n",
        "begin_line": 361,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.initialize#248",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.initialize()",
        "snippet": "  protected void initialize() {\n    // TODO(user): Calling clear doesn't deallocate the memory in a\n    // LinkedHashSet. Consider creating a new work set if we plan to repeatedly\n    // call analyze.\n    orderedWorkSet.clear();\n    for (DiGraphNode<N, Branch> node : cfg.getDirectedGraphNodes()) {\n      node.setAnnotation(new FlowState<L>(createInitialEstimateLattice(),\n          createInitialEstimateLattice()));\n      if (node != cfg.getImplicitReturn()) {\n        orderedWorkSet.add(node);\n      }\n    }\n  }\n",
        "begin_line": 248,
        "end_line": 260,
        "comment": "\n   * Initializes the work list and the control flow graph.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.getOptionalNodeComparator#1021",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.getOptionalNodeComparator(boolean)",
        "snippet": "    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n",
        "begin_line": 1021,
        "end_line": 1046,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.compare#1039",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.Anonymous-3e0d8d07-dcb3-4c1b-b0c0-687f7ffe1f70.compare(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n",
        "begin_line": 1039,
        "end_line": 1043,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.EliminationPass#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.EliminationPass.EliminationPass(com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>)",
        "snippet": "    private EliminationPass(ControlFlowGraph<Node> cfg) {\n      this.cfg = cfg;\n    }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.UnreachableCodeElimination#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.UnreachableCodeElimination(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  UnreachableCodeElimination(AbstractCompiler compiler,\n      boolean removeNoOpStatements) {\n    this.compiler = compiler;\n    this.removeNoOpStatements = removeNoOpStatements;\n  }\n",
        "begin_line": 54,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.process#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 80,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.visit#255",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {}\n",
        "begin_line": 255,
        "end_line": 256,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnreachableCodeElimination.enterScope#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {}\n",
        "begin_line": 258,
        "end_line": 259,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getVarCount#595",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getVarCount()",
        "snippet": "  public int getVarCount() {\n    return vars.size();\n  }\n",
        "begin_line": 595,
        "end_line": 597,
        "comment": "\n   * Returns number of variables in this scope\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1652",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-31fc9ffa-d8ca-4fd0-838f-66f70dd1aca1.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new UnreachableCodeElimination(compiler, true);\n    }\n",
        "begin_line": 1652,
        "end_line": 1655,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.combineChecks#1239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.combineChecks(com.google.javascript.jscomp.AbstractCompiler, java.util.List<com.google.javascript.jscomp.NodeTraversal.Callback>)",
        "snippet": "  private static HotSwapCompilerPass combineChecks(AbstractCompiler compiler,\n      List<Callback> callbacks) {\n    Preconditions.checkArgument(callbacks.size() > 0);\n    Callback[] array = callbacks.toArray(new Callback[callbacks.size()]);\n    return new CombinedCompilerPass(compiler, array);\n  }\n",
        "begin_line": 1239,
        "end_line": 1244,
        "comment": " Executes the given callbacks with a {@link CombinedCompilerPass}. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getUniqueNameIdSupplier#1014",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getUniqueNameIdSupplier()",
        "snippet": "  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n",
        "begin_line": 1014,
        "end_line": 1023,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.CombinedCompilerPass#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.NodeTraversal.Callback...)",
        "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, Callback... callbacks) {\n    this(compiler, Lists.<Callback>newArrayList(callbacks));\n  }\n",
        "begin_line": 59,
        "end_line": 62,
        "comment": "\n   * Creates a combined compiler pass.\n   * @param compiler the compiler\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphReachability.GraphReachability#38",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphReachability.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
        "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(com.google.javascript.jscomp.graph.DiGraph<N, E>)",
        "snippet": "  public GraphReachability(DiGraph<N, E> graph) {\n    this(graph, null);\n  }\n",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "WarningLevel.setOptionsForWarningLevel#33",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningLevel.java",
        "class_name": "com.google.javascript.jscomp.WarningLevel",
        "signature": "com.google.javascript.jscomp.WarningLevel.setOptionsForWarningLevel(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public void setOptionsForWarningLevel(CompilerOptions options) {\n    switch (this) {\n      case QUIET:\n        silenceAllWarnings(options);\n        break;\n      case DEFAULT:\n        addDefaultWarnings(options);\n        break;\n      case VERBOSE:\n        addVerboseWarnings(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown warning level.\");\n    }\n  }\n",
        "begin_line": 33,
        "end_line": 47,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.isBleedingFunction#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isBleedingFunction()",
        "snippet": "    public boolean isBleedingFunction() {\n      return NodeUtil.isFunctionExpression(getParentNode());\n    }\n",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n     * Whether this is a bleeding function (an anonymous named function\n     * that bleeds into the inner scope).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.enterScope#192",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.ProcessVars.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) return;\n\n      Iterator<Var> it = t.getScope().getVars();\n      while (it.hasNext()) {\n        Var current = it.next();\n        if (current.isBleedingFunction()) {\n          localBleedingFunctions.add(current);\n          localBleedingFunctionsPerScope.put(\n              t.getScope().getParent(), current);\n        }\n      }\n    }\n",
        "begin_line": 192,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.okToRenameVar#535",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.okToRenameVar(java.lang.String, boolean)",
        "snippet": "  private boolean okToRenameVar(String name, boolean isLocal) {\n    return !compiler.getCodingConvention().isExported(name, isLocal);\n  }\n",
        "begin_line": 535,
        "end_line": 537,
        "comment": "\n   * Determines whether a variable name is okay to rename.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.isVarInlineForbidden#342",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isVarInlineForbidden(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is exported,\n      // 2) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      return var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }\n",
        "begin_line": 342,
        "end_line": 353,
        "comment": "\n     * Whether the given variable is forbidden from being inlined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.process#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n\n    // Code with hidden side-effect code is common, for example\n    // accessing \"el.offsetWidth\" forces a reflow in browsers, to allow this\n    // will still allowing local dead code removal in general,\n    // protect the \"side-effect free\" code in the source.\n    //\n    if (protectSideEffectFreeCode) {\n      protectSideEffects();\n    }\n  }\n",
        "begin_line": 64,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.protectSideEffects#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.protectSideEffects()",
        "snippet": "  private void protectSideEffects() {\n    if (!problemNodes.isEmpty()) {\n      addExtern();\n      for (Node n : problemNodes) {\n        Node name = IR.name(PROTECTOR_FN).srcref(n);\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        Node replacement = IR.call(name).srcref(n);\n        replacement.putBooleanProp(Node.FREE_CALL, true);\n        n.getParent().replaceChild(n, replacement);\n        replacement.addChildToBack(n);\n      }\n      compiler.reportCodeChange();\n    }\n  }\n",
        "begin_line": 138,
        "end_line": 151,
        "comment": "\n   * Protect side-effect free nodes by making them parameters\n   * to a extern function call.  This call will be removed\n   * after all the optimizations passes have run.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1319
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.getRValueOfLValue#3101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getRValueOfLValue(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getRValueOfLValue(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.ASSIGN:\n        return n.getNext();\n      case Token.VAR:\n        return n.getFirstChild();\n      case Token.FUNCTION:\n        return parent;\n    }\n    return null;\n  }\n",
        "begin_line": 3101,
        "end_line": 3112,
        "comment": " Gets the r-value of a node returned by getBestLValue. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 6
    },
    {
        "name": "ReferenceCollectingCallback.ReferenceCollectingCallback#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollectingCallback(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior)",
        "snippet": "  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) {\n    this(compiler, behavior, Predicates.<Var>alwaysTrue());\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "\n   * Constructor initializes block stack.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.visitOrMaybeActivate#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.visitOrMaybeActivate(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n      if (isActive()) {\n        callback.visit(t, n, parent);\n      } else if (waiting == n) {\n        waiting = null;\n      }\n    }\n",
        "begin_line": 121,
        "end_line": 127,
        "comment": "\n     * Visits the node unless the wrapped callback is inactive. Activates the\n     * callback if appropriate.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.shouldTraverseIfActive#129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.shouldTraverseIfActive(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n      if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n        waiting = n;\n      }\n    }\n",
        "begin_line": 129,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.isActive#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CallbackWrapper.isActive()",
        "snippet": "    boolean isActive() {\n      return waiting == null;\n    }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.CombinedCompilerPass#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(com.google.javascript.jscomp.AbstractCompiler, java.util.List<com.google.javascript.jscomp.NodeTraversal.Callback>)",
        "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, List<Callback> callbacks) {\n    this.compiler = compiler;\n    this.callbacks = new CallbackWrapper[callbacks.size()];\n    for (int i = 0; i < callbacks.size(); i++) {\n      this.callbacks[i] = new CallbackWrapper(callbacks.get(i));\n    }\n  }\n",
        "begin_line": 64,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.process#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public final void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 152,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.shouldTraverse#162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.shouldTraverseIfActive(t, n, parent);\n    }\n    // Note that this method could return false if all callbacks are inactive.\n    // This apparent optimization would make this method more expensive\n    // in the typical case where not all nodes are inactive. It is\n    // very unlikely that many all callbacks would be inactive at the same\n    // time (indeed, there are several checking passes that never return false).\n    return true;\n  }\n",
        "begin_line": 162,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.visit#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.visitOrMaybeActivate(t, n, parent);\n    }\n  }\n",
        "begin_line": 175,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.enterScope#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.enterScopeIfActive(t);\n    }\n  }\n",
        "begin_line": 182,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "CombinedCompilerPass.exitScope#189",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CombinedCompilerPass.java",
        "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
        "signature": "com.google.javascript.jscomp.CombinedCompilerPass.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.exitScopeIfActive(t);\n    }\n  }\n",
        "begin_line": 189,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeFoldConstants.tryFoldAssign#462",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldAssign(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.isAssign());\n\n    if (!late) {\n      return n;\n    }\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return n;\n    }\n\n    if (mayHaveSideEffects(left)) {\n      return n;\n    }\n\n    Node newRight;\n    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n      newRight = right.getLastChild();\n    } else if (NodeUtil.isCommutative(right.getType()) &&\n          areNodesEqualForInlining(left, right.getLastChild())) {\n      newRight = right.getFirstChild();\n    } else {\n      return n;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return n;\n    }\n\n    Node newNode = new Node(newType,\n        left.detachFromParent(), newRight.detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }\n",
        "begin_line": 462,
        "end_line": 536,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 2
    },
    {
        "name": "ExploitAssigns.collapseAssign#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
        "class_name": "com.google.javascript.jscomp.ExploitAssigns",
        "signature": "com.google.javascript.jscomp.ExploitAssigns.collapseAssign(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void collapseAssign(Node assign, Node expr,\n      Node exprParent) {\n    Node leftValue = assign.getFirstChild();\n    Node rightValue = leftValue.getNext();\n    if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n      reportCodeChange();\n    } else if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n      reportCodeChange();\n    } else if (rightValue.isAssign()) {\n      // Recursively deal with nested assigns.\n      collapseAssign(rightValue, expr, exprParent);\n    }\n  }\n",
        "begin_line": 46,
        "end_line": 60,
        "comment": "\n   * Try to collapse the given assign into subsequent expressions.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 2
    },
    {
        "name": "ExploitAssigns.isCollapsibleValue#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ExploitAssigns.java",
        "class_name": "com.google.javascript.jscomp.ExploitAssigns",
        "signature": "com.google.javascript.jscomp.ExploitAssigns.isCollapsibleValue(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private boolean isCollapsibleValue(Node value, boolean isLValue) {\n    switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented setter functions, and oftentimes\n        // setter functions fail on native objects. This is OK for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().isThis();\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }\n  }\n",
        "begin_line": 76,
        "end_line": 91,
        "comment": "\n   * Determines whether we know enough about the given value to be able\n   * to collapse it into subsequent expressions.\n   *\n   * For example, we can collapse booleans and variable names:\n   * <code>\n   * x = 3; y = x; // y = x = 3;\n   * a = true; b = true; // b = a = true;\n   * <code>\n   * But we won't try to collapse complex expressions.\n   *\n   * @param value The value node.\n   * @param isLValue Whether it's on the left-hand side of an expr.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1313
        },
        "num_failing_tests": 2
    },
    {
        "name": "AstValidator.validateOptionalName#344",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateOptionalName(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateOptionalName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonNullString(n);\n    validateChildCount(n, 0);\n  }\n",
        "begin_line": 344,
        "end_line": 348,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1308
        },
        "num_failing_tests": 6
    },
    {
        "name": "AstValidator.validateFunctionExpression#358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateFunctionExpression(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateOptionalName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }\n",
        "begin_line": 358,
        "end_line": 364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1308
        },
        "num_failing_tests": 6
    },
    {
        "name": "ParserRunner.getReservedVars#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/ParserRunner.java",
        "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
        "signature": "com.google.javascript.jscomp.parsing.ParserRunner.getReservedVars()",
        "snippet": "  public static Set<String> getReservedVars() {\n    initResourceConfig();\n    return reservedVars;\n  }\n",
        "begin_line": 77,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphReachability.GraphReachability#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphReachability.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
        "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(com.google.javascript.jscomp.graph.DiGraph<N, E>, com.google.common.base.Predicate<com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple<N, E>>)",
        "snippet": "  public GraphReachability(DiGraph<N, E> graph,\n                           Predicate<EdgeTuple<N, E>> edgePredicate) {\n    this.graph = graph;\n    this.edgePredicate = edgePredicate;\n  }\n",
        "begin_line": 48,
        "end_line": 52,
        "comment": "\n   * @param graph The graph.\n   * @param edgePredicate Given the predecessor P of the a node S and the edge\n   *      coming from P to S, this predicate should return true if S is\n   *      reachable from P using the edge.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphReachability.compute#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphReachability.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
        "signature": "com.google.javascript.jscomp.graph.GraphReachability.compute(N)",
        "snippet": "  public void compute(N entry) {\n    graph.clearNodeAnnotations();\n    graph.getNode(entry).setAnnotation(REACHABLE);\n    FixedPointGraphTraversal.newTraversal(this)\n        .computeFixedPoint(graph, entry);\n  }\n",
        "begin_line": 54,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "GraphReachability.traverseEdge#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphReachability.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
        "signature": "com.google.javascript.jscomp.graph.GraphReachability.traverseEdge(N, E, N)",
        "snippet": "  @Override\n  public boolean traverseEdge(N source, E e, N destination) {\n    if (graph.getNode(source).getAnnotation() == REACHABLE &&\n        (edgePredicate == null ||\n            edgePredicate.apply(new EdgeTuple<N, E>(source, e, destination)))) {\n      GraphNode<N, E> destNode = graph.getNode(destination);\n      if (destNode.getAnnotation() != REACHABLE) {\n        destNode.setAnnotation(REACHABLE);\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 69,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "FixedPointGraphTraversal.computeFixedPoint#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java",
        "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
        "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(com.google.javascript.jscomp.graph.DiGraph<N, E>, N)",
        "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, N entry) {\n    Set<N> entrySet = Sets.newHashSet();\n    entrySet.add(entry);\n    computeFixedPoint(graph, entrySet);\n  }\n",
        "begin_line": 82,
        "end_line": 86,
        "comment": "\n   * Compute a fixed point for the given graph, entering from the given node.\n   * @param graph The graph to traverse.\n   * @param entry The node to begin traversing from.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "SortedDependencies.SortedDependencies#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.SortedDependencies(java.util.List<INPUT>)",
        "snippet": "  public SortedDependencies(List<INPUT> inputs)\n      throws CircularDependencyException {\n    this.inputs = Lists.newArrayList(inputs);\n    noProvides = Lists.newArrayList();\n\n    // Collect all symbols provided in these files.\n    for (INPUT input : inputs) {\n      Collection<String> currentProvides = input.getProvides();\n      if (currentProvides.isEmpty()) {\n        noProvides.add(input);\n      }\n\n      for (String provide : currentProvides) {\n        provideMap.put(provide, input);\n      }\n    }\n\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    sortedList = topologicalStableSort(inputs, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n  }\n",
        "begin_line": 64,
        "end_line": 108,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.ProcessVars#188",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.ProcessVars.ProcessVars(boolean)",
        "snippet": "    ProcessVars(boolean isExterns) {\n      isExternsPass_ = isExterns;\n    }\n",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.exitScope#207",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.ProcessVars.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}\n",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.assignNames#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.assignNames(java.util.Set<com.google.javascript.jscomp.RenameVars.Assignment>)",
        "snippet": "  private void assignNames(Set<Assignment> varsToRename) {\n    NameGenerator globalNameGenerator =\n        new NameGenerator(reservedNames, prefix, reservedCharacters);\n\n    // Local variables never need a prefix.\n    NameGenerator localNameGenerator =\n        prefix.isEmpty() ? globalNameGenerator : new NameGenerator(\n            reservedNames, \"\", reservedCharacters);\n\n    // Generated names and the assignments for non-local vars.\n    List<Assignment> pendingAssignments = new ArrayList<Assignment>();\n    List<String> generatedNamesForAssignments = new ArrayList<String>();\n\n    for (Assignment a : varsToRename) {\n      if (a.newName != null) {\n        continue;\n      }\n\n      if (externNames.contains(a.oldName)) {\n        continue;\n      }\n\n      String newName;\n      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)) {\n        // For local variable, we make the assignment right away.\n        newName = localNameGenerator.generateNextName();\n        finalizeNameAssignment(a, newName);\n      } else {\n        // For non-local variable, delay finalizing the name assignment\n        // until we know how many new names we'll have of length 2, 3, etc.\n        newName = globalNameGenerator.generateNextName();\n        pendingAssignments.add(a);\n        generatedNamesForAssignments.add(newName);\n      }\n      reservedNames.add(newName);\n    }\n\n    // Now that we have a list of generated names, and a list of variable\n    // Assignment objects, we assign the generated names to the vars as\n    // follows:\n    // 1) The most frequent vars get the shorter names.\n    // 2) If N number of vars are going to be assigned names of the same\n    //    length, we assign the N names based on the order at which the vars\n    //    first appear in the source. This makes the output somewhat less\n    //    random, because symbols declared close together are assigned names\n    //    that are quite similar. With this heuristic, the output is more\n    //    compressible.\n    //    For instance, the output may look like:\n    //    var da = \"..\", ea = \"..\";\n    //    function fa() { .. } function ga() { .. }\n\n    int numPendingAssignments = generatedNamesForAssignments.size();\n    for (int i = 0; i < numPendingAssignments;) {\n      SortedSet<Assignment> varsByOrderOfOccurrence =\n          new TreeSet<Assignment>(ORDER_OF_OCCURRENCE_COMPARATOR);\n\n      // Add k number of Assignment to the set, where k is the number of\n      // generated names of the same length.\n      int len = generatedNamesForAssignments.get(i).length();\n      for (int j = i; j < numPendingAssignments\n          && generatedNamesForAssignments.get(j).length() == len; j++) {\n        varsByOrderOfOccurrence.add(pendingAssignments.get(j));\n      }\n\n      // Now, make the assignments\n      for (Assignment a : varsByOrderOfOccurrence) {\n        finalizeNameAssignment(a, generatedNamesForAssignments.get(i));\n        ++i;\n      }\n    }\n  }\n",
        "begin_line": 440,
        "end_line": 510,
        "comment": "\n   * Determines which new names to substitute for the original names.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "RenameVars.getVariableMap#528",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.getVariableMap()",
        "snippet": "  VariableMap getVariableMap() {\n    return new VariableMap(ImmutableMap.copyOf(renameMap));\n  }\n",
        "begin_line": 528,
        "end_line": 530,
        "comment": "\n   * Gets the variable map.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2084",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-4df28ce6-0920-411e-a3da-b0bde08a0804.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      final VariableMap prevVariableMap = options.inputVariableMap;\n      return new CompilerPass() {\n        @Override public void process(Node externs, Node root) {\n          variableMap = runVariableRenaming(\n              compiler, prevVariableMap, externs, root);\n        }\n      };\n    }\n",
        "begin_line": 2084,
        "end_line": 2093,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#2088",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-e16d062f-64a9-4756-b804-3e7d131cb1b1.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override public void process(Node externs, Node root) {\n          variableMap = runVariableRenaming(\n              compiler, prevVariableMap, externs, root);\n        }\n",
        "begin_line": 2088,
        "end_line": 2091,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1307
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryReplaceUndefined#400",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReplaceUndefined(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryReplaceUndefined(Node n) {\n    // TODO(johnlenz): consider doing this as a normalization.\n    if (isASTNormalized()\n        && NodeUtil.isUndefined(n)\n        && !NodeUtil.isLValue(n)) {\n      Node replacement = NodeUtil.newUndefinedNode(n);\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n    return n;\n  }\n",
        "begin_line": 400,
        "end_line": 411,
        "comment": "\n   * Use \"void 0\" in place of \"undefined\"\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isUndefined#1250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isUndefined(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isUndefined(Node n) {\n    switch (n.getType()) {\n      case Token.VOID:\n        return true;\n      case Token.NAME:\n        return n.getString().equals(\"undefined\");\n    }\n    return false;\n  }\n",
        "begin_line": 1250,
        "end_line": 1258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.maybeEscapedOrModifiedArguments#224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.maybeEscapedOrModifiedArguments(com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, ReferenceMap referenceMap) {\n      if (scope.isLocal()) {\n        Var arguments = scope.getArgumentsVar();\n        ReferenceCollection refs = referenceMap.getReferences(arguments);\n        if (refs != null && !refs.references.isEmpty()) {\n          for (Reference ref : refs.references) {\n            Node refNode = ref.getNode();\n            Node refParent = ref.getParent();\n            // Any reference that is not a read of the arguments property\n            // consider a escape of the arguments object.\n            if (!(NodeUtil.isGet(refParent)\n                && refNode == ref.getParent().getFirstChild()\n                && !isLValue(refParent))) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n",
        "begin_line": 224,
        "end_line": 244,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1779",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-6b8585b2-efbd-4734-84f0-653624d5495f.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      boolean removeOnlyLocals = options.removeUnusedLocalVars\n          && !options.removeUnusedVars;\n      boolean preserveAnonymousFunctionNames =\n          options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n      return new RemoveUnusedVars(\n          compiler,\n          !removeOnlyLocals,\n          preserveAnonymousFunctionNames,\n          false);\n    }\n",
        "begin_line": 1779,
        "end_line": 1790,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractPeepholeOptimization.mayHaveSideEffects#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.mayHaveSideEffects(com.google.javascript.rhino.Node)",
        "snippet": "  boolean mayHaveSideEffects(Node n) {\n    return NodeUtil.mayHaveSideEffects(n, compiler);\n  }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": "\n   * @return Whether the node may have side effects when executed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.AnnotatedLinkedDirectedGraphEdge#565",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphEdge.AnnotatedLinkedDirectedGraphEdge(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>, E, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "    AnnotatedLinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n        E edgeValue, DiGraphNode<N, E> destNode) {\n      super(sourceNode, edgeValue, destNode);\n    }\n",
        "begin_line": 565,
        "end_line": 568,
        "comment": "\n     * Constructor.\n     *\n     * @param edgeValue Edge Value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "Graph.clearNodeAnnotations#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.clearNodeAnnotations()",
        "snippet": "  @Override\n  public final void clearNodeAnnotations() {\n    for (GraphNode<N, E> n : getNodes()) {\n      n.setAnnotation(null);\n    }\n  }\n",
        "begin_line": 227,
        "end_line": 232,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeCollectPropertyAssignments.optimizeSubtree#35",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java",
        "class_name": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments",
        "signature": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    if (!subtree.isScript() && !subtree.isBlock()) {\n      return subtree;\n    }\n\n    boolean codeChanged = false;\n\n    // Look for variable declarations or simple assignments\n    // and start processing there.\n    for (Node child = subtree.getFirstChild();\n         child != null; child = child.getNext()) {\n      if (!child.isVar() && !NodeUtil.isExprAssign(child)) {\n        continue;\n      }\n      if (!isPropertyAssignmentToName(child.getNext())) {\n        // Quick check to see if there's anything to collapse.\n        continue;\n      }\n\n      Preconditions.checkState(child.hasOneChild());\n      Node name = getName(child);\n      if (!name.isName()) {\n        // The assignment target is not a simple name.\n        continue;\n      }\n      Node value = getValue(child);\n      if (value == null || !isInterestingValue(value)) {\n        // No initializer or not an Object or Array literal.\n        continue;\n      }\n\n      Node propertyCandidate;\n      while ((propertyCandidate = child.getNext()) != null) {\n        // This does not infinitely loop because collectProperty always\n        // removes propertyCandidate from its parent when it returns true.\n        if (!collectProperty(propertyCandidate, name.getString(), value)) {\n          break;\n        }\n        codeChanged = true;\n      }\n    }\n\n    if (codeChanged) {\n      reportCodeChange();\n    }\n    return subtree;\n  }\n",
        "begin_line": 35,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.enterScope#299",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      referenceStack.push(referencedNames);\n      referencedNames = Sets.newHashSet();\n    }\n",
        "begin_line": 299,
        "end_line": 307,
        "comment": "\n     * Prepare a set for the new scope.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.visit#391",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (NodeUtil.isReferenceName(node)) {\n        String name = node.getString();\n        // Add all referenced names to the set so it is possible to check for\n        // conflicts.\n        referencedNames.add(name);\n        // Store only references to candidate names in the node map.\n        if (containsSeparator(name)) {\n          addCandidateNameReference(name, node);\n        }\n      }\n    }\n",
        "begin_line": 391,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractPeepholeOptimization.isASTNormalized#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.isASTNormalized()",
        "snippet": "  protected boolean isASTNormalized() {\n    Preconditions.checkNotNull(compiler);\n\n    return compiler.getLifeCycleStage().isNormalized();\n  }\n",
        "begin_line": 82,
        "end_line": 86,
        "comment": "\n   *  Is the current AST normalized? (e.g. has the Normalize pass been run\n   *  and has the Denormalize pass not yet been run?)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1296
        },
        "num_failing_tests": 4
    },
    {
        "name": "FixedPointGraphTraversal.computeFixedPoint#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java",
        "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
        "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(com.google.javascript.jscomp.graph.DiGraph<N, E>, java.util.Set<N>)",
        "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, Set<N> entrySet) {\n    int cycleCount = 0;\n    long nodeCount = graph.getNodes().size();\n\n    // Choose a bail-out heuristically in case the computation\n    // doesn't converge.\n    long maxIterations = Math.max(nodeCount * nodeCount * nodeCount, 100);\n\n    // Use a LinkedHashSet, so that the traversal is deterministic.\n    LinkedHashSet<DiGraphNode<N, E>> workSet =\n        Sets.newLinkedHashSet();\n    for (N n : entrySet) {\n      workSet.add(graph.getDirectedGraphNode(n));\n    }\n    for (; !workSet.isEmpty() && cycleCount < maxIterations; cycleCount++) {\n      // For every out edge in the workSet, traverse that edge. If that\n      // edge updates the state of the graph, then add the destination\n      // node to the resultSet, so that we can update all of its out edges\n      // on the next iteration.\n      DiGraphNode<N, E> source = workSet.iterator().next();\n      N sourceValue = source.getValue();\n\n      workSet.remove(source);\n\n      List<DiGraphEdge<N, E>> outEdges = source.getOutEdges();\n      for (DiGraphEdge<N, E> edge : outEdges) {\n        N destNode = edge.getDestination().getValue();\n        if (callback.traverseEdge(sourceValue, edge.getValue(), destNode)) {\n          workSet.add(edge.getDestination());\n        }\n      }\n    }\n\n    Preconditions.checkState(cycleCount != maxIterations,\n        NON_HALTING_ERROR_MSG);\n  }\n",
        "begin_line": 93,
        "end_line": 128,
        "comment": "\n   * Compute a fixed point for the given graph, entering from the given nodes.\n   * @param graph The graph to traverse.\n   * @param entrySet The nodes to begin traversing from.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.afterExitScope#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.afterExitScope(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      collectAliasCandidates(t, referenceMap);\n      doInlinesForScope(t, referenceMap);\n    }\n",
        "begin_line": 157,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.InlineVariables#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InlineVariables(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.InlineVariables.Mode, boolean)",
        "snippet": "  InlineVariables(\n      AbstractCompiler compiler,\n      Mode mode,\n      boolean inlineAllStrings) {\n    this.compiler = compiler;\n    this.mode = mode;\n    this.inlineAllStrings = inlineAllStrings;\n  }\n",
        "begin_line": 73,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 4
    },
    {
        "name": "InlineVariables.process#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }\n",
        "begin_line": 82,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 4
    },
    {
        "name": "AnonymousFunctionNamingPolicy.getReservedCharacters#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AnonymousFunctionNamingPolicy.java",
        "class_name": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy",
        "signature": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy.getReservedCharacters()",
        "snippet": "  public char[] getReservedCharacters() {\n    // TODO(user) - for MAPPED, only the first character is reserved which\n    // can be used to further optimize\n    return reservedCharacters;\n  }\n",
        "begin_line": 56,
        "end_line": 60,
        "comment": "\n   * Gets characters that are reserved for use in anonymous function names and\n   * can't be used in variable or property names.\n   * @return reserved characters or null if no characters are reserved\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.hashCode#376",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Arguments.hashCode()",
        "snippet": "    @Override public int hashCode() {\n      return System.identityHashCode(this);\n    }\n",
        "begin_line": 376,
        "end_line": 378,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1286
        },
        "num_failing_tests": 4
    },
    {
        "name": "VariableMap.VariableMap#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VariableMap.java",
        "class_name": "com.google.javascript.jscomp.VariableMap",
        "signature": "com.google.javascript.jscomp.VariableMap.VariableMap(java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "  VariableMap(Map<String, String> map) {\n    this.map = ImmutableMap.copyOf(map);\n  }\n",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileParser.parseLine#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileParser.parseLine(java.lang.String)",
        "snippet": "  @Override\n  protected boolean parseLine(String line) throws ParseException {\n    boolean lineHasProvidesOrRequires = false;\n\n    // Quick sanity check that will catch most cases. This is a performance\n    // win for people with a lot of JS.\n    if (line.indexOf(\"provide\") != -1 ||\n        line.indexOf(\"require\") != -1 ||\n        line.indexOf(\"addDependency\") != -1) {\n      // Iterate over the provides/requires.\n      googMatcher.reset(line);\n      while (googMatcher.find()) {\n        lineHasProvidesOrRequires = true;\n\n        if (includeGoogBase && !fileHasProvidesOrRequires) {\n          fileHasProvidesOrRequires = true;\n          requires.add(\"goog\");\n        }\n\n        // See if it's a require or provide.\n        char firstChar = googMatcher.group(1).charAt(0);\n        boolean isProvide = firstChar == 'p';\n        boolean isRequire = firstChar == 'r';\n\n        if (isProvide || isRequire) {\n          // Parse the param.\n          String arg = parseJsString(googMatcher.group(2));\n\n          // Add the dependency.\n          if (isRequire) {\n            // goog is always implicit.\n            // TODO(nicksantos): I'm pretty sure we don't need this anymore.\n            // Remove this later.\n            if (!\"goog\".equals(arg)) {\n              requires.add(arg);\n            }\n          } else {\n            provides.add(arg);\n          }\n        }\n      }\n    } else if (includeGoogBase && line.startsWith(BASE_JS_START) &&\n               provides.isEmpty() && requires.isEmpty()) {\n      provides.add(\"goog\");\n\n      // base.js can't provide or require anything else.\n      return false;\n    }\n\n    return !shortcutMode || lineHasProvidesOrRequires ||\n        CharMatcher.WHITESPACE.matchesAllOf(line);\n  }\n",
        "begin_line": 137,
        "end_line": 188,
        "comment": "\n   * Parses a line of JavaScript, extracting goog.provide and goog.require\n   * information.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.getReferences#262",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMapWrapper.getReferences(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    @Override\n    public ReferenceCollection getReferences(Var var) {\n      return referenceMap.get(var);\n    }\n",
        "begin_line": 262,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.add#297",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.add(com.google.javascript.jscomp.ReferenceCollectingCallback.Reference, com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    void add(Reference reference, NodeTraversal t, Var v) {\n      references.add(reference);\n    }\n",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.Reference#497",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.Reference(com.google.javascript.rhino.Node, com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock)",
        "snippet": "    Reference(Node nameNode, NodeTraversal t,\n        BasicBlock basicBlock) {\n      this(nameNode, basicBlock, t.getScope(), t.getInput().getInputId());\n    }\n",
        "begin_line": 497,
        "end_line": 500,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.Reference#521",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.Reference(com.google.javascript.rhino.Node, com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock, com.google.javascript.jscomp.Scope, com.google.javascript.rhino.InputId)",
        "snippet": "    private Reference(Node nameNode,\n        BasicBlock basicBlock, Scope scope, InputId inputId) {\n      this.nameNode = nameNode;\n      this.basicBlock = basicBlock;\n      this.scope = scope;\n      this.inputId = inputId;\n      this.sourceFile = nameNode.getStaticSourceFile();\n    }\n",
        "begin_line": 521,
        "end_line": 528,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.visit#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n      Var v;\n      if (n.getString().equals(\"arguments\")) {\n        v = t.getScope().getArgumentsVar();\n      } else {\n        v = t.getScope().getVar(n.getString());\n      }\n      if (v != null && varFilter.apply(v)) {\n        addReference(t, v, new Reference(n, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }\n",
        "begin_line": 147,
        "end_line": 164,
        "comment": "\n   * For each node, update the block stack and reference collection\n   * as appropriate.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.addReference#239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.addReference(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.Reference)",
        "snippet": "  private void addReference(NodeTraversal t, Var v, Reference reference) {\n    // Create collection if none already\n    ReferenceCollection referenceInfo = referenceMap.get(v);\n    if (referenceInfo == null) {\n      referenceInfo = new ReferenceCollection();\n      referenceMap.put(v, referenceInfo);\n    }\n\n    // Add this particular reference\n    referenceInfo.add(reference, t, v);\n  }\n",
        "begin_line": 239,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalVarReferenceMap.resetGlobalVarReferences#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalVarReferenceMap.java",
        "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
        "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.resetGlobalVarReferences(java.util.Map<com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection>)",
        "snippet": "  private void resetGlobalVarReferences(\n      Map<Var, ReferenceCollection> globalRefMap) {\n    refMap = Maps.newHashMap();\n    for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n      Var var = entry.getKey();\n      if (var.isGlobal()) {\n        refMap.put(var.getName(), entry.getValue());\n      }\n    }\n  }\n",
        "begin_line": 78,
        "end_line": 87,
        "comment": "\n   * Resets global var reference map with the new provide map.\n   *\n   * @param globalRefMap The reference map result of a\n   *     {@link ReferenceCollectingCallback} pass collected from the whole AST.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1275
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isEquivalentTo#166",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.NumberNode.isEquivalentTo(com.google.javascript.rhino.Node, boolean, boolean)",
        "snippet": "    @Override\n    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n      boolean equivalent = super.isEquivalentTo(node, compareJsType, recurse);\n      if (equivalent) {\n        double thisValue = getDouble();\n        double thatValue = ((NumberNode) node).getDouble();\n        if (thisValue == thatValue) {\n          // detect the difference between 0.0 and -0.0.\n          return (thisValue != 0.0) || (1/thisValue == 1/thatValue);\n        }\n      }\n      return false;\n    }\n",
        "begin_line": 166,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileLineParser.doParse#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileLineParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileLineParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileLineParser.doParse(java.lang.String, java.io.Reader)",
        "snippet": "  void doParse(String filePath, Reader fileContents) {\n    this.filePath = filePath;\n    parseSucceeded = true;\n\n    BufferedReader lineBuffer = new BufferedReader(fileContents);\n\n    // Parse all lines.\n    String line = null;\n    lineNum = 0;\n    boolean inMultilineComment = false;\n\n    try {\n      while (null != (line = lineBuffer.readLine())) {\n        ++lineNum;\n        try {\n          String revisedLine = line;\n          if (inMultilineComment) {\n            int endOfComment = revisedLine.indexOf(\"*/\");\n            if (endOfComment != -1) {\n              revisedLine = revisedLine.substring(endOfComment + 2);\n              inMultilineComment = false;\n            } else {\n              revisedLine = \"\";\n            }\n          }\n\n          if (!inMultilineComment) {\n            while (true) {\n              int startOfLineComment = revisedLine.indexOf(\"//\");\n              int startOfMultilineComment = revisedLine.indexOf(\"/*\");\n              if (startOfLineComment != -1 &&\n                  (startOfMultilineComment == -1 ||\n                   startOfLineComment < startOfMultilineComment)) {\n                revisedLine = revisedLine.substring(0, startOfLineComment);\n                break;\n              } else if (startOfMultilineComment != -1) {\n                int endOfMultilineComment = revisedLine.indexOf(\"*/\",\n                    startOfMultilineComment + 2);\n                if (endOfMultilineComment == -1) {\n                  revisedLine = revisedLine.substring(\n                      0, startOfMultilineComment);\n                  inMultilineComment = true;\n                  break;\n                } else {\n                  revisedLine =\n                      revisedLine.substring(0, startOfMultilineComment) +\n                      revisedLine.substring(endOfMultilineComment + 2);\n                }\n              } else {\n                break;\n              }\n            }\n          }\n\n          if (!revisedLine.isEmpty()) {\n            // This check for shortcut mode should be redundant, but\n            // it's done for safety reasons.\n            if (!parseLine(revisedLine) && shortcutMode) {\n              break;\n            }\n          }\n        } catch (ParseException e) {\n          // Inform the error handler of the exception.\n          errorManager.report(\n              e.isFatal() ? CheckLevel.ERROR : CheckLevel.WARNING,\n              JSError.make(filePath, lineNum, 0 /* char offset */,\n                  e.isFatal() ? PARSE_ERROR : PARSE_WARNING,\n                  e.getMessage(), line));\n          parseSucceeded = parseSucceeded && !e.isFatal();\n        }\n      }\n    } catch (IOException e) {\n      errorManager.report(CheckLevel.ERROR,\n          JSError.make(filePath, 0, 0 /* char offset */,\n              PARSE_ERROR, \"Error reading file: \" + filePath));\n      parseSucceeded = false;\n    }\n  }\n",
        "begin_line": 119,
        "end_line": 196,
        "comment": "\n   * Performs the line-by-line parsing of the given fileContents. This method\n   * strips out JavaScript comments and then uses the abstract parseLine()\n   * method to do the line parsing.\n   *\n   * @param filePath The path to the file being parsed. Used for reporting parse\n   *     exceptions.\n   * @param fileContents A reader for the contents of the file.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalVarReferenceMap.getReferences#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalVarReferenceMap.java",
        "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
        "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.getReferences(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  @Override\n  public ReferenceCollection getReferences(Var var) {\n    if (!var.isGlobal()) {\n      return null;\n    }\n    return refMap.get(var.getName());\n  }\n",
        "begin_line": 64,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 4
    },
    {
        "name": "SortedDependencies.getDependenciesOf#210",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.getDependenciesOf(java.util.List<INPUT>, boolean)",
        "snippet": "  public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted) {\n    Preconditions.checkArgument(inputs.containsAll(roots));\n    Set<INPUT> included = Sets.newHashSet();\n    Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots);\n    while (!worklist.isEmpty()) {\n      INPUT current = worklist.pop();\n      if (included.add(current)) {\n        for (String req : current.getRequires()) {\n          INPUT dep = provideMap.get(req);\n          if (dep != null) {\n            worklist.add(dep);\n          }\n        }\n      }\n    }\n\n    ImmutableList.Builder<INPUT> builder = ImmutableList.builder();\n    for (INPUT current : (sorted ? sortedList : inputs)) {\n      if (included.contains(current)) {\n        builder.add(current);\n      }\n    }\n    return builder.build();\n  }\n",
        "begin_line": 210,
        "end_line": 233,
        "comment": "\n   * Gets all the dependencies of the given roots. The inputs must be returned\n   * in a stable order. In other words, if A comes before B, and A does not\n   * transitively depend on B, then A must also come before B in the returned\n   * list.\n   *\n   * @param sorted If true, get them in topologically sorted order. If false,\n   *     get them in the original order they were passed to the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.Arguments#354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Arguments.Arguments(com.google.javascript.jscomp.Scope)",
        "snippet": "    Arguments(Scope scope) {\n      super(\n        false, // no inferred\n        \"arguments\", // always arguments\n        null,  // no declaration node\n        // TODO(johnlenz): provide the type of \"Arguments\".\n        null,  // no type info\n        scope,\n        -1,    // no variable index\n        null   // input\n        );\n    }\n",
        "begin_line": 354,
        "end_line": 365,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getArgumentsVar#542",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getArgumentsVar()",
        "snippet": "  public Var getArgumentsVar() {\n    if (arguments == null) {\n      arguments = new Arguments(this);\n    }\n    return arguments;\n  }\n",
        "begin_line": 542,
        "end_line": 547,
        "comment": "\n   * Get a unique VAR object to represents \"arguments\" within this scope\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.ReferenceMapWrapper#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMapWrapper.ReferenceMapWrapper(java.util.Map<com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection>)",
        "snippet": "    public ReferenceMapWrapper(Map<Var, ReferenceCollection> referenceMap) {\n      this.referenceMap = referenceMap;\n    }\n",
        "begin_line": 258,
        "end_line": 260,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.BasicBlock#665",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock.BasicBlock(com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock, com.google.javascript.rhino.Node)",
        "snippet": "    BasicBlock(BasicBlock parent, Node root) {\n      this.parent = parent;\n\n      // only named functions may be hoisted.\n      this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n\n      this.isFunction = root.isFunction();\n\n      if (root.getParent() != null) {\n        int pType = root.getParent().getType();\n        this.isLoop = pType == Token.DO ||\n            pType == Token.WHILE ||\n            pType == Token.FOR;\n      } else {\n        this.isLoop = false;\n      }\n    }\n",
        "begin_line": 665,
        "end_line": 681,
        "comment": "\n     * Creates a new block.\n     * @param parent The containing block.\n     * @param root The root node of the block.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.exitScope#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }\n",
        "begin_line": 179,
        "end_line": 189,
        "comment": "\n   * Updates block stack and invokes any additional behavior.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "NameGenerator.NameGenerator#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NameGenerator.java",
        "class_name": "com.google.javascript.jscomp.NameGenerator",
        "signature": "com.google.javascript.jscomp.NameGenerator.NameGenerator(java.util.Set<java.lang.String>, java.lang.String, char[])",
        "snippet": "  NameGenerator(Set<String> reservedNames, String prefix,\n      @Nullable char[] reservedCharacters) {\n    this.reservedNames = reservedNames;\n    this.prefix = prefix;\n\n    // build the character arrays to use\n    this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters);\n    this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters);\n\n    checkPrefix(prefix);\n  }\n",
        "begin_line": 59,
        "end_line": 69,
        "comment": "\n   * Creates a NameGenerator.\n   *\n   * @param reservedNames set of names that are reserved; generated names will\n   *   not include these names. This set is referenced rather than copied,\n   *   so changes to the set will be reflected in how names are generated.\n   * @param prefix all generated names begin with this prefix.\n   * @param reservedCharacters If specified these characters won't be used in\n   *   generated names\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "NameGenerator.reserveCharacters#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NameGenerator.java",
        "class_name": "com.google.javascript.jscomp.NameGenerator",
        "signature": "com.google.javascript.jscomp.NameGenerator.reserveCharacters(char[], char[])",
        "snippet": "  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n    if (reservedCharacters == null || reservedCharacters.length == 0) {\n      return chars;\n    }\n    Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));\n    for (char reservedCharacter : reservedCharacters) {\n      charSet.remove(reservedCharacter);\n    }\n    return Chars.toArray(charSet);\n  }\n",
        "begin_line": 78,
        "end_line": 87,
        "comment": "\n   * Provides the array of available characters based on the specified arrays.\n   * @param chars The list of characters that are legal\n   * @param reservedCharacters The characters that should not be used\n   * @return An array of characters to use. Will return the chars array if\n   *    reservedCharacters is null or empty, otherwise creates a new array.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "NameGenerator.checkPrefix#90",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NameGenerator.java",
        "class_name": "com.google.javascript.jscomp.NameGenerator",
        "signature": "com.google.javascript.jscomp.NameGenerator.checkPrefix(java.lang.String)",
        "snippet": "  private void checkPrefix(String prefix) {\n    if (prefix.length() > 0) {\n      // Make sure that prefix starts with a legal character.\n      if (!contains(firstChars, prefix.charAt(0))) {\n        throw new IllegalArgumentException(\"prefix must start with one of: \" +\n                                           Arrays.toString(firstChars));\n      }\n      for (int pos = 1; pos < prefix.length(); ++pos) {\n        if (!contains(nonFirstChars, prefix.charAt(pos))) {\n          throw new IllegalArgumentException(\"prefix has invalid characters, \" +\n                                             \"must be one of: \" +\n                                             Arrays.toString(nonFirstChars));\n        }\n      }\n    }\n  }\n",
        "begin_line": 90,
        "end_line": 105,
        "comment": " Validates a name prefix. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModuleGraph.manageDependencies#354",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModuleGraph.java",
        "class_name": "com.google.javascript.jscomp.JSModuleGraph",
        "signature": "com.google.javascript.jscomp.JSModuleGraph.manageDependencies(com.google.javascript.jscomp.DependencyOptions, java.util.List<com.google.javascript.jscomp.CompilerInput>)",
        "snippet": "  public List<CompilerInput> manageDependencies(\n      DependencyOptions depOptions,\n      List<CompilerInput> inputs)\n      throws CircularDependencyException, MissingProvideException {\n\n    SortedDependencies<CompilerInput> sorter =\n        new SortedDependencies<CompilerInput>(inputs);\n    Set<CompilerInput> entryPointInputs = Sets.newLinkedHashSet();\n    if (depOptions.shouldPruneDependencies()) {\n      if (!depOptions.shouldDropMoochers()) {\n        entryPointInputs.addAll(sorter.getInputsWithoutProvides());\n      }\n\n      for (String entryPoint : depOptions.getEntryPoints()) {\n        entryPointInputs.add(sorter.getInputProviding(entryPoint));\n      }\n\n      CompilerInput baseJs = sorter.maybeGetInputProviding(\"goog\");\n      if (baseJs != null) {\n        entryPointInputs.add(baseJs);\n      }\n    } else {\n      entryPointInputs.addAll(inputs);\n    }\n\n    // The order of inputs, sorted independently of modules.\n    List<CompilerInput> absoluteOrder =\n        sorter.getDependenciesOf(inputs, depOptions.shouldSortDependencies());\n\n    // Figure out which sources *must* be in each module.\n    ListMultimap<JSModule, CompilerInput> entryPointInputsPerModule =\n        LinkedListMultimap.create();\n    for (CompilerInput input : entryPointInputs) {\n      JSModule module = input.getModule();\n      Preconditions.checkNotNull(module);\n      entryPointInputsPerModule.put(module, input);\n    }\n\n    // Clear the modules of their inputs. This also nulls out\n    // the input's reference to its module.\n    for (JSModule module : getAllModules()) {\n      module.removeAll();\n    }\n\n    // Figure out which sources *must* be in each module, or in one\n    // of that module's dependencies.\n    for (JSModule module : entryPointInputsPerModule.keySet()) {\n      List<CompilerInput> transitiveClosure =\n          sorter.getDependenciesOf(\n              entryPointInputsPerModule.get(module),\n              depOptions.shouldSortDependencies());\n      for (CompilerInput input : transitiveClosure) {\n        JSModule oldModule = input.getModule();\n        if (oldModule == null) {\n          input.setModule(module);\n        } else {\n          input.setModule(null);\n          input.setModule(\n              getDeepestCommonDependencyInclusive(oldModule, module));\n        }\n      }\n    }\n\n    // All the inputs are pointing to the modules that own them. Yeah!\n    // Update the modules to reflect this.\n    for (CompilerInput input : absoluteOrder) {\n      JSModule module = input.getModule();\n      if (module != null) {\n        module.add(input);\n      }\n    }\n\n    // Now, generate the sorted result.\n    List<CompilerInput> result = Lists.newArrayList();\n    for (JSModule module : getAllModules()) {\n      result.addAll(module.getInputs());\n    }\n\n    return result;\n  }\n",
        "begin_line": 354,
        "end_line": 433,
        "comment": "\n   * Apply the dependency options to the list of sources, returning a new\n   * source list re-ordering and dropping files as necessary.\n   * This module graph will be updated to reflect the new list.\n   *\n   * @param inputs The original list of sources. Used to ensure that the sort\n   *     is stable.\n   * @throws CircularDependencyException if there is a circular dependency\n   *     between the provides and requires.\n   * @throws MissingProvideException if an entry point was not provided\n   *     by any of the inputs.\n   * @see DependencyOptions for more info on how this works.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModule.removeAll#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.removeAll()",
        "snippet": "  public void removeAll() {\n    for (CompilerInput input : inputs) {\n      input.setModule(null);\n    }\n    inputs.clear();\n  }\n",
        "begin_line": 145,
        "end_line": 150,
        "comment": " Removes all of the inputs from this module. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "DependencyOptions.shouldSortDependencies#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.shouldSortDependencies()",
        "snippet": "  boolean shouldSortDependencies() {\n    return sortDependencies;\n  }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.setRenamingPolicy#1159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setRenamingPolicy(com.google.javascript.jscomp.VariableRenamingPolicy, com.google.javascript.jscomp.PropertyRenamingPolicy)",
        "snippet": "  public void setRenamingPolicy(VariableRenamingPolicy newVariablePolicy,\n      PropertyRenamingPolicy newPropertyPolicy) {\n    this.variableRenaming = newVariablePolicy;\n    this.propertyRenaming = newPropertyPolicy;\n  }\n",
        "begin_line": 1159,
        "end_line": 1163,
        "comment": "\n   * Sets the variable and property renaming policies for the compiler,\n   * in a way that clears warnings about the renaming policy being\n   * uninitialized from flags.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.rebuildInputsFromModules#481",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.rebuildInputsFromModules()",
        "snippet": "  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n",
        "begin_line": 481,
        "end_line": 484,
        "comment": "\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(List, List, CompilerOptions)} call.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.repartitionInputs#1472",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.repartitionInputs()",
        "snippet": "  private void repartitionInputs() {\n    fillEmptyModules(modules);\n    rebuildInputsFromModules();\n  }\n",
        "begin_line": 1472,
        "end_line": 1475,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1265
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReorderConstantExpression.optimizeSubtree#32",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReorderConstantExpression.java",
        "class_name": "com.google.javascript.jscomp.ReorderConstantExpression",
        "signature": "com.google.javascript.jscomp.ReorderConstantExpression.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    // if the operator is symmetric\n    if (NodeUtil.isSymmetricOperation(subtree)\n        || NodeUtil.isRelationalOperation(subtree)) {\n      // right value is immutable and left is not\n      if (NodeUtil.isImmutableValue(subtree.getLastChild())\n          && !NodeUtil.isImmutableValue(subtree.getFirstChild())) {\n\n        // if relational, get the inverse operator.\n        if (NodeUtil.isRelationalOperation(subtree)){\n          int inverseOperator = NodeUtil.getInverseOperator(subtree.getType());\n          subtree.setType(inverseOperator);\n        }\n\n        // swap them\n        Node firstNode = subtree.getFirstChild().detachFromParent();\n        Node lastNode = subtree.getLastChild().detachFromParent();\n\n        subtree.addChildrenToFront(lastNode);\n        subtree.addChildrenToBack(firstNode);\n        reportCodeChange();\n      }\n    }\n    return subtree;\n  }\n",
        "begin_line": 32,
        "end_line": 57,
        "comment": " to follow our naming convention.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.PeepholeSubstituteAlternateSyntax#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.PeepholeSubstituteAlternateSyntax(boolean)",
        "snippet": "  PeepholeSubstituteAlternateSyntax(boolean late) {\n    this.late = late;\n  }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n   * @param late When late is false, this mean we are currently running before\n   * most of the other optimizations. In this case we would avoid optimizations\n   * that would make the code harder to analyze (such as using string splitting,\n   * merging statements with commas, etc). When this is true, we would\n   * do anything to minimize for size.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeReplaceKnownMethods.PeepholeReplaceKnownMethods#42",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
        "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.PeepholeReplaceKnownMethods(boolean)",
        "snippet": "  PeepholeReplaceKnownMethods(boolean late) {\n    this.late = late;\n  }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n   * @param late When late is true, this mean we are currently running after\n   * most of the other optimizations. In this case we avoid changes that make\n   * the code larger (but otherwise easier to analyze - such as using string\n   * splitting).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeReplaceKnownMethods.optimizeSubtree#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
        "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    if (subtree.isCall() ){\n      return tryFoldKnownMethods(subtree);\n    }\n    return subtree;\n  }\n",
        "begin_line": 46,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.isUnremovableNode#541",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.isUnremovableNode(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isUnremovableNode(Node n) {\n    return (n.isBlock() && n.isSyntheticBlock()) || n.isScript();\n  }\n",
        "begin_line": 541,
        "end_line": 543,
        "comment": "\n   * Some nodes unremovable node don't have side-effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.tryOptimizeConditionalAfterAssign#550",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryOptimizeConditionalAfterAssign(com.google.javascript.rhino.Node)",
        "snippet": "  private void tryOptimizeConditionalAfterAssign(Node n) {\n    Node next = n.getNext();\n\n    // Look for patterns like the following and replace the if-condition with\n    // a constant value so it can later be folded:\n    //   var a = /a/;\n    //   if (a) {foo(a)}\n    // or\n    //   a = 0;\n    //   a ? foo(a) : c;\n    // or\n    //   a = 0;\n    //   a || foo(a);\n    // or\n    //   a = 0;\n    //   a && foo(a)\n    //\n    // TODO(johnlenz): This would be better handled by control-flow sensitive\n    // constant propagation. As the other case that I want to handle is:\n    //   i=0; for(;i<0;i++){}\n    // as right now nothing facilitates removing a loop like that.\n    // This is here simply to remove the cruft left behind goog.userAgent and\n    // similar cases.\n\n    if (isSimpleAssignment(n) && isConditionalStatement(next)) {\n      Node lhsAssign = getSimpleAssignmentName(n);\n\n      Node condition = getConditionalStatementCondition(next);\n      if (lhsAssign.isName() && condition.isName()\n          && lhsAssign.getString().equals(condition.getString())) {\n        Node rhsAssign = getSimpleAssignmentValue(n);\n        TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign);\n        if (value != TernaryValue.UNKNOWN) {\n          Node replacementConditionNode =\n              NodeUtil.booleanNode(value.toBoolean(true));\n          condition.getParent().replaceChild(condition,\n              replacementConditionNode);\n          reportCodeChange();\n        }\n      }\n    }\n  }\n",
        "begin_line": 550,
        "end_line": 591,
        "comment": "\n   * Attempt to replace the condition of if or hook immediately that is a\n   * reference to a name that is assigned immediately before.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.isSimpleAssignment#597",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.isSimpleAssignment(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isSimpleAssignment(Node n) {\n    // For our purposes we define a simple assignment to be a assignment\n    // to a NAME node, or a VAR declaration with one child and a initializer.\n    if (NodeUtil.isExprAssign(n)\n        && n.getFirstChild().getFirstChild().isName()) {\n      return true;\n    } else if (n.isVar() && n.hasOneChild() &&\n        n.getFirstChild().getFirstChild() != null) {\n      return true;\n    }\n\n    return false;\n  }\n",
        "begin_line": 597,
        "end_line": 609,
        "comment": "\n   * @return whether the node is a assignment to a simple name, or simple var\n   * declaration with initialization.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeFoldConstants.PeepholeFoldConstants#74",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.PeepholeFoldConstants(boolean)",
        "snippet": "  PeepholeFoldConstants(boolean late) {\n    this.late = late;\n  }\n",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n   * @param late When late is false, this mean we are currently running before\n   * most of the other optimizations. In this case we would avoid optimizations\n   * that would make the code harder to analyze. When this is true, we would\n   * do anything to minimize for size.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeFoldConstants.optimizeSubtree#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.optimizeSubtree(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.NEW:\n        return tryFoldCtorCall(subtree);\n\n      case Token.TYPEOF:\n        return tryFoldTypeof(subtree);\n\n      case Token.NOT:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldUnaryOperator(subtree);\n\n      case Token.VOID:\n        return tryReduceVoid(subtree);\n\n      default:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldBinaryOperator(subtree);\n    }\n  }\n",
        "begin_line": 78,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeFoldConstants.tryReduceOperandsForOp#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryReduceOperandsForOp(com.google.javascript.rhino.Node)",
        "snippet": "  private void tryReduceOperandsForOp(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n        if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) {\n          tryConvertOperandsToNumber(n);\n        }\n        break;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n        // TODO(johnlenz): convert these to integers.\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_DIV:\n        tryConvertToNumber(n.getLastChild());\n        break;\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.POS:\n      case Token.NEG:\n        tryConvertOperandsToNumber(n);\n        break;\n    }\n  }\n",
        "begin_line": 196,
        "end_line": 234,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isSymmetricOperation#523",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isSymmetricOperation(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isSymmetricOperation(Node n) {\n    switch (n.getType()) {\n      case Token.EQ: // equal\n      case Token.NE: // not equal\n      case Token.SHEQ: // exactly equal\n      case Token.SHNE: // exactly not equal\n      case Token.MUL: // multiply, unlike add it only works on numbers\n                      // or results NaN if any of the operators is not a number\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 523,
        "end_line": 534,
        "comment": "\n   * Returns true if the operator on this node is symmetric\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isRelationalOperation#540",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isRelationalOperation(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isRelationalOperation(Node n) {\n    switch (n.getType()) {\n      case Token.GT: // equal\n      case Token.GE: // not equal\n      case Token.LT: // exactly equal\n      case Token.LE: // exactly not equal\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 540,
        "end_line": 549,
        "comment": "\n   * Returns true if the operator on this node is relational.\n   * the returned set does not include the equalities.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "MinimizeExitPoints.MinimizeExitPoints#42",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.MinimizeExitPoints(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  MinimizeExitPoints(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "MinimizeExitPoints.process#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java",
        "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
        "signature": "com.google.javascript.jscomp.MinimizeExitPoints.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModuleGraph.getAllModules#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModuleGraph.java",
        "class_name": "com.google.javascript.jscomp.JSModuleGraph",
        "signature": "com.google.javascript.jscomp.JSModuleGraph.getAllModules()",
        "snippet": "  Iterable<JSModule> getAllModules() {\n    return modules;\n  }\n",
        "begin_line": 120,
        "end_line": 122,
        "comment": "\n   * Gets an iterable over all modules in dependency order.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalVarReferenceMap.GlobalVarReferenceMap#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalVarReferenceMap.java",
        "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
        "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.GlobalVarReferenceMap(java.util.List<com.google.javascript.jscomp.CompilerInput>, java.util.List<com.google.javascript.jscomp.CompilerInput>)",
        "snippet": "  GlobalVarReferenceMap(List<CompilerInput> inputs, List<CompilerInput> externs) {\n    inputOrder = Maps.newHashMap();\n    int ind = 0;\n    for (CompilerInput extern : externs) {\n      inputOrder.put(extern.getInputId(), ind);\n      ind++;\n    }\n    for (CompilerInput input : inputs) {\n      inputOrder.put(input.getInputId(), ind);\n      ind++;\n    }\n  }\n",
        "begin_line": 51,
        "end_line": 62,
        "comment": "\n   * @param inputs The ordered list of all inputs for the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "DependencyOptions.shouldPruneDependencies#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.shouldPruneDependencies()",
        "snippet": "  boolean shouldPruneDependencies() {\n    return pruneDependencies;\n  }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1641",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-09d3b908-c51f-47bc-8c68-12f15946960c.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new MinimizeExitPoints(compiler);\n    }\n",
        "begin_line": 1641,
        "end_line": 1644,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1067",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-494eacf8-7964-49a6-9402-b89fc7512644.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      final boolean late = true;\n      return new PeepholeOptimizationsPass(compiler,\n            new StatementFusion(),\n            new PeepholeRemoveDeadCode(),\n            new PeepholeSubstituteAlternateSyntax(late),\n            new PeepholeReplaceKnownMethods(late),\n            new PeepholeFoldConstants(late),\n            new ReorderConstantExpression());\n    }\n",
        "begin_line": 1067,
        "end_line": 1077,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1052",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-37570b8a-ac92-460d-aa55-2ac7dc74f393.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      final boolean late = false;\n      return new PeepholeOptimizationsPass(compiler,\n            new PeepholeSubstituteAlternateSyntax(late),\n            new PeepholeReplaceKnownMethods(late),\n            new PeepholeRemoveDeadCode(),\n            new PeepholeFoldConstants(late),\n            new PeepholeCollectPropertyAssignments());\n    }\n",
        "begin_line": 1052,
        "end_line": 1061,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 4
    },
    {
        "name": "SortedDependencies.topologicalStableSort#239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.topologicalStableSort(java.util.List<T>, com.google.common.collect.Multimap<T, T>)",
        "snippet": "  private static <T> List<T> topologicalStableSort(\n      List<T> items, Multimap<T, T> deps) {\n    if (items.size() == 0) {\n      // Priority queue blows up if we give it a size of 0. Since we need\n      // to special case this either way, just bail out.\n      return Lists.newArrayList();\n    }\n\n    final Map<T, Integer> originalIndex = Maps.newHashMap();\n    for (int i = 0; i < items.size(); i++) {\n      originalIndex.put(items.get(i), i);\n    }\n\n    PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(),\n        new Comparator<T>() {\n      @Override\n      public int compare(T a, T b) {\n        return originalIndex.get(a).intValue() -\n            originalIndex.get(b).intValue();\n      }\n    });\n    List<T> result = Lists.newArrayList();\n\n    Multiset<T> inDegree = HashMultiset.create();\n    Multimap<T, T> reverseDeps = ArrayListMultimap.create();\n    Multimaps.invertFrom(deps, reverseDeps);\n\n    // First, add all the inputs with in-degree 0.\n    for (T item : items) {\n      Collection<T> itemDeps = deps.get(item);\n      inDegree.add(item, itemDeps.size());\n      if (itemDeps.isEmpty()) {\n        inDegreeZero.add(item);\n      }\n    }\n\n    // Then, iterate to a fixed point over the reverse dependency graph.\n    while (!inDegreeZero.isEmpty()) {\n      T item = inDegreeZero.remove();\n      result.add(item);\n      for (T inWaiting : reverseDeps.get(item)) {\n        inDegree.remove(inWaiting, 1);\n        if (inDegree.count(inWaiting) == 0) {\n          inDegreeZero.add(inWaiting);\n        }\n      }\n    }\n\n    return result;\n  }\n",
        "begin_line": 239,
        "end_line": 288,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.ReferenceCollectingCallback#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollectingCallback(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior, com.google.common.base.Predicate<com.google.javascript.jscomp.Scope.Var>)",
        "snippet": "  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior,\n      Predicate<Var> varFilter) {\n    this.compiler = compiler;\n    this.behavior = behavior;\n    this.varFilter = varFilter;\n  }\n",
        "begin_line": 97,
        "end_line": 102,
        "comment": "\n   * Constructor only collects references that match the given variable.\n   *\n   * The test for Var equality uses reference equality, so it's necessary to\n   * inject a scope when you traverse.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.process#108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }\n",
        "begin_line": 108,
        "end_line": 112,
        "comment": "\n   * Convenience method for running this pass over a tree with this\n   * class as a callback.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.enterScope#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node n = t.getScope().getRootNode();\n    BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n    blockStack.push(new BasicBlock(parent, n));\n  }\n",
        "begin_line": 169,
        "end_line": 174,
        "comment": "\n   * Updates block stack and invokes any additional behavior.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.shouldTraverse#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n      Node parent) {\n    // If node is a new basic block, put on basic block stack\n    if (isBlockBoundary(n, parent)) {\n      blockStack.push(new BasicBlock(blockStack.peek(), n));\n    }\n    return true;\n  }\n",
        "begin_line": 194,
        "end_line": 202,
        "comment": "\n   * Updates block stack.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalVarReferenceMap.updateGlobalVarReferences#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalVarReferenceMap.java",
        "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
        "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.updateGlobalVarReferences(java.util.Map<com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection>, com.google.javascript.rhino.Node)",
        "snippet": "  void updateGlobalVarReferences(Map<Var, ReferenceCollection>\n      refMapPatch, Node root) {\n    if (refMap == null || !root.isScript()) {\n      resetGlobalVarReferences(refMapPatch);\n      return;\n    }\n\n    InputId inputId = root.getInputId();\n    Preconditions.checkNotNull(inputId);\n    // Note there are two assumptions here (i) the order of compiler inputs\n    // has not changed and (ii) all references are in the order they appear\n    // in AST (this is enforced in ReferenceCollectionCallback).\n    removeScriptReferences(inputId);\n    for (Entry<Var, ReferenceCollection> entry : refMapPatch.entrySet()) {\n      Var var = entry.getKey();\n      if (var.isGlobal()) {\n        replaceReferences(var.getName(), inputId, entry.getValue());\n      }\n    }\n  }\n",
        "begin_line": 100,
        "end_line": 119,
        "comment": "\n   * Updates the internal reference map based on the provided parameters. If\n   * {@code scriptRoot} is not SCRIPT, it basically replaces the internal map\n   * with the new one, otherwise it replaces all the information associated to\n   * the given script.\n   *\n   * @param refMapPatch The reference map result of a\n   *     {@link ReferenceCollectingCallback} pass which might be collected from\n   *     the whole AST or just a sub-tree associated to a SCRIPT node.\n   * @param root AST sub-tree root on which reference collection was done.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getInputsInOrder#2252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getInputsInOrder()",
        "snippet": "  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n",
        "begin_line": 2252,
        "end_line": 2255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getExternsInOrder#2267",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getExternsInOrder()",
        "snippet": "  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n",
        "begin_line": 2267,
        "end_line": 2269,
        "comment": "\n   * Gets the externs in the order in which they are being processed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.updateGlobalVarReferences#2355",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.updateGlobalVarReferences(java.util.Map<com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection>, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n",
        "begin_line": 2355,
        "end_line": 2365,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getGlobalVarReferences#2367",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getGlobalVarReferences()",
        "snippet": "  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n",
        "begin_line": 2367,
        "end_line": 2370,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1255
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isForIn#1614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isForIn(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }\n",
        "begin_line": 1614,
        "end_line": 1617,
        "comment": "\n   * @return Whether the node represents a FOR-IN loop.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1253
        },
        "num_failing_tests": 5
    },
    {
        "name": "CodeGenerator.CodeGenerator#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(com.google.javascript.jscomp.CodeConsumer)",
        "snippet": "  private CodeGenerator(CodeConsumer consumer) {\n    cc = consumer;\n    outputCharsetEncoder = null;\n    preferSingleQuotes = false;\n    trustedStrings = true;\n  }\n",
        "begin_line": 54,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeGenerator.forCostEstimation#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.forCostEstimation(com.google.javascript.jscomp.CodeConsumer)",
        "snippet": "  static CodeGenerator forCostEstimation(CodeConsumer consumer) {\n    return new CodeGenerator(consumer);\n  }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 4
    },
    {
        "name": "TernaryValue.forBoolean#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/TernaryValue.java",
        "class_name": "com.google.javascript.rhino.jstype.TernaryValue",
        "signature": "com.google.javascript.rhino.jstype.TernaryValue.forBoolean(boolean)",
        "snippet": "  public static TernaryValue forBoolean(boolean val) {\n    return val ? TernaryValue.TRUE : TernaryValue.FALSE;\n  }\n",
        "begin_line": 201,
        "end_line": 203,
        "comment": "\n   * Gets the TernaryValue for the given boolean.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.visit#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n      checkFunctionUse(t, n);\n    } else if (n.isName()) {\n      if (!isDeclaration(n)) {\n        checkNameUse(t, n);\n      }\n    } else if (n.isAssign()) {\n      checkAssignment(t, n);\n    } else if (n.isDelProp()) {\n      checkDelete(t, n);\n    } else if (n.isObjectLit()) {\n      checkObjectLiteral(t, n);\n    } else if (n.isLabel()) {\n      checkLabel(t, n);\n    }\n  }\n",
        "begin_line": 101,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.checkObjectLiteral#191",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.checkObjectLiteral(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkObjectLiteral(NodeTraversal t, Node n) {\n    Set<String> getters = Sets.newHashSet();\n    Set<String> setters = Sets.newHashSet();\n    for (Node key = n.getFirstChild();\n         key != null;\n         key = key.getNext()) {\n      if (!noCajaChecks && key.getString().endsWith(\"__\")) {\n        t.report(key, ILLEGAL_NAME);\n      }\n      if (!key.isSetterDef()) {\n        // normal property and getter cases\n        if (getters.contains(key.getString())) {\n          t.report(key, DUPLICATE_OBJECT_KEY);\n        } else {\n          getters.add(key.getString());\n        }\n      }\n      if (!key.isGetterDef()) {\n        // normal property and setter cases\n        if (setters.contains(key.getString())) {\n          t.report(key, DUPLICATE_OBJECT_KEY);\n        } else {\n          setters.add(key.getString());\n        }\n      }\n    }\n  }\n",
        "begin_line": 191,
        "end_line": 217,
        "comment": " Checks that object literal keys are valid. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.processRequireCall#264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.processRequireCall(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyArgument(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before runtime.  The one\n      // exception is if the type has not been provided yet and\n      // errors for broken requires are turned off, in which case,\n      // we will be doing a later pass that may error, so we can\n      // leave this here this time and let it error next time if it\n      // is still not provided.\n      if (provided != null || requiresLevel.isOn()) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n",
        "begin_line": 264,
        "end_line": 304,
        "comment": "\n   * Handles a goog.require call.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getPureBooleanValue#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getPureBooleanValue(com.google.javascript.rhino.Node)",
        "snippet": "  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
        "begin_line": 123,
        "end_line": 169,
        "comment": "\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getImpureBooleanValue if you don't care about side-effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 2
    },
    {
        "name": "MustBeReachingVariableDef.addToDefIfLocal#327",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.addToDefIfLocal(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef)",
        "snippet": "  private void addToDefIfLocal( String name, @Nullable Node node,\n      @Nullable Node rValue, MustDef def) {\n    Var var = jsScope.getVar(name);\n\n    // var might be null because the variable might be defined in the extern\n    // that we might not traverse.\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n\n    for (Var other : def.reachingDef.keySet()) {\n      Definition otherDef = def.reachingDef.get(other);\n      if (otherDef == null) {\n        continue;\n      }\n      if (otherDef.depends.contains(var)) {\n        def.reachingDef.put(other, null);\n      }\n    }\n\n    if (!escaped.contains(var)) {\n      if (node == null) {\n        def.reachingDef.put(var, null);\n      } else {\n        Definition definition = new Definition(node);\n        if (rValue != null) {\n          computeDependence(definition, rValue);\n        }\n        def.reachingDef.put(var, definition);\n      }\n    }\n  }\n",
        "begin_line": 327,
        "end_line": 358,
        "comment": "\n   * Set the variable lattice for the given name to the node value in the def\n   * lattice. Do nothing if the variable name is one of the escaped variable.\n   *\n   * @param node The CFG node where the definition should be record to.\n   *     {@code null} if this is a conditional define.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaybeReachingVariableUse.removeFromUseIfLocal#276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.removeFromUseIfLocal(java.lang.String, com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses)",
        "snippet": "  private void removeFromUseIfLocal(String name, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.removeAll(var);\n    }\n  }\n",
        "begin_line": 276,
        "end_line": 284,
        "comment": "\n   * Removes the variable for the given name from the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "CollapseVariableDeclarations.blacklistStubVars#181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.GatherCollapses.blacklistStubVars(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "    private void blacklistStubVars(NodeTraversal t, Node varNode) {\n      for (Node child = varNode.getFirstChild();\n           child != null; child = child.getNext()) {\n        if (child.getFirstChild() == null) {\n          blacklistedVars.add(t.getScope().getVar(child.getString()));\n        }\n      }\n    }\n",
        "begin_line": 181,
        "end_line": 188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.cloneNode#1670",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.cloneNode()",
        "snippet": "  public Node cloneNode() {\n    Node result;\n    try {\n      result = (Node) super.clone();\n      // PropListItem lists are immutable and can be shared so there is no\n      // need to clone them here.\n      result.next = null;\n      result.first = null;\n      result.last = null;\n      result.parent = null;\n    } catch (CloneNotSupportedException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return result;\n  }\n",
        "begin_line": 1670,
        "end_line": 1684,
        "comment": "\n   * @return A detached clone of the Node, specifically excluding its children.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "SimpleDependencyInfo.SimpleDependencyInfo#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java",
        "class_name": "com.google.javascript.jscomp.deps.SimpleDependencyInfo",
        "signature": "com.google.javascript.jscomp.deps.SimpleDependencyInfo.SimpleDependencyInfo(java.lang.String, java.lang.String, java.util.List<java.lang.String>, java.util.List<java.lang.String>)",
        "snippet": "  public SimpleDependencyInfo(\n      String srcPathRelativeToClosure, String pathOfDefiningFile,\n      List<String> provides, List<String> requires) {\n    this.srcPathRelativeToClosure = srcPathRelativeToClosure;\n    this.pathOfDefiningFile = pathOfDefiningFile;\n    this.provides = provides;\n    this.requires = requires;\n  }\n",
        "begin_line": 55,
        "end_line": 62,
        "comment": "\n   * Constructs a DependencyInfo object with the given list of provides &\n   * requires. This does *not* copy the given lists, but uses them directly.\n   *\n   * @param srcPathRelativeToClosure The closure-relative path of the file\n   *     associated with this DependencyInfo.\n   * @param pathOfDefiningFile The path to the file from which this dependency\n   *     information was extracted.\n   * @param provides List of provided symbols.\n   * @param requires List of required symbols.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "SimpleDependencyInfo.getProvides#74",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java",
        "class_name": "com.google.javascript.jscomp.deps.SimpleDependencyInfo",
        "signature": "com.google.javascript.jscomp.deps.SimpleDependencyInfo.getProvides()",
        "snippet": "  @Override\n  public Collection<String> getProvides() {\n    return Collections.<String>unmodifiableList(provides);\n  }\n",
        "begin_line": 74,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "SimpleDependencyInfo.getRequires#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java",
        "class_name": "com.google.javascript.jscomp.deps.SimpleDependencyInfo",
        "signature": "com.google.javascript.jscomp.deps.SimpleDependencyInfo.getRequires()",
        "snippet": "  @Override\n  public Collection<String> getRequires() {\n    return Collections.<String>unmodifiableList(requires);\n  }\n",
        "begin_line": 79,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "SimpleDependencyInfo.toString#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java",
        "class_name": "com.google.javascript.jscomp.deps.SimpleDependencyInfo",
        "signature": "com.google.javascript.jscomp.deps.SimpleDependencyInfo.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return String.format(\"DependencyInfo(relativePath='%1$s', path='%2$s', \"\n        + \"provides=%3$s, requires=%4$s)\", srcPathRelativeToClosure,\n        pathOfDefiningFile, provides, requires);\n  }\n",
        "begin_line": 97,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileParser.JsFileParser#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileParser.JsFileParser(com.google.javascript.jscomp.ErrorManager)",
        "snippet": "  public JsFileParser(ErrorManager errorManager) {\n    super(errorManager);\n  }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n   * Constructor\n   *\n   * @param errorManager Handles parse errors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileParser.setIncludeGoogBase#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileParser.setIncludeGoogBase(boolean)",
        "snippet": "  public JsFileParser setIncludeGoogBase(boolean include) {\n    includeGoogBase = include;\n    return this;\n  }\n",
        "begin_line": 82,
        "end_line": 85,
        "comment": "\n   * Sets whether we should create implicit provides and requires of the\n   * root namespace.\n   *\n   * When generating deps files, you do not want this behavior. Deps files\n   * need base.js to run anyway, so they don't need information about it.\n   *\n   * When generating abstract build graphs, you probably do want this behavior.\n   * It will create an implicit dependency of all files with provides/requires\n   * on base.js.\n   *\n   * @return this for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileParser.parseFile#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileParser.parseFile(java.lang.String, java.lang.String, java.lang.String)",
        "snippet": "  public DependencyInfo parseFile(String filePath, String closureRelativePath,\n      String fileContents) {\n    return parseReader(filePath, closureRelativePath,\n        new StringReader(fileContents));\n  }\n",
        "begin_line": 112,
        "end_line": 116,
        "comment": "\n   * Parses the given file and returns the dependency information that it\n   * contained.\n   *\n   * @param filePath Path to the file to parse.\n   * @param closureRelativePath Path of the file relative to closure.\n   * @param fileContents The contents to parse.\n   * @return A DependencyInfo containing all provides/requires found in the\n   *     file.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileParser.parseReader#118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileParser.parseReader(java.lang.String, java.lang.String, java.io.Reader)",
        "snippet": "  private DependencyInfo parseReader(String filePath,\n      String closureRelativePath, Reader fileContents) {\n    provides = Lists.newArrayList();\n    requires = Lists.newArrayList();\n    fileHasProvidesOrRequires = false;\n\n    logger.fine(\"Parsing Source: \" + filePath);\n    doParse(filePath, fileContents);\n\n    DependencyInfo dependencyInfo = new SimpleDependencyInfo(\n        closureRelativePath, filePath, provides, requires);\n    logger.fine(\"DepInfo: \" + dependencyInfo);\n    return dependencyInfo;\n  }\n",
        "begin_line": 118,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsFileLineParser.JsFileLineParser#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileLineParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileLineParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileLineParser.JsFileLineParser(com.google.javascript.jscomp.ErrorManager)",
        "snippet": "  public JsFileLineParser(ErrorManager errorManager) {\n    this.errorManager = errorManager;\n  }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n   * Constructor.\n   *\n   * @param errorManager Parse error handler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.StateStack#62",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.StateStack.StateStack()",
        "snippet": "    StateStack() {\n      states.add(new ScopeState());\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.peek#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.StateStack.peek()",
        "snippet": "    ScopeState peek() {\n      return states.get(currentDepth);\n    }\n",
        "begin_line": 66,
        "end_line": 68,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.push#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.StateStack.push()",
        "snippet": "    void push() {\n      currentDepth++;\n      if (states.size() <= currentDepth) {\n        states.add(new ScopeState());\n      } else {\n        states.get(currentDepth).reset();\n      }\n    }\n",
        "begin_line": 70,
        "end_line": 77,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.pop#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.StateStack.pop()",
        "snippet": "    void pop() {\n      currentDepth--;\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.ScopeState#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.ScopeState.ScopeState()",
        "snippet": "    ScopeState() {\n      reset();\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.reset#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.ScopeState.reset()",
        "snippet": "    void reset() {\n      changed = false;\n      traverseChildScopes = true;\n    }\n",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.PeepholeOptimizationsPass#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.PeepholeOptimizationsPass(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.AbstractPeepholeOptimization...)",
        "snippet": "  PeepholeOptimizationsPass(AbstractCompiler compiler,\n      AbstractPeepholeOptimization... optimizations) {\n    this.compiler = compiler;\n    this.peepholeOptimizations = optimizations;\n  }\n",
        "begin_line": 95,
        "end_line": 99,
        "comment": "\n   * Creates a peephole optimization pass that runs the given\n   * optimizations.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.process#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }\n",
        "begin_line": 110,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.traverse#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.traverse(com.google.javascript.rhino.Node)",
        "snippet": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }\n",
        "begin_line": 120,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.shouldRetraverse#147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.shouldRetraverse(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean shouldRetraverse(Node node) {\n    if (retraverseOnChange\n        && node.getParent() != null \n        && (node.isFunction() || node.isScript())) {\n      ScopeState state = traversalState.peek();\n      if (state.changed) {\n        // prepare to re-visit the scope:\n        // when revisiting, only visit the immediate scope\n        // this reduces the cost of getting to a fixed\n        // point in global scope.\n        state.changed = false;\n        state.traverseChildScopes = false;\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 147,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.shouldVisit#165",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.shouldVisit(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean shouldVisit(Node node) {\n    if (node.isFunction() || node.isScript()) {\n      ScopeState previous = traversalState.peek();\n      if (!previous.traverseChildScopes) {\n        return false;\n      }\n      traversalState.push();\n    }\n    return true;\n  }\n",
        "begin_line": 165,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.exitNode#176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.exitNode(com.google.javascript.rhino.Node)",
        "snippet": "  private void exitNode(Node node) {\n    if (node.isFunction() || node.isScript()) {\n      traversalState.pop();\n    }\n  }\n",
        "begin_line": 176,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.visit#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.visit(com.google.javascript.rhino.Node)",
        "snippet": "  public void visit(Node n) {\n    Node currentVersionOfNode = n;\n    boolean somethingChanged = false;\n\n    do {\n      somethingChanged = false;\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n        Node newVersionOfNode =\n            optimization.optimizeSubtree(currentVersionOfNode);\n\n        if (newVersionOfNode != currentVersionOfNode) {\n          somethingChanged = true;\n\n          currentVersionOfNode = newVersionOfNode;\n        }\n\n        if (currentVersionOfNode == null) {\n          return;\n        }\n      }\n    } while(somethingChanged);\n  }\n",
        "begin_line": 182,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.beginTraversal#209",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.beginTraversal()",
        "snippet": "  private void beginTraversal() {\n    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n      optimization.beginTraversal(compiler);\n    }\n  }\n",
        "begin_line": 209,
        "end_line": 213,
        "comment": "\n   * Make sure that all the optimizations have the current traversal so they\n   * can report errors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeOptimizationsPass.endTraversal#215",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.endTraversal()",
        "snippet": "  private void endTraversal() {\n    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n      optimization.endTraversal(compiler);\n    }\n  }\n",
        "begin_line": 215,
        "end_line": 219,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1454",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-da370451-f1d5-4edc-9f43-fa6b9ee12be0.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new ClosureOptimizePrimitives(compiler);\n    }\n",
        "begin_line": 1454,
        "end_line": 1457,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.checkErrorManager#150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.checkErrorManager()",
        "snippet": "  private void checkErrorManager() {\n    Preconditions.checkNotNull(compiler,\n        \"Expected setCompiler to be called first: \" + this);\n    Preconditions.checkNotNull(compiler.getErrorManager(),\n        \"Expected compiler to call an error manager: \" + this);\n  }\n",
        "begin_line": 150,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.getRequires#158",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getRequires()",
        "snippet": "  @Override\n  public Collection<String> getRequires() {\n    checkErrorManager();\n    try {\n      regenerateDependencyInfoIfNecessary();\n      return Collections.<String>unmodifiableSet(requires);\n    } catch (IOException e) {\n      compiler.getErrorManager().report(CheckLevel.ERROR,\n          JSError.make(AbstractCompiler.READ_ERROR, getName()));\n      return ImmutableList.<String>of();\n    }\n  }\n",
        "begin_line": 158,
        "end_line": 169,
        "comment": " Gets a list of types depended on by this input. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.getProvides#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getProvides()",
        "snippet": "  @Override\n  public Collection<String> getProvides() {\n    checkErrorManager();\n    try {\n      regenerateDependencyInfoIfNecessary();\n      return Collections.<String>unmodifiableSet(provides);\n    } catch (IOException e) {\n      compiler.getErrorManager().report(CheckLevel.ERROR,\n          JSError.make(AbstractCompiler.READ_ERROR, getName()));\n      return ImmutableList.<String>of();\n    }\n  }\n",
        "begin_line": 172,
        "end_line": 183,
        "comment": " Gets a list of types provided by this input. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.regenerateDependencyInfoIfNecessary#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.regenerateDependencyInfoIfNecessary()",
        "snippet": "  private void regenerateDependencyInfoIfNecessary() throws IOException {\n    // If the code is NOT a JsAst, then it was not originally JS code.\n    // Look at the Ast for dependency info.\n    if (!(ast instanceof JsAst)) {\n      Preconditions.checkNotNull(compiler,\n          \"Expected setCompiler to be called first\");\n      DepsFinder finder = new DepsFinder();\n      Node root = getAstRoot(compiler);\n      if (root == null) {\n        return;\n      }\n\n      finder.visitTree(getAstRoot(compiler));\n\n      // TODO(nicksantos|user): This caching behavior is a bit\n      // odd, and only works if you assume the exact call flow that\n      // clients are currently using.  In that flow, they call\n      // getProvides(), then remove the goog.provide calls from the\n      // AST, and then call getProvides() again.\n      //\n      // This won't work for any other call flow, or any sort of incremental\n      // compilation scheme. The API needs to be fixed so callers aren't\n      // doing weird things like this, and then we should get rid of the\n      // multiple-scan strategy.\n\n      provides.addAll(finder.provides);\n      requires.addAll(finder.requires);\n    } else {\n      // Otherwise, look at the source code.\n      if (!generatedDependencyInfoFromSource) {\n        // Note: it's OK to use getName() instead of\n        // getPathRelativeToClosureBase() here because we're not using\n        // this to generate deps files. (We're only using it for\n        // symbol dependencies.)\n        DependencyInfo info =\n            (new JsFileParser(compiler.getErrorManager()))\n            .setIncludeGoogBase(true)\n            .parseFile(getName(), getName(), getCode());\n\n        provides.addAll(info.getProvides());\n        requires.addAll(info.getRequires());\n\n        generatedDependencyInfoFromSource = true;\n      }\n    }\n  }\n",
        "begin_line": 205,
        "end_line": 250,
        "comment": "\n   * Regenerates the provides/requires if we need to do so.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.getCode#314",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getCode()",
        "snippet": "  public String getCode() throws IOException {\n    return getSourceFile().getCode();\n  }\n",
        "begin_line": 314,
        "end_line": 316,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.toString#359",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.toString()",
        "snippet": "  @Override\n  public String toString() {\n    return getName();\n  }\n",
        "begin_line": 359,
        "end_line": 362,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.removeChangeHandler#1972",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.removeChangeHandler(com.google.javascript.jscomp.CodeChangeHandler)",
        "snippet": "  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n",
        "begin_line": 1972,
        "end_line": 1975,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilationLevel.CompilationLevel#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilationLevel.java",
        "class_name": "com.google.javascript.jscomp.CompilationLevel",
        "signature": "com.google.javascript.jscomp.CompilationLevel.CompilationLevel()",
        "snippet": "  private CompilationLevel() {}\n",
        "begin_line": 51,
        "end_line": 51,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureOptimizePrimitives.visit#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
        "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.FindObjectCreateCalls.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall()) {\n        String fnName = n.getFirstChild().getQualifiedName();\n        if (\"goog$object$create\".equals(fnName) ||\n            \"goog.object.create\".equals(fnName)) {\n          callNodes.add(n);\n        }\n      }\n    }\n",
        "begin_line": 45,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureOptimizePrimitives.ClosureOptimizePrimitives#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
        "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.ClosureOptimizePrimitives(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  ClosureOptimizePrimitives(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n   * @param compiler The AbstractCompiler\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureOptimizePrimitives.process#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
        "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    FindObjectCreateCalls pass = new FindObjectCreateCalls();\n    NodeTraversal.traverse(compiler, root, pass);\n    processObjectCreateCalls(pass.callNodes);\n  }\n",
        "begin_line": 64,
        "end_line": 69,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureOptimizePrimitives.processObjectCreateCalls#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
        "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.processObjectCreateCalls(java.util.List<com.google.javascript.rhino.Node>)",
        "snippet": "  private void processObjectCreateCalls(List<Node> callNodes) {\n    for (Node callNode : callNodes) {\n      Node curParam = callNode.getFirstChild().getNext();\n      if (canOptimizeObjectCreate(curParam)) {\n        Node objNode = IR.objectlit().srcref(callNode);\n        while (curParam != null) {\n          Node keyNode = curParam;\n          Node valueNode = curParam.getNext();\n          curParam = valueNode.getNext();\n\n          callNode.removeChild(keyNode);\n          callNode.removeChild(valueNode);\n\n          if (!keyNode.isString()) {\n            keyNode = IR.string(NodeUtil.getStringValue(keyNode))\n                .srcref(keyNode);\n          }\n          keyNode.setType(Token.STRING_KEY);\n          keyNode.setQuotedString();\n          objNode.addChildToBack(IR.propdef(keyNode, valueNode));\n        }\n        callNode.getParent().replaceChild(callNode, objNode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n",
        "begin_line": 75,
        "end_line": 100,
        "comment": "\n   * Converts all of the given call nodes to object literals that are safe to\n   * do so.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractPeepholeOptimization.beginTraversal#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.beginTraversal(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  void beginTraversal(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n   * Informs the optimization that a traversal will begin.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "AbstractPeepholeOptimization.endTraversal#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.endTraversal(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  void endTraversal(AbstractCompiler compiler) {\n    this.compiler = null;\n  }\n",
        "begin_line": 98,
        "end_line": 100,
        "comment": "\n   * Informs the optimization that a traversal has completed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1245
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isTryFinallyNode#1788",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isTryFinallyNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.isTry() && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }\n",
        "begin_line": 1788,
        "end_line": 1791,
        "comment": " Whether the child node is the FINALLY block of a try. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1241
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.isTryCatchNodeContainer#1794",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isTryCatchNodeContainer(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isTryCatchNodeContainer(Node n) {\n    Node parent = n.getParent();\n    return parent.isTry()\n        && parent.getFirstChild().getNext() == n;\n  }\n",
        "begin_line": 1794,
        "end_line": 1798,
        "comment": " Whether the node is a CATCH container BLOCK. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1241
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.removeChild#1801",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.removeChild(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  static void removeChild(Node parent, Node node) {\n    if (isTryFinallyNode(parent, node)) {\n      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n        // A finally can only be removed if there is a catch.\n        parent.removeChild(node);\n      } else {\n        // Otherwise, only its children can be removed.\n        node.detachChildren();\n      }\n    } else if (node.isCatch()) {\n      // The CATCH can can only be removed if there is a finally clause.\n      Node tryNode = node.getParent().getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachFromParent();\n    } else if (isTryCatchNodeContainer(node)) {\n      // The container node itself can't be removed, but the contained CATCH\n      // can if there is a 'finally' clause\n      Node tryNode = node.getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachChildren();\n    } else if (node.isBlock()) {\n      // Simply empty the block.  This maintains source location and\n      // \"synthetic\"-ness.\n      node.detachChildren();\n    } else if (isStatementBlock(parent)\n        || isSwitchCase(node)) {\n      // A statement in a block can simply be removed.\n      parent.removeChild(node);\n    } else if (parent.isVar()) {\n      if (parent.hasMoreThanOneChild()) {\n        parent.removeChild(node);\n      } else {\n        // Remove the node from the parent, so it can be reused.\n        parent.removeChild(node);\n        // This would leave an empty VAR, remove the VAR itself.\n        removeChild(parent.getParent(), parent);\n      }\n    } else if (parent.isLabel()\n        && node == parent.getLastChild()) {\n      // Remove the node from the parent, so it can be reused.\n      parent.removeChild(node);\n      // A LABEL without children can not be referred to, remove it.\n      removeChild(parent.getParent(), parent);\n    } else if (parent.isFor()\n        && parent.getChildCount() == 4) {\n      // Only Token.FOR can have an Token.EMPTY other control structure\n      // need something for the condition. Others need to be replaced\n      // or the structure removed.\n      parent.replaceChild(node, IR.empty());\n    } else {\n      throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n          node.toString() + \" of \" + parent.toString());\n    }\n  }\n",
        "begin_line": 1801,
        "end_line": 1854,
        "comment": " Safely remove children while maintaining a valid node structure. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1241
        },
        "num_failing_tests": 3
    },
    {
        "name": "Node.isCase#2181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCase()",
        "snippet": "  public boolean isCase() {\n    return this.getType() == Token.CASE;\n  }\n",
        "begin_line": 2181,
        "end_line": 2183,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.collect#310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.collect(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    public void collect(NodeTraversal t, Node n, Node parent) {\n      if (nodeFilter != null && !nodeFilter.apply(n)) {\n        return;\n      }\n\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) return;\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null ||\n                    NodeUtil.isFunctionExpression(parent)) return;\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) return;\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      Scope scope = t.getScope();\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(t, n, parent, name);\n        }\n      } else {\n        handleGet(t, n, parent, name);\n      }\n    }\n",
        "begin_line": 310,
        "end_line": 438,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isIf#2257",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isIf()",
        "snippet": "  public boolean isIf() {\n    return this.getType() == Token.IF;\n  }\n",
        "begin_line": 2257,
        "end_line": 2259,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1236
        },
        "num_failing_tests": 4
    },
    {
        "name": "DependencyOptions.setDependencySorting#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.setDependencySorting(boolean)",
        "snippet": "  public DependencyOptions setDependencySorting(boolean enabled) {\n    this.sortDependencies = enabled;\n    return this;\n  }\n",
        "begin_line": 55,
        "end_line": 58,
        "comment": "\n   * Enables or disables dependency sorting mode.\n   *\n   * If true, we will sort the input files based on dependency information\n   * in them. Otherwise, we will use the order of files specified\n   * on the command-line.\n   * @return this for easy building.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1236
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.getValueType#516",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.getValueType(com.google.javascript.rhino.Node)",
        "snippet": "    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) return t;\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }\n",
        "begin_line": 516,
        "end_line": 538,
        "comment": "\n     * Gets the type of a value or simple expression.\n     *\n     * @param n An r-value in an assignment or variable declaration (not null)\n     * @return A {@link Name.Type}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1233
        },
        "num_failing_tests": 3
    },
    {
        "name": "IR.trueNode#458",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.trueNode()",
        "snippet": "  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n",
        "begin_line": 458,
        "end_line": 460,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReplaceCssNames.visit#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReplaceCssNames.java",
        "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
        "signature": "com.google.javascript.jscomp.ReplaceCssNames.Traversal.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall() &&\n          GET_CSS_NAME_FUNCTION.equals(n.getFirstChild().getQualifiedName())) {\n        int count = n.getChildCount();\n        Node first = n.getFirstChild().getNext();\n        switch (count) {\n          case 2:\n            // Replace the function call with the processed argument.\n            if (first.isString()) {\n              processStringNode(t, first);\n              n.removeChild(first);\n              parent.replaceChild(n, first);\n              compiler.reportCodeChange();\n            } else {\n              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(first.getType())));\n            }\n            break;\n\n          case 3:\n            // Replace function call with concatenation of two args.  It's\n            // assumed the first arg has already been processed.\n\n            Node second = first.getNext();\n\n            if (!second.isString()) {\n              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(second.getType())));\n            } else if (first.isString()) {\n              compiler.report(t.makeError(\n                  n, UNEXPECTED_STRING_LITERAL_ERROR,\n                  first.getString(), second.getString()));\n            } else {\n              processStringNode(t, second);\n              n.removeChild(first);\n              Node replacement = IR.add(first,\n                  IR.string(\"-\" + second.getString())\n                      .copyInformationFrom(second))\n                  .copyInformationFrom(n);\n              replacement.setJSType(nativeStringType);\n              parent.replaceChild(n, replacement);\n              compiler.reportCodeChange();\n            }\n            break;\n\n          default:\n            compiler.report(t.makeError(\n                n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count)));\n        }\n      }\n    }\n",
        "begin_line": 145,
        "end_line": 196,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReplaceCssNames.ReplaceCssNames#118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReplaceCssNames.java",
        "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
        "signature": "com.google.javascript.jscomp.ReplaceCssNames.ReplaceCssNames(com.google.javascript.jscomp.AbstractCompiler, java.util.Map<java.lang.String, java.lang.Integer>, java.util.Set<java.lang.String>)",
        "snippet": "  ReplaceCssNames(AbstractCompiler compiler,\n      @Nullable Map<String, Integer> cssNames,\n      @Nullable Set<String> whitelist) {\n    this.compiler = compiler;\n    this.cssNames = cssNames;\n    this.whitelist = whitelist;\n    this.nativeStringType =  compiler.getTypeRegistry()\n        .getNativeType(STRING_TYPE);\n  }\n",
        "begin_line": 118,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReplaceCssNames.process#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReplaceCssNames.java",
        "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
        "signature": "com.google.javascript.jscomp.ReplaceCssNames.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // The CssRenamingMap may not have been available from the compiler when\n    // this ReplaceCssNames pass was constructed, so getCssRenamingMap() should\n    // only be called before this pass is actually run.\n    symbolMap = getCssRenamingMap();\n\n    NodeTraversal.traverse(compiler, root, new Traversal());\n  }\n",
        "begin_line": 128,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReplaceCssNames.getCssRenamingMap#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReplaceCssNames.java",
        "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
        "signature": "com.google.javascript.jscomp.ReplaceCssNames.getCssRenamingMap()",
        "snippet": "  @VisibleForTesting\n  protected CssRenamingMap getCssRenamingMap() {\n    return compiler.getCssRenamingMap();\n  }\n",
        "begin_line": 138,
        "end_line": 141,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1444",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-10ae79da-ec03-44bd-aea2-13822490f95b.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new ClosureCodeRemoval(compiler, options.removeAbstractMethods,\n          options.removeClosureAsserts);\n    }\n",
        "begin_line": 1444,
        "end_line": 1448,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1015",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-05f27e7d-4e02-4f28-991d-e45a6390c0fc.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new CompilerPass() {\n        @Override\n        public void process(Node externs, Node jsRoot) {\n          Map<String, Integer> newCssNames = null;\n          if (options.gatherCssNames) {\n            newCssNames = Maps.newHashMap();\n          }\n          ReplaceCssNames pass = new ReplaceCssNames(\n              compiler,\n              newCssNames,\n              options.cssRenamingWhitelist);\n          pass.process(externs, jsRoot);\n          cssNames = newCssNames;\n        }\n      };\n    }\n",
        "begin_line": 1015,
        "end_line": 1032,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#1018",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-d334e043-0fd3-4e90-aeef-8418c82da6c0.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node jsRoot) {\n          Map<String, Integer> newCssNames = null;\n          if (options.gatherCssNames) {\n            newCssNames = Maps.newHashMap();\n          }\n          ReplaceCssNames pass = new ReplaceCssNames(\n              compiler,\n              newCssNames,\n              options.cssRenamingWhitelist);\n          pass.process(externs, jsRoot);\n          cssNames = newCssNames;\n        }\n",
        "begin_line": 1018,
        "end_line": 1030,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getAdditionalReplacements#2232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getAdditionalReplacements(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  @VisibleForTesting\n  static Map<String, Node> getAdditionalReplacements(\n      CompilerOptions options) {\n    Map<String, Node> additionalReplacements = Maps.newHashMap();\n\n    if (options.markAsCompiled || options.closurePass) {\n      additionalReplacements.put(COMPILED_CONSTANT_NAME, IR.trueNode());\n    }\n\n    if (options.closurePass && options.locale != null) {\n      additionalReplacements.put(CLOSURE_LOCALE_CONSTANT_NAME,\n          IR.string(options.locale));\n    }\n\n    return additionalReplacements;\n  }\n",
        "begin_line": 2232,
        "end_line": 2247,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getCssRenamingMap#1900",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getCssRenamingMap()",
        "snippet": "  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n",
        "begin_line": 1900,
        "end_line": 1903,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureCodeRemoval.visit#139",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodeRemoval.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval",
        "signature": "com.google.javascript.jscomp.ClosureCodeRemoval.FindAbstractMethods.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        Node valueNode = n.getLastChild();\n\n        if (nameNode.isQualifiedName() &&\n            valueNode.isQualifiedName() &&\n            ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) {\n          abstractMethodAssignmentNodes.add(new RemovableAssignment(\n              n.getFirstChild(), n, t));\n        }\n      }\n    }\n",
        "begin_line": 139,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureCodeRemoval.ClosureCodeRemoval#189",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodeRemoval.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval",
        "signature": "com.google.javascript.jscomp.ClosureCodeRemoval.ClosureCodeRemoval(com.google.javascript.jscomp.AbstractCompiler, boolean, boolean)",
        "snippet": "  ClosureCodeRemoval(AbstractCompiler compiler, boolean removeAbstractMethods,\n                     boolean removeAssertionCalls) {\n    this.compiler = compiler;\n    this.removeAbstractMethods = removeAbstractMethods;\n    this.removeAssertionCalls = removeAssertionCalls;\n  }\n",
        "begin_line": 189,
        "end_line": 194,
        "comment": "\n   * Creates a Closure code remover.\n   *\n   * @param compiler The AbstractCompiler\n   * @param removeAbstractMethods Remove declarations of abstract methods.\n   * @param removeAssertionCalls Remove calls to goog.assert functions.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureCodeRemoval.process#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodeRemoval.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval",
        "signature": "com.google.javascript.jscomp.ClosureCodeRemoval.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    List<Callback> passes = Lists.newArrayList();\n    if (removeAbstractMethods) {\n      passes.add(new FindAbstractMethods());\n    }\n    if (removeAssertionCalls) {\n      passes.add(new FindAssertionCalls());\n    }\n    CombinedCompilerPass.traverse(compiler, root, passes);\n\n    for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {\n      assignment.remove();\n    }\n\n    for (Node call : assertionCalls) {\n      // If the assertion is an expression, just strip the whole thing.\n      Node parent = call.getParent();\n      if (parent.isExprResult()) {\n        parent.getParent().removeChild(parent);\n      } else {\n        // Otherwise, replace the assertion with its first argument,\n        // which is the return value of the assertion.\n        Node firstArg = call.getFirstChild().getNext();\n        if (firstArg == null) {\n          parent.replaceChild(call, NodeUtil.newUndefinedNode(call));\n        } else {\n          parent.replaceChild(call, firstArg.detachFromParent());\n        }\n      }\n      compiler.reportCodeChange();\n    }\n  }\n",
        "begin_line": 196,
        "end_line": 228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1231
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeTraversal.shouldTraverse#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild();\n    }\n",
        "begin_line": 160,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1226
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.analyze#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
        "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }\n",
        "begin_line": 201,
        "end_line": 229,
        "comment": "\n   * Finds a fixed-point solution. The function has the side effect of replacing\n   * the existing node annotations with the computed solutions using {@link\n   * com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.\n   *\n   * <p>Initially, each node's input and output flow state contains the value\n   * given by {@link #createInitialEstimateLattice()} (with the exception of the\n   * entry node of the graph which takes on the {@link #createEntryLattice()}\n   * value. Each node will use the output state of its predecessor and compute a\n   * output state according to the instruction. At that time, any nodes that\n   * depends on the node's newly modified output value will need to recompute\n   * their output state again. Each step will perform a computation at one node\n   * until no extra computation will modify any existing output state anymore.\n   *\n   * @param maxSteps Max number of iterations before the method stops and throw\n   *        a {@link MaxIterationsExceededException}. This will prevent the\n   *        analysis from going into a infinite loop.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1226
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.compare#1031",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.Anonymous-7d0d649b-4fc9-4a00-a62b-71572ab7d094.compare(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n",
        "begin_line": 1031,
        "end_line": 1035,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1226
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.isInliningForbidden#2209",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.isInliningForbidden()",
        "snippet": "  private boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n",
        "begin_line": 2209,
        "end_line": 2213,
        "comment": "\n   * All inlining is forbidden in heuristic renaming mode, because inlining\n   * will ruin the invariants that it depends on.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.Node#358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node)",
        "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 358,
        "end_line": 370,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1221
        },
        "num_failing_tests": 6
    },
    {
        "name": "Node.isFor#2233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFor()",
        "snippet": "  public boolean isFor() {\n    return this.getType() == Token.FOR;\n  }\n",
        "begin_line": 2233,
        "end_line": 2235,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.122
        },
        "num_failing_tests": 5
    },
    {
        "name": "FixedPointGraphTraversal.FixedPointGraphTraversal#53",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java",
        "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
        "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.FixedPointGraphTraversal(com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback<N, E>)",
        "snippet": "  public FixedPointGraphTraversal(EdgeCallback<N, E> callback) {\n    this.callback = callback;\n  }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n   * Create a new traversal.\n   * @param callback A callback for updating the state of the graph each\n   *     time an edge is traversed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1217
        },
        "num_failing_tests": 4
    },
    {
        "name": "FixedPointGraphTraversal.newTraversal#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/FixedPointGraphTraversal.java",
        "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
        "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.newTraversal(com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback<NODE, EDGE>)",
        "snippet": "  public static <NODE, EDGE> FixedPointGraphTraversal<NODE, EDGE> newTraversal(\n      EdgeCallback<NODE, EDGE> callback) {\n    return new FixedPointGraphTraversal<NODE, EDGE>(callback);\n  }\n",
        "begin_line": 60,
        "end_line": 63,
        "comment": "\n   * Helper method for creating new traversals.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1217
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.isExtern#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isExtern()",
        "snippet": "    boolean isExtern() {\n      return input == null || input.isExtern();\n    }\n",
        "begin_line": 205,
        "end_line": 207,
        "comment": "\n     * Returns whether this is defined in an extern file.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1217
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getOutEdges#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getOutEdges(N)",
        "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n  }\n",
        "begin_line": 127,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getDirectedPredNodes#227",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedPredNodes(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedPredNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getInEdges()) {\n      nodeList.add(edge.getSource());\n    }\n    return nodeList;\n  }\n",
        "begin_line": 227,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getNodes#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNodes()",
        "snippet": "  @Override\n  public Collection<GraphNode<N, E>> getNodes() {\n    return Collections.<GraphNode<N, E>>unmodifiableCollection(nodes.values());\n  }\n",
        "begin_line": 284,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeTraversal.pushScope#573",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n",
        "begin_line": 573,
        "end_line": 580,
        "comment": " Creates a new scope (e.g. when entering a function). ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.DataFlowAnalysis#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(com.google.javascript.jscomp.ControlFlowGraph<N>, com.google.javascript.jscomp.JoinOp<L>)",
        "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 130,
        "comment": "\n   * Constructs a data flow analysis.\n   *\n   * <p>Typical usage\n   * <pre>\n   * DataFlowAnalysis dfa = ...\n   * dfa.analyze();\n   * </pre>\n   *\n   * {@link #analyze()} annotates the result to the control flow graph by\n   * means of {@link DiGraphNode#setAnnotation} without any\n   * modification of the graph itself. Additional calls to {@link #analyze()}\n   * recomputes the analysis which can be useful if the control flow graph\n   * has been modified.\n   *\n   * @param targetCfg The control flow graph object that this object performs\n   *     on. Modification of the graph requires a separate call to\n   *     {@link #analyze()}.\n   *\n   * @see #analyze()\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.getCfg#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
        "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n   * Returns the control flow graph that this analysis was performed on.\n   * Modifications can be done on this graph, however, the only time that the\n   * annotations are correct is after {@link #analyze()} is called and before\n   * the graph has been modified.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "DataFlowAnalysis.analyze#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
        "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }\n",
        "begin_line": 179,
        "end_line": 181,
        "comment": "\n   * Finds a fixed-point solution using at most {@link #MAX_STEPS}\n   * iterations.\n   *\n   * @see #analyze(int)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.getPosition#1052",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.getPosition(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n",
        "begin_line": 1052,
        "end_line": 1056,
        "comment": "\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.handleStmtList#484",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n",
        "begin_line": 484,
        "end_line": 523,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 4
    },
    {
        "name": "CommandLineRunner.CommandLineRunner#580",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.CommandLineRunner(java.lang.String[])",
        "snippet": "  protected CommandLineRunner(String[] args) {\n    super();\n    initConfigFromFlags(args, System.err);\n  }\n",
        "begin_line": 580,
        "end_line": 583,
        "comment": "\n   * Create a new command-line runner. You should only need to call\n   * the constructor if you're extending this class. Otherwise, the main\n   * method should instantiate it.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1209
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.AbstractCommandLineRunner#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.AbstractCommandLineRunner()",
        "snippet": "  AbstractCommandLineRunner() {\n    this(System.out, System.err);\n  }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1209
        },
        "num_failing_tests": 3
    },
    {
        "name": "LinkedDirectedGraph.getSource#478",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getSource()",
        "snippet": "    @Override\n    public DiGraphNode<N, E> getSource() {\n      return sourceNode;\n    }\n",
        "begin_line": 478,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.ProvidedName#788",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.ProvidedName(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.JSModule, boolean)",
        "snippet": "    ProvidedName(String namespace, Node node, JSModule module,\n        boolean explicit) {\n      Preconditions.checkArgument(\n          node == null /* The base case */ ||\n          node.isExprResult());\n      this.namespace = namespace;\n      this.firstNode = node;\n      this.firstModule = module;\n\n      addProvide(node, module, explicit);\n    }\n",
        "begin_line": 788,
        "end_line": 798,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.addProvide#803",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.addProvide(com.google.javascript.rhino.Node, com.google.javascript.jscomp.JSModule, boolean)",
        "snippet": "    void addProvide(Node node, JSModule module, boolean explicit) {\n      if (explicit) {\n        Preconditions.checkState(explicitNode == null);\n        Preconditions.checkArgument(node.isExprResult());\n        explicitNode = node;\n        explicitModule = module;\n      }\n      updateMinimumModule(module);\n    }\n",
        "begin_line": 803,
        "end_line": 811,
        "comment": "\n     * Add an implicit or explicit provide.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.updateMinimumModule#834",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.updateMinimumModule(com.google.javascript.jscomp.JSModule)",
        "snippet": "    private void updateMinimumModule(JSModule newModule) {\n      if (minimumModule == null) {\n        minimumModule = newModule;\n      } else if (moduleGraph != null) {\n        minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n            minimumModule, newModule);\n      } else {\n        // If there is no module graph, then there must be exactly one\n        // module in the program.\n        Preconditions.checkState(newModule == minimumModule,\n                                 \"Missing module graph\");\n      }\n    }\n",
        "begin_line": 834,
        "end_line": 846,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.replace#855",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.replace()",
        "snippet": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (candidateDefinition.isExprResult() &&\n            !candidateDefinition.getFirstChild().isQualifiedName()) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.isName()) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = IR.var(nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n",
        "begin_line": 855,
        "end_line": 918,
        "comment": "\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.ProcessClosurePrimitives#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProcessClosurePrimitives(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.PreprocessorSymbolTable, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  ProcessClosurePrimitives(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      CheckLevel requiresLevel) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }\n",
        "begin_line": 123,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.getExportedVariableNames#136",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.getExportedVariableNames()",
        "snippet": "  Set<String> getExportedVariableNames() {\n    return exportedVariables;\n  }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessClosurePrimitives.process#140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }\n",
        "begin_line": 140,
        "end_line": 163,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModuleGraph.JSModuleGraph#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModuleGraph.java",
        "class_name": "com.google.javascript.jscomp.JSModuleGraph",
        "signature": "com.google.javascript.jscomp.JSModuleGraph.JSModuleGraph(java.util.List<com.google.javascript.jscomp.JSModule>)",
        "snippet": "  public JSModuleGraph(List<JSModule> modulesInDepOrder) {\n    Preconditions.checkState(\n        modulesInDepOrder.size() == Sets.newHashSet(modulesInDepOrder).size(),\n        \"Found duplicate modules\");\n    modules = ImmutableList.copyOf(modulesInDepOrder);\n    modulesByDepth = Lists.newArrayList();\n\n    for (JSModule module : modulesInDepOrder) {\n      int depth = 0;\n      for (JSModule dep : module.getDependencies()) {\n        int depDepth = dep.getDepth();\n        if (depDepth < 0) {\n          throw new ModuleDependenceException(String.format(\n              \"Modules not in dependency order: %s preceded %s\",\n              module.getName(), dep.getName()),\n              module, dep);\n        }\n        depth = Math.max(depth, depDepth + 1);\n      }\n\n      module.setDepth(depth);\n      if (depth == modulesByDepth.size()) {\n        modulesByDepth.add(new ArrayList<JSModule>());\n      }\n      modulesByDepth.get(depth).add(module);\n    }\n  }\n",
        "begin_line": 89,
        "end_line": 115,
        "comment": "\n   * Creates a module graph from a list of modules in dependency order.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModule.getDependencies#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.getDependencies()",
        "snippet": "  public List<JSModule> getDependencies() {\n    return deps;\n  }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": "\n   * Gets the list of modules that this module depends on.\n   *\n   * @return A list that may be empty but not null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSModule.setDepth#294",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSModule.java",
        "class_name": "com.google.javascript.jscomp.JSModule",
        "signature": "com.google.javascript.jscomp.JSModule.setDepth(int)",
        "snippet": "  public void setDepth(int dep) {\n    this.depth = dep;\n  }\n",
        "begin_line": 294,
        "end_line": 296,
        "comment": "\n   * @param dep the depth to set\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#911",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-470d31bd-8a34-46cb-b759-ee79a765e08f.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      maybeInitializePreprocessorSymbolTable(compiler);\n      final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n          compiler,\n          preprocessorSymbolTable,\n          options.brokenClosureRequiresLevel);\n\n      return new HotSwapCompilerPass() {\n        @Override\n        public void process(Node externs, Node root) {\n          pass.process(externs, root);\n          exportedNames = pass.getExportedVariableNames();\n        }\n        @Override\n        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n          pass.hotSwapScript(scriptRoot, originalRoot);\n        }\n      };\n    }\n",
        "begin_line": 911,
        "end_line": 930,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#920",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-a8627e0e-af43-43b8-b0e5-4baa667ae2c9.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node root) {\n          pass.process(externs, root);\n          exportedNames = pass.getExportedVariableNames();\n        }\n",
        "begin_line": 920,
        "end_line": 924,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1208
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.getAliasDefinitionsInOrder#221",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.getAliasDefinitionsInOrder()",
        "snippet": "    Collection<Node> getAliasDefinitionsInOrder() {\n      return aliasDefinitionsInOrder;\n    }\n",
        "begin_line": 221,
        "end_line": 223,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.getAliasUsages#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.getAliasUsages()",
        "snippet": "    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }\n",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.getScopeCalls#229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.getScopeCalls()",
        "snippet": "    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }\n",
        "begin_line": 229,
        "end_line": 231,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.hasErrors#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.hasErrors()",
        "snippet": "    boolean hasErrors() {\n      return hasErrors;\n    }\n",
        "begin_line": 233,
        "end_line": 235,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.isCallToScopeMethod#237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.isCallToScopeMethod(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isCallToScopeMethod(Node n) {\n      return n.isCall() &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }\n",
        "begin_line": 237,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.enterScope#242",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n",
        "begin_line": 242,
        "end_line": 250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.exitScope#252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }\n",
        "begin_line": 252,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.visit#395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.Traversal.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n",
        "begin_line": 395,
        "end_line": 461,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.ScopedAliases#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.ScopedAliases(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.PreprocessorSymbolTable, com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler)",
        "snippet": "  ScopedAliases(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.transformationHandler = transformationHandler;\n  }\n",
        "begin_line": 93,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.process#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n",
        "begin_line": 101,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ScopedAliases.hotSwapScript#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ScopedAliases.java",
        "class_name": "com.google.javascript.jscomp.ScopedAliases",
        "signature": "com.google.javascript.jscomp.ScopedAliases.hotSwapScript(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n",
        "begin_line": 106,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#989",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-25e43476-8e61-4de7-ab41-f7bd8587bab9.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new ClosureRewriteClass(compiler);\n    }\n",
        "begin_line": 989,
        "end_line": 992,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#976",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-651cac8d-564a-44c7-bda3-c4e997a62fef.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      maybeInitializePreprocessorSymbolTable(compiler);\n      return new ScopedAliases(\n          compiler,\n          preprocessorSymbolTable,\n          options.getAliasTransformationHandler());\n    }\n",
        "begin_line": 976,
        "end_line": 983,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.maybeInitializePreprocessorSymbolTable#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.maybeInitializePreprocessorSymbolTable(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  void maybeInitializePreprocessorSymbolTable(AbstractCompiler compiler) {\n    if (options.ideMode) {\n      Node root = compiler.getRoot();\n      if (preprocessorSymbolTable == null ||\n          preprocessorSymbolTable.getRootNode() != root) {\n        preprocessorSymbolTable = new PreprocessorSymbolTable(root);\n      }\n    }\n  }\n",
        "begin_line": 172,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.compare#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.Anonymous-d56d13ee-e603-415e-8388-8f49eb46eb99.compare(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n",
        "begin_line": 72,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.prioritizeFromEntryNode#196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n",
        "begin_line": 196,
        "end_line": 215,
        "comment": "\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.getAliasTransformationHandler#1500",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getAliasTransformationHandler()",
        "snippet": "  public AliasTransformationHandler getAliasTransformationHandler() {\n    return this.aliasHandler;\n  }\n",
        "begin_line": 1500,
        "end_line": 1502,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureRewriteClass.ClosureRewriteClass#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.ClosureRewriteClass(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public ClosureRewriteClass(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureRewriteClass.process#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 68,
        "end_line": 71,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureRewriteClass.visit#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isCall() && isGoogDefineClass(n)) {\n      if (!validateUsage(n)) {\n        compiler.report(JSError.make(n, GOOG_CLASS_TARGET_INVALID));\n      }\n    }\n    maybeRewriteClassDefinition(n);\n  }\n",
        "begin_line": 79,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureRewriteClass.maybeRewriteClassDefinition#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.maybeRewriteClassDefinition(com.google.javascript.rhino.Node)",
        "snippet": "  private void maybeRewriteClassDefinition(Node n) {\n    if (n.isVar()) {\n      Node target = n.getFirstChild();\n      Node value = target.getFirstChild();\n      maybeRewriteClassDefinition(n, target, value);\n    } else if (NodeUtil.isExprAssign(n)) {\n      Node assign = n.getFirstChild();\n      Node target = assign.getFirstChild();\n      Node value = assign.getLastChild();\n      maybeRewriteClassDefinition(n, target, value);\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.12
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateExprStmt#473",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateExprStmt(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateExprStmt(Node n) {\n    validateNodeType(Token.EXPR_RESULT, n);\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }\n",
        "begin_line": 473,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1184
        },
        "num_failing_tests": 6
    },
    {
        "name": "LinkedDirectedGraph.getAnnotation#441",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.getAnnotation()",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }\n",
        "begin_line": 441,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1183
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.setAnnotation#447",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.setAnnotation(com.google.javascript.jscomp.graph.Annotation)",
        "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }\n",
        "begin_line": 447,
        "end_line": 450,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1183
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.computeFollowNode#674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowAnalysis)",
        "snippet": "  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n",
        "begin_line": 674,
        "end_line": 676,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1183
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode#437",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.AnnotatedLinkedDirectedGraphNode.AnnotatedLinkedDirectedGraphNode(N)",
        "snippet": "    AnnotatedLinkedDirectedGraphNode(N nodeValue) {\n      super(nodeValue);\n    }\n",
        "begin_line": 437,
        "end_line": 439,
        "comment": "\n     * @param nodeValue Node's value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getDirectedSuccNodes#240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }\n",
        "begin_line": 240,
        "end_line": 251,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "Graph.connectIfNotFound#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N, E, N)",
        "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    if (!isConnected(n1, edge, n2)) {\n      connect(n1, edge, n2);\n    }\n  }\n",
        "begin_line": 119,
        "end_line": 123,
        "comment": "\n   * Connects two nodes in the graph with an edge if such edge does not already\n   * exists between the nodes.\n   *\n   * @param n1 First node.\n   * @param edge The edge.\n   * @param n2 Second node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiGraph.isConnected#97",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/DiGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.DiGraph",
        "signature": "com.google.javascript.jscomp.graph.DiGraph.isConnected(N, E, N)",
        "snippet": "  @Override\n  public boolean isConnected(N n1, E e, N n2) {\n    return isConnectedInDirection(n1, e, n2) ||\n        isConnectedInDirection(n2, e, n1);\n  }\n",
        "begin_line": 97,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowGraph.ControlFlowGraph#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N, boolean, boolean)",
        "snippet": "  ControlFlowGraph(\n      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n    super(nodeAnnotations, edgeAnnotations);\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }\n",
        "begin_line": 47,
        "end_line": 52,
        "comment": "\n   * Constructor.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowGraph.getImplicitReturn#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
        "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n   * Gets the implicit return node.\n   *\n   * @return Return node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowGraph.getEntry#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowGraph.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
        "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
        "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }\n",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n   * Gets the entry point of the control flow graph. In general, this should be\n   * the beginning of the global script or beginning of a function.\n   *\n   * @return The entry point.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.AstControlFlowGraph#1013",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.AstControlFlowGraph.AstControlFlowGraph(com.google.javascript.rhino.Node, java.util.Map<com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch>, java.lang.Integer>, boolean)",
        "snippet": "    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n",
        "begin_line": 1013,
        "end_line": 1019,
        "comment": "\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.ControlFlowAnalysis#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(com.google.javascript.jscomp.AbstractCompiler, boolean, boolean)",
        "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n",
        "begin_line": 137,
        "end_line": 142,
        "comment": "\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.getCfg#144",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
        "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n",
        "begin_line": 144,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.process#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n",
        "begin_line": 148,
        "end_line": 190,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.computeFallThrough#796",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(com.google.javascript.rhino.Node)",
        "snippet": "  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n",
        "begin_line": 796,
        "end_line": 810,
        "comment": "\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.createEdge#818",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(com.google.javascript.rhino.Node, com.google.javascript.jscomp.ControlFlowGraph.Branch, com.google.javascript.rhino.Node)",
        "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n",
        "begin_line": 818,
        "end_line": 823,
        "comment": "\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 4
    },
    {
        "name": "UnknownType.getImplicitPrototype#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.getImplicitPrototype()",
        "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }\n",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getGlobalScope#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getGlobalScope()",
        "snippet": "  Scope getGlobalScope() {\n    Scope result = this;\n    while (result.getParent() != null) {\n      result = result.getParent();\n    }\n    return result;\n  }\n",
        "begin_line": 440,
        "end_line": 446,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryMinimizeNot#600",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryMinimizeNot(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryMinimizeNot(Node n) {\n    Node parent = n.getParent();\n\n    Node notChild = n.getFirstChild();\n    // negative operator of the current one : == -> != for instance.\n    int complementOperator;\n    switch (notChild.getType()) {\n      case Token.EQ:\n        complementOperator = Token.NE;\n        break;\n      case Token.NE:\n        complementOperator = Token.EQ;\n        break;\n      case Token.SHEQ:\n        complementOperator = Token.SHNE;\n        break;\n      case Token.SHNE:\n        complementOperator = Token.SHEQ;\n        break;\n      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n      default:\n        return n;\n    }\n    Node newOperator = n.removeFirstChild();\n    newOperator.setType(complementOperator);\n    parent.replaceChild(n, newOperator);\n    reportCodeChange();\n    return newOperator;\n  }\n",
        "begin_line": 600,
        "end_line": 628,
        "comment": "\n   * Try to minimize NOT nodes such as !(x==y).\n   *\n   * Returns the replacement for n or the original if no change was made\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeFoldConstants.tryFoldAndOr#566",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldAndOr(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldAndOr(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n\n    Node result = null;\n\n    int type = n.getType();\n\n    TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left);\n\n    if (leftVal != TernaryValue.UNKNOWN) {\n      boolean lval = leftVal.toBoolean(true);\n\n      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n      // (FALSE && x) => FALSE\n      if (lval && type == Token.OR ||\n          !lval && type == Token.AND) {\n        result = left;\n\n      } else if (!mayHaveSideEffects(left)) {\n        // (FALSE || x) => x\n        // (TRUE && x) => x\n        result = right;\n      }\n    }\n\n    // Note: Right hand side folding is handled by\n    // PeepholeSubstituteAlternateSyntax#tryMinimizeCondition\n\n    if (result != null) {\n      // Fold it!\n      n.removeChild(result);\n      parent.replaceChild(n, result);\n      reportCodeChange();\n\n      return result;\n    } else {\n      return n;\n    }\n  }\n",
        "begin_line": 566,
        "end_line": 604,
        "comment": "\n   * Try to fold a AND/OR node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.checkNameVisibility#338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.checkNameVisibility(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        // If a name is private, make sure that we're in the same file.\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE) {\n          StaticSourceFile varSrc = var.getSourceFile();\n          StaticSourceFile refSrc = name.getStaticSourceFile();\n          if (varSrc != null &&\n              refSrc != null &&\n              !varSrc.getName().equals(refSrc.getName())) {\n            if (docInfo.isConstructor() &&\n                isValidPrivateConstructorAccess(parent)) {\n              return;\n            }\n\n            compiler.report(\n                t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                    name.getString(), varSrc.getName()));\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 338,
        "end_line": 363,
        "comment": "\n   * Determines whether the given name is visible in the current context.\n   * @param t The current traversal.\n   * @param name The name node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1179
        },
        "num_failing_tests": 1
    },
    {
        "name": "PhaseOptimizer.optimizePasses#387",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.Loop.optimizePasses()",
        "snippet": "    private void optimizePasses() {\n      // It's important that this ordering is deterministic, so that\n      // multiple compiles with the same input produce exactly the same\n      // results.\n      //\n      // To do this, grab any passes we recognize, and move them to the end\n      // in an \"optimal\" order.\n      List<NamedPass> optimalPasses = Lists.newArrayList();\n      for (String passName : OPTIMAL_ORDER) {\n        for (NamedPass pass : myPasses) {\n          if (pass.name.equals(passName)) {\n            optimalPasses.add(pass);\n            break;\n          }\n        }\n      }\n\n      myPasses.removeAll(optimalPasses);\n      myPasses.addAll(optimalPasses);\n    }\n",
        "begin_line": 387,
        "end_line": 406,
        "comment": " Re-arrange the passes in an optimal order. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.117
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.isConnectedInDirection#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N, E, N)",
        "snippet": "  @Override\n  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n  }\n",
        "begin_line": 198,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1166
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.isConnectedInDirection#203",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N, com.google.common.base.Predicate<E>, N)",
        "snippet": "  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n    // Verify the nodes.\n    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2 &&\n          edgeMatcher.apply(outEdge.getValue())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 203,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1166
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isCall#2177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isCall()",
        "snippet": "  public boolean isCall() {\n    return this.getType() == Token.CALL;\n  }\n",
        "begin_line": 2177,
        "end_line": 2179,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1162
        },
        "num_failing_tests": 6
    },
    {
        "name": "CompilerInput.isExtern#336",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.isExtern()",
        "snippet": "  public boolean isExtern() {\n    if (ast == null || ast.getSourceFile() == null) {\n      return false;\n    }\n    return ast.getSourceFile().isExtern();\n  }\n",
        "begin_line": 336,
        "end_line": 341,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1159
        },
        "num_failing_tests": 4
    },
    {
        "name": "GoogleCodingConvention.isConstant#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(java.lang.String)",
        "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    return isConstantKey(name);\n  }\n",
        "begin_line": 70,
        "end_line": 87,
        "comment": "\n   * {@inheritDoc}\n   *\n   * <p>This enforces the Google const name convention, that the first character\n   * after the last $ must be an upper-case letter and all subsequent letters\n   * must be upper case. The name must be at least 2 characters long.\n   *\n   * <p>Examples:\n   * <pre>\n   *      aaa          Not constant - lower-case letters in the name\n   *      A            Not constant - too short\n   *      goog$A       Constant - letters after the $ are upper-case.\n   *      AA17         Constant - digits can appear after the first letter\n   *      goog$7A      Not constant - first character after the $ must be\n   *                   upper case.\n   *      $A           Constant - doesn't have to be anything in front of the $\n   * </pre>\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.CodingConventions.Proxy": null
        },
        "susp": {
            "ochiai_susp": 0.1158
        },
        "num_failing_tests": 5
    },
    {
        "name": "GoogleCodingConvention.isConstantKey#89",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstantKey(java.lang.String)",
        "snippet": "  @Override\n  public boolean isConstantKey(String name) {\n    if (name.isEmpty() || !Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }\n",
        "begin_line": 89,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1158
        },
        "num_failing_tests": 5
    },
    {
        "name": "LinkedDirectedGraph.getValue#498",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getValue()",
        "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }\n",
        "begin_line": 498,
        "end_line": 501,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1155
        },
        "num_failing_tests": 4
    },
    {
        "name": "SourceFile.isExtern#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SourceFile.java",
        "class_name": "com.google.javascript.jscomp.SourceFile",
        "signature": "com.google.javascript.jscomp.SourceFile.isExtern()",
        "snippet": "  @Override\n  public boolean isExtern() {\n    return isExternFile;\n  }\n",
        "begin_line": 179,
        "end_line": 182,
        "comment": " Returns whether this is an extern. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1155
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getErrorManager#2244",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrorManager()",
        "snippet": "  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n",
        "begin_line": 2244,
        "end_line": 2250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1155
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getInEdges#387",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getInEdges()",
        "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }\n",
        "begin_line": 387,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraphEdge#471",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.LinkedDirectedGraphEdge(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>, E, com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, E>)",
        "snippet": "    LinkedDirectedGraphEdge(DiGraphNode<N, E> sourceNode,\n        E edgeValue, DiGraphNode<N, E> destNode) {\n      this.value = edgeValue;\n      this.sourceNode = sourceNode;\n      this.destNode = destNode;\n    }\n",
        "begin_line": 471,
        "end_line": 476,
        "comment": "\n     * Constructor.\n     *\n     * @param edgeValue Edge Value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getDestination#483",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphEdge.getDestination()",
        "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }\n",
        "begin_line": 483,
        "end_line": 486,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.connect#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N, E, N)",
        "snippet": "  @Override\n  public void connect(N srcValue, E edgeValue, N destValue) {\n    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n    LinkedDirectedGraphEdge<N, E> edge =\n        useEdgeAnnotations ?\n        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n  }\n",
        "begin_line": 77,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getNode#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
        "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1151
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.call#1729",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Anonymous-e56e57cf-e392-4415-8d8d-47bd53a4bbb6.call()",
        "snippet": "      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n",
        "begin_line": 1729,
        "end_line": 1785,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.115
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputSourceMap#1173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputSourceMap(B, java.lang.String)",
        "snippet": "  private void outputSourceMap(B options, String associatedName)\n      throws IOException {\n    if (Strings.isNullOrEmpty(options.sourceMapOutputPath)) {\n      return;\n    }\n\n    String outName = expandSourceMapPath(options, null);\n    Writer out = fileNameToOutputWriter2(outName);\n    compiler.getSourceMap().appendTo(out, associatedName);\n    out.close();\n  }\n",
        "begin_line": 1173,
        "end_line": 1183,
        "comment": "\n   * Outputs the source map found in the compiler to the proper path if one\n   * exists.\n   *\n   * @param options The options to the Compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.115
        },
        "num_failing_tests": 3
    },
    {
        "name": "Graph.getNodeOrFail#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.getNodeOrFail(N)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n    T node = (T) getNode(val);\n    if (node == null) {\n      throw new IllegalArgumentException(val + \" does not exist in graph\");\n    }\n    return node;\n  }\n",
        "begin_line": 218,
        "end_line": 225,
        "comment": "\n   * Gets the node of the specified type, or throws an\n   * IllegalArgumentException.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.addChildBefore#632",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.addChildBefore(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public void addChildBefore(Node newChild, Node node) {\n    Preconditions.checkArgument(node != null && node.parent == this,\n        \"The existing child node of the parent should not be null.\");\n    Preconditions.checkArgument(newChild.next == null,\n        \"The new child node has siblings.\");\n    Preconditions.checkArgument(newChild.parent == null,\n        \"The new child node already has a parent.\");\n    if (first == node) {\n      newChild.parent = this;\n      newChild.next = first;\n      first = newChild;\n      return;\n    }\n    Node prev = getChildBefore(node);\n    addChildAfter(newChild, prev);\n  }\n",
        "begin_line": 632,
        "end_line": 647,
        "comment": "\n   * Add 'child' before 'node'.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1147
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractCommandLineRunner.processResults#820",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.processResults(com.google.javascript.jscomp.Result, java.util.List<com.google.javascript.jscomp.JSModule>, B)",
        "snippet": "  int processResults(Result result, List<JSModule> modules, B options)\n       throws FlagUsageException, IOException {\n    if (config.computePhaseOrdering) {\n      return 0;\n    }\n\n    if (config.printPassGraph) {\n      if (compiler.getRoot() == null) {\n        return 1;\n      } else {\n        jsOutput.append(\n            DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n        jsOutput.append('\\n');\n        return 0;\n      }\n    }\n\n    if (config.printAst) {\n      if (compiler.getRoot() == null) {\n        return 1;\n      } else {\n        ControlFlowGraph<Node> cfg = compiler.computeCFG();\n        DotFormatter.appendDot(\n            compiler.getRoot().getLastChild(), cfg, jsOutput);\n        jsOutput.append('\\n');\n        return 0;\n      }\n    }\n\n    if (config.printTree) {\n      if (compiler.getRoot() == null) {\n        jsOutput.append(\"Code contains errors; no tree was generated.\\n\");\n        return 1;\n      } else {\n        compiler.getRoot().appendStringTree(jsOutput);\n        jsOutput.append(\"\\n\");\n        return 0;\n      }\n    }\n\n    rootRelativePathsMap = constructRootRelativePathsMap();\n\n    if (config.skipNormalOutputs) {\n      // Output the manifest and bundle files if requested.\n      outputManifest();\n      outputBundle();\n      outputModuleGraphJson();\n      return 0;\n    } else if (result.success) {\n      outputModuleGraphJson();\n      if (modules == null) {\n        outputSingleBinary();\n\n        // Output the source map if requested.\n        outputSourceMap(options, config.jsOutputFile);\n      } else {\n        outputModuleBinaryAndSourceMaps(modules, options);\n      }\n\n      // Output the externs if required.\n      if (options.externExportsPath != null) {\n        Writer eeOut =\n            openExternExportsStream(options, config.jsOutputFile);\n        eeOut.append(result.externExport);\n        eeOut.close();\n      }\n\n      // Output the variable and property name maps if requested.\n      outputNameMaps(options);\n\n      // Output the manifest and bundle files if requested.\n      outputManifest();\n      outputBundle();\n    }\n\n    // return 0 if no errors, the error count otherwise\n    return Math.min(result.errors.length, 0x7f);\n  }\n",
        "begin_line": 820,
        "end_line": 897,
        "comment": "\n   * Processes the results of the compile job, and returns an error code.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1144
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputSingleBinary#904",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputSingleBinary()",
        "snippet": "  void outputSingleBinary() throws IOException {\n    Function<String, String> escaper = null;\n    String marker = OUTPUT_MARKER;\n    if (config.outputWrapper.contains(OUTPUT_MARKER_JS_STRING)) {\n      marker = OUTPUT_MARKER_JS_STRING;\n      escaper = getJavascriptEscaper();\n    }\n\n    writeOutput(\n        jsOutput, compiler, compiler.toSource(), config.outputWrapper,\n        marker, escaper);\n  }\n",
        "begin_line": 904,
        "end_line": 915,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1144
        },
        "num_failing_tests": 3
    },
    {
        "name": "ProcessDefines.updateAssignAllowedStack#380",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.CollectDefines.updateAssignAllowedStack(com.google.javascript.rhino.Node, boolean)",
        "snippet": "    private void updateAssignAllowedStack(Node n, boolean entering) {\n      switch (n.getType()) {\n        case Token.CASE:\n        case Token.FOR:\n        case Token.FUNCTION:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.SWITCH:\n        case Token.WHILE:\n          if (entering) {\n            assignAllowed.push(0);\n          } else {\n            assignAllowed.remove();\n          }\n          break;\n      }\n    }\n",
        "begin_line": 380,
        "end_line": 396,
        "comment": "\n     * Determines whether assignment to a define should be allowed\n     * in the subtree of the given node, and if not, records that fact.\n     *\n     * @param n The node whose subtree we're about to enter or exit.\n     * @param entering True if we're entering the subtree, false otherwise.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.114
        },
        "num_failing_tests": 4
    },
    {
        "name": "CommandLineRunner.processArgs#614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.processArgs(java.lang.String[])",
        "snippet": "  private List<String> processArgs(String[] args) {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    return processedArgs;\n  }\n",
        "begin_line": 614,
        "end_line": 640,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1137
        },
        "num_failing_tests": 3
    },
    {
        "name": "Node.isGetElem#2245",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isGetElem()",
        "snippet": "  public boolean isGetElem() {\n    return this.getType() == Token.GETELEM;\n  }\n",
        "begin_line": 2245,
        "end_line": 2247,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1132
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.getQualifiedName#1548",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getQualifiedName()",
        "snippet": "  public String getQualifiedName() {\n    if (type == Token.NAME) {\n      String name = getString();\n      return name.isEmpty() ? null : name;\n    } else if (type == Token.GETPROP) {\n      String left = getFirstChild().getQualifiedName();\n      if (left == null) {\n        return null;\n      }\n      return left + \".\" + getLastChild().getString();\n    } else if (type == Token.THIS) {\n      return \"this\";\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 1548,
        "end_line": 1563,
        "comment": "\n   * This function takes a set of GETPROP nodes and produces a string that is\n   * each property separated by dots. If the node ultimately under the left\n   * sub-tree is not a simple name, this is not a valid qualified name.\n   *\n   * @return a null if this is not a qualified name, or a dot-separated string\n   *         of the name and properties.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1129
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.isSyntheticBlock#1910",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
        "snippet": "  public boolean isSyntheticBlock() {\n    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n  }\n",
        "begin_line": 1910,
        "end_line": 1912,
        "comment": "\n   * Returns whether this is a synthetic block that should not be considered\n   * a real source block.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1125
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getDirectedGraphNodes#105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
        "snippet": "  @Override\n  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n        nodes.values());\n  }\n",
        "begin_line": 105,
        "end_line": 109,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1125
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.assertAllLoopablePasses#815",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllLoopablePasses(java.util.List<com.google.javascript.jscomp.PassFactory>)",
        "snippet": "  private void assertAllLoopablePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(!pass.isOneTimePass());\n    }\n  }\n",
        "begin_line": 815,
        "end_line": 819,
        "comment": " Verify that all the passes are multi-run passes. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1125
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isThis#2345",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isThis()",
        "snippet": "  public boolean isThis() {\n    return this.getType() == Token.THIS;\n  }\n",
        "begin_line": 2345,
        "end_line": 2347,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1124
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.toSource#1611",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.toSource()",
        "snippet": "  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n",
        "begin_line": 1611,
        "end_line": 1632,
        "comment": "\n   * Converts the main parse tree back to JS code.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1124
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.call#1613",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Anonymous-e7378c4c-4493-4913-a680-6ddf814bd33a.call()",
        "snippet": "      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n",
        "begin_line": 1613,
        "end_line": 1630,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1124
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeTraversal.getCurrentNode#446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getCurrentNode()",
        "snippet": "  public Node getCurrentNode() {\n    return curNode;\n  }\n",
        "begin_line": 446,
        "end_line": 448,
        "comment": " Returns the node currently being traversed. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1122
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.processExpressionStatement#659",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processExpressionStatement(com.google.javascript.rhino.head.ast.ExpressionStatement)",
        "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n",
        "begin_line": 659,
        "end_line": 664,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 6
    },
    {
        "name": "PhaseOptimizer.addLoopedPass#303",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.Loop.addLoopedPass(com.google.javascript.jscomp.PassFactory)",
        "snippet": "    void addLoopedPass(PassFactory factory) {\n      String name = factory.getName();\n      Preconditions.checkArgument(!myNames.contains(name),\n          \"Already a pass with name '%s' in this loop\", name);\n      myNames.add(name);\n      myPasses.add(new NamedPass(factory));\n    }\n",
        "begin_line": 303,
        "end_line": 309,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.consume#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.consume(java.util.List<com.google.javascript.jscomp.PassFactory>)",
        "snippet": "  void consume(List<PassFactory> factories) {\n    Loop currentLoop = new Loop();\n    boolean isCurrentLoopPopulated = false;\n    for (PassFactory factory : factories) {\n      if (factory.isOneTimePass()) {\n        if (isCurrentLoopPopulated) {\n          passes.add(currentLoop);\n          currentLoop = new Loop();\n          isCurrentLoopPopulated = false;\n        }\n        addOneTimePass(factory);\n      } else {\n        currentLoop.addLoopedPass(factory);\n        isCurrentLoopPopulated = true;\n      }\n    }\n\n    if (isCurrentLoopPopulated) {\n      passes.add(currentLoop);\n    }\n  }\n",
        "begin_line": 133,
        "end_line": 153,
        "comment": "\n   * Add the passes generated by the given factories to the compile sequence.\n   *\n   * Automatically pulls multi-run passes into fixed point loops. If there\n   * are 1 or more multi-run passes in a row, they will run together in\n   * the same fixed point loop. The passes will run until they are finished\n   * making changes.\n   *\n   * The PhaseOptimizer is free to tweak the order and frequency of multi-run\n   * passes in a fixed-point loop.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.append#1826",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.CodeBuilder.append(java.lang.String)",
        "snippet": "    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n",
        "begin_line": 1826,
        "end_line": 1845,
        "comment": " Appends the given string to the text buffer. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 3
    },
    {
        "name": "TokenStream.isJSIdentifier#190",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/TokenStream.java",
        "class_name": "com.google.javascript.rhino.TokenStream",
        "signature": "com.google.javascript.rhino.TokenStream.isJSIdentifier(java.lang.String)",
        "snippet": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0)))\n        return false;\n\n      for (int i = 1; i < length; i++) {\n        if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
        "begin_line": 190,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isValidSimpleName#2442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isValidSimpleName(java.lang.String)",
        "snippet": "  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }\n",
        "begin_line": 2442,
        "end_line": 2452,
        "comment": "\n   * Determines whether the given name is a valid variable name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.isValidPropertyName#2476",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isValidPropertyName(java.lang.String)",
        "snippet": "  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }\n",
        "begin_line": 2476,
        "end_line": 2478,
        "comment": "\n   * Determines whether the given name can appear on the right side of\n   * the dot operator. Many properties (like reserved words) cannot.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processIfStatement#793",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processIfStatement(com.google.javascript.rhino.head.ast.IfStatement)",
        "snippet": "    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF);\n      node.addChildToBack(transform(statementNode.getCondition()));\n      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n      }\n      return node;\n    }\n",
        "begin_line": 793,
        "end_line": 802,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.isExplicitlyProvided#813",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.isExplicitlyProvided()",
        "snippet": "    boolean isExplicitlyProvided() {\n      return explicitNode != null;\n    }\n",
        "begin_line": 813,
        "end_line": 815,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.opToStrNoFail#2208",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.opToStrNoFail(int)",
        "snippet": "  static String opToStrNoFail(int operator) {\n    String res = opToStr(operator);\n    if (res == null) {\n      throw new Error(\"Unknown op \" + operator + \": \" +\n                      Token.name(operator));\n    }\n    return res;\n  }\n",
        "begin_line": 2208,
        "end_line": 2215,
        "comment": "\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation or fails.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation\n   * @throws Error if the token value is not an operator\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1118
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraphNode#346",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.LinkedDirectedGraphNode(N)",
        "snippet": "    LinkedDirectedGraphNode(N nodeValue) {\n      this.value = nodeValue;\n    }\n",
        "begin_line": 346,
        "end_line": 348,
        "comment": "\n     * Constructor\n     *\n     * @param nodeValue Node's value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getValue#350",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getValue()",
        "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }\n",
        "begin_line": 350,
        "end_line": 353,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getOutEdges#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraphNode.getOutEdges()",
        "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }\n",
        "begin_line": 392,
        "end_line": 395,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.LinkedDirectedGraph#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraph(boolean, boolean)",
        "snippet": "  protected LinkedDirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }\n",
        "begin_line": 71,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.getDirectedGraphNode#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
        "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }\n",
        "begin_line": 111,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.createDirectedGraphNode#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
        "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = useNodeAnnotations ?\n          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n          new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }\n",
        "begin_line": 133,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "LinkedDirectedGraph.createNode#175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
        "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }\n",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1115
        },
        "num_failing_tests": 4
    },
    {
        "name": "GoogleCodingConvention.GoogleCodingConvention#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention()",
        "snippet": "  public GoogleCodingConvention() {\n    this(new ClosureCodingConvention());\n  }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": " By default, decorate the ClosureCodingConvention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1114
        },
        "num_failing_tests": 5
    },
    {
        "name": "GoogleCodingConvention.GoogleCodingConvention#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GoogleCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
        "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  public GoogleCodingConvention(CodingConvention convention) {\n    super(convention);\n  }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": " Decorates a wrapped CodingConvention. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1114
        },
        "num_failing_tests": 5
    },
    {
        "name": "AbstractCommandLineRunner.writeOutput#683",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.writeOutput(java.lang.Appendable, com.google.javascript.jscomp.Compiler, java.lang.String, java.lang.String, java.lang.String, com.google.common.base.Function<java.lang.String, java.lang.String>)",
        "snippet": "  static void writeOutput(Appendable out, Compiler compiler, String code,\n      String wrapper, String codePlaceholder,\n      @Nullable Function<String, String> escaper)\n      throws IOException {\n    int pos = wrapper.indexOf(codePlaceholder);\n    if (pos != -1) {\n      String prefix = \"\";\n\n      if (pos > 0) {\n        prefix = wrapper.substring(0, pos);\n        out.append(prefix);\n      }\n\n      out.append(escaper == null ? code : escaper.apply(code));\n\n      int suffixStart = pos + codePlaceholder.length();\n      if (suffixStart != wrapper.length()) {\n        // Something after placeholder?\n        out.append(wrapper.substring(suffixStart));\n      }\n      // Make sure we always end output with a line feed.\n      out.append('\\n');\n\n      // If we have a source map, adjust its offsets to match\n      // the code WITHIN the wrapper.\n      if (compiler != null && compiler.getSourceMap() != null) {\n        compiler.getSourceMap().setWrapperPrefix(prefix);\n      }\n\n    } else {\n      out.append(code);\n      out.append('\\n');\n    }\n  }\n",
        "begin_line": 683,
        "end_line": 716,
        "comment": "\n   * Writes code to an output stream, optionally wrapping it in an arbitrary\n   * wrapper that contains a placeholder where the code should be inserted.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputNameMaps#1224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputNameMaps(B)",
        "snippet": "  private void outputNameMaps(B options) throws FlagUsageException,\n      IOException {\n\n    String propertyMapOutputPath = null;\n    String variableMapOutputPath = null;\n    String functionInformationMapOutputPath = null;\n\n    // Check the create_name_map_files FLAG.\n    if (config.createNameMapFiles) {\n      String basePath = getMapPath(config.jsOutputFile);\n\n      propertyMapOutputPath = basePath + \"_props_map.out\";\n      variableMapOutputPath = basePath + \"_vars_map.out\";\n      functionInformationMapOutputPath = basePath + \"_functions_map.out\";\n    }\n\n    // Check the individual FLAGS.\n    if (!config.variableMapOutputFile.equals(\"\")) {\n      if (variableMapOutputPath != null) {\n        throw new FlagUsageException(\"The flags variable_map_output_file and \"\n            + \"create_name_map_files cannot both be used simultaniously.\");\n      }\n\n      variableMapOutputPath = config.variableMapOutputFile;\n    }\n\n    if (!config.propertyMapOutputFile.equals(\"\")) {\n      if (propertyMapOutputPath != null) {\n        throw new FlagUsageException(\"The flags property_map_output_file and \"\n            + \"create_name_map_files cannot both be used simultaniously.\");\n      }\n\n      propertyMapOutputPath = config.propertyMapOutputFile;\n    }\n\n    // Output the maps.\n    if (variableMapOutputPath != null) {\n      if (compiler.getVariableMap() != null) {\n        compiler.getVariableMap().save(variableMapOutputPath);\n      }\n    }\n\n    if (propertyMapOutputPath != null) {\n      if (compiler.getPropertyMap() != null) {\n        compiler.getPropertyMap().save(propertyMapOutputPath);\n      }\n    }\n\n    if (functionInformationMapOutputPath != null) {\n      if (compiler.getFunctionalInformationMap() != null) {\n        OutputStream file =\n            filenameToOutputStream(functionInformationMapOutputPath);\n        CodedOutputStream outputStream = CodedOutputStream.newInstance(file);\n        compiler.getFunctionalInformationMap().writeTo(outputStream);\n        outputStream.flush();\n        file.flush();\n        file.close();\n      }\n    }\n  }\n",
        "begin_line": 1224,
        "end_line": 1283,
        "comment": "\n   * Outputs the variable and property name maps for the specified compiler if\n   * the proper FLAGS are set.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputManifest#1363",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputManifest()",
        "snippet": "  private void outputManifest() throws IOException {\n    outputManifestOrBundle(config.outputManifests, true);\n  }\n",
        "begin_line": 1363,
        "end_line": 1365,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputBundle#1367",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputBundle()",
        "snippet": "  private void outputBundle() throws IOException {\n    outputManifestOrBundle(config.outputBundles, false);\n  }\n",
        "begin_line": 1367,
        "end_line": 1369,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputManifestOrBundle#1375",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputManifestOrBundle(java.util.List<java.lang.String>, boolean)",
        "snippet": "  private void outputManifestOrBundle(List<String> outputFiles,\n      boolean isManifest) throws IOException {\n    if (outputFiles.isEmpty()) {\n      return;\n    }\n\n    for (String output : outputFiles) {\n      if (output.isEmpty()) {\n        continue;\n      }\n\n      if (shouldGenerateOutputPerModule(output)) {\n        // Generate per-module manifests or bundles\n        JSModuleGraph graph = compiler.getDegenerateModuleGraph();\n        Iterable<JSModule> modules = graph.getAllModules();\n        for (JSModule module : modules) {\n          Writer out = fileNameToOutputWriter2(\n              expandCommandLinePath(output, module));\n          if (isManifest) {\n            printManifestTo(module.getInputs(), out);\n          } else {\n            printBundleTo(module.getInputs(), out);\n          }\n          out.close();\n        }\n      } else {\n        // Generate a single file manifest or bundle.\n        Writer out = fileNameToOutputWriter2(\n            expandCommandLinePath(output, null));\n        if (config.module.isEmpty()) {\n          if (isManifest) {\n            printManifestTo(compiler.getInputsInOrder(), out);\n          } else {\n            printBundleTo(compiler.getInputsInOrder(), out);\n          }\n        } else {\n          printModuleGraphManifestOrBundleTo(\n              compiler.getDegenerateModuleGraph(), out, isManifest);\n        }\n        out.close();\n      }\n    }\n  }\n",
        "begin_line": 1375,
        "end_line": 1417,
        "comment": "\n   * Writes the manifest or bundle of all compiler input files that survived\n   * manage_closure_dependencies, if requested.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.outputModuleGraphJson#1422",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputModuleGraphJson()",
        "snippet": "  private void outputModuleGraphJson() throws IOException {\n    if (config.outputModuleDependencies != null &&\n        config.outputModuleDependencies != \"\") {\n      Writer out = fileNameToOutputWriter2(config.outputModuleDependencies);\n      printModuleGraphJsonTo(compiler.getDegenerateModuleGraph(), out);\n      out.close();\n    }\n  }\n",
        "begin_line": 1422,
        "end_line": 1429,
        "comment": "\n   * Creates a file containing the current module graph in JSON serialization.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.11
        },
        "num_failing_tests": 3
    },
    {
        "name": "LoggerErrorManager.LoggerErrorManager#37",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LoggerErrorManager.java",
        "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
        "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(com.google.javascript.jscomp.MessageFormatter, java.util.logging.Logger)",
        "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }\n",
        "begin_line": 37,
        "end_line": 40,
        "comment": "\n   * Creates an instance.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1096
        },
        "num_failing_tests": 5
    },
    {
        "name": "Compiler.Compiler#229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
        "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }\n",
        "begin_line": 229,
        "end_line": 231,
        "comment": "\n   * Creates a Compiler that reports errors and warnings to its logger.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1096
        },
        "num_failing_tests": 5
    },
    {
        "name": "CompilerInput.getSourceFile#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getSourceFile()",
        "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return ast.getSourceFile();\n  }\n",
        "begin_line": 130,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1094
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodingConventions.isConstantKey#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.isConstantKey(java.lang.String)",
        "snippet": "    @Override public boolean isConstantKey(String keyName) {\n      return nextConvention.isConstantKey(keyName);\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1094
        },
        "num_failing_tests": 3
    },
    {
        "name": "CodingConventions.isConstantKey#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.isConstantKey(java.lang.String)",
        "snippet": "    @Override\n    public boolean isConstantKey(String variableName) {\n      return false;\n    }\n",
        "begin_line": 258,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1094
        },
        "num_failing_tests": 3
    },
    {
        "name": "PeepholeRemoveDeadCode.isExprConditional#644",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.isExprConditional(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isExprConditional(Node n) {\n    if (n.isExprResult()) {\n      switch (n.getFirstChild().getType()) {\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n          return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 644,
        "end_line": 654,
        "comment": "\n   * @return Whether the node is a rooted with a HOOK, AND, or OR node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1091
        },
        "num_failing_tests": 2
    },
    {
        "name": "Compiler.toSource#1725",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.toSource(com.google.javascript.jscomp.Compiler.CodeBuilder, int, com.google.javascript.rhino.Node)",
        "snippet": "  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n",
        "begin_line": 1725,
        "end_line": 1787,
        "comment": "\n   * Writes out JS code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1088
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.runInCompilerThread#649",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.runInCompilerThread(java.util.concurrent.Callable<T>)",
        "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T> T runInCompilerThread(final Callable<T> callable) {\n    final boolean dumpTraceReport = options != null && options.tracer.isOn();\n    T result = null;\n    final Throwable[] exception = new Throwable[1];\n    Callable<T> bootCompilerThread = new Callable<T>() {\n      @Override\n      public T call() {\n        try {\n          compilerThread = Thread.currentThread();\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          return callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          compilerThread = null;\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n            tracker.outputTracerReport(outStream == null ?\n                System.out : outStream);\n          }\n        }\n        return null;\n      }\n    };\n\n    Preconditions.checkState(\n        compilerThread == null || compilerThread == Thread.currentThread(),\n        \"Please do not share the Compiler across threads\");\n\n    // If the compiler thread is available, use it.\n    if (useThreads && compilerThread == null) {\n      try {\n        result = compilerExecutor.submit(bootCompilerThread).get();\n      } catch (InterruptedException e) {\n        throw Throwables.propagate(e);\n      } catch (ExecutionException e) {\n        throw Throwables.propagate(e);\n      }\n    } else {\n      try {\n        result = callable.call();\n      } catch (Exception e) {\n        exception[0] = e;\n      }\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return result;\n  }\n",
        "begin_line": 649,
        "end_line": 704,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1088
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.toString#1848",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.CodeBuilder.toString()",
        "snippet": "    @Override\n    public String toString() {\n      return sb.toString();\n    }\n",
        "begin_line": 1848,
        "end_line": 1851,
        "comment": " Returns all text in the text buffer. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1083
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.isGet#1555",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isGet(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isGet(Node n) {\n    return n.isGetProp() || n.isGetElem();\n  }\n",
        "begin_line": 1555,
        "end_line": 1557,
        "comment": "\n   * Is this a GETPROP or GETELEM node?\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1072
        },
        "num_failing_tests": 5
    },
    {
        "name": "CodingConventions.isConstant#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.isConstant(java.lang.String)",
        "snippet": "    @Override\n    public boolean isConstant(String variableName) {\n      return nextConvention.isConstant(variableName);\n    }\n",
        "begin_line": 63,
        "end_line": 66,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1071
        },
        "num_failing_tests": 3
    },
    {
        "name": "CodingConventions.isConstant#253",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.isConstant(java.lang.String)",
        "snippet": "    @Override\n    public boolean isConstant(String variableName) {\n      return false;\n    }\n",
        "begin_line": 253,
        "end_line": 256,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1071
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeTraversal.getCompiler#399",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getCompiler()",
        "snippet": "  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }\n",
        "begin_line": 399,
        "end_line": 403,
        "comment": "\n   * Gets the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 5
    },
    {
        "name": "PeepholeRemoveDeadCode.tryFoldAssignment#118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldAssignment(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldAssignment(Node subtree) {\n    Preconditions.checkState(subtree.isAssign());\n    Node left = subtree.getFirstChild();\n    Node right = subtree.getLastChild();\n    // Only names\n    if (left.isName()\n        && right.isName()\n        && left.getString().equals(right.getString())) {\n      subtree.getParent().replaceChild(subtree, right.detachFromParent());\n      reportCodeChange();\n      return right;\n    }\n    return subtree;\n  }\n",
        "begin_line": 118,
        "end_line": 131,
        "comment": "\n   * Try removing identity assignments\n   * @return the replacement node, if changed, or the original if not\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 2
    },
    {
        "name": "JoinOp.apply#36",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JoinOp.java",
        "class_name": "com.google.javascript.jscomp.JoinOp",
        "signature": "com.google.javascript.jscomp.JoinOp.BinaryJoinOp.apply(java.util.List<L>)",
        "snippet": "    @Override\n    public final L apply(List<L> values) {\n      Preconditions.checkArgument(!values.isEmpty());\n      int size = values.size();\n      if (size == 1) {\n        return values.get(0);\n      } else if (size == 2) {\n        return apply(values.get(0), values.get(1));\n      } else {\n        int mid = computeMidPoint(size);\n        return apply(\n            apply(values.subList(0, mid)),\n            apply(values.subList(mid, size)));\n      }\n    }\n",
        "begin_line": 36,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 2
    },
    {
        "name": "RenameVars.compare#300",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.Anonymous-0d63c0a9-61ef-485a-a9bb-570b25fd63f4.compare(com.google.javascript.jscomp.RenameVars.Assignment, com.google.javascript.jscomp.RenameVars.Assignment)",
        "snippet": "    @Override\n    public int compare(Assignment a1, Assignment a2) {\n      if (a1.count != a2.count) {\n        return a2.count - a1.count;\n      }\n      // Break a tie using the order in which the variable first appears in\n      // the source.\n      return ORDER_OF_OCCURRENCE_COMPARATOR.compare(a1, a2);\n    }\n",
        "begin_line": 300,
        "end_line": 308,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.newExpr#758",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.newExpr(com.google.javascript.rhino.Node)",
        "snippet": "  static Node newExpr(Node child) {\n    return IR.exprResult(child).srcref(child);\n  }\n",
        "begin_line": 758,
        "end_line": 760,
        "comment": "\n   * Creates an EXPR_RESULT.\n   *\n   * @param child The expression itself.\n   * @return Newly created EXPR node with the child as subexpression.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1066
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.handleTypedefDefinition#338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.handleTypedefDefinition(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void handleTypedefDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    JSDocInfo info = n.getFirstChild().getJSDocInfo();\n    if (t.inGlobalScope() && info != null && info.hasTypedefType()) {\n      String name = n.getFirstChild().getQualifiedName();\n      if (name != null) {\n        ProvidedName pn = providedNames.get(name);\n        if (pn != null) {\n          pn.addDefinition(n, t.getModule());\n        }\n      }\n    }\n  }\n",
        "begin_line": 338,
        "end_line": 350,
        "comment": "\n   * Handles a typedef definition for a goog.provided name.\n   * @param n EXPR_RESULT node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1061
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.createSourceInputs#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createSourceInputs(java.util.List<java.lang.String>)",
        "snippet": "  private List<SourceFile> createSourceInputs(List<String> files)\n      throws FlagUsageException, IOException {\n    if (isInTestMode()) {\n      return inputsSupplierForTesting.get();\n    }\n    if (files.isEmpty()) {\n      files = Collections.singletonList(\"-\");\n    }\n    try {\n      return createInputs(files, true);\n    } catch (FlagUsageException e) {\n      throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage());\n    }\n  }\n",
        "begin_line": 477,
        "end_line": 490,
        "comment": "\n   * Creates JS source code inputs from a list of files.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.105
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.doRun#739",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.doRun()",
        "snippet": "  protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n\n    List<SourceFile> externs = createExterns();\n\n    compiler = createCompiler();\n    B options = createOptions();\n\n    List<JSModule> modules = null;\n    Result result = null;\n\n    setRunOptions(options);\n\n    boolean writeOutputToFile = !config.jsOutputFile.isEmpty();\n    List<String> outputFileNames = Lists.newArrayList();\n    if (writeOutputToFile) {\n      outputFileNames.add(config.jsOutputFile);\n      jsOutput = fileNameToLegacyOutputWriter(config.jsOutputFile);\n    } else if (jsOutput instanceof OutputStream) {\n      jsOutput = streamToLegacyOutputWriter((OutputStream) jsOutput);\n    }\n\n    List<String> jsFiles = config.js;\n    List<String> moduleSpecs = config.module;\n\n    boolean createCommonJsModules = false;\n    if (options.processCommonJSModules) {\n      if (moduleSpecs.size() == 1 && \"auto\".equals(moduleSpecs.get(0))) {\n        createCommonJsModules = true;\n        moduleSpecs.remove(0);\n      }\n    }\n    if (!moduleSpecs.isEmpty()) {\n      modules = createJsModules(moduleSpecs, jsFiles);\n      for (JSModule m : modules) {\n        outputFileNames.add(getModuleOutputFileName(m));\n      }\n\n      if (config.skipNormalOutputs) {\n        compiler.initModules(externs, modules, options);\n      } else {\n        result = compiler.compileModules(externs, modules, options);\n      }\n    } else {\n      List<SourceFile> inputs = createSourceInputs(jsFiles);\n      if (config.skipNormalOutputs) {\n        compiler.init(externs, inputs, options);\n      } else {\n        result = compiler.compile(externs, inputs, options);\n      }\n    }\n    if (createCommonJsModules) {\n      // For CommonJS modules construct modules from actual inputs.\n      modules = Lists.newArrayList(compiler.getDegenerateModuleGraph()\n          .getAllModules());\n      for (JSModule m : modules) {\n        outputFileNames.add(getModuleOutputFileName(m));\n      }\n    }\n\n    for (String outputFileName : outputFileNames) {\n      if (compiler.getSourceFileByName(outputFileName) != null) {\n        compiler.report(\n            JSError.make(OUTPUT_SAME_AS_INPUT_ERROR, outputFileName));\n        return 1;\n      }\n    }\n\n    int errCode = processResults(result, modules, options);\n    // Flush the output if we are writing to a file.\n    // We can't close yet, because we may need to write phase ordering\n    // info to it later.\n    if (jsOutput instanceof Flushable) {\n      ((Flushable) jsOutput).flush();\n    }\n    return errCode;\n  }\n",
        "begin_line": 739,
        "end_line": 815,
        "comment": "\n   * Parses command-line arguments and runs the compiler.\n   *\n   * @return system exit status\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.105
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.getModuleGraph#1171",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getModuleGraph()",
        "snippet": "  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n",
        "begin_line": 1171,
        "end_line": 1174,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1048
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.handleExpr#534",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleExpr(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n",
        "begin_line": 534,
        "end_line": 537,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1045
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.compile#578",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.compile(java.util.List<T1>, java.util.List<T2>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n",
        "begin_line": 578,
        "end_line": 594,
        "comment": "\n   * Compiles a list of inputs.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1045
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.createDependencyOptions#215",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createDependencyOptions(boolean, boolean, boolean, java.util.List<java.lang.String>)",
        "snippet": "  static DependencyOptions createDependencyOptions(\n      boolean manageClosureDependencies,\n      boolean onlyClosureDependencies,\n      boolean processCommonJSModules,\n      List<String> closureEntryPoints)\n      throws FlagUsageException {\n    if (onlyClosureDependencies) {\n      if (closureEntryPoints.isEmpty()) {\n        throw new FlagUsageException(\"When only_closure_dependencies is \"\n          + \"on, you must specify at least one closure_entry_point\");\n      }\n\n      return new DependencyOptions()\n          .setDependencyPruning(true)\n          .setDependencySorting(true)\n          .setMoocherDropping(true)\n          .setEntryPoints(closureEntryPoints);\n    } else if (processCommonJSModules) {\n      return new DependencyOptions()\n        .setDependencyPruning(false)\n        .setDependencySorting(true)\n        .setMoocherDropping(false)\n        .setEntryPoints(closureEntryPoints);\n    }\n    else if (manageClosureDependencies ||\n        closureEntryPoints.size() > 0) {\n      return new DependencyOptions()\n          .setDependencyPruning(true)\n          .setDependencySorting(true)\n          .setMoocherDropping(false)\n          .setEntryPoints(closureEntryPoints);\n    }\n    return null;\n  }\n",
        "begin_line": 215,
        "end_line": 248,
        "comment": "\n   * A helper function for creating the dependency options object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1045
        },
        "num_failing_tests": 3
    },
    {
        "name": "ControlFlowAnalysis.mayThrowException#910",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 910,
        "end_line": 931,
        "comment": "\n   * Determines if the subtree might throw an exception.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.104
        },
        "num_failing_tests": 3
    },
    {
        "name": "CompilerOptions.fromString#2037",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.LanguageMode.fromString(java.lang.String)",
        "snippet": "    public static LanguageMode fromString(String value) {\n      if (value.equals(\"ECMASCRIPT5_STRICT\") ||\n          value.equals(\"ES5_STRICT\")) {\n        return CompilerOptions.LanguageMode.ECMASCRIPT5_STRICT;\n      } else if (value.equals(\"ECMASCRIPT5\") ||\n          value.equals(\"ES5\")) {\n        return CompilerOptions.LanguageMode.ECMASCRIPT5;\n      } else if (value.equals(\"ECMASCRIPT3\") ||\n                 value.equals(\"ES3\")) {\n        return CompilerOptions.LanguageMode.ECMASCRIPT3;\n      }\n      return null;\n    }\n",
        "begin_line": 2037,
        "end_line": 2049,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1035
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.streamToLegacyOutputWriter#1143",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.streamToLegacyOutputWriter(java.io.OutputStream)",
        "snippet": "  private Writer streamToLegacyOutputWriter(OutputStream stream)\n      throws IOException {\n    if (legacyOutputCharset == null) {\n      return new BufferedWriter(\n          new OutputStreamWriter(stream));\n    } else {\n      return new BufferedWriter(\n          new OutputStreamWriter(stream, legacyOutputCharset));\n    }\n  }\n",
        "begin_line": 1143,
        "end_line": 1152,
        "comment": "\n   * Create a writer with the legacy output charset.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1035
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.nodeTypeMayHaveSideEffects#1084",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.nodeTypeMayHaveSideEffects(com.google.javascript.rhino.Node, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    if (isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.DELPROP:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.CALL:\n        return NodeUtil.functionCallHasSideEffects(n, compiler);\n      case Token.NEW:\n        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1084,
        "end_line": 1105,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1031
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnreachableCodeElimination.tryRemoveUnconditionalBranching#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/UnreachableCodeElimination.java",
        "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
        "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.EliminationPass.tryRemoveUnconditionalBranching(com.google.javascript.rhino.Node)",
        "snippet": "    @SuppressWarnings(\"fallthrough\")\n    private Node tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return n;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, there is no chance this jump is useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeDeadExprStatementSafely(n);\n              return fallThrough;\n            }\n          }\n      }\n      return n;\n    }\n",
        "begin_line": 131,
        "end_line": 180,
        "comment": "\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to remove\n     * the target branch as well. The reason why we want to cascade this removal\n     * is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When we\n     * first look at the first break, we see that it branches to the 2nd break.\n     * However, if we remove the last break, the 2nd break becomes useless and\n     * finally the first break becomes useless as well.\n     *\n     * @return The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.103
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.constructRootRelativePathsMap#1526",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.constructRootRelativePathsMap()",
        "snippet": "  private Map<String, String> constructRootRelativePathsMap() {\n    Map<String, String> rootRelativePathsMap = Maps.newLinkedHashMap();\n    for (String mapString : config.manifestMaps) {\n      int colonIndex = mapString.indexOf(':');\n      Preconditions.checkState(colonIndex > 0);\n      String execPath = mapString.substring(0, colonIndex);\n      String rootRelativePath = mapString.substring(colonIndex + 1);\n      Preconditions.checkState(rootRelativePath.indexOf(':') == -1);\n      rootRelativePathsMap.put(execPath, rootRelativePath);\n    }\n    return rootRelativePathsMap;\n  }\n",
        "begin_line": 1526,
        "end_line": 1537,
        "comment": "\n   * Construct and return the input root path map. The key is the exec path of\n   * each input file, and the value is the corresponding root relative path.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.103
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfoBuilder.recordThrowType#310",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordThrowType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordThrowType(JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags()) {\n      currentInfo.declareThrows(type);\n      populated = true;\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 310,
        "end_line": 317,
        "comment": "\n   * Records a thrown type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfoBuilder.recordThisType#567",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordThisType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordThisType(JSTypeExpression type) {\n    if (type != null && !hasAnySingletonTypeTags() &&\n        !currentInfo.hasThisType()) {\n      currentInfo.setThisType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 567,
        "end_line": 576,
        "comment": "\n   * Records a type for {@code @this} annotation.\n   *\n   * @return {@code true} if the type was recorded and\n   *     {@code false} if it is invalid or if it collided with {@code @enum} or\n   *     {@code @type} annotations\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfo.declareThrows#960",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.declareThrows(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  boolean declareThrows(JSTypeExpression jsType) {\n    lazyInitInfo();\n\n    if (info.thrownTypes == null) {\n      info.thrownTypes = Lists.newArrayList();\n    }\n\n    info.thrownTypes.add(jsType);\n    return true;\n  }\n",
        "begin_line": 960,
        "end_line": 969,
        "comment": "\n   * Declares that the method throws a given type.\n   *\n   * @param jsType The type that can be thrown by the method.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfo.setThisType#1155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setThisType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setThisType(JSTypeExpression type) {\n    this.thisType = type;\n  }\n",
        "begin_line": 1155,
        "end_line": 1157,
        "comment": "\n   * Sets the type specified by the {@code @this} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocTokenStream.getJsDocToken#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
        "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a JsDoc string but discard last . if it is followed by\n          // a non-JsDoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 58,
        "end_line": 194,
        "comment": "\n   * Tokenizes JSDoc comments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parse#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
        "snippet": "  @SuppressWarnings(\"incomplete-switch\")\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case STRUCT:\n                  if (!jsdocBuilder.recordStruct()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DICT:\n                  if (!jsdocBuilder.recordDict()) {\n                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                          stream.getLineno(),\n                                          stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case STABLEIDGENERATOR:\n                  if (!jsdocBuilder.recordStableIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  List<String> names = Lists.newArrayList(\n                      Splitter.on(',')\n                          .trimResults()\n                          .split(templateInfo.string));\n\n                  if (names.size() == 0 || names.get(0).length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                case DEFINE:\n                case RETURN:\n                case PRIVATE:\n                case PROTECTED:\n                case PUBLIC:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  boolean hasType = lookAheadForTypeAnnotation();\n                  boolean isAlternateTypeAnnotation =\n                      (annotation == Annotation.PRIVATE ||\n                       annotation == Annotation.PROTECTED ||\n                       annotation == Annotation.PUBLIC ||\n                       annotation == Annotation.CONSTANT);\n                  boolean canSkipTypeAnnotation =\n                      (isAlternateTypeAnnotation ||\n                       annotation == Annotation.RETURN);\n                  type = null;\n                  if (hasType || !canSkipTypeAnnotation) {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n\n                    if (annotation == Annotation.THIS) {\n                      typeNode = wrapNode(Token.BANG, typeNode);\n                    }\n                    type = createJSTypeExpression(typeNode);\n                  }\n\n                  // The error was reported during recursive descent\n                  // recovering parsing\n                  boolean hasError = type == null && !canSkipTypeAnnotation;\n                  if (!hasError) {\n                    // Record types for @type.\n                    // If the @private, @protected, or @public annotations\n                    // have a type attached, pretend that they actually wrote:\n                    // @type {type}\\n@private\n                    // This will have some weird behavior in some cases\n                    // (for example, @private can now be used as a type-cast),\n                    // but should be mostly OK.\n                    if ((type != null && isAlternateTypeAnnotation)\n                        || annotation == Annotation.TYPE) {\n                      if (!jsdocBuilder.recordType(type)) {\n                        parser.addTypeWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    }\n\n                    switch (annotation) {\n                      case CONSTANT:\n                        if (!jsdocBuilder.recordConstancy()) {\n                          parser.addParserWarning(\"msg.jsdoc.const\",\n                              stream.getLineno(), stream.getCharno());\n                        }\n                        break;\n\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PRIVATE:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.private\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PROTECTED:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.protected\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case PUBLIC:\n                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                          parser.addParserWarning(\n                              \"msg.jsdoc.visibility.public\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (type == null) {\n                          type = createJSTypeExpression(newNode(Token.QMARK));\n                        }\n\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n",
        "begin_line": 182,
        "end_line": 992,
        "comment": "\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation#1609",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }\n",
        "begin_line": 1609,
        "end_line": 1644,
        "comment": "\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocInfoParser.parseTypeExpression#1723",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 5 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }\n",
        "begin_line": 1723,
        "end_line": 1766,
        "comment": "\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseBasicTypeExpression#1772",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n",
        "begin_line": 1772,
        "end_line": 1798,
        "comment": "\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureCodingConvention.typeofClassDefiningName#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.typeofClassDefiningName(com.google.javascript.rhino.Node)",
        "snippet": "  private SubclassType typeofClassDefiningName(Node callName) {\n    // Check if the method name matches one of the class-defining methods.\n    String methodName = null;\n    if (callName.isGetProp()) {\n      methodName = callName.getLastChild().getString();\n    } else if (callName.isName()) {\n      String name = callName.getString();\n      int dollarIndex = name.lastIndexOf('$');\n      if (dollarIndex != -1) {\n        methodName = name.substring(dollarIndex + 1);\n      }\n    }\n\n    if (methodName != null) {\n      if (methodName.equals(\"inherits\")) {\n        return SubclassType.INHERITS;\n      } else if (methodName.equals(\"mixin\")) {\n        return SubclassType.MIXIN;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 160,
        "end_line": 181,
        "comment": "\n   * Determines whether the given node is a class-defining name, like\n   * \"inherits\" or \"mixin.\"\n   * @return The type of class-defining name, or null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1025
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocInfoParser.newNode#2228",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newNode(int)",
        "snippet": "  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 2228,
        "end_line": 2231,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "PrintStreamErrorManager.PrintStreamErrorManager#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrintStreamErrorManager.java",
        "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
        "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.PrintStreamErrorManager(com.google.javascript.jscomp.MessageFormatter, java.io.PrintStream)",
        "snippet": "  public PrintStreamErrorManager(MessageFormatter formatter,\n                                 PrintStream stream) {\n    this.formatter = formatter;\n    this.stream = stream;\n  }\n",
        "begin_line": 43,
        "end_line": 47,
        "comment": "\n   * Creates an error manager.\n   * @param formatter the message formatter used to format the messages\n   * @param stream the stream on which the errors and warnings should be\n   *     printed. This class does not close the stream\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "PrintStreamErrorManager.setSummaryDetailLevel#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrintStreamErrorManager.java",
        "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
        "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.setSummaryDetailLevel(int)",
        "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "PrintStreamErrorManager.printSummary#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrintStreamErrorManager.java",
        "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
        "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.printSummary()",
        "snippet": "  @Override\n  public void printSummary() {\n    if (summaryDetailLevel >= 3 ||\n        (summaryDetailLevel >= 1 && getErrorCount() + getWarningCount() > 0) ||\n        (summaryDetailLevel >= 2 && getTypedPercent() > 0.0)) {\n      if (getTypedPercent() > 0.0) {\n        stream.format(\"%d error(s), %d warning(s), %.1f%% typed%n\",\n            getErrorCount(), getWarningCount(), getTypedPercent());\n      } else {\n        stream.format(\"%d error(s), %d warning(s)%n\", getErrorCount(),\n            getWarningCount());\n      }\n    }\n  }\n",
        "begin_line": 65,
        "end_line": 78,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "PhaseOptimizer.getLoopsRun#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.getLoopsRun()",
        "snippet": "  static List<List<String>> getLoopsRun() {\n    return loopsRun;\n  }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n   * Get the phase ordering of loops during this run.\n   * Returns an empty list when the loops are not randomized.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "PhaseOptimizer.clearLoopsRun#118",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.clearLoopsRun()",
        "snippet": "  static void clearLoopsRun() {\n    loopsRun.clear();\n  }\n",
        "begin_line": 118,
        "end_line": 120,
        "comment": "\n   * Clears the phase ordering of loops during this run.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.recordStartRun#1548",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.RunTimeStats.recordStartRun()",
        "snippet": "    private void recordStartRun() {\n      lastStartTime = System.currentTimeMillis();\n      PhaseOptimizer.clearLoopsRun();\n    }\n",
        "begin_line": 1548,
        "end_line": 1551,
        "comment": "\n     * Record the start of a run.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.recordEndRun#1556",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.RunTimeStats.recordEndRun()",
        "snippet": "    private void recordEndRun() {\n      long endTime = System.currentTimeMillis();\n      long length = endTime - lastStartTime;\n      worstRunTime = Math.max(length, worstRunTime);\n      if (length < bestRunTime) {\n        loopedPassesInBestRun = PhaseOptimizer.getLoopsRun();\n        bestRunTime = length;\n      }\n    }\n",
        "begin_line": 1556,
        "end_line": 1564,
        "comment": "\n     * Record the end of a run.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.enableTestMode#156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.enableTestMode(com.google.common.base.Supplier<java.util.List<com.google.javascript.jscomp.SourceFile>>, com.google.common.base.Supplier<java.util.List<com.google.javascript.jscomp.SourceFile>>, com.google.common.base.Supplier<java.util.List<com.google.javascript.jscomp.JSModule>>, com.google.common.base.Function<java.lang.Integer, java.lang.Boolean>)",
        "snippet": "  @VisibleForTesting\n  void enableTestMode(\n      Supplier<List<SourceFile>> externsSupplier,\n      Supplier<List<SourceFile>> inputsSupplier,\n      Supplier<List<JSModule>> modulesSupplier,\n      Function<Integer, Boolean> exitCodeReceiver) {\n    Preconditions.checkArgument(\n        inputsSupplier == null ^ modulesSupplier == null);\n    testMode = true;\n    this.externsSupplierForTesting = externsSupplier;\n    this.inputsSupplierForTesting = inputsSupplier;\n    this.modulesSupplierForTesting = modulesSupplier;\n    this.exitCodeReceiverForTesting = exitCodeReceiver;\n  }\n",
        "begin_line": 156,
        "end_line": 169,
        "comment": "\n   * Put the command line runner into test mode. In test mode,\n   * all outputs will be blackholed.\n   * @param externsSupplier A provider for externs.\n   * @param inputsSupplier A provider for source inputs.\n   * @param modulesSupplier A provider for modules. Only one of inputsSupplier\n   *     and modulesSupplier may be non-null.\n   * @param exitCodeReceiver A receiver for the status code that would\n   *     have been passed to System.exit in non-test mode.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getCompiler#365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getCompiler()",
        "snippet": "  final protected A getCompiler() {\n    return compiler;\n  }\n",
        "begin_line": 365,
        "end_line": 367,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.run#373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.run()",
        "snippet": "  final public void run() {\n    int result = 0;\n    int runs = 1;\n    if (config.computePhaseOrdering) {\n      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n      PhaseOptimizer.randomizeLoops();\n    }\n    try {\n      for (int i = 0; i < runs && result == 0; i++) {\n        runTimeStats.recordStartRun();\n        result = doRun();\n        runTimeStats.recordEndRun();\n      }\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n      System.err.println(e.getMessage());\n      result = -1;\n    } catch (Throwable t) {\n      t.printStackTrace();\n      result = -2;\n    }\n\n    if (config.computePhaseOrdering) {\n      runTimeStats.outputBestPhaseOrdering();\n    }\n\n    try {\n      if (jsOutput instanceof Closeable) {\n        ((Closeable) jsOutput).close();\n      }\n    } catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n\n    if (testMode) {\n      exitCodeReceiverForTesting.apply(result);\n    } else {\n      System.exit(result);\n    }\n  }\n",
        "begin_line": 373,
        "end_line": 411,
        "comment": "\n   * Runs the Compiler and calls System.exit() with the exit status of the\n   * compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfo.isDeprecated#542",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isDeprecated()",
        "snippet": "  public boolean isDeprecated() {\n    return getFlag(MASK_DEPRECATED);\n  }\n",
        "begin_line": 542,
        "end_line": 544,
        "comment": "\n   * Returns whether the {@code @deprecated} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "SortedDependencies.getInputsWithoutProvides#235",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.getInputsWithoutProvides()",
        "snippet": "  public List<INPUT> getInputsWithoutProvides() {\n    return Collections.<INPUT>unmodifiableList(noProvides);\n  }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visit#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.CAST:\n        Node expr = n.getFirstChild();\n        ensureTyped(t, n, getJSType(expr));\n\n        // If the cast, tightens the type apply it, so it is available post\n        // normalization.\n        JSType castType = getJSType(n);\n        JSType exprType = getJSType(expr);\n        if (castType.isSubtype(exprType)) {\n          expr.setJSType(castType);\n        }\n        break;\n\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        typeable = false;\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.STRING_KEY:\n        typeable = false;\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        checkPropCreation(t, left);\n        validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE: {\n        left = n.getFirstChild();\n        right = n.getLastChild();\n\n        if (left.isTypeOf()) {\n          if (right.isString()) {\n            checkTypeofString(t, right, right.getString());\n          }\n        } else if (right.isTypeOf() && left.isString()) {\n          checkTypeofString(t, left, left.getString());\n        }\n\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n\n        // We do not want to warn about explicit comparisons to VOID. People\n        // often do this if they think their type annotations screwed up.\n        //\n        // We do want to warn about cases where people compare things like\n        // (Array|null) == (Function|null)\n        // because it probably means they screwed up.\n        //\n        // This heuristic here is not perfect, but should catch cases we\n        // care about without too many false negatives.\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n\n        TernaryValue result = TernaryValue.UNKNOWN;\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n          if (n.isNE()) {\n            result = result.not();\n          }\n        } else {\n          // SHEQ or SHNE\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                  rightTypeRestricted)) {\n            result = n.getType() == Token.SHEQ ?\n                TernaryValue.FALSE : TernaryValue.TRUE;\n          }\n        }\n\n        if (result != TernaryValue.UNKNOWN) {\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right);\n        validator.expectString(t, left, getJSType(left), \"left side of 'in'\");\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        if (rightType.isStruct()) {\n          report(t, right, IN_USED_WITH_STRUCT);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n        validator.expectAnyObject(\n            t, left, getJSType(left), \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n        checkPropCreation(t, n.getFirstChild());\n        // fall through\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          Node obj = n.getChildAtIndex(1);\n          if (getJSType(obj).isStruct()) {\n            report(t, obj, IN_USED_WITH_STRUCT);\n          }\n        }\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          JSType typ = getJSType(n);\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n, typ);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n",
        "begin_line": 477,
        "end_line": 854,
        "comment": "\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getImpureBooleanValue#75",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getImpureBooleanValue(com.google.javascript.rhino.Node)",
        "snippet": "  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
        "begin_line": 75,
        "end_line": 115,
        "comment": "\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.isEmptyFunction#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.isEmptyFunction(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean isEmptyFunction(Node function) {\n    return function.getChildCount() == 3 &&\n           !function.getFirstChild().getNext().getNext().hasChildren();\n  }\n",
        "begin_line": 179,
        "end_line": 182,
        "comment": "\n   * @return {@code true} if function represents a JavaScript function\n   *     with an empty body\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.normalizeClassType#206",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.normalizeClassType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isNominalConstructor()) {\n      return (type.toMaybeFunctionType()).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((ObjectType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }\n",
        "begin_line": 206,
        "end_line": 218,
        "comment": "\n   * Normalize the type of a constructor, its instance, and its prototype\n   * all down to the same type (the instance type).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompilerOptions.setTrustedStrings#726",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setTrustedStrings(boolean)",
        "snippet": "  public void setTrustedStrings(boolean yes) {\n    trustedStrings = yes;\n  }\n",
        "begin_line": 726,
        "end_line": 728,
        "comment": "\n   * Some people want to put arbitrary user input into strings, which are then\n   * run through the compiler. These scripts are then put into HTML.\n   * By default, we assume strings are untrusted. If the compiler is run\n   * from the command-line, we assume that strings are trusted.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "CompilerOptions.setSummaryDetailLevel#1416",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setSummaryDetailLevel(int)",
        "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }\n",
        "begin_line": 1416,
        "end_line": 1418,
        "comment": "\n   * Controls how detailed the compilation summary is. Values:\n   *  0 (never print summary), 1 (print summary only if there are\n   * errors or warnings), 2 (print summary if type checking is on,\n   * see --check_types), 3 (always print summary). The default level\n   * is 1\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.shouldRunCompiler#927",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.shouldRunCompiler()",
        "snippet": "  public boolean shouldRunCompiler() {\n    return this.isConfigValid;\n  }\n",
        "begin_line": 927,
        "end_line": 929,
        "comment": "\n   * @return Whether the configuration is valid.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setRunOptions#256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.setRunOptions(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    if (config.warningGuards != null) {\n      for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {\n        diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level);\n      }\n    }\n\n    if (!config.warningsWhitelistFile.isEmpty()) {\n      options.addWarningsGuard(\n          WhitelistWarningsGuard.fromFile(\n              new File(config.warningsWhitelistFile)));\n    }\n\n    createDefineOrTweakReplacements(config.define, options, false);\n\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n\n    DependencyOptions depOptions = createDependencyOptions(\n        config.manageClosureDependencies,\n        config.onlyClosureDependencies,\n        config.processCommonJSModules,\n        config.closureEntryPoints);\n    if (depOptions != null) {\n      options.setDependencyOptions(depOptions);\n    }\n\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n    options.setTrustedStrings(true);\n\n    legacyOutputCharset = options.outputCharset = getLegacyOutputCharset();\n    outputCharset2 = getOutputCharset2();\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      if (config.skipNormalOutputs) {\n        throw new FlagUsageException(\"skip_normal_outputs and js_output_file\"\n            + \" cannot be used together.\");\n      }\n    }\n\n    if (config.skipNormalOutputs && config.printAst) {\n      throw new FlagUsageException(\"skip_normal_outputs and print_ast cannot\"\n          + \" be used together.\");\n    }\n\n    if (config.skipNormalOutputs && config.printTree) {\n      throw new FlagUsageException(\"skip_normal_outputs and print_tree cannot\"\n          + \" be used together.\");\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMap =\n          VariableMap.load(config.variableMapInputFile);\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMap =\n          VariableMap.load(config.propertyMapInputFile);\n    }\n\n    if (config.languageIn.length() > 0) {\n      CompilerOptions.LanguageMode languageMode =\n          CompilerOptions.LanguageMode.fromString(config.languageIn);\n      if (languageMode != null) {\n        options.setLanguageIn(languageMode);\n      } else {\n        throw new FlagUsageException(\"Unknown language `\" + config.languageIn +\n                                     \"' specified.\");\n      }\n    }\n\n    if (!config.outputManifests.isEmpty()) {\n      Set<String> uniqueNames = Sets.newHashSet();\n      for (String filename : config.outputManifests) {\n        if (!uniqueNames.add(filename)) {\n          throw new FlagUsageException(\"output_manifest flags specify \" +\n              \"duplicate file names: \" + filename);\n        }\n      }\n    }\n\n    if (!config.outputBundles.isEmpty()) {\n      Set<String> uniqueNames = Sets.newHashSet();\n      for (String filename : config.outputBundles) {\n        if (!uniqueNames.add(filename)) {\n          throw new FlagUsageException(\"output_bundle flags specify \" +\n              \"duplicate file names: \" + filename);\n        }\n      }\n    }\n\n    options.acceptConstKeyword = config.acceptConstKeyword;\n    options.transformAMDToCJSModules = config.transformAMDToCJSModules;\n    options.processCommonJSModules = config.processCommonJSModules;\n    options.commonJSModulePathPrefix = config.commonJSModulePathPrefix;\n  }\n",
        "begin_line": 256,
        "end_line": 363,
        "comment": "\n   * Sets options based on the configurations set flags API.\n   * Called during the run() run() method.\n   * If you want to ignore the flags API, or interpret flags your own way,\n   * then you should override this method.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getInputCharset#971",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getInputCharset()",
        "snippet": "  private Charset getInputCharset() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return Charset.forName(config.charset);\n    }\n    return Charsets.UTF_8;\n  }\n",
        "begin_line": 971,
        "end_line": 980,
        "comment": "\n   * Query the flag for the input charset, and return a Charset object\n   * representing the selection.\n   *\n   * @return Charset to use when reading inputs\n   * @throws FlagUsageException if flag is not a valid Charset name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getLegacyOutputCharset#994",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getLegacyOutputCharset()",
        "snippet": "  private String getLegacyOutputCharset() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return config.charset;\n    }\n    return \"US-ASCII\";\n  }\n",
        "begin_line": 994,
        "end_line": 1003,
        "comment": "\n   * Query the flag for the output charset.\n   *\n   * Let the outputCharset be the same as the input charset... except if\n   * we're reading in UTF-8 by default.  By tradition, we've always\n   * output ASCII to avoid various hiccups with different browsers,\n   * proxies and firewalls.\n   *\n   * @return Name of the charset to use when writing outputs. Guaranteed to\n   *    be a supported charset.\n   * @throws FlagUsageException if flag is not a valid Charset name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getOutputCharset2#1009",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getOutputCharset2()",
        "snippet": "  private Charset getOutputCharset2() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return Charset.forName(config.charset);\n    }\n    return Charsets.UTF_8;\n  }\n",
        "begin_line": 1009,
        "end_line": 1018,
        "comment": "\n   * Query the flag for the output charset. Defaults to UTF-8.\n   * @throws FlagUsageException if flag is not a valid Charset name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1016
        },
        "num_failing_tests": 3
    },
    {
        "name": "Node.Node#442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node, int, int)",
        "snippet": "  public Node(int nodeType, Node child, int lineno, int charno) {\n    this(nodeType, child);\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 442,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocInfoParser.wrapNode#2222",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int, com.google.javascript.rhino.Node)",
        "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 2222,
        "end_line": 2226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocInfoParser.skipEOLs#2345",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
        "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }\n",
        "begin_line": 2345,
        "end_line": 2352,
        "comment": "\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 4
    },
    {
        "name": "RemoveUnusedVars.markReferencedVar#787",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.markReferencedVar(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 787,
        "end_line": 795,
        "comment": "\n   * Marks a var as referenced, recursing into any values of this var\n   * that we skipped.\n   * @return True if this variable had not been referenced before.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CompilerOptions.setTweakProcessing#1453",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setTweakProcessing(com.google.javascript.jscomp.CompilerOptions.TweakProcessing)",
        "snippet": "  public void setTweakProcessing(TweakProcessing tweakProcessing) {\n    this.tweakProcessing = tweakProcessing;\n  }\n",
        "begin_line": 1453,
        "end_line": 1455,
        "comment": "\n   * Sets how goog.tweak calls are processed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "Compiler.setLoggingLevel#2229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setLoggingLevel(java.util.logging.Level)",
        "snippet": "  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n",
        "begin_line": 2229,
        "end_line": 2231,
        "comment": "\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.getJsFiles#438",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.getJsFiles()",
        "snippet": "    List<String> getJsFiles() {\n      List<String> allJsInputs = Lists.newArrayListWithCapacity(\n          js.size() + arguments.size());\n      allJsInputs.addAll(js);\n      allJsInputs.addAll(arguments);\n      return allJsInputs;\n    }\n",
        "begin_line": 438,
        "end_line": 444,
        "comment": "\n     * Users may specify JS inputs via the legacy {@code --js} option, as well\n     * as via additional arguments to the Closure Compiler. For example, it is\n     * convenient to leverage the additional arguments feature when using the\n     * Closure Compiler in combination with {@code find} and {@code xargs}:\n     * <pre>\n     * find MY_JS_SRC_DIR -name '*.js' \\\n     *     | xargs java -jar compiler.jar --manage_closure_dependencies\n     * </pre>\n     * The {@code find} command will produce a list of '*.js' source files in\n     * the {@code MY_JS_SRC_DIR} directory while {@code xargs} will convert them\n     * to a single, space-delimited set of arguments that are appended to the\n     * {@code java} command to run the Compiler.\n     * <p>\n     * Note that it is important to use the\n     * {@code --manage_closure_dependencies} option in this case because the\n     * order produced by {@code find} is unlikely to be sorted correctly with\n     * respect to {@code goog.provide()} and {@code goog.requires()}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.initConfigFromFlags#663",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.initConfigFromFlags(java.lang.String[], java.io.PrintStream)",
        "snippet": "  private void initConfigFromFlags(String[] args, PrintStream err) {\n\n    List<String> processedArgs = processArgs(args);\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    Flags.warningGuardSpec.clear();\n    isConfigValid = true;\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n      // For contains --flagfile flag\n      if (!flags.flag_file.equals(\"\")) {\n        processFlagFile(err);\n      }\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      isConfigValid = false;\n    } catch (IOException ioErr) {\n      err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n      isConfigValid = false;\n    }\n\n    if (flags.version) {\n      err.println(\n          \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n          \"Version: \" + Compiler.getReleaseVersion() + \"\\n\" +\n          \"Built on: \" + Compiler.getReleaseDate());\n      err.flush();\n    }\n\n    if (flags.process_common_js_modules) {\n      flags.process_closure_primitives = true;\n      flags.manage_closure_dependencies = true;\n      if (flags.common_js_entry_module == null) {\n        err.println(\"Please specify --common_js_entry_module.\");\n        err.flush();\n        isConfigValid = false;\n      }\n      flags.closure_entry_point = Lists.newArrayList(\n          ProcessCommonJSModules.toModuleName(flags.common_js_entry_module));\n    }\n\n    if (!isConfigValid || flags.display_help) {\n      isConfigValid = false;\n      parser.printUsage(err);\n    } else {\n      CodingConvention conv;\n      if (flags.third_party) {\n        conv = CodingConventions.getDefault();\n      } else if (flags.process_jquery_primitives) {\n        conv = new JqueryCodingConvention();\n      } else {\n        conv = new ClosureCodingConvention();\n      }\n\n      getCommandLineConfig()\n          .setPrintTree(flags.print_tree)\n          .setPrintAst(flags.print_ast)\n          .setPrintPassGraph(flags.print_pass_graph)\n          .setJscompDevMode(flags.jscomp_dev_mode)\n          .setLoggingLevel(flags.logging_level)\n          .setExterns(flags.externs)\n          .setJs(flags.getJsFiles())\n          .setJsOutputFile(flags.js_output_file)\n          .setModule(flags.module)\n          .setVariableMapInputFile(flags.variable_map_input_file)\n          .setPropertyMapInputFile(flags.property_map_input_file)\n          .setVariableMapOutputFile(flags.variable_map_output_file)\n          .setCreateNameMapFiles(flags.create_name_map_files)\n          .setPropertyMapOutputFile(flags.property_map_output_file)\n          .setCodingConvention(conv)\n          .setSummaryDetailLevel(flags.summary_detail_level)\n          .setOutputWrapper(flags.output_wrapper)\n          .setModuleWrapper(flags.module_wrapper)\n          .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n          .setCreateSourceMap(flags.create_source_map)\n          .setSourceMapFormat(flags.source_map_format)\n          .setWarningGuardSpec(Flags.warningGuardSpec)\n          .setDefine(flags.define)\n          .setCharset(flags.charset)\n          .setManageClosureDependencies(flags.manage_closure_dependencies)\n          .setOnlyClosureDependencies(flags.only_closure_dependencies)\n          .setClosureEntryPoints(flags.closure_entry_point)\n          .setOutputManifest(ImmutableList.of(flags.output_manifest))\n          .setOutputModuleDependencies(flags.output_module_dependencies)\n          .setAcceptConstKeyword(flags.accept_const_keyword)\n          .setLanguageIn(flags.language_in)\n          .setProcessCommonJSModules(flags.process_common_js_modules)\n          .setCommonJSModulePathPrefix(flags.common_js_path_prefix)\n          .setTransformAMDToCJSModules(flags.transform_amd_modules)\n          .setWarningsWhitelistFile(flags.warnings_whitelist_file);\n    }\n  }\n",
        "begin_line": 663,
        "end_line": 754,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.createOptions#756",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.createOptions()",
        "snippet": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.process_jquery_primitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.use_types_for_optimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generate_exports) {\n      options.setGenerateExports(flags.generate_exports);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n\n    options.jqueryPass = flags.process_jquery_primitives &&\n        CompilationLevel.ADVANCED_OPTIMIZATIONS == level;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it.\n      options.messageBundle = new EmptyMessageBundle();\n    }\n\n    return options;\n  }\n",
        "begin_line": 756,
        "end_line": 811,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.createCompiler#813",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.createCompiler()",
        "snippet": "  @Override\n  protected Compiler createCompiler() {\n    return new Compiler(getErrorPrintStream());\n  }\n",
        "begin_line": 813,
        "end_line": 816,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.createExterns#818",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.createExterns()",
        "snippet": "  @Override\n  protected List<SourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    List<SourceFile> externs = super.createExterns();\n    if (flags.use_only_custom_externs || isInTestMode()) {\n      return externs;\n    } else {\n      List<SourceFile> defaultExterns = getDefaultExterns();\n      defaultExterns.addAll(externs);\n      return defaultExterns;\n    }\n  }\n",
        "begin_line": 818,
        "end_line": 829,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setPrintTree#1598",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setPrintTree(boolean)",
        "snippet": "    CommandLineConfig setPrintTree(boolean printTree) {\n      this.printTree = printTree;\n      return this;\n    }\n",
        "begin_line": 1598,
        "end_line": 1601,
        "comment": " Prints out the parse tree and exits ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setPrintAst#1620",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setPrintAst(boolean)",
        "snippet": "    CommandLineConfig setPrintAst(boolean printAst) {\n      this.printAst = printAst;\n      return this;\n    }\n",
        "begin_line": 1620,
        "end_line": 1623,
        "comment": "\n     * Prints a dot file describing the internal abstract syntax tree\n     * and exits\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setPrintPassGraph#1628",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setPrintPassGraph(boolean)",
        "snippet": "    CommandLineConfig setPrintPassGraph(boolean printPassGraph) {\n      this.printPassGraph = printPassGraph;\n      return this;\n    }\n",
        "begin_line": 1628,
        "end_line": 1631,
        "comment": " Prints a dot file describing the passes that will get run and exits ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setJscompDevMode#1636",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setJscompDevMode(com.google.javascript.jscomp.CompilerOptions.DevMode)",
        "snippet": "    CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) {\n      this.jscompDevMode = jscompDevMode;\n      return this;\n    }\n",
        "begin_line": 1636,
        "end_line": 1639,
        "comment": " Turns on extra sanity checks ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setLoggingLevel#1648",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setLoggingLevel(java.lang.String)",
        "snippet": "    CommandLineConfig setLoggingLevel(String loggingLevel) {\n      this.loggingLevel = loggingLevel;\n      return this;\n    }\n",
        "begin_line": 1648,
        "end_line": 1651,
        "comment": "\n     * The logging level (standard java.util.logging.Level\n     * values) for Compiler progress. Does not control errors or\n     * warnings for the JavaScript code under compilation\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setExterns#1658",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setExterns(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setExterns(List<String> externs) {\n      this.externs.clear();\n      this.externs.addAll(externs);\n      return this;\n    }\n",
        "begin_line": 1658,
        "end_line": 1662,
        "comment": "\n     * The file containing JavaScript externs. You may specify multiple.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setJs#1669",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setJs(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setJs(List<String> js) {\n      this.js.clear();\n      this.js.addAll(js);\n      return this;\n    }\n",
        "begin_line": 1669,
        "end_line": 1673,
        "comment": "\n     * The JavaScript filename. You may specify multiple.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setJsOutputFile#1680",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setJsOutputFile(java.lang.String)",
        "snippet": "    CommandLineConfig setJsOutputFile(String jsOutputFile) {\n      this.jsOutputFile = jsOutputFile;\n      return this;\n    }\n",
        "begin_line": 1680,
        "end_line": 1683,
        "comment": "\n     * Primary output filename. If not specified, output is written to stdout\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setModule#1695",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setModule(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setModule(List<String> module) {\n      this.module.clear();\n      this.module.addAll(module);\n      return this;\n    }\n",
        "begin_line": 1695,
        "end_line": 1699,
        "comment": "\n     * A JavaScript module specification. The format is\n     * <name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be\n     * unique. Each dep is the name of a module that this module\n     * depends on. Modules must be listed in dependency order, and JS\n     * source files must be listed in the corresponding order. Where\n     * --module flags occur in relation to --js flags is unimportant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setVariableMapInputFile#1707",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setVariableMapInputFile(java.lang.String)",
        "snippet": "    CommandLineConfig setVariableMapInputFile(String variableMapInputFile) {\n      this.variableMapInputFile = variableMapInputFile;\n      return this;\n    }\n",
        "begin_line": 1707,
        "end_line": 1710,
        "comment": "\n     * File containing the serialized version of the variable renaming\n     * map produced by a previous compilation\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setPropertyMapInputFile#1718",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setPropertyMapInputFile(java.lang.String)",
        "snippet": "    CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) {\n      this.propertyMapInputFile = propertyMapInputFile;\n      return this;\n    }\n",
        "begin_line": 1718,
        "end_line": 1721,
        "comment": "\n     * File containing the serialized version of the property renaming\n     * map produced by a previous compilation\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setVariableMapOutputFile#1729",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setVariableMapOutputFile(java.lang.String)",
        "snippet": "    CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) {\n      this.variableMapOutputFile = variableMapOutputFile;\n      return this;\n    }\n",
        "begin_line": 1729,
        "end_line": 1732,
        "comment": "\n     * File where the serialized version of the variable renaming map\n     * produced should be saved\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setCreateNameMapFiles#1743",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setCreateNameMapFiles(boolean)",
        "snippet": "    CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) {\n      this.createNameMapFiles = createNameMapFiles;\n      return this;\n    }\n",
        "begin_line": 1743,
        "end_line": 1746,
        "comment": "\n     * If true, variable renaming and property renaming map\n     * files will be produced as {binary name}_vars_map.out and\n     * {binary name}_props_map.out. Note that this flag cannot be used\n     * in conjunction with either variable_map_output_file or\n     * property_map_output_file\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setPropertyMapOutputFile#1754",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setPropertyMapOutputFile(java.lang.String)",
        "snippet": "    CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) {\n      this.propertyMapOutputFile = propertyMapOutputFile;\n      return this;\n    }\n",
        "begin_line": 1754,
        "end_line": 1757,
        "comment": "\n     * File where the serialized version of the property renaming map\n     * produced should be saved\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setCodingConvention#1764",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setCodingConvention(com.google.javascript.jscomp.CodingConvention)",
        "snippet": "    CommandLineConfig setCodingConvention(CodingConvention codingConvention) {\n      this.codingConvention = codingConvention;\n      return this;\n    }\n",
        "begin_line": 1764,
        "end_line": 1767,
        "comment": "\n     * Sets rules and conventions to enforce.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setSummaryDetailLevel#1778",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setSummaryDetailLevel(int)",
        "snippet": "    CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) {\n      this.summaryDetailLevel = summaryDetailLevel;\n      return this;\n    }\n",
        "begin_line": 1778,
        "end_line": 1781,
        "comment": "\n     * Controls how detailed the compilation summary is. Values:\n     *  0 (never print summary), 1 (print summary only if there are\n     * errors or warnings), 2 (print summary if type checking is on,\n     * see --check_types), 3 (always print summary). The default level\n     * is 1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setOutputWrapper#1789",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setOutputWrapper(java.lang.String)",
        "snippet": "    CommandLineConfig setOutputWrapper(String outputWrapper) {\n      this.outputWrapper = outputWrapper;\n      return this;\n    }\n",
        "begin_line": 1789,
        "end_line": 1792,
        "comment": "\n     * Interpolate output into this string at the place denoted\n     * by the marker token %output%, or %output|jsstring%\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setModuleWrapper#1800",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setModuleWrapper(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n      this.moduleWrapper.clear();\n      this.moduleWrapper.addAll(moduleWrapper);\n      return this;\n    }\n",
        "begin_line": 1800,
        "end_line": 1804,
        "comment": "\n     * An output wrapper for a JavaScript module (optional). See the flag\n     * description for formatting requirements.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setModuleOutputPathPrefix#1813",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setModuleOutputPathPrefix(java.lang.String)",
        "snippet": "    CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {\n      this.moduleOutputPathPrefix = moduleOutputPathPrefix;\n      return this;\n    }\n",
        "begin_line": 1813,
        "end_line": 1816,
        "comment": "\n     * Prefix for filenames of compiled JS modules.\n     * <module-name>.js will be appended to this prefix. Directories\n     * will be created as needed. Use with --module\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setCreateSourceMap#1827",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setCreateSourceMap(java.lang.String)",
        "snippet": "    CommandLineConfig setCreateSourceMap(String createSourceMap) {\n      this.createSourceMap = createSourceMap;\n      return this;\n    }\n",
        "begin_line": 1827,
        "end_line": 1830,
        "comment": "\n     * If specified, a source map file mapping the generated\n     * source files back to the original source file will be\n     * output to the specified path. The %outname% placeholder will\n     * expand to the name of the output file that the source map\n     * corresponds to.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setSourceMapFormat#1849",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setSourceMapFormat(com.google.javascript.jscomp.SourceMap.Format)",
        "snippet": "    CommandLineConfig setSourceMapFormat(SourceMap.Format format) {\n      this.sourceMapFormat = format;\n      return this;\n    }\n",
        "begin_line": 1849,
        "end_line": 1852,
        "comment": "\n     * The detail supplied in the source map file, if generated.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setWarningGuardSpec#1859",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setWarningGuardSpec(com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec)",
        "snippet": "    CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {\n      this.warningGuards = spec;\n      return this;\n    }\n",
        "begin_line": 1859,
        "end_line": 1862,
        "comment": "\n     * Add warning guards.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setDefine#1873",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setDefine(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setDefine(List<String> define) {\n      this.define.clear();\n      this.define.addAll(define);\n      return this;\n    }\n",
        "begin_line": 1873,
        "end_line": 1877,
        "comment": "\n     * Override the value of a variable annotated @define.\n     * The format is <name>[=<val>], where <name> is the name of a @define\n     * variable and <val> is a boolean, number, or a single-quoted string\n     * that contains no single quotes. If [=<val>] is omitted,\n     * the variable is marked true\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setCharset#1908",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setCharset(java.lang.String)",
        "snippet": "    CommandLineConfig setCharset(String charset) {\n      this.charset = charset;\n      return this;\n    }\n",
        "begin_line": 1908,
        "end_line": 1911,
        "comment": "\n     * Input charset for all files.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setManageClosureDependencies#1919",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setManageClosureDependencies(boolean)",
        "snippet": "    CommandLineConfig setManageClosureDependencies(boolean newVal) {\n      this.manageClosureDependencies = newVal;\n      return this;\n    }\n",
        "begin_line": 1919,
        "end_line": 1922,
        "comment": "\n     * Sets whether to sort files by their goog.provide/require deps,\n     * and prune inputs that are not required.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setOnlyClosureDependencies#1931",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setOnlyClosureDependencies(boolean)",
        "snippet": "    CommandLineConfig setOnlyClosureDependencies(boolean newVal) {\n      this.onlyClosureDependencies = newVal;\n      return this;\n    }\n",
        "begin_line": 1931,
        "end_line": 1934,
        "comment": "\n     * Sets whether to sort files by their goog.provide/require deps,\n     * and prune inputs that are not required, and drop all non-closure\n     * files.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setClosureEntryPoints#1942",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setClosureEntryPoints(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setClosureEntryPoints(List<String> entryPoints) {\n      Preconditions.checkNotNull(entryPoints);\n      this.closureEntryPoints = entryPoints;\n      return this;\n    }\n",
        "begin_line": 1942,
        "end_line": 1946,
        "comment": "\n     * Set closure entry points, which makes the compiler only include\n     * those files and sort them in dependency order.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setOutputManifest#1954",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setOutputManifest(java.util.List<java.lang.String>)",
        "snippet": "    CommandLineConfig setOutputManifest(List<String> outputManifests) {\n      this.outputManifests = Lists.newArrayList();\n      for (String manifestName : outputManifests) {\n        if (!manifestName.isEmpty()) {\n          this.outputManifests.add(manifestName);\n        }\n      }\n      this.outputManifests = ImmutableList.copyOf(this.outputManifests);\n      return this;\n    }\n",
        "begin_line": 1954,
        "end_line": 1963,
        "comment": "\n     * Sets whether to print output manifest files.\n     * Filter out empty file names.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setOutputModuleDependencies#1971",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setOutputModuleDependencies(java.lang.String)",
        "snippet": "    CommandLineConfig setOutputModuleDependencies(String\n        outputModuleDependencies) {\n      this.outputModuleDependencies = outputModuleDependencies;\n      return this;\n    }\n",
        "begin_line": 1971,
        "end_line": 1975,
        "comment": "\n     * Sets whether a JSON file representing the dependencies between modules\n     * should be created.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setAcceptConstKeyword#1992",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setAcceptConstKeyword(boolean)",
        "snippet": "    CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) {\n      this.acceptConstKeyword = acceptConstKeyword;\n      return this;\n    }\n",
        "begin_line": 1992,
        "end_line": 1995,
        "comment": "\n     * Sets whether to accept usage of 'const' keyword.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setLanguageIn#2003",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setLanguageIn(java.lang.String)",
        "snippet": "    CommandLineConfig setLanguageIn(String languageIn) {\n      this.languageIn = languageIn;\n      return this;\n    }\n",
        "begin_line": 2003,
        "end_line": 2006,
        "comment": "\n     * Sets whether to accept input files as ECMAScript5 compliant.\n     * Otherwise, input files are treated as ECMAScript3 compliant.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setTransformAMDToCJSModules#2034",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setTransformAMDToCJSModules(boolean)",
        "snippet": "    CommandLineConfig setTransformAMDToCJSModules(\n        boolean transformAMDToCJSModules) {\n      this.transformAMDToCJSModules = transformAMDToCJSModules;\n      return this;\n    }\n",
        "begin_line": 2034,
        "end_line": 2038,
        "comment": "\n     * Set whether to transform AMD to CommonJS modules.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setProcessCommonJSModules#2045",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setProcessCommonJSModules(boolean)",
        "snippet": "    CommandLineConfig setProcessCommonJSModules(\n        boolean processCommonJSModules) {\n      this.processCommonJSModules = processCommonJSModules;\n      return this;\n    }\n",
        "begin_line": 2045,
        "end_line": 2049,
        "comment": "\n     * Sets whether to process CommonJS modules.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setCommonJSModulePathPrefix#2058",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setCommonJSModulePathPrefix(java.lang.String)",
        "snippet": "    CommandLineConfig setCommonJSModulePathPrefix(\n        String commonJSModulePathPrefix) {\n      this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n      return this;\n    }\n",
        "begin_line": 2058,
        "end_line": 2062,
        "comment": "\n     * Sets the CommonJS module path prefix.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.setWarningsWhitelistFile#2069",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig.setWarningsWhitelistFile(java.lang.String)",
        "snippet": "    CommandLineConfig setWarningsWhitelistFile(String fileName) {\n      this.warningsWhitelistFile = fileName;\n      return this;\n    }\n",
        "begin_line": 2069,
        "end_line": 2072,
        "comment": "\n     * Sets a whitelist file that suppresses warnings.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.isInTestMode#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.isInTestMode()",
        "snippet": "  protected boolean isInTestMode() {\n    return testMode;\n  }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "\n   * Returns whether we're in test mode.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getCommandLineConfig#181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getCommandLineConfig()",
        "snippet": "  protected CommandLineConfig getCommandLineConfig() {\n    return config;\n  }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n   * Get the command line config, so that it can be initialized.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getDiagnosticGroups#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getDiagnosticGroups()",
        "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    if (compiler == null) {\n      return new DiagnosticGroups();\n    }\n    return compiler.getDiagnosticGroups();\n  }\n",
        "begin_line": 201,
        "end_line": 206,
        "comment": "\n   * The warning classes that are available from the command-line.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.getErrorPrintStream#417",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getErrorPrintStream()",
        "snippet": "  protected PrintStream getErrorPrintStream() {\n    return err;\n  }\n",
        "begin_line": 417,
        "end_line": 419,
        "comment": "\n   * Returns the PrintStream for writing errors associated with this\n   * AbstractCommandLineRunner.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.createExterns#1020",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createExterns()",
        "snippet": "  protected List<SourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    return isInTestMode() ? externsSupplierForTesting.get() :\n        createExternInputs(config.externs);\n  }\n",
        "begin_line": 1020,
        "end_line": 1024,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.createDefineOrTweakReplacements#1293",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createDefineOrTweakReplacements(java.util.List<java.lang.String>, com.google.javascript.jscomp.CompilerOptions, boolean)",
        "snippet": "  @VisibleForTesting\n  static void createDefineOrTweakReplacements(List<String> definitions,\n      CompilerOptions options, boolean tweaks) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        String defValue = assignment.length == 1 ? \"true\" : assignment[1];\n\n        boolean isTrue = defValue.equals(\"true\");\n        boolean isFalse = defValue.equals(\"false\");\n        if (isTrue || isFalse) {\n          if (tweaks) {\n            options.setTweakToBooleanLiteral(defName, isTrue);\n          } else {\n            options.setDefineToBooleanLiteral(defName, isTrue);\n          }\n          continue;\n        } else if (defValue.length() > 1\n            && ((defValue.charAt(0) == '\\'' &&\n                defValue.charAt(defValue.length() - 1) == '\\'')\n                || (defValue.charAt(0) == '\\\"' &&\n                    defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n          // If the value starts and ends with a single quote,\n          // we assume that it's a string.\n          String maybeStringVal =\n              defValue.substring(1, defValue.length() - 1);\n          if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n            if (tweaks) {\n              options.setTweakToStringLiteral(defName, maybeStringVal);\n            } else {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n            }\n            continue;\n          }\n        } else {\n          try {\n            double value = Double.parseDouble(defValue);\n            if (tweaks) {\n              options.setTweakToDoubleLiteral(defName, value);\n            } else {\n              options.setDefineToDoubleLiteral(defName, value);\n            }\n            continue;\n          } catch (NumberFormatException e) {\n            // do nothing, it will be caught at the end\n          }\n        }\n      }\n\n      if (tweaks) {\n        throw new RuntimeException(\n            \"--tweak flag syntax invalid: \" + override);\n      }\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }\n",
        "begin_line": 1293,
        "end_line": 1352,
        "comment": "\n   * Create a map of constant names to constant values from a textual\n   * description of the map.\n   *\n   * @param definitions A list of overriding definitions for defines in\n   *     the form <name>[=<val>], where <val> is a number, boolean, or\n   *     single-quoted string without single quotes.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1011
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfoBuilder.markName#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(java.lang.String, com.google.javascript.rhino.jstype.StaticSourceFile, int, int)",
        "snippet": "  public void markName(String name, StaticSourceFile file,\n      int lineno, int charno) {\n    if (currentMarker != null) {\n      // Record the name as both a SourcePosition<String> and a\n      // SourcePosition<Node>. The <String> form is deprecated,\n      // because <Node> is more consistent with how other name\n      // references are handled (see #markTypeNode)\n      //\n      // TODO(nicksantos): Remove all uses of the Name position\n      // and replace them with the NameNode position.\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(name);\n      position.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setName(position);\n\n      SourcePosition<Node> nodePos =\n          new JSDocInfo.NamePosition();\n      Node node = Node.newString(Token.NAME, name, lineno, charno);\n      node.setLength(name.length());\n      node.setStaticSourceFile(file);\n      nodePos.setItem(node);\n      nodePos.setPositionInformation(lineno, charno,\n          lineno, charno + name.length());\n      currentMarker.setNameNode(nodePos);\n    }\n  }\n",
        "begin_line": 205,
        "end_line": 232,
        "comment": "\n   * Adds a name declaration to the current marker.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfoBuilder.recordParameter#266",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(java.lang.String, com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 266,
        "end_line": 274,
        "comment": "\n   * Records a typed parameter.\n   *\n   * @return {@code true} if the typed parameter was recorded and\n   *     {@code false} if a parameter with the same name was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "JSDocInfo.declareParam#925",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(com.google.javascript.rhino.JSTypeExpression, java.lang.String)",
        "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 925,
        "end_line": 936,
        "comment": "\n   * Declares a parameter. Parameters are described using the {@code @param}\n   * annotation.\n   *\n   * @param jsType the parameter's type, it may be {@code null} when the\n   *     {@code @param} annotation did not specify a type.\n   * @param parameter the parameter's name\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "JsDocInfoParser.parseAndRecordParamTypeNode#1156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    if (typeNode != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n\n      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n          endLineno, endCharno, true);\n    }\n    return typeNode;\n  }\n",
        "begin_line": 1156,
        "end_line": 1170,
        "comment": "\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * Parameter type expressions are special for two reasons:\n   * <ol>\n   *   <li>They must begin with '{', to distinguish type names from param names.\n   *   <li>They may end in '=', to denote optionality.\n   * </ol>\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.WarningGuardWarningOptionHandler#503",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.WarningGuardWarningOptionHandler.WarningGuardWarningOptionHandler(org.kohsuke.args4j.CmdLineParser, org.kohsuke.args4j.OptionDef, org.kohsuke.args4j.spi.Setter<? super java.lang.String>)",
        "snippet": "      public WarningGuardWarningOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n        super(parser, option,\n            new WarningGuardSetter(setter, CheckLevel.WARNING));\n      }\n",
        "begin_line": 503,
        "end_line": 508,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.WarningGuardSetter#524",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.WarningGuardSetter.WarningGuardSetter(org.kohsuke.args4j.spi.Setter<? super java.lang.String>, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "      private WarningGuardSetter(\n          Setter<? super String> proxy, CheckLevel level) {\n        this.proxy = proxy;\n        this.level = level;\n      }\n",
        "begin_line": 524,
        "end_line": 528,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.WarningGuardOffOptionHandler#513",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.WarningGuardOffOptionHandler.WarningGuardOffOptionHandler(org.kohsuke.args4j.CmdLineParser, org.kohsuke.args4j.OptionDef, org.kohsuke.args4j.spi.Setter<? super java.lang.String>)",
        "snippet": "      public WarningGuardOffOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n        super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF));\n      }\n",
        "begin_line": 513,
        "end_line": 517,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.WarningGuardErrorOptionHandler#494",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.WarningGuardErrorOptionHandler.WarningGuardErrorOptionHandler(org.kohsuke.args4j.CmdLineParser, org.kohsuke.args4j.OptionDef, org.kohsuke.args4j.spi.Setter<? super java.lang.String>)",
        "snippet": "      public WarningGuardErrorOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n        super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR));\n      }\n",
        "begin_line": 494,
        "end_line": 498,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.BooleanOptionHandler#454",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.Flags.BooleanOptionHandler.BooleanOptionHandler(org.kohsuke.args4j.CmdLineParser, org.kohsuke.args4j.OptionDef, org.kohsuke.args4j.spi.Setter<? super java.lang.Boolean>)",
        "snippet": "      public BooleanOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super Boolean> setter) {\n        super(parser, option, setter);\n      }\n",
        "begin_line": 454,
        "end_line": 458,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CommandLineRunner.CommandLineRunner#585",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.CommandLineRunner",
        "signature": "com.google.javascript.jscomp.CommandLineRunner.CommandLineRunner(java.lang.String[], java.io.PrintStream, java.io.PrintStream)",
        "snippet": "  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n    super(out, err);\n    initConfigFromFlags(args, err);\n  }\n",
        "begin_line": 585,
        "end_line": 588,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.clear#2097",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec.clear()",
        "snippet": "    protected void clear() {\n      entries.clear();\n    }\n",
        "begin_line": 2097,
        "end_line": 2099,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "AbstractCommandLineRunner.AbstractCommandLineRunner#140",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractCommandLineRunner.java",
        "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
        "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.AbstractCommandLineRunner(java.io.PrintStream, java.io.PrintStream)",
        "snippet": "  AbstractCommandLineRunner(PrintStream out, PrintStream err) {\n    this.config = new CommandLineConfig();\n    this.jsOutput = Preconditions.checkNotNull(out);\n    this.err = Preconditions.checkNotNull(err);\n  }\n",
        "begin_line": 140,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 3
    },
    {
        "name": "CodingConventions.getSingletonGetterClassName#344",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public String getSingletonGetterClassName(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 344,
        "end_line": 347,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1002
        },
        "num_failing_tests": 3
    },
    {
        "name": "ClosureCodingConvention.getSingletonGetterClassName#281",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public String getSingletonGetterClassName(Node callNode) {\n    Node callArg = callNode.getFirstChild();\n    String callName = callArg.getQualifiedName();\n\n    // Use both the original name and the post-CollapseProperties name.\n    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n          \"goog$addSingletonGetter\".equals(callName)) ||\n        callNode.getChildCount() != 2) {\n      return super.getSingletonGetterClassName(callNode);\n    }\n\n    return callArg.getNext().getQualifiedName();\n  }\n",
        "begin_line": 281,
        "end_line": 294,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1002
        },
        "num_failing_tests": 3
    },
    {
        "name": "CodingConventions.getSingletonGetterClassName#150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getSingletonGetterClassName(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public String getSingletonGetterClassName(Node callNode) {\n      return nextConvention.getSingletonGetterClassName(callNode);\n    }\n",
        "begin_line": 150,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0998
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.isReferenceName#1783",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isReferenceName(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isReferenceName(Node n) {\n    return n.isName() && !n.getString().isEmpty();\n  }\n",
        "begin_line": 1783,
        "end_line": 1785,
        "comment": "\n   * @return Whether the name is a reference to a variable, function or\n   *       function parameter (not a label or a empty function expression name).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0998
        },
        "num_failing_tests": 4
    },
    {
        "name": "ClosureCodingConvention.getClassesDefinedByCall#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n    SubclassRelationship relationship =\n        super.getClassesDefinedByCall(callNode);\n    if (relationship != null) return relationship;\n\n    Node callName = callNode.getFirstChild();\n    SubclassType type = typeofClassDefiningName(callName);\n    if (type != null) {\n      Node subclass = null;\n      Node superclass = callNode.getLastChild();\n\n      // There are six possible syntaxes for a class-defining method:\n      // SubClass.inherits(SuperClass)\n      // goog.inherits(SubClass, SuperClass)\n      // goog$inherits(SubClass, SuperClass)\n      // SubClass.mixin(SuperClass.prototype)\n      // goog.mixin(SubClass.prototype, SuperClass.prototype)\n      // goog$mixin(SubClass.prototype, SuperClass.prototype)\n      boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n          callName.isGetProp();\n      if (isDeprecatedCall) {\n        // SubClass.inherits(SuperClass)\n        subclass = callName.getFirstChild();\n      } else if (callNode.getChildCount() == 3) {\n        // goog.inherits(SubClass, SuperClass)\n        subclass = callName.getNext();\n      } else {\n        return null;\n      }\n\n      if (type == SubclassType.MIXIN) {\n        // Only consider mixins that mix two prototypes as related to\n        // inheritance.\n        if (!endsWithPrototype(superclass)) {\n          return null;\n        }\n        if (!isDeprecatedCall) {\n          if (!endsWithPrototype(subclass)) {\n            return null;\n          }\n          // Strip off the prototype from the name.\n          subclass = subclass.getFirstChild();\n        }\n        superclass = superclass.getFirstChild();\n      }\n\n      // bail out if either of the side of the \"inherits\"\n      // isn't a real class name. This prevents us from\n      // doing something weird in cases like:\n      // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)\n      if (subclass != null &&\n          subclass.isUnscopedQualifiedName() &&\n          superclass.isUnscopedQualifiedName()) {\n        return new SubclassRelationship(type, subclass, superclass);\n      }\n    }\n\n    return null;\n  }\n",
        "begin_line": 94,
        "end_line": 153,
        "comment": "\n   * {@inheritDoc}\n   *\n   * <p>Understands several different inheritance patterns that occur in\n   * Google code (various uses of {@code inherits} and {@code mixin}).\n   ",
        "resolved_comments": {
            "com.google.javascript.jscomp.CodingConventions.Proxy": null
        },
        "susp": {
            "ochiai_susp": 0.0989
        },
        "num_failing_tests": 3
    },
    {
        "name": "IRFactory.processFunctionCall#695",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processFunctionCall(com.google.javascript.rhino.head.ast.FunctionCall)",
        "snippet": "    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      node.setLineno(node.getFirstChild().getLineno());\n      node.setCharno(node.getFirstChild().getCharno());\n      maybeSetLengthFrom(node, callNode);\n      return node;\n    }\n",
        "begin_line": 695,
        "end_line": 707,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0988
        },
        "num_failing_tests": 4
    },
    {
        "name": "PrepareAst.annotateCalls#158",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.annotateCalls(com.google.javascript.rhino.Node)",
        "snippet": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n",
        "begin_line": 158,
        "end_line": 174,
        "comment": "\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0988
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSType.isNominalConstructor#578",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isNominalConstructor()",
        "snippet": "  public final boolean isNominalConstructor() {\n    if (isConstructor() || isInterface()) {\n      FunctionType fn = toMaybeFunctionType();\n      if (fn == null) {\n        return false;\n      }\n\n      // Programmer-defined constructors will have a link\n      // back to the original function in the source tree.\n      // Structural constructors will not.\n      if (fn.getSource() != null) {\n        return true;\n      }\n\n      // Native constructors are always nominal.\n      return fn.isNativeObjectType();\n    }\n    return false;\n  }\n",
        "begin_line": 578,
        "end_line": 596,
        "comment": "\n   * Whether this type is the original constructor of a nominal type.\n   * Does not include structural constructors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "SortedDependencies.maybeGetInputProviding#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.maybeGetInputProviding(java.lang.String)",
        "snippet": "  public INPUT maybeGetInputProviding(String symbol) {\n    return provideMap.get(symbol);\n  }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": "\n   * Return the input that gives us the given symbol, or null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.enterScope#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth++;\n      }\n\n      if (methodDepth == 0) {\n        currentClass = getClassOfMethod(n, parent);\n      }\n      methodDepth++;\n    }\n  }\n",
        "begin_line": 138,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.exitScope#154",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth--;\n      }\n\n      methodDepth--;\n      if (methodDepth == 0) {\n        currentClass = null;\n      }\n    }\n  }\n",
        "begin_line": 154,
        "end_line": 168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.getClassOfMethod#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.getClassOfMethod(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.isAssign()) {\n      Node lValue = parent.getFirstChild();\n      if (NodeUtil.isGet(lValue)) {\n        // We have an assignment of the form \"a.b = ...\".\n        JSType lValueType = lValue.getJSType();\n        if (lValueType != null && lValueType.isNominalConstructor()) {\n          // If a.b is a constructor, then everything in this function\n          // belongs to the \"a.b\" type.\n          return (lValueType.toMaybeFunctionType()).getInstanceType();\n        } else {\n          // If a.b is not a constructor, then treat this as a method\n          // of whatever type is on \"a\".\n          return normalizeClassType(lValue.getFirstChild().getJSType());\n        }\n      } else {\n        // We have an assignment of the form \"a = ...\", so pull the\n        // type off the \"a\".\n        return normalizeClassType(lValue.getJSType());\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.isName()) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }\n",
        "begin_line": 174,
        "end_line": 200,
        "comment": "\n   * Gets the type of the class that \"owns\" a method, or null if\n   * we know that its un-owned.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.visit#225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n      case Token.FUNCTION:\n        checkFinalClassOverrides(t, n, parent);\n        break;\n    }\n  }\n",
        "begin_line": 225,
        "end_line": 244,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.checkFinalClassOverrides#370",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.checkFinalClassOverrides(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkFinalClassOverrides(NodeTraversal t, Node fn, Node parent) {\n    JSType type = fn.getJSType().toMaybeFunctionType();\n    if (type != null && type.isConstructor()) {\n      JSType finalParentClass = getFinalParentClass(getClassOfMethod(fn, parent));\n      if (finalParentClass != null) {\n        compiler.report(\n            t.makeError(fn, EXTEND_FINAL_CLASS,\n                type.getDisplayName(), finalParentClass.getDisplayName()));\n      }\n    }\n  }\n",
        "begin_line": 370,
        "end_line": 380,
        "comment": "\n   * Checks if a constructor is trying to override a final class.\n   * @param t The current traversal.\n   * @param name The name node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.isDeprecatedFunction#620",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.isDeprecatedFunction(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean isDeprecatedFunction(Node n, Node parent) {\n    if (n.isFunction()) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }\n",
        "begin_line": 620,
        "end_line": 629,
        "comment": "\n   * Returns whether this is a function node annotated as deprecated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.getTypeDeprecationInfo#636",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.getTypeDeprecationInfo(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private static String getTypeDeprecationInfo(JSType type) {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) {\n      ObjectType implicitProto = objType.getImplicitPrototype();\n      if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 636,
        "end_line": 656,
        "comment": "\n   * Returns the deprecation reason for the type if it is marked\n   * as being deprecated. Returns empty string if the type is deprecated\n   * but no reason was given. Returns null if the type is not deprecated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "MakeDeclaredNamesUnique.ContextualRenameInverter#274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.ContextualRenameInverter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    private ContextualRenameInverter(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n",
        "begin_line": 274,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0974
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.process#278",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node js) {\n      NodeTraversal.traverse(compiler, js, this);\n    }\n",
        "begin_line": 278,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0974
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.shouldTraverse#386",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }\n",
        "begin_line": 386,
        "end_line": 389,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0974
        },
        "num_failing_tests": 4
    },
    {
        "name": "MakeDeclaredNamesUnique.getContextualRenameInverter#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getContextualRenameInverter(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {\n    return new ContextualRenameInverter(compiler);\n  }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0974
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2028",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-4f008c5b-e2b4-43f4-8b1b-f235fe81fc98.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);\n    }\n",
        "begin_line": 2028,
        "end_line": 2031,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0974
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isString#2333",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isString()",
        "snippet": "  public boolean isString() {\n    return this.getType() == Token.STRING;\n  }\n",
        "begin_line": 2333,
        "end_line": 2335,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0959
        },
        "num_failing_tests": 5
    },
    {
        "name": "Node.copyInformationFromForTree#1731",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.copyInformationFromForTree(com.google.javascript.rhino.Node)",
        "snippet": "  public Node copyInformationFromForTree(Node other) {\n    copyInformationFrom(other);\n    for (Node child = getFirstChild();\n         child != null; child = child.getNext()) {\n      child.copyInformationFromForTree(other);\n    }\n\n    return this;\n  }\n",
        "begin_line": 1731,
        "end_line": 1739,
        "comment": " TODO(nicksantos): The semantics of this method are ill-defined. Delete it.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0953
        },
        "num_failing_tests": 2
    },
    {
        "name": "ClosureRewriteClass.isGoogDefineClass#395",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.isGoogDefineClass(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isGoogDefineClass(Node value) {\n    if (value != null && value.isCall()) {\n      String targetName = value.getFirstChild().getQualifiedName();\n      return (\"goog.defineClass\".equals(targetName) ||\n              \"goog.labs.classdef.defineClass\".equals(targetName));\n    }\n    return false;\n  }\n",
        "begin_line": 395,
        "end_line": 402,
        "comment": "\n   * @return Whether the call represents a class definition.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0949
        },
        "num_failing_tests": 3
    },
    {
        "name": "IRFactory.newNode#1426",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int, com.google.javascript.rhino.Node)",
        "snippet": "  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1426,
        "end_line": 1428,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0947
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getRoot#994",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getRoot()",
        "snippet": "  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n",
        "begin_line": 994,
        "end_line": 997,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isTrue#2353",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isTrue()",
        "snippet": "  public boolean isTrue() {\n    return this.getType() == Token.TRUE;\n  }\n",
        "begin_line": 2353,
        "end_line": 2355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaybeReachingVariableUse.addToUseIfLocal#261",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java",
        "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
        "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.addToUseIfLocal(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.MaybeReachingVariableUse.ReachingUses)",
        "snippet": "  private void addToUseIfLocal(String name, Node node, ReachingUses use) {\n    Var var = jsScope.getVar(name);\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n    if (!escaped.contains(var)) {\n      use.mayUseMap.put(var, node);\n    }\n  }\n",
        "begin_line": 261,
        "end_line": 269,
        "comment": "\n   * Sets the variable for the given name to the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "LiveVariablesAnalysis.addToSetIfLocal#277",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal(com.google.javascript.rhino.Node, java.util.BitSet)",
        "snippet": "  private void addToSetIfLocal(Node node, BitSet set) {\n    Preconditions.checkState(node.isName());\n    String name = node.getString();\n    if (!jsScope.isDeclared(name, false)) {\n      return;\n    }\n    Var var = jsScope.getVar(name);\n    if (!escaped.contains(var)) {\n      set.set(var.index);\n    }\n  }\n",
        "begin_line": 277,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "DependencyOptions.shouldDropMoochers#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.shouldDropMoochers()",
        "snippet": "  boolean shouldDropMoochers() {\n    return pruneDependencies && dropMoochers;\n  }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "DependencyOptions.getEntryPoints#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.getEntryPoints()",
        "snippet": "  Collection<String> getEntryPoints() {\n    return entryPoints;\n  }\n",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0945
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckSideEffects.visit#83",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult() || n.isBlock()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperator(n);\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n",
        "begin_line": 83,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0943
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodingConventions.getClassesDefinedByCall#103",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n      return nextConvention.getClassesDefinedByCall(callNode);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0937
        },
        "num_failing_tests": 3
    },
    {
        "name": "CodingConventions.getClassesDefinedByCall#296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.getClassesDefinedByCall(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n      return null;\n    }\n",
        "begin_line": 296,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0937
        },
        "num_failing_tests": 3
    },
    {
        "name": "ConstCheck.visit#58",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConstCheck.java",
        "class_name": "com.google.javascript.jscomp.ConstCheck",
        "signature": "com.google.javascript.jscomp.ConstCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        if (parent != null &&\n            parent.isVar() &&\n            n.hasChildren()) {\n          String name = n.getString();\n          Scope.Var var = t.getScope().getVar(name);\n          if (isConstant(var)) {\n            if (initializedConstants.contains(var)) {\n              reportError(t, n, name);\n            } else {\n              initializedConstants.add(var);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD: {\n        Node lhs = n.getFirstChild();\n        if (lhs.isName()) {\n          String name = lhs.getString();\n          Scope.Var var = t.getScope().getVar(name);\n          if (isConstant(var)) {\n            if (initializedConstants.contains(var)) {\n              reportError(t, n, name);\n            } else {\n              initializedConstants.add(var);\n            }\n          }\n        }\n        break;\n      }\n\n      case Token.INC:\n      case Token.DEC: {\n        Node lhs = n.getFirstChild();\n        if (lhs.isName()) {\n          String name = lhs.getString();\n          Scope.Var var = t.getScope().getVar(name);\n          if (isConstant(var)) {\n            reportError(t, n, name);\n          }\n        }\n        break;\n      }\n    }\n  }\n",
        "begin_line": 58,
        "end_line": 117,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0925
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.isLocal#198",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isLocal()",
        "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }\n",
        "begin_line": 198,
        "end_line": 200,
        "comment": "\n     * Returns whether this is a local variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0917
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.isGlobalNameReference#237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalNameReference(java.lang.String, com.google.javascript.jscomp.Scope)",
        "snippet": "  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }\n",
        "begin_line": 237,
        "end_line": 240,
        "comment": "\n   * Determines whether a name reference in a particular scope is a global name\n   * reference.\n   *\n   * @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global name reference\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0915
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.getTopVarName#248",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.getTopVarName(java.lang.String)",
        "snippet": "  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }\n",
        "begin_line": 248,
        "end_line": 251,
        "comment": "\n   * Gets the top variable name from a possibly namespaced name.\n   *\n   * @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\")\n   * @return The top variable name (e.g. \"a\")\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0915
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.isGlobalVarReference#261",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalVarReference(java.lang.String, com.google.javascript.jscomp.Scope)",
        "snippet": "  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }\n",
        "begin_line": 261,
        "end_line": 267,
        "comment": "\n   * Determines whether a variable name reference in a particular scope is a\n   * global variable reference.\n   *\n   * @param name A variable name (e.g. \"a\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global variable reference\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0915
        },
        "num_failing_tests": 4
    },
    {
        "name": "Denormalize.Denormalize#42",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Denormalize.java",
        "class_name": "com.google.javascript.jscomp.Denormalize",
        "signature": "com.google.javascript.jscomp.Denormalize.Denormalize(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  Denormalize(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "Denormalize.process#46",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Denormalize.java",
        "class_name": "com.google.javascript.jscomp.Denormalize",
        "signature": "com.google.javascript.jscomp.Denormalize.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "Denormalize.shouldTraverse#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Denormalize.java",
        "class_name": "com.google.javascript.jscomp.Denormalize",
        "signature": "com.google.javascript.jscomp.Denormalize.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }\n",
        "begin_line": 51,
        "end_line": 54,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "Denormalize.visit#56",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Denormalize.java",
        "class_name": "com.google.javascript.jscomp.Denormalize",
        "signature": "com.google.javascript.jscomp.Denormalize.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    maybeCollapseIntoForStatements(n, parent);\n  }\n",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "Denormalize.maybeCollapseIntoForStatements#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Denormalize.java",
        "class_name": "com.google.javascript.jscomp.Denormalize",
        "signature": "com.google.javascript.jscomp.Denormalize.maybeCollapseIntoForStatements(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void maybeCollapseIntoForStatements(Node n, Node parent) {\n    // Only SCRIPT, BLOCK, and LABELs can have FORs that can be collapsed into.\n    // LABELs are not supported here.\n    if (parent == null || !NodeUtil.isStatementBlock(parent)) {\n      return;\n    }\n\n    // Is the current node something that can be in a for loop initializer?\n    if (!n.isExprResult() && !n.isVar()) {\n      return;\n    }\n\n    // Is the next statement a valid FOR?\n    Node nextSibling = n.getNext();\n    if (nextSibling == null) {\n      return;\n    } else if (NodeUtil.isForIn(nextSibling)) {\n      Node forNode = nextSibling;\n      Node forVar = forNode.getFirstChild();\n      if (forVar.isName()\n          && n.isVar() && n.hasOneChild()) {\n        Node name = n.getFirstChild();\n        if (!name.hasChildren()\n            && forVar.getString().equals(name.getString())) {\n          // OK, the names match, and the var declaration does not have an\n          // initializer. Move it into the loop.\n          parent.removeChild(n);\n          forNode.replaceChild(forVar, n);\n          compiler.reportCodeChange();\n        }\n      }\n    } else if (nextSibling.isFor()\n        && nextSibling.getFirstChild().isEmpty()) {\n\n      // Does the current node contain an in operator?  If so, embedding\n      // the expression in a for loop can cause some JavaScript parsers (such\n      // as the PlayStation 3's browser based on Access's NetFront\n      // browser) to fail to parse the code.\n      // See bug 1778863 for details.\n      if (NodeUtil.containsType(n, Token.IN)) {\n        return;\n      }\n\n      // Move the current node into the FOR loop initializer.\n      Node forNode = nextSibling;\n      Node oldInitializer = forNode.getFirstChild();\n      parent.removeChild(n);\n\n      Node newInitializer;\n      if (n.isVar()) {\n        newInitializer = n;\n      } else {\n        // Extract the expression from EXPR_RESULT node.\n        Preconditions.checkState(n.hasOneChild());\n        newInitializer = n.getFirstChild();\n        n.removeChild(newInitializer);\n      }\n\n      forNode.replaceChild(oldInitializer, newInitializer);\n\n      compiler.reportCodeChange();\n    }\n  }\n",
        "begin_line": 65,
        "end_line": 127,
        "comment": "\n   * Collapse VARs and EXPR_RESULT node into FOR loop initializers where\n   * possible.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-e6595fa7-0e37-4882-b1b4-7208c0234b1b.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new VarCheck(compiler, true);\n    }\n",
        "begin_line": 2149,
        "end_line": 2152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-f2c33cfa-eab8-404e-840e-6f1eaf93fd0e.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new AstValidator();\n    }\n",
        "begin_line": 2141,
        "end_line": 2144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2019",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-fcc89260-b94b-4176-897b-f8b81ad09d11.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new Denormalize(compiler);\n    }\n",
        "begin_line": 2019,
        "end_line": 2022,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2007",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-36490b40-29e9-4a00-92d0-f7af96e28d0f.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new CompilerPass() {\n        @Override public void process(Node externs, Node root) {\n          compiler.setLifeCycleStage(LifeCycleStage.RAW);\n        }\n      };\n    }\n",
        "begin_line": 2007,
        "end_line": 2014,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#2010",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-b8a607dc-7749-4135-a492-a63122f80b07.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override public void process(Node externs, Node root) {\n          compiler.setLifeCycleStage(LifeCycleStage.RAW);\n        }\n",
        "begin_line": 2010,
        "end_line": 2012,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#775",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-7f6e13a8-803d-4b71-9fe6-1d7441859e67.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler\n        compiler) {\n      return new CheckSideEffects.StripProtection(compiler);\n    }\n",
        "begin_line": 775,
        "end_line": 779,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.StripProtection#173",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.StripProtection.StripProtection(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    StripProtection(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n",
        "begin_line": 173,
        "end_line": 175,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.process#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.StripProtection.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      NodeTraversal.traverse(compiler, root, this);\n    }\n",
        "begin_line": 177,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.visit#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.StripProtection.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall()) {\n        Node target = n.getFirstChild();\n        // TODO(johnlenz): add this to the coding convention\n        // so we can remove goog.reflect.sinkValue as well.\n        if (target.isName() && target.getString().equals(PROTECTOR_FN)) {\n          Node expr = n.getLastChild();\n          n.detachChildren();\n          parent.replaceChild(n, expr);\n        }\n      }\n    }\n",
        "begin_line": 182,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.process#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      validateCodeRoot(externs);\n    }\n    if (root != null) {\n      validateCodeRoot(root);\n    }\n  }\n",
        "begin_line": 57,
        "end_line": 65,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 4
    },
    {
        "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler#830",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n",
        "begin_line": 830,
        "end_line": 857,
        "comment": "\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 3
    },
    {
        "name": "TypedScopeCreator.attachLiteralTypes#571",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.attachLiteralTypes(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "    private void attachLiteralTypes(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }\n",
        "begin_line": 571,
        "end_line": 614,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineObjectLiteral#616",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineObjectLiteral(com.google.javascript.rhino.Node)",
        "snippet": "    private void defineObjectLiteral(Node objectLit) {\n      // Handle the @lends annotation.\n      JSType type = null;\n      JSDocInfo info = objectLit.getJSDocInfo();\n      if (info != null && info.getLendsName() != null) {\n        String lendsName = info.getLendsName();\n        Var lendsVar = scope.getVar(lendsName);\n        if (lendsVar == null) {\n          compiler.report(\n              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n        } else {\n          type = lendsVar.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n            compiler.report(\n                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n                    lendsName, type.toString()));\n            type = null;\n          } else {\n            objectLit.setJSType(type);\n          }\n        }\n      }\n\n      info = NodeUtil.getBestJSDocInfo(objectLit);\n      Node lValue = NodeUtil.getBestLValue(objectLit);\n      String lValueName = NodeUtil.getBestLValueName(lValue);\n      boolean createdEnumType = false;\n      if (info != null && info.hasEnumParameterType()) {\n        type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n        createdEnumType = true;\n      }\n\n      if (type == null) {\n        type = typeRegistry.createAnonymousObjectType(info);\n      }\n\n      setDeferredType(objectLit, type);\n\n      // If this is an enum, the properties were already taken care of above.\n      processObjectLitProperties(\n          objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);\n    }\n",
        "begin_line": 616,
        "end_line": 660,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.processObjectLitProperties#670",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.processObjectLitProperties(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.ObjectType, boolean)",
        "snippet": "    void processObjectLitProperties(\n        Node objLit, ObjectType objLitType,\n        boolean declareOnOwner) {\n      for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n           keyNode = keyNode.getNext()) {\n        Node value = keyNode.getFirstChild();\n        String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n        JSDocInfo info = keyNode.getJSDocInfo();\n        JSType valueType =\n            getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value);\n        JSType keyType =  objLitType.isEnumType() ?\n            objLitType.toMaybeEnumType().getElementsType() :\n            NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);\n\n        // Try to declare this property in the current scope if it\n        // has an authoritative name.\n        String qualifiedName = NodeUtil.getBestLValueName(keyNode);\n        if (qualifiedName != null) {\n          boolean inferred = keyType == null;\n          defineSlot(keyNode, objLit, qualifiedName, keyType, inferred);\n        } else if (keyType != null) {\n          setDeferredType(keyNode, keyType);\n        }\n\n        if (keyType != null && objLitType != null && declareOnOwner) {\n          // Declare this property on its object literal.\n          boolean isExtern = keyNode.isFromExterns();\n          objLitType.defineDeclaredProperty(memberName, keyType, keyNode);\n        }\n      }\n    }\n",
        "begin_line": 670,
        "end_line": 700,
        "comment": "\n     * Process an object literal and all the types on it.\n     * @param objLit The OBJECTLIT node.\n     * @param objLitType The type of the OBJECTLIT node. This might be a named\n     *     type, because of the lends annotation.\n     * @param declareOnOwner If true, declare properties on the objLitType as\n     *     well. If false, the caller should take care of this.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverse#303",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverse(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        break;\n    }\n\n    // TODO(johnlenz): remove this after the CAST node change has shaken out.\n    if (!n.isFunction()) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\n\n        // A stubbed type declaration on a qualified name should take\n        // effect for all subsequent accesses of that name,\n        // so treat it the same as an assign to that name.\n        if (n.isQualifiedName() &&\n            n.getParent().isExprResult()) {\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n        }\n\n        n.setJSType(castType);\n      }\n    }\n\n    return scope;\n  }\n",
        "begin_line": 303,
        "end_line": 472,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverseObjectLiteral#732",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseObjectLiteral(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n      scope = traverse(name.getFirstChild(), scope);\n    }\n\n    // Object literals can be reflected on other types, or changed with\n    // type casts.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    // TODO(nicksantos): There should be an \"anonymous object\" type that\n    // we can check for here.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n      return scope;\n    }\n\n    boolean hasLendsName = n.getJSDocInfo() != null &&\n        n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n      return scope;\n    }\n\n    String qObjName = NodeUtil.getBestLValueName(\n        NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null;\n         name = name.getNext()) {\n      Node value = name.getFirstChild();\n      String memberName = NodeUtil.getObjectLitKeyName(name);\n      if (memberName != null) {\n        JSType rawValueType =  name.getFirstChild().getJSType();\n        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            name, rawValueType);\n        if (valueType == null) {\n          valueType = unknownType;\n        }\n        objectType.defineInferredProperty(memberName, valueType, name);\n\n        // Do normal flow inference if this is a direct property assignment.\n        if (qObjName != null && name.isStringKey()) {\n          String qKeyName = qObjName + \".\" + memberName;\n          Var var = syntacticScope.getVar(qKeyName);\n          JSType oldType = var == null ? null : var.getType();\n          if (var != null && var.isTypeInferred()) {\n            var.setType(oldType == null ?\n                valueType : oldType.getLeastSupertype(oldType));\n          }\n\n          scope.inferQualifiedSlot(name, qKeyName,\n              oldType == null ? unknownType : oldType,\n              valueType);\n        }\n      } else {\n        n.setJSType(unknownType);\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 732,
        "end_line": 791,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalNames.findPrototypeProps#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalNames.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
        "signature": "com.google.javascript.jscomp.CheckGlobalNames.findPrototypeProps(java.lang.String, java.util.Set<java.lang.String>)",
        "snippet": "  private void findPrototypeProps(String type, Set<String> props) {\n    Name slot = namespace.getSlot(type);\n    if (slot != null) {\n      for (Ref ref : slot.getRefs()) {\n        if (ref.type == Ref.Type.PROTOTYPE_GET) {\n          Node fullName = ref.getNode().getParent().getParent();\n          if (fullName.isGetProp()) {\n            props.add(fullName.getLastChild().getString());\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 106,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1361",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-81c27387-7bf3-4822-b376-b2fa6df4b34d.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new ConstCheck(compiler);\n    }\n",
        "begin_line": 1361,
        "end_line": 1364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0905
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConstCheck.ConstCheck#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConstCheck.java",
        "class_name": "com.google.javascript.jscomp.ConstCheck",
        "signature": "com.google.javascript.jscomp.ConstCheck.ConstCheck(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  public ConstCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.initializedConstants = new HashSet<Scope.Var>();\n  }\n",
        "begin_line": 47,
        "end_line": 50,
        "comment": "\n   * Creates an instance.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0905
        },
        "num_failing_tests": 4
    },
    {
        "name": "ConstCheck.process#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConstCheck.java",
        "class_name": "com.google.javascript.jscomp.ConstCheck",
        "signature": "com.google.javascript.jscomp.ConstCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 52,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0905
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.optimize#1879",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.optimize()",
        "snippet": "  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n  }\n",
        "begin_line": 1879,
        "end_line": 1893,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0905
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.endPass#214",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.endPass(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void endPass(Node externs, Node root) {\n    Preconditions.checkState(currentTracer != null && currentPassName != null);\n\n    String passToCheck = currentPassName;\n    try {\n      if (progressRange == null) {\n        compiler.setProgress(-1, currentPassName);\n      } else {\n        progress += progressStep;\n        compiler.setProgress(progress, currentPassName);\n      }\n      stopTracer(currentTracer, currentPassName);\n      currentPassName = null;\n      currentTracer = null;\n\n      maybeSanityCheck(externs, root);\n    } catch (Exception e) {\n      // TODO(johnlenz): Remove this once the normalization checks report\n      // errors instead of exceptions.\n      throw new RuntimeException(\"Sanity check failed for \" + passToCheck, e);\n    }\n  }\n",
        "begin_line": 214,
        "end_line": 235,
        "comment": "\n   * Marks the end of a pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-74930be8-a164-4dbf-9984-8ed4811ce2d6.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n      return new HotSwapCompilerPass() {\n        @Override\n        public void process(Node externs, Node jsRoot) {\n          // Kill the global namespace so that it can be garbage collected\n          // after all passes are through with it.\n          namespaceForChecks = null;\n        }\n\n        @Override\n        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n          process(null, null);\n        }\n      };\n    }\n",
        "begin_line": 1341,
        "end_line": 1356,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#1344",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-33948fde-b966-476a-9024-f5532f012ddf.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node jsRoot) {\n          // Kill the global namespace so that it can be garbage collected\n          // after all passes are through with it.\n          namespaceForChecks = null;\n        }\n",
        "begin_line": 1344,
        "end_line": 1349,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.compileInternal#706",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.compileInternal()",
        "snippet": "  private void compileInternal() {\n    setProgress(0.0, null);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15, \"parse\");\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0, \"recordFunctionInformation\");\n  }\n",
        "begin_line": 706,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.process#850",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.process(com.google.javascript.jscomp.CompilerPass)",
        "snippet": "  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n",
        "begin_line": 850,
        "end_line": 853,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.maybeSanityCheck#863",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.maybeSanityCheck()",
        "snippet": "  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n",
        "begin_line": 863,
        "end_line": 867,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.startPass#923",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.startPass(java.lang.String)",
        "snippet": "  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n",
        "begin_line": 923,
        "end_line": 927,
        "comment": "\n   * Marks the beginning of a pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.endPass#932",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.endPass()",
        "snippet": "  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n",
        "begin_line": 932,
        "end_line": 941,
        "comment": "\n   * Marks the end of a pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.normalize#1933",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.normalize()",
        "snippet": "  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n",
        "begin_line": 1933,
        "end_line": 1938,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0904
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.CollectDefines#237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.CollectDefines.CollectDefines(com.google.javascript.jscomp.AbstractCompiler, java.util.List<com.google.javascript.jscomp.GlobalNamespace.Name>)",
        "snippet": "    CollectDefines(AbstractCompiler compiler, List<Name> listOfDefines) {\n      this.compiler = compiler;\n      this.allDefines = Maps.newHashMap();\n\n      assignableDefines = Maps.newHashMap();\n      assignAllowed = new ArrayDeque<Integer>();\n      assignAllowed.push(1);\n\n      // Create a map of references to defines keyed by node for easy lookup\n      allRefInfo = Maps.newHashMap();\n      for (Name name : listOfDefines) {\n        Ref decl = name.getDeclaration();\n        if (decl != null) {\n          allRefInfo.put(decl.node,\n                         new RefInfo(decl, name));\n        }\n        for (Ref ref : name.getRefs()) {\n          if (ref == decl) {\n            // Declarations were handled above.\n            continue;\n          }\n\n          // If there's a TWIN def, only put one of the twins in.\n          if (ref.getTwin() == null || !ref.getTwin().isSet()) {\n            allRefInfo.put(ref.node, new RefInfo(ref, name));\n          }\n        }\n      }\n    }\n",
        "begin_line": 237,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.getAllDefines#271",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.CollectDefines.getAllDefines()",
        "snippet": "    Map<String, DefineInfo> getAllDefines() {\n      return allDefines;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "\n     * Get a map of {@link DefineInfo} structures, keyed by the name of\n     * the define.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.shouldTraverse#279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.CollectDefines.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      updateAssignAllowedStack(n, true);\n      return true;\n    }\n",
        "begin_line": 279,
        "end_line": 284,
        "comment": "\n     * Keeps track of whether the traversal is in a conditional branch.\n     * We traverse all nodes of the parse tree.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.visit#286",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.CollectDefines.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      RefInfo refInfo = allRefInfo.get(n);\n      if (refInfo != null) {\n        Ref ref = refInfo.ref;\n        Name name = refInfo.name;\n        String fullName = name.getFullName();\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n          case SET_FROM_LOCAL:\n            Node valParent = getValueParent(ref);\n            Node val = valParent.getLastChild();\n            if (valParent.isAssign() && name.isSimpleName() &&\n                name.getDeclaration() == ref) {\n              // For defines, it's an error if a simple name is assigned\n              // before it's declared\n              compiler.report(\n                  t.makeError(val, INVALID_DEFINE_INIT_ERROR, fullName));\n            } else if (processDefineAssignment(t, fullName, val, valParent)) {\n              // remove the assignment so that the variable is still declared,\n              // but no longer assigned to a value, e.g.,\n              // DEF_FOO = 5; // becomes \"5;\"\n\n              // We can't remove the ASSIGN/VAR when we're still visiting its\n              // children, so we'll have to come back later to remove it.\n              refInfo.name.removeRef(ref);\n              lvalueToRemoveLater = valParent;\n            }\n            break;\n          default:\n            if (t.inGlobalScope()) {\n              // Treat this as a reference to a define in the global scope.\n              // After this point, the define must not be reassigned,\n              // or it's an error.\n              DefineInfo info = assignableDefines.get(fullName);\n              if (info != null) {\n                setDefineInfoNotAssignable(info, t);\n                assignableDefines.remove(fullName);\n              }\n            }\n            break;\n        }\n      }\n\n      if (!t.inGlobalScope() &&\n          n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {\n        // warn about @define annotations in local scopes\n        compiler.report(\n            t.makeError(n, NON_GLOBAL_DEFINE_INIT_ERROR, \"\"));\n      }\n\n      if (lvalueToRemoveLater == n) {\n        lvalueToRemoveLater = null;\n        if (n.isAssign()) {\n          Node last = n.getLastChild();\n          n.removeChild(last);\n          parent.replaceChild(n, last);\n        } else {\n          Preconditions.checkState(n.isName());\n          n.removeChild(n.getFirstChild());\n        }\n        compiler.reportCodeChange();\n      }\n\n      if (n.isCall()) {\n        if (t.inGlobalScope()) {\n          // If there's a function call in the global scope,\n          // we just say it's unsafe and freeze all the defines.\n          //\n          // NOTE(nicksantos): We could be a lot smarter here. For example,\n          // ReplaceOverriddenVars keeps a call graph of all functions and\n          // which functions/variables that they reference, and tries\n          // to statically determine which functions are \"safe\" and which\n          // are not. But this would be overkill, especially because\n          // the intended use of defines is with config_files, where\n          // all the defines are at the top of the bundle.\n          for (DefineInfo info : assignableDefines.values()) {\n            setDefineInfoNotAssignable(info, t);\n          }\n\n          assignableDefines.clear();\n        }\n      }\n\n      updateAssignAllowedStack(n, false);\n    }\n",
        "begin_line": 286,
        "end_line": 371,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.ProcessDefines#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.ProcessDefines(com.google.javascript.jscomp.AbstractCompiler, java.util.Map<java.lang.String, com.google.javascript.rhino.Node>)",
        "snippet": "  ProcessDefines(AbstractCompiler compiler, Map<String, Node> replacements) {\n    this.compiler = compiler;\n    dominantReplacements = replacements;\n  }\n",
        "begin_line": 100,
        "end_line": 103,
        "comment": "\n   * Create a pass that overrides define constants.\n   *\n   * TODO(nicksantos): Write a builder to help JSCompiler induce\n   *    {@code replacements} from command-line flags\n   *\n   * @param replacements A hash table of names of defines to their replacements.\n   *   All replacements <b>must</b> be literals.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.injectNamespace#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.injectNamespace(com.google.javascript.jscomp.GlobalNamespace)",
        "snippet": "  ProcessDefines injectNamespace(GlobalNamespace namespace) {\n    this.namespace = namespace;\n    return this;\n  }\n",
        "begin_line": 110,
        "end_line": 113,
        "comment": "\n   * Injects a pre-computed global namespace, so that the same namespace\n   * can be re-used for multiple check passes. Returns {@code this} for\n   * easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.process#115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (namespace == null) {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n    overrideDefines(collectDefines(root, namespace));\n  }\n",
        "begin_line": 115,
        "end_line": 121,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.overrideDefines#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.overrideDefines(java.util.Map<java.lang.String, com.google.javascript.jscomp.ProcessDefines.DefineInfo>)",
        "snippet": "  private void overrideDefines(Map<String, DefineInfo> allDefines) {\n    boolean changed = false;\n    for (Map.Entry<String, DefineInfo> def : allDefines.entrySet()) {\n      String defineName = def.getKey();\n      DefineInfo info = def.getValue();\n      Node inputValue = dominantReplacements.get(defineName);\n      Node finalValue = inputValue != null ?\n          inputValue : info.getLastValue();\n      if (finalValue != info.initialValue) {\n        info.initialValueParent.replaceChild(\n            info.initialValue, finalValue.cloneTree());\n        compiler.addToDebugLog(\"Overriding @define variable \" + defineName);\n        changed = changed ||\n            finalValue.getType() != info.initialValue.getType() ||\n            !finalValue.isEquivalentTo(info.initialValue);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    Set<String> unusedReplacements = dominantReplacements.keySet();\n    unusedReplacements.removeAll(allDefines.keySet());\n    unusedReplacements.removeAll(KNOWN_DEFINES);\n    for (String unknownDefine : unusedReplacements) {\n      compiler.report(JSError.make(UNKNOWN_DEFINE_WARNING, unknownDefine));\n    }\n  }\n",
        "begin_line": 123,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "ProcessDefines.collectDefines#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessDefines.java",
        "class_name": "com.google.javascript.jscomp.ProcessDefines",
        "signature": "com.google.javascript.jscomp.ProcessDefines.collectDefines(com.google.javascript.rhino.Node, com.google.javascript.jscomp.GlobalNamespace)",
        "snippet": "  private Map<String, DefineInfo> collectDefines(Node root,\n      GlobalNamespace namespace) {\n    // Find all the global names with a @define annotation\n    List<Name> allDefines = Lists.newArrayList();\n    for (Name name : namespace.getNameIndex().values()) {\n      Ref decl = name.getDeclaration();\n      if (name.docInfo != null && name.docInfo.isDefine()) {\n        // Process defines should not depend on check types being enabled,\n        // so we look for the JSDoc instead of the inferred type.\n        if (isValidDefineType(name.docInfo.getType())) {\n          allDefines.add(name);\n        } else {\n          JSError error = JSError.make(\n              decl.getSourceName(),\n              decl.node, INVALID_DEFINE_TYPE_ERROR);\n          compiler.report(error);\n        }\n      } else {\n        for (Ref ref : name.getRefs()) {\n          if (ref == decl) {\n            // Declarations were handled above.\n            continue;\n          }\n\n          Node n = ref.node;\n          Node parent = ref.node.getParent();\n          JSDocInfo info = n.getJSDocInfo();\n          if (info == null &&\n              parent.isVar() && parent.hasOneChild()) {\n            info = parent.getJSDocInfo();\n          }\n\n          if (info != null && info.isDefine()) {\n            allDefines.add(name);\n            break;\n          }\n        }\n      }\n    }\n\n    CollectDefines pass = new CollectDefines(compiler, allDefines);\n    NodeTraversal.traverse(compiler, root, pass);\n    return pass.getAllDefines();\n  }\n",
        "begin_line": 172,
        "end_line": 215,
        "comment": "\n   * Finds all defines, and creates a {@link DefineInfo} data structure for\n   * each one.\n   * @return A map of {@link DefineInfo} structures, keyed by name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.process#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    progress = 0.0;\n    progressStep = 0.0;\n    if (progressRange != null) {\n      progressStep = (progressRange.maxValue - progressRange.initialValue)\n          / passes.size();\n      progress = progressRange.initialValue;\n    }\n\n    for (CompilerPass pass : passes) {\n      pass.process(externs, root);\n      if (hasHaltingErrors()) {\n        return;\n      }\n    }\n  }\n",
        "begin_line": 184,
        "end_line": 200,
        "comment": "\n   * Run all the passes in the optimizer.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.getNameIndex#168",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameIndex()",
        "snippet": "  Map<String, Name> getNameIndex() {\n    ensureGenerated();\n    return nameMap;\n  }\n",
        "begin_line": 168,
        "end_line": 171,
        "comment": "\n   * Gets an index of all the global names, indexed by full qualified name\n   * (as in \"a\", \"a.b.c\", etc.).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1323",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-c885cd3a-b493-4372-bdb3-b206da2582aa.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new CompilerPass() {\n        @Override\n        public void process(Node externs, Node jsRoot) {\n          Map<String, Node> replacements = getAdditionalReplacements(options);\n          replacements.putAll(options.getDefineReplacements());\n\n          new ProcessDefines(compiler, replacements)\n              .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n        }\n      };\n    }\n",
        "begin_line": 1323,
        "end_line": 1335,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#1326",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-097d7248-c722-4878-ba86-6f8a297a901e.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node jsRoot) {\n          Map<String, Node> replacements = getAdditionalReplacements(options);\n          replacements.putAll(options.getDefineReplacements());\n\n          new ProcessDefines(compiler, replacements)\n              .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n        }\n",
        "begin_line": 1326,
        "end_line": 1333,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.shouldStrip#2095",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.TweakProcessing.shouldStrip()",
        "snippet": "    public boolean shouldStrip() {\n      return this == STRIP;\n    }\n",
        "begin_line": 2095,
        "end_line": 2097,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.getDefineReplacements#1000",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getDefineReplacements()",
        "snippet": "  public Map<String, Node> getDefineReplacements() {\n    return getReplacementsHelper(defineReplacements);\n  }\n",
        "begin_line": 1000,
        "end_line": 1002,
        "comment": "\n   * Returns the map of define replacements.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.getReplacementsHelper#1014",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getReplacementsHelper(java.util.Map<java.lang.String, java.lang.Object>)",
        "snippet": "  private static Map<String, Node> getReplacementsHelper(\n      Map<String, Object> source) {\n    Map<String, Node> map = Maps.newHashMap();\n    for (Map.Entry<String, Object> entry : source.entrySet()) {\n      String name = entry.getKey();\n      Object value = entry.getValue();\n      if (value instanceof Boolean) {\n        map.put(name, NodeUtil.booleanNode(((Boolean) value).booleanValue()));\n      } else if (value instanceof Integer) {\n        map.put(name, IR.number(((Integer) value).intValue()));\n      } else if (value instanceof Double) {\n        map.put(name, IR.number(((Double) value).doubleValue()));\n      } else {\n        Preconditions.checkState(value instanceof String);\n        map.put(name, IR.string((String) value));\n      }\n    }\n    return map;\n  }\n",
        "begin_line": 1014,
        "end_line": 1032,
        "comment": "\n   * Creates a map of String->Node from a map of String->Number/String/Boolean.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.isExternExportsEnabled#1432",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.isExternExportsEnabled()",
        "snippet": "  public boolean isExternExportsEnabled() {\n    return externExports;\n  }\n",
        "begin_line": 1432,
        "end_line": 1434,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.check#801",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.check()",
        "snippet": "  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n",
        "begin_line": 801,
        "end_line": 836,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.BuildGlobalNamespace#288",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.BuildGlobalNamespace()",
        "snippet": "    BuildGlobalNamespace() {\n      this(null);\n    }\n",
        "begin_line": 288,
        "end_line": 290,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.BuildGlobalNamespace#296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.BuildGlobalNamespace(com.google.common.base.Predicate<com.google.javascript.rhino.Node>)",
        "snippet": "    BuildGlobalNamespace(Predicate<Node> nodeFilter) {\n      this.nodeFilter = nodeFilter;\n    }\n",
        "begin_line": 296,
        "end_line": 298,
        "comment": "\n     * Builds a global namespace, but only visits nodes that match the\n     * given filter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.visit#300",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {}\n",
        "begin_line": 300,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.shouldTraverse#304",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      collect(t, n, parent);\n      return true;\n    }\n",
        "begin_line": 304,
        "end_line": 308,
        "comment": " Collect the references in pre-order. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.GlobalNamespace#96",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n    this.compiler = compiler;\n    this.externsRoot = externsRoot;\n    this.root = root;\n  }\n",
        "begin_line": 96,
        "end_line": 100,
        "comment": "\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param externsRoot The root of the externs to build a namespace for. If\n   *     this is null, externs and properties defined on extern types will not\n   *     be included in the global namespace.  If non-null, it allows\n   *     user-defined function on extern types to be included in the global\n   *     namespace.  E.g. String.foo.\n   * @param root The root of the rest of the code to build a namespace for.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.ensureGenerated#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.ensureGenerated()",
        "snippet": "  private void ensureGenerated() {\n    if (!generated) {\n      process();\n    }\n  }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.process#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.process()",
        "snippet": "  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }\n",
        "begin_line": 218,
        "end_line": 227,
        "comment": "\n   * Builds the namespace lazily.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "ComposeWarningsGuard.disables#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.disables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean disables(DiagnosticGroup group) {\n    nextSingleton:\n    for (DiagnosticType type : group.getTypes()) {\n      DiagnosticGroup singleton = DiagnosticGroup.forType(type);\n\n      for (WarningsGuard guard : guards) {\n        if (guard.disables(singleton)) {\n          continue nextSingleton;\n        } else if (guard.enables(singleton)) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n",
        "begin_line": 124,
        "end_line": 142,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.isQualifiedName#1569",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
        "snippet": "  public boolean isQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n        return getString().isEmpty() ? false : true;\n      case Token.THIS:\n        return true;\n      case Token.GETPROP:\n        return getFirstChild().isQualifiedName();\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 1569,
        "end_line": 1580,
        "comment": "\n   * Returns whether a node corresponds to a simple or a qualified name, such as\n   * <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 4
    },
    {
        "name": "VarCheck.visit#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.NameRefInExternsCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        switch (parent.getType()) {\n          case Token.VAR:\n          case Token.FUNCTION:\n          case Token.PARAM_LIST:\n            // These are okay.\n            break;\n          case Token.GETPROP:\n            if (n == parent.getFirstChild()) {\n              Scope scope = t.getScope();\n              Scope.Var var = scope.getVar(n.getString());\n              if (var == null) {\n                t.report(n, UNDEFINED_EXTERN_VAR_ERROR, n.getString());\n                varsToDeclareInExterns.add(n.getString());\n              }\n            }\n            break;\n          default:\n            t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n\n            Scope scope = t.getScope();\n            Scope.Var var = scope.getVar(n.getString());\n            if (var == null) {\n              varsToDeclareInExterns.add(n.getString());\n            }\n            break;\n        }\n      }\n    }\n",
        "begin_line": 233,
        "end_line": 263,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0889
        },
        "num_failing_tests": 4
    },
    {
        "name": "VarCheck.visit#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n      return;\n    }\n\n    String varName = n.getString();\n\n    // Only a function can have an empty name.\n    if (varName.isEmpty()) {\n      Preconditions.checkState(parent.isFunction());\n      Preconditions.checkState(NodeUtil.isFunctionExpression(parent));\n      return;\n    }\n\n    // Check if this is a declaration for a var that has been declared\n    // elsewhere. If so, mark it as a duplicate.\n    if ((parent.isVar() ||\n         NodeUtil.isFunctionDeclaration(parent)) &&\n        varsToDeclareInExterns.contains(varName)) {\n      createSynthesizedExternVar(varName);\n\n      n.addSuppression(\"duplicate\");\n    }\n\n    // Check that the var has been declared.\n    Scope scope = t.getScope();\n    Scope.Var var = scope.getVar(varName);\n    if (var == null) {\n      if (NodeUtil.isFunctionExpression(parent)) {\n        // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n        // current scope.\n      } else {\n        // The extern checks are stricter, don't report a second error.\n        if (!strictExternCheck || !t.getInput().isExtern()) {\n          t.report(n, UNDEFINED_VAR_ERROR, varName);\n        }\n\n        if (sanityCheck) {\n          throw new IllegalStateException(\"Unexpected variable \" + varName);\n        } else {\n          createSynthesizedExternVar(varName);\n          scope.getGlobalScope().declare(varName, n,\n              null, getSynthesizedExternsInput());\n        }\n      }\n      return;\n    }\n\n    CompilerInput currInput = t.getInput();\n    CompilerInput varInput = var.input;\n    if (currInput == varInput || currInput == null || varInput == null) {\n      // The variable was defined in the same file. This is fine.\n      return;\n    }\n\n    // Check module dependencies.\n    JSModule currModule = currInput.getModule();\n    JSModule varModule = varInput.getModule();\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    if (!sanityCheck &&\n        varModule != currModule && varModule != null && currModule != null) {\n      if (moduleGraph.dependsOn(currModule, varModule)) {\n        // The module dependency was properly declared.\n      } else {\n        if (scope.isGlobal()) {\n          if (moduleGraph.dependsOn(varModule, currModule)) {\n            // The variable reference violates a declared module dependency.\n            t.report(n, VIOLATED_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          } else {\n            // The variable reference is between two modules that have no\n            // dependency relationship. This should probably be considered an\n            // error, but just issue a warning for now.\n            t.report(n, MISSING_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          }\n        } else {\n          t.report(n, STRICT_MODULE_DEP_ERROR,\n                   currModule.getName(), varModule.getName(), varName);\n        }\n      }\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0889
        },
        "num_failing_tests": 4
    },
    {
        "name": "ReferenceCollectingCallback.getNode#542",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.getNode()",
        "snippet": "    @Override\n    public Node getNode() {\n      return nameNode;\n    }\n",
        "begin_line": 542,
        "end_line": 545,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.isDeclaration#556",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isDeclaration()",
        "snippet": "    boolean isDeclaration() {\n      Node parent = getParent();\n      Node grandparent = parent.getParent();\n      return DECLARATION_PARENTS.contains(parent.getType()) ||\n          parent.isParamList() &&\n          grandparent.isFunction();\n    }\n",
        "begin_line": 556,
        "end_line": 562,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.getBasicBlock#593",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.getBasicBlock()",
        "snippet": "    BasicBlock getBasicBlock() {\n      return basicBlock;\n    }\n",
        "begin_line": 593,
        "end_line": 595,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.getParent#597",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.getParent()",
        "snippet": "    Node getParent() {\n      return getNode().getParent();\n    }\n",
        "begin_line": 597,
        "end_line": 599,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processObjectLiteral#896",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processObjectLiteral(com.google.javascript.rhino.head.ast.ObjectLiteral)",
        "snippet": "    @Override\n    Node processObjectLiteral(ObjectLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.OBJECTLIT);\n      for (ObjectProperty el : literalNode.getElements()) {\n        if (config.languageMode == LanguageMode.ECMASCRIPT3) {\n          if (el.isGetter()) {\n            reportGetter(el);\n            continue;\n          } else if (el.isSetter()) {\n            reportSetter(el);\n            continue;\n          }\n        }\n\n        Node key = transformAsString(el.getLeft());\n        key.setType(Token.STRING_KEY);\n\n        Node value = transform(el.getRight());\n        if (el.isGetter()) {\n          key.setType(Token.GETTER_DEF);\n          Preconditions.checkState(value.isFunction());\n          if (getFnParamNode(value).hasChildren()) {\n            reportGetterParam(el.getLeft());\n          }\n        } else if (el.isSetter()) {\n          key.setType(Token.SETTER_DEF);\n          Preconditions.checkState(value.isFunction());\n          if (!getFnParamNode(value).hasOneChild()) {\n            reportSetterParam(el.getLeft());\n          }\n        }\n        key.addChildToFront(value);\n        node.addChildToBack(key);\n      }\n      return node;\n    }\n",
        "begin_line": 896,
        "end_line": 935,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 2
    },
    {
        "name": "CollapseVariableDeclarations.Collapse#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.Collapse.Collapse(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    Collapse(Node startNode, Node endNode, Node parent) {\n      this.startNode = startNode;\n      this.endNode = endNode;\n      this.parent = parent;\n    }\n",
        "begin_line": 84,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 1
    },
    {
        "name": "CollapseVariableDeclarations.applyCollapses#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CollapseVariableDeclarations.java",
        "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
        "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.applyCollapses()",
        "snippet": "  private void applyCollapses() {\n    for (Collapse collapse : collapses) {\n\n      Node var = new Node(Token.VAR);\n      var.copyInformationFrom(collapse.startNode);\n      collapse.parent.addChildBefore(var, collapse.startNode);\n\n      boolean redeclaration = false;\n      for (Node n = collapse.startNode; n != collapse.endNode;) {\n        Node next = n.getNext();\n\n        Preconditions.checkState(var.getNext() == n);\n        collapse.parent.removeChildAfter(var);\n\n        if (n.isVar()) {\n          while(n.hasChildren()) {\n            var.addChildToBack(n.removeFirstChild());\n          }\n        } else {\n          Node assign = n.getFirstChild();\n          Node lhs = assign.getFirstChild();\n          Preconditions.checkState(lhs.isName());\n          Node rhs = assign.getLastChild();\n          lhs.addChildToBack(rhs.detachFromParent());\n          var.addChildToBack(lhs.detachFromParent());\n          redeclaration = true;\n        }\n        n = next;\n      }\n\n      if (redeclaration) {\n        JSDocInfo info = new JSDocInfo();\n        info.addSuppression(\"duplicate\");\n        var.setJSDocInfo(info);\n      }\n    }\n  }\n",
        "begin_line": 213,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.checkNameDeprecation#274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.checkNameDeprecation(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking definitions or constructors.\n    if (parent.isFunction() || parent.isVar() ||\n        parent.isNew()) {\n      return;\n    }\n\n    Scope.Var var = t.getScope().getVar(n.getString());\n    JSDocInfo docInfo = var == null ? null : var.getJSDocInfo();\n\n    if (docInfo != null && docInfo.isDeprecated() &&\n        shouldEmitDeprecationWarning(t, n, parent)) {\n\n      if (docInfo.getDeprecationReason() != null) {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n                docInfo.getDeprecationReason()));\n      } else {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME, n.getString()));\n      }\n    }\n  }\n",
        "begin_line": 274,
        "end_line": 296,
        "comment": "\n   * Checks the given NAME node to ensure that access restrictions are obeyed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateUnaryOp#743",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateUnaryOp(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateUnaryOp(Node n) {\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }\n",
        "begin_line": 743,
        "end_line": 746,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0884
        },
        "num_failing_tests": 1
    },
    {
        "name": "VarCheck.VarCheck#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  VarCheck(AbstractCompiler compiler) {\n    this(compiler, false);\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0882
        },
        "num_failing_tests": 4
    },
    {
        "name": "VarCheck.VarCheck#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(com.google.javascript.jscomp.AbstractCompiler, boolean)",
        "snippet": "  VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n    this.compiler = compiler;\n    this.strictExternCheck = compiler.getErrorLevel(\n        JSError.make(\"\", 0, 0, UNDEFINED_EXTERN_VAR_ERROR)) == CheckLevel.ERROR;\n    this.sanityCheck = sanityCheck;\n  }\n",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0882
        },
        "num_failing_tests": 4
    },
    {
        "name": "VarCheck.process#93",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Don't run externs-checking in sanity check mode. Normalization will\n    // remove duplicate VAR declarations, which will make\n    // externs look like they have assigns.\n    if (!sanityCheck) {\n      NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n    }\n\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n    for (String varName : varsToDeclareInExterns) {\n      createSynthesizedExternVar(varName);\n    }\n  }\n",
        "begin_line": 93,
        "end_line": 107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0882
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#1083",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-3ffdcb1b-89cb-4c7a-812f-161af7b80319.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new VarCheck(compiler);\n    }\n",
        "begin_line": 1083,
        "end_line": 1086,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0882
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getErrorLevel#2085",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getErrorLevel(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n",
        "begin_line": 2085,
        "end_line": 2089,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0882
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSError.make#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.make(java.lang.String, int, int, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  public static JSError make(String sourceName, int lineno, int charno,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, null, lineno, charno, type, null, arguments);\n  }\n",
        "begin_line": 85,
        "end_line": 88,
        "comment": "\n   * Creates a JSError at a given source location\n   *\n   * @param sourceName The source file name\n   * @param lineno Line number with source file, or -1 if unknown\n   * @param charno Column number within line, or -1 for whole line.\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.088
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isConstant#461",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isConstant()",
        "snippet": "  public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }\n",
        "begin_line": 461,
        "end_line": 463,
        "comment": "\n   * Returns whether the {@code @const} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0879
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isDefine#494",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
        "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }\n",
        "begin_line": 494,
        "end_line": 496,
        "comment": "\n   * Returns whether the {@code @define} annotation is present on this\n   * {@link JSDocInfo}. If this annotation is present, then the\n   * {@link #getType()} method will retrieve the define type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0879
        },
        "num_failing_tests": 4
    },
    {
        "name": "GlobalNamespace.getDocInfoForDeclaration#1142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.getDocInfoForDeclaration(com.google.javascript.jscomp.GlobalNamespace.Ref)",
        "snippet": "    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }\n",
        "begin_line": 1142,
        "end_line": 1156,
        "comment": "\n     * Tries to get the doc info for a given declaration ref.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0878
        },
        "num_failing_tests": 3
    },
    {
        "name": "NodeUtil.isExpressionResultUsed#3149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isExpressionResultUsed(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isExpressionResultUsed(Node expr) {\n    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n    Node parent = expr.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n        return false;\n      case Token.CAST:\n        return isExpressionResultUsed(parent);\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return (expr == parent.getFirstChild())\n            ? true : isExpressionResultUsed(parent);\n      case Token.COMMA:\n        Node gramps = parent.getParent();\n        if (gramps.isCall() &&\n            parent == gramps.getFirstChild()) {\n          // Semantically, a direct call to eval is different from an indirect\n          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n          // expression to a comma to be a no-op if it's used to indirect\n          // an eval. This we pretend that this is \"used\".\n          if (expr == parent.getFirstChild() &&\n              parent.getChildCount() == 2 &&\n              expr.getNext().isName() &&\n              \"eval\".equals(expr.getNext().getString())) {\n            return true;\n          }\n        }\n\n        return (expr == parent.getFirstChild())\n            ? false : isExpressionResultUsed(parent);\n      case Token.FOR:\n        if (!NodeUtil.isForIn(parent)) {\n          // Only an expression whose result is in the condition part of the\n          // expression is used.\n          return (parent.getChildAtIndex(1) == expr);\n        }\n        break;\n    }\n    return true;\n  }\n",
        "begin_line": 3149,
        "end_line": 3190,
        "comment": "\n   * @returns false iff the result of the expression is not consumed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0875
        },
        "num_failing_tests": 4
    },
    {
        "name": "Scope.getScope#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getScope()",
        "snippet": "    Scope getScope() {\n      return scope;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "\n     * Gets the scope where this variable is declared.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 2
    },
    {
        "name": "PhaseOptimizer.ProgressRange#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.ProgressRange.ProgressRange(double, double)",
        "snippet": "    public ProgressRange(double initialValue, double maxValue) {\n      this.initialValue = initialValue;\n      this.maxValue = maxValue;\n    }\n",
        "begin_line": 413,
        "end_line": 416,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.NamedPass#276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.NamedPass.NamedPass(com.google.javascript.jscomp.PassFactory)",
        "snippet": "    NamedPass(PassFactory factory) {\n      this.name = factory.getName();\n      this.factory = factory;\n    }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.process#281",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.NamedPass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      logger.fine(name);\n      startPass(name);\n      // Delay the creation of the actual pass until *after* all previous passes\n      // have been processed.\n      // Some precondition checks rely on this, eg, in CoalesceVariableNames.\n      factory.create(compiler).process(externs, root);\n      endPass(externs, root);\n    }\n",
        "begin_line": 281,
        "end_line": 290,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.PhaseOptimizer#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.PhaseOptimizer(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.PerformanceTracker, com.google.javascript.jscomp.PhaseOptimizer.ProgressRange)",
        "snippet": "  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker,\n      ProgressRange progressRange) {\n    this.compiler = compiler;\n    this.tracker = tracker;\n    this.progressRange = progressRange;\n    compiler.addChangeHandler(recentChange);\n  }\n",
        "begin_line": 91,
        "end_line": 97,
        "comment": "\n   * @param compiler the compiler that owns/creates this.\n   * @param tracker an optional performance tracker\n   * @param progressRange the progress range for the process function or null\n   * if progress should not be reported.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.addOneTimePass#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.addOneTimePass(com.google.javascript.jscomp.PassFactory)",
        "snippet": "  void addOneTimePass(PassFactory factory) {\n    passes.add(new NamedPass(factory));\n  }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n   * Add the pass generated by the given factory to the compile sequence.\n   * This pass will be run once.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.startPass#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.startPass(java.lang.String)",
        "snippet": "  private void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null && currentPassName == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n",
        "begin_line": 205,
        "end_line": 209,
        "comment": "\n   * Marks the beginning of a pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.maybeSanityCheck#240",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.maybeSanityCheck(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  void maybeSanityCheck(Node externs, Node root) {\n    if (sanityCheck != null) {\n      sanityCheck.create(compiler).process(externs, root);\n    }\n  }\n",
        "begin_line": 240,
        "end_line": 244,
        "comment": "\n   * Runs the sanity check if it is available.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.hasHaltingErrors#246",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.hasHaltingErrors()",
        "snippet": "  private boolean hasHaltingErrors() {\n    return compiler.hasHaltingErrors();\n  }\n",
        "begin_line": 246,
        "end_line": 248,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.newTracer#253",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.newTracer(java.lang.String)",
        "snippet": "  private Tracer newTracer(String passName) {\n    String comment = passName +\n        (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (tracker != null) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"JSCompiler\", comment);\n  }\n",
        "begin_line": 253,
        "end_line": 260,
        "comment": "\n   * Returns a new tracer for the given pass name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PhaseOptimizer.stopTracer#262",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PhaseOptimizer.java",
        "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
        "signature": "com.google.javascript.jscomp.PhaseOptimizer.stopTracer(com.google.javascript.jscomp.Tracer, java.lang.String)",
        "snippet": "  private void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (tracker != null) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n",
        "begin_line": 262,
        "end_line": 267,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PassFactory.getName#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassFactory.java",
        "class_name": "com.google.javascript.jscomp.PassFactory",
        "signature": "com.google.javascript.jscomp.PassFactory.getName()",
        "snippet": "  String getName() {\n    return name;\n  }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n   * @return The name of this pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "PassFactory.isOneTimePass#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassFactory.java",
        "class_name": "com.google.javascript.jscomp.PassFactory",
        "signature": "com.google.javascript.jscomp.PassFactory.isOneTimePass()",
        "snippet": "  boolean isOneTimePass() {\n    return isOneTimePass;\n  }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n   * @return Whether the pass produced by this factory can only be run once.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.createEmptyPass#2183",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.createEmptyPass(java.lang.String)",
        "snippet": "  static PassFactory createEmptyPass(String name) {\n    return new PassFactory(name, true) {\n      @Override\n      protected CompilerPass create(final AbstractCompiler compiler) {\n        return runInSerial();\n      }\n    };\n  }\n",
        "begin_line": 2183,
        "end_line": 2190,
        "comment": "\n   * Create a no-op pass that can only run once. Used to break up loops.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#2185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-c95bc448-60ce-477c-8a4e-34ef0c944869.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "      @Override\n      protected CompilerPass create(final AbstractCompiler compiler) {\n        return runInSerial();\n      }\n",
        "begin_line": 2185,
        "end_line": 2188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.runInSerial#2221",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(java.util.Collection<com.google.javascript.jscomp.CompilerPass>)",
        "snippet": "  private static CompilerPass runInSerial(\n      final Collection<CompilerPass> passes) {\n    return new CompilerPass() {\n      @Override public void process(Node externs, Node root) {\n        for (CompilerPass pass : passes) {\n          pass.process(externs, root);\n        }\n      }\n    };\n  }\n",
        "begin_line": 2221,
        "end_line": 2230,
        "comment": " Create a compiler pass that runs the given passes in serial. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.process#2224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-de4895d6-efd0-4dad-bbd8-8e2713a73de8.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "      @Override public void process(Node externs, Node root) {\n        for (CompilerPass pass : passes) {\n          pass.process(externs, root);\n        }\n      }\n",
        "begin_line": 2224,
        "end_line": 2228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.create#757",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-8ba63d8a-4b7a-43ee-9798-1d27b4b8d088.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n      // The current approach to protecting \"hidden\" side-effects is to\n      // wrap them in a function call that is stripped later, this shouldn't\n      // be done in IDE mode where AST changes may be unexpected.\n      boolean protectHiddenSideEffects =\n          options.protectHiddenSideEffects && !options.ideMode;\n      return new CheckSideEffects(compiler,\n          options.checkSuspiciousCode ? CheckLevel.WARNING : CheckLevel.OFF,\n              protectHiddenSideEffects);\n    }\n",
        "begin_line": 757,
        "end_line": 767,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.assertAllOneTimePasses#808",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllOneTimePasses(java.util.List<com.google.javascript.jscomp.PassFactory>)",
        "snippet": "  private void assertAllOneTimePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(pass.isOneTimePass());\n    }\n  }\n",
        "begin_line": 808,
        "end_line": 812,
        "comment": " Verify that all the passes are one-time passes. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.runInSerial#2216",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(com.google.javascript.jscomp.CompilerPass...)",
        "snippet": "  private static CompilerPass runInSerial(final CompilerPass ... passes) {\n    return runInSerial(Lists.newArrayList(passes));\n  }\n",
        "begin_line": 2216,
        "end_line": 2218,
        "comment": " Create a compiler pass that runs the given passes in serial. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "ComposeWarningsGuard.level#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ComposeWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
        "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    for (WarningsGuard guard : guards) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        if (demoteErrors && newLevel == CheckLevel.ERROR) {\n          return CheckLevel.WARNING;\n        }\n        return newLevel;\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 110,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.isOn#2091",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.TweakProcessing.isOn()",
        "snippet": "    public boolean isOn() {\n      return this != OFF;\n    }\n",
        "begin_line": 2091,
        "end_line": 2093,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerOptions.getTweakProcessing#1457",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.getTweakProcessing()",
        "snippet": "  public TweakProcessing getTweakProcessing() {\n    return tweakProcessing;\n  }\n",
        "begin_line": 1457,
        "end_line": 1459,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.runCustomPasses#904",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.runCustomPasses(com.google.javascript.jscomp.CustomPassExecutionTime)",
        "snippet": "  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n",
        "begin_line": 904,
        "end_line": 915,
        "comment": "\n   * Runs custom passes that are designated to run at a particular time.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getProgress#2380",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getProgress()",
        "snippet": "  @Override\n  public double getProgress() {\n    return progress;\n  }\n",
        "begin_line": 2380,
        "end_line": 2383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "CheckSideEffects.CheckSideEffects#57",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckSideEffects.java",
        "class_name": "com.google.javascript.jscomp.CheckSideEffects",
        "signature": "com.google.javascript.jscomp.CheckSideEffects.CheckSideEffects(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CheckLevel, boolean)",
        "snippet": "  CheckSideEffects(AbstractCompiler compiler, CheckLevel level,\n      boolean protectSideEffectFreeCode) {\n    this.compiler = compiler;\n    this.level = level;\n    this.protectSideEffectFreeCode = protectSideEffectFreeCode;\n  }\n",
        "begin_line": 57,
        "end_line": 62,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroup.isSubGroup#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 116,
        "end_line": 123,
        "comment": "\n   * Returns whether all of the types in the given group are in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.eatTokensUntilEOL#2276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }\n",
        "begin_line": 2276,
        "end_line": 2285,
        "comment": "\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0865
        },
        "num_failing_tests": 4
    },
    {
        "name": "WarningsGuard.disables#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.disables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  protected boolean disables(DiagnosticGroup group) {\n    return false;\n  }\n",
        "begin_line": 94,
        "end_line": 96,
        "comment": "\n   * Returns whether all warnings in the given diagnostic group will be\n   * filtered out. Used to determine which passes to skip.\n   *\n   * @param group A group of DiagnosticTypes.\n   * @return Whether all warnings of these types are disabled by this guard.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0865
        },
        "num_failing_tests": 4
    },
    {
        "name": "WarningsGuard.enables#105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.WarningsGuard",
        "signature": "com.google.javascript.jscomp.WarningsGuard.enables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  protected boolean enables(DiagnosticGroup group) {\n    return false;\n  }\n",
        "begin_line": 105,
        "end_line": 107,
        "comment": "\n   * Returns whether any of the warnings in the given diagnostic group will be\n   * upgraded to a warning or error.\n   *\n   * @param group A group of DiagnosticTypes.\n   * @return Whether any warnings of these types are enabled by this guard.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0865
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateGetProp#619",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateGetProp(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateGetProp(Node n) {\n    validateNodeType(Token.GETPROP, n);\n    validateChildCount(n, 2);\n    validateExpression(n.getFirstChild());\n    Node prop = n.getLastChild();\n    validateNodeType(Token.STRING, prop);\n    validateNonEmptyString(prop);\n  }\n",
        "begin_line": 619,
        "end_line": 626,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0864
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroupWarningsGuard.disables#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.precheck#797",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.precheck()",
        "snippet": "  boolean precheck() {\n    return true;\n  }\n",
        "begin_line": 797,
        "end_line": 799,
        "comment": "\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isSimpleOperatorType#714",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isSimpleOperatorType(int)",
        "snippet": "  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 714,
        "end_line": 750,
        "comment": "\n   * A \"simple\" operator is one whose children are expressions,\n   * has no direct side-effects (unlike '+='), and has no\n   * conditional aspects (unlike '||').\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0861
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.StringNode#195",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.StringNode(int, java.lang.String, int, int)",
        "snippet": "    StringNode(int type, String str, int lineno, int charno) {\n      super(type, lineno, charno);\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }\n",
        "begin_line": 195,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.newString#511",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(java.lang.String, int, int)",
        "snippet": "  public static Node newString(String str, int lineno, int charno) {\n    return new StringNode(Token.STRING, str, lineno, charno);\n  }\n",
        "begin_line": 511,
        "end_line": 513,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSTypeExpression.JSTypeExpression#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  public JSTypeExpression(Node root, String sourceName) {\n    this.root = root;\n    this.sourceName = sourceName;\n  }\n",
        "begin_line": 64,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.markTypeNode#181",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(com.google.javascript.rhino.Node, int, int, int, int, boolean)",
        "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n      int endLineno, int endCharno, boolean hasLC) {\n    if (currentMarker != null) {\n      JSDocInfo.TypePosition position = new JSDocInfo.TypePosition();\n      position.setItem(typeNode);\n      position.setHasBrackets(hasLC);\n      position.setPositionInformation(lineno, startCharno,\n          endLineno, endCharno);\n      currentMarker.setType(position);\n    }\n  }\n",
        "begin_line": 181,
        "end_line": 191,
        "comment": "\n   * Adds a type declaration to the current marker.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.recordType#451",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordType(JSTypeExpression type) {\n    if (type != null && !hasAnyTypeRelatedTags()) {\n      currentInfo.setType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 451,
        "end_line": 459,
        "comment": "\n   * Records a type.\n   *\n   * @return {@code true} if the type was recorded and {@code false} if\n   *     it is invalid or was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.recordReturnType#498",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordReturnType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  public boolean recordReturnType(JSTypeExpression jsType) {\n    if (jsType != null && currentInfo.getReturnType() == null &&\n        !hasAnySingletonTypeTags()) {\n      currentInfo.setReturnType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 498,
        "end_line": 507,
        "comment": "\n   * Records a return type.\n   *\n   * @return {@code true} if the return type was recorded and {@code false} if\n   *     it is invalid or was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.recordNoSideEffects#931",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordNoSideEffects()",
        "snippet": "  public boolean recordNoSideEffects() {\n    if (!hasAnySingletonSideEffectTags()\n        && !currentInfo.isNoSideEffects()) {\n      currentInfo.setNoSideEffects(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 931,
        "end_line": 940,
        "comment": "\n   * Records that the {@link JSDocInfo} being built should have its\n   * {@link JSDocInfo#isNoSideEffects()} flag set to {@code true}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.hasAnyTypeRelatedTags#1012",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnyTypeRelatedTags()",
        "snippet": "  private boolean hasAnyTypeRelatedTags() {\n    return currentInfo.isConstructor() ||\n        currentInfo.isInterface() ||\n        currentInfo.getParameterCount() > 0 ||\n        currentInfo.hasReturnType() ||\n        currentInfo.hasBaseType() ||\n        currentInfo.getExtendedInterfacesCount() > 0 ||\n        currentInfo.getLendsName() != null ||\n        currentInfo.hasThisType() ||\n        hasAnySingletonTypeTags();\n  }\n",
        "begin_line": 1012,
        "end_line": 1022,
        "comment": "\n   * Whether the current doc info has other type tags, like\n   * {@code @param} or {@code @return} or {@code @type} or etc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.hasAnySingletonSideEffectTags#1040",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonSideEffectTags()",
        "snippet": "  private boolean hasAnySingletonSideEffectTags() {\n    return currentInfo.isNoSideEffects() ||\n        currentInfo.hasModifies();\n  }\n",
        "begin_line": 1040,
        "end_line": 1043,
        "comment": "\n   * Whether the current doc info has any of the singleton type\n   * tags that may not appear with other type tags, like\n   * {@code @type} or {@code @typedef}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setNoSideEffects#418",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setNoSideEffects(boolean)",
        "snippet": "  void setNoSideEffects(boolean value) {\n    setFlag(value, MASK_NOSIDEEFFECTS);\n  }\n",
        "begin_line": 418,
        "end_line": 420,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isNoSideEffects#598",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoSideEffects()",
        "snippet": "  public boolean isNoSideEffects() {\n    return getFlag(MASK_NOSIDEEFFECTS);\n  }\n",
        "begin_line": 598,
        "end_line": 600,
        "comment": "\n   * Returns whether the {@code @nosideeffects} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isJavaDispatch#614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
        "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }\n",
        "begin_line": 614,
        "end_line": 616,
        "comment": "\n   * Returns whether the {@code @javadispatch} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setType#1037",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1037,
        "end_line": 1039,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setReturnType#1041",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setReturnType(com.google.javascript.rhino.JSTypeExpression)",
        "snippet": "  void setReturnType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1041,
        "end_line": 1043,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setType#1053",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setType(com.google.javascript.rhino.JSTypeExpression, int)",
        "snippet": "  private void setType(JSTypeExpression type, int mask) {\n    if ((bitset & MASK_TYPEFIELD) != 0) {\n      throw new IllegalStateException(\n          \"API tried to add two incompatible type tags. \" +\n          \"This should have been blocked and emitted a warning.\");\n    }\n    this.bitset = (bitset & MASK_FLAGS) | mask;\n    this.type = type;\n  }\n",
        "begin_line": 1053,
        "end_line": 1061,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getReturnType#1119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getReturnType()",
        "snippet": "  public JSTypeExpression getReturnType() {\n    return getType(TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1119,
        "end_line": 1121,
        "comment": "\n   * Gets the return type specified by the {@code @return} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getType#1137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getType(int)",
        "snippet": "  private JSTypeExpression getType(int typefield) {\n    if ((MASK_TYPEFIELD & bitset) == typefield) {\n      return type;\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 1137,
        "end_line": 1143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getBaseType#1175",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
        "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }\n",
        "begin_line": 1175,
        "end_line": 1177,
        "comment": "\n   * Gets the base type specified by the {@code @extends} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getLendsName#1219",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getLendsName()",
        "snippet": "  public String getLendsName() {\n    return (info == null) ? null : info.lendsName;\n  }\n",
        "begin_line": 1219,
        "end_line": 1221,
        "comment": "\n   * Gets the name we're lending to in a {@code @lends} annotation.\n   *\n   * In many reflection APIs, you pass an anonymous object to a function,\n   * and that function mixes the anonymous object into another object.\n   * The {@code @lends} annotation allows the type system to track\n   * those property assignments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasBaseType#1256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
        "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }\n",
        "begin_line": 1256,
        "end_line": 1258,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @extends}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getExtendedInterfacesCount#1333",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getExtendedInterfacesCount()",
        "snippet": "  public int getExtendedInterfacesCount() {\n    if (info == null || info.extendedInterfaces == null) {\n      return 0;\n    }\n    return info.extendedInterfaces.size();\n  }\n",
        "begin_line": 1333,
        "end_line": 1338,
        "comment": "\n   * Gets the number of extended interfaces specified\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasModifies#1526",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasModifies()",
        "snippet": "  public boolean hasModifies() {\n    return info != null && info.modifies != null;\n  }\n",
        "begin_line": 1526,
        "end_line": 1528,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.matchChar#259",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
        "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }\n",
        "begin_line": 259,
        "end_line": 268,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getChar#336",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
        "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }\n",
        "begin_line": 336,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.ungetCharIgnoreLineEnd#438",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetCharIgnoreLineEnd(int)",
        "snippet": "  private void ungetCharIgnoreLineEnd(int c) {\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }\n",
        "begin_line": 438,
        "end_line": 441,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.getSourceName#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getSourceName()",
        "snippet": "  private String getSourceName() {\n    return sourceFile == null ? null : sourceFile.getName();\n  }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseAndRecordTypeNode#1111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n  }\n",
        "begin_line": 1111,
        "end_line": 1113,
        "comment": "\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseAndRecordTypeNode#1123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(com.google.javascript.jscomp.parsing.JsDocToken, boolean)",
        "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);\n  }\n",
        "begin_line": 1123,
        "end_line": 1126,
        "comment": "\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseAndRecordTypeNode#1185",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(com.google.javascript.jscomp.parsing.JsDocToken, int, int, boolean, boolean)",
        "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    if (typeNode != null) {\n      int endLineno = stream.getLineno();\n      int endCharno = stream.getCharno();\n\n      jsdocBuilder.markTypeNode(\n          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);\n    }\n\n    return typeNode;\n  }\n",
        "begin_line": 1185,
        "end_line": 1206,
        "comment": "\n   * Looks for a parameter type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\n   *     (via a call to parseTypeNameAnnotation instead of\n   *     parseTypeExpressionAnnotation).\n   * @return The type expression found or null if none.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.createJSTypeExpression#1276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, getSourceName());\n  }\n",
        "begin_line": 1276,
        "end_line": 1279,
        "comment": "\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseTypeExpressionAnnotation#1581",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }\n",
        "begin_line": 1581,
        "end_line": 1598,
        "comment": "\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseTopLevelTypeExpression#1674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }\n",
        "begin_line": 1674,
        "end_line": 1690,
        "comment": "\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.parseTypeName#1804",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }\n",
        "begin_line": 1804,
        "end_line": 1839,
        "comment": "\n   * TypeName := NameExpression | NameExpression TypeApplication\n   * TypeApplication := '.<' TypeExpressionList '>'\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.newStringNode#2237",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(java.lang.String, int, int)",
        "snippet": "  private Node newStringNode(String s, int lineno, int charno) {\n    Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n    n.setLength(s.length());\n    return n;\n  }\n",
        "begin_line": 2237,
        "end_line": 2241,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.lookAheadForTypeAnnotation#2385",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.lookAheadForTypeAnnotation()",
        "snippet": "  private boolean lookAheadForTypeAnnotation() {\n    boolean matchedLc = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == '{') {\n        matchedLc = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matchedLc;\n  }\n",
        "begin_line": 2385,
        "end_line": 2401,
        "comment": "\n   * Look ahead for a type annotation by advancing the character stream.\n   * Does not modify the token stream.\n   * This is kind of a hack, and is only necessary because we use the token\n   * stream to parse types, but need the underlying character stream to get\n   * JsDoc descriptions.\n   * @return Whether we found a type annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.validateTypeAnnotations#289",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.validateTypeAnnotations(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.head.ast.AstNode, com.google.javascript.rhino.Node)",
        "snippet": "  private void validateTypeAnnotations(\n      JSDocInfo info, AstNode node, Node irNode) {\n    if (info.hasType()) {\n      boolean valid = false;\n      switch (node.getType()) {\n        // Casts are valid\n        case com.google.javascript.rhino.head.Token.LP:\n          valid = node instanceof ParenthesizedExpression;\n          break;\n        // Variable declarations are valid\n        case com.google.javascript.rhino.head.Token.VAR:\n          valid = true;\n          break;\n        // Function declarations are valid\n        case com.google.javascript.rhino.head.Token.FUNCTION:\n          FunctionNode fnNode = (FunctionNode)node;\n          valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n          break;\n        // Object literal properties and catch declarations are valid.\n        case com.google.javascript.rhino.head.Token.NAME:\n          valid = node.getParent() instanceof ObjectProperty\n              || node.getParent() instanceof CatchClause\n              || node.getParent() instanceof FunctionNode;\n          break;\n        // Object literal properties are valid\n        case com.google.javascript.rhino.head.Token.GET:\n        case com.google.javascript.rhino.head.Token.SET:\n        case com.google.javascript.rhino.head.Token.NUMBER:\n        case com.google.javascript.rhino.head.Token.STRING:\n          valid = node.getParent() instanceof ObjectProperty;\n          break;\n\n        // Property assignments are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.ASSIGN:\n          if (node instanceof Assignment) {\n            valid = isExprStmt(node.getParent())\n                && isPropAccess(((Assignment)node).getLeft());\n          }\n          break;\n\n        // Property definitions are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.GETPROP:\n        case com.google.javascript.rhino.head.Token.GETELEM:\n          valid = isExprStmt(node.getParent());\n          break;\n      }\n      if (!valid) {\n        errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n            sourceName,\n            node.getLineno(), \"\", 0);\n      }\n    }\n  }\n",
        "begin_line": 289,
        "end_line": 341,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.isExprStmt#348",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.isExprStmt(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "  private boolean isExprStmt(AstNode node) {\n    return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT\n        || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID;\n  }\n",
        "begin_line": 348,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "CompilerInput.getModule#319",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerInput.java",
        "class_name": "com.google.javascript.jscomp.CompilerInput",
        "signature": "com.google.javascript.jscomp.CompilerInput.getModule()",
        "snippet": "  public JSModule getModule() {\n    return module;\n  }\n",
        "begin_line": 319,
        "end_line": 321,
        "comment": " Returns the module to which the input belongs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.isConditionalStatement#635",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.isConditionalStatement(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isConditionalStatement(Node n) {\n    // We defined a conditional statement to be a IF or EXPR_RESULT rooted with\n    // a HOOK, AND, or OR node.\n    return n != null && (n.isIf() || isExprConditional(n));\n  }\n",
        "begin_line": 635,
        "end_line": 639,
        "comment": "\n   * @return Whether the node is a conditional statement.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getName#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getName()",
        "snippet": "  @Override\n      public String getName() {\n    return name;\n  }\n",
        "begin_line": 87,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "Property.getNode#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getNode()",
        "snippet": "  @Override\n      public Node getNode() {\n    return propertyNode;\n  }\n",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createFromTypeNodesInternal#1520",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodesInternal(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  private JSType createFromTypeNodesInternal(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    switch (n.getType()) {\n      case Token.LC: // Record type.\n        return createRecordTypeFromNodes(\n            n.getFirstChild(), sourceName, scope);\n\n      case Token.BANG: // Not nullable\n        return createFromTypeNodesInternal(\n            n.getFirstChild(), sourceName, scope)\n            .restrictByNotNullOrUndefined();\n\n      case Token.QMARK: // Nullable or unknown\n        Node firstChild = n.getFirstChild();\n        if (firstChild == null) {\n          return getNativeType(UNKNOWN_TYPE);\n        }\n        return createDefaultObjectUnion(\n            createFromTypeNodesInternal(\n                firstChild, sourceName, scope));\n\n      case Token.EQUALS: // Optional\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.ELLIPSIS: // Var args\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.STAR: // The AllType\n        return getNativeType(ALL_TYPE);\n\n      case Token.LB: // Array type\n        // TODO(nicksantos): Enforce membership restrictions on the Array.\n        return getNativeType(ARRAY_TYPE);\n\n      case Token.PIPE: // Union type\n        UnionTypeBuilder builder = new UnionTypeBuilder(this);\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          builder.addAlternate(\n              createFromTypeNodesInternal(child, sourceName, scope));\n        }\n        return builder.build();\n\n      case Token.EMPTY: // When the return value of a function is not specified\n        return getNativeType(UNKNOWN_TYPE);\n\n      case Token.VOID: // Only allowed in the return value of a function.\n        return getNativeType(VOID_TYPE);\n\n      case Token.STRING:\n        JSType namedType = getType(scope, n.getString(), sourceName,\n            n.getLineno(), n.getCharno());\n        if (resolveMode != ResolveMode.LAZY_NAMES) {\n          namedType = namedType.resolveInternal(reporter, scope);\n        }\n        if ((namedType instanceof ObjectType) &&\n            !(nonNullableTypeNames.contains(n.getString()))) {\n          Node typeList = n.getFirstChild();\n          if (typeList != null &&\n              (\"Array\".equals(n.getString()) ||\n               \"Object\".equals(n.getString()))) {\n            JSType parameterType =\n                createFromTypeNodesInternal(\n                    typeList.getLastChild(), sourceName, scope);\n            namedType = new ParameterizedType(\n                this, (ObjectType) namedType, parameterType);\n            if (typeList.hasMoreThanOneChild()) {\n              JSType indexType =\n                  createFromTypeNodesInternal(\n                      typeList.getFirstChild(), sourceName, scope);\n              namedType = new IndexedType(\n                  this, (ObjectType) namedType, indexType);\n            }\n          }\n          return createDefaultObjectUnion(namedType);\n        } else {\n          return namedType;\n        }\n\n      case Token.FUNCTION:\n        ObjectType thisType = null;\n        boolean isConstructor = false;\n        Node current = n.getFirstChild();\n        if (current.getType() == Token.THIS ||\n            current.getType() == Token.NEW) {\n          Node contextNode = current.getFirstChild();\n          thisType =\n              ObjectType.cast(\n                  createFromTypeNodesInternal(\n                      contextNode, sourceName, scope)\n                  .restrictByNotNullOrUndefined());\n          if (thisType == null) {\n            reporter.warning(\n                ScriptRuntime.getMessage0(\n                    current.getType() == Token.THIS ?\n                    \"msg.jsdoc.function.thisnotobject\" :\n                    \"msg.jsdoc.function.newnotobject\"),\n                sourceName,\n                contextNode.getLineno(), contextNode.getCharno());\n          }\n\n          isConstructor = current.getType() == Token.NEW;\n          current = current.getNext();\n        }\n\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n\n        if (current.getType() == Token.PARAM_LIST) {\n          Node args = current.getFirstChild();\n          for (Node arg = current.getFirstChild(); arg != null;\n               arg = arg.getNext()) {\n            if (arg.getType() == Token.ELLIPSIS) {\n              if (arg.getChildCount() == 0) {\n                paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n              } else {\n                paramBuilder.addVarArgs(\n                    createFromTypeNodesInternal(\n                        arg.getFirstChild(), sourceName, scope));\n              }\n            } else {\n              JSType type = createFromTypeNodesInternal(\n                  arg, sourceName, scope);\n              if (arg.getType() == Token.EQUALS) {\n                boolean addSuccess = paramBuilder.addOptionalParams(type);\n                if (!addSuccess) {\n                  reporter.warning(\n                      ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"),\n                      sourceName, arg.getLineno(), arg.getCharno());\n                }\n              } else {\n                paramBuilder.addRequiredParams(type);\n              }\n            }\n          }\n          current = current.getNext();\n        }\n\n        JSType returnType =\n            createFromTypeNodesInternal(current, sourceName, scope);\n\n        return new FunctionBuilder(this)\n            .withParams(paramBuilder)\n            .withReturnType(returnType)\n            .withTypeOfThis(thisType)\n            .setIsConstructor(isConstructor)\n            .build();\n    }\n\n    throw new IllegalStateException(\n        \"Unexpected node in type expression: \" + n.toString());\n  }\n",
        "begin_line": 1520,
        "end_line": 1674,
        "comment": " @see #createFromTypeNodes(Node, String, StaticScope) ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.isInstanceType#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isInstanceType()",
        "snippet": "  @Override\n  public boolean isInstanceType() {\n    // The universal constructor is its own instance, bizarrely. It overrides\n    // getConstructor() appropriately when it's declared.\n    return this == registry.getNativeType(U2U_CONSTRUCTOR_TYPE);\n  }\n",
        "begin_line": 182,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.hasEqualCallType#913",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.hasEqualCallType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.checkArrowEquivalenceHelper(\n        otherType.call, EquivalenceMethod.IDENTITY);\n  }\n",
        "begin_line": 913,
        "end_line": 916,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.setSource#1100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.setSource(com.google.javascript.rhino.Node)",
        "snippet": "  public void setSource(Node source) {\n    if (prototypeSlot != null) {\n      // NOTE(bashir): On one hand when source is null we want to drop any\n      // references to old nodes retained in prototypeSlot. On the other hand\n      // we cannot simply drop prototypeSlot, so we retain all information\n      // except the propertyNode for which we use an approximation! These\n      // details mostly matter in hot-swap passes.\n      if (source == null || prototypeSlot.getNode() == null) {\n        prototypeSlot = new Property(prototypeSlot.getName(),\n            prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source);\n      }\n    }\n    this.source = source;\n  }\n",
        "begin_line": 1100,
        "end_line": 1113,
        "comment": "\n   * Sets the source node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrowType.hasEqualParameters#177",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.hasEqualParameters(com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.checkEquivalenceHelper(\n                otherParamType, eqMethod)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n\n      // Check var_args/optionality\n      if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {\n        return false;\n      }\n\n      if (thisParam.isVarArgs() != otherParam.isVarArgs()) {\n        return false;\n      }\n\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }\n",
        "begin_line": 177,
        "end_line": 211,
        "comment": "\n   * @return True if our parameter spec is equal to {@code that}'s parameter\n   *     spec.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrowType.checkArrowEquivalenceHelper#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.checkArrowEquivalenceHelper(com.google.javascript.rhino.jstype.ArrowType, com.google.javascript.rhino.jstype.EquivalenceMethod)",
        "snippet": "  boolean checkArrowEquivalenceHelper(\n      ArrowType that, EquivalenceMethod eqMethod) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {\n      return false;\n    }\n    return hasEqualParameters(that, eqMethod);\n  }\n",
        "begin_line": 213,
        "end_line": 220,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getThisType#1148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getThisType()",
        "snippet": "  public JSTypeExpression getThisType() {\n    return thisType;\n  }\n",
        "begin_line": 1148,
        "end_line": 1150,
        "comment": "\n   * Gets the type specified by the {@code @this} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.unaryOp#478",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.unaryOp(int, com.google.javascript.rhino.Node)",
        "snippet": "  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n",
        "begin_line": 478,
        "end_line": 481,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processUnaryExpression#1104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processUnaryExpression(com.google.javascript.rhino.head.ast.UnaryExpression)",
        "snippet": "    @Override\n    Node processUnaryExpression(UnaryExpression exprNode) {\n      int type = transformTokenType(exprNode.getType());\n      Node operand = transform(exprNode.getOperand());\n      if (type == Token.NEG && operand.isNumber()) {\n        operand.setDouble(-operand.getDouble());\n        return operand;\n      } else {\n        if (type == Token.DELPROP &&\n            !(operand.isGetProp() ||\n              operand.isGetElem() ||\n              operand.isName())) {\n          String msg =\n              \"Invalid delete operand. Only properties can be deleted.\";\n          errorReporter.error(\n              msg,\n              sourceName,\n              operand.getLineno(), \"\", 0);\n        } else  if (type == Token.INC || type == Token.DEC) {\n          if (!validAssignmentTarget(operand)) {\n            String msg = (type == Token.INC)\n                ? \"invalid increment target\"\n                : \"invalid decrement target\";\n            errorReporter.error(\n                msg,\n                sourceName,\n                operand.getLineno(), \"\", 0);\n          }\n        }\n\n        Node node = newNode(type, operand);\n        if (exprNode.isPostfix()) {\n          node.putBooleanProp(Node.INCRDECR_PROP, true);\n        }\n        return node;\n      }\n    }\n",
        "begin_line": 1104,
        "end_line": 1140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.finishConstructorDefinition#1206",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.finishConstructorDefinition(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.CompilerInput, com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    private void finishConstructorDefinition(\n        Node n, String variableName, FunctionType fnType,\n        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n      // Declare var.prototype in the scope chain.\n      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n      Property prototypeSlot = fnType.getSlot(\"prototype\");\n\n      // When we declare the function prototype implicitly, we\n      // want to make sure that the function and its prototype\n      // are declared at the same node. We also want to make sure\n      // that the if a symbol has both a Var and a JSType, they have\n      // the same node.\n      //\n      // This consistency is helpful to users of SymbolTable,\n      // because everything gets declared at the same place.\n      prototypeSlot.setNode(n);\n\n      String prototypeName = variableName + \".prototype\";\n\n      // There are some rare cases where the prototype will already\n      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n      // Fortunately, other warnings will complain if this happens.\n      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n      if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n        scopeToDeclareIn.undeclare(prototypeVar);\n      }\n\n      scopeToDeclareIn.declare(prototypeName,\n          n, prototypeSlot.getType(), input,\n          /* declared iff there's an explicit supertype */\n          superClassCtor == null ||\n          superClassCtor.getInstanceType().isEquivalentTo(\n              getNativeType(OBJECT_TYPE)));\n\n      // Make sure the variable is initialized to something if\n      // it constructs itself.\n      if (newVar.getInitialValue() == null &&\n          !n.isFromExterns()) {\n        compiler.report(\n            JSError.make(sourceName, n,\n                fnType.isConstructor() ?\n                CTOR_INITIALIZER : IFACE_INITIALIZER,\n                variableName));\n      }\n    }\n",
        "begin_line": 1206,
        "end_line": 1250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.getNode#1225",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Ref.getNode()",
        "snippet": "    @Override\n    public Node getNode() {\n      return node;\n    }\n",
        "begin_line": 1225,
        "end_line": 1228,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferThisType#394",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info) {\n    JSType maybeThisType = null;\n    if (info != null && info.hasThisType()) {\n      // TODO(johnlenz): In ES5 strict mode a function can have a null or\n      // undefined \"this\" value, but all the existing \"@this\" annotations\n      // don't declare restricted types.\n      maybeThisType = info.getThisType().evaluate(scope, typeRegistry)\n          .restrictByNotNullOrUndefined();\n    }\n    if (maybeThisType != null) {\n      thisType = maybeThisType;\n    }\n\n    return this;\n  }\n",
        "begin_line": 394,
        "end_line": 408,
        "comment": "\n   * Infers the type of {@code this}.\n   * @param info The JSDocInfo for this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.addParameter#547",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.addParameter(com.google.javascript.rhino.jstype.FunctionParamBuilder, com.google.javascript.rhino.jstype.JSType, boolean, boolean, boolean)",
        "snippet": "  private boolean addParameter(FunctionParamBuilder builder,\n      JSType paramType, boolean warnedAboutArgList,\n      boolean isOptional, boolean isVarArgs) {\n    boolean emittedWarning = false;\n    if (isOptional) {\n      // Remembering that an optional parameter has been encountered\n      // so that if a non optional param is encountered later, an\n      // error can be reported.\n      if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else if (isVarArgs) {\n      if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else {\n      if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {\n        // An optional parameter was seen and this argument is not an optional\n        // or var arg so it is an error.\n        if (builder.hasVarArgs()) {\n          reportWarning(VAR_ARGS_MUST_BE_LAST);\n        } else {\n          reportWarning(OPTIONAL_ARG_AT_END);\n        }\n        emittedWarning = true;\n      }\n    }\n    return emittedWarning;\n  }\n",
        "begin_line": 547,
        "end_line": 577,
        "comment": "\n   * Add a parameter to the param list.\n   * @param builder A builder.\n   * @param paramType The parameter type.\n   * @param warnedAboutArgList Whether we've already warned about arg ordering\n   *     issues (like if optional args appeared before required ones).\n   * @param isOptional Is this an optional parameter?\n   * @param isVarArgs Is this a var args parameter?\n   * @return Whether a warning was emitted.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.getOrCreateConstructor#665",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getOrCreateConstructor()",
        "snippet": "  private FunctionType getOrCreateConstructor() {\n    FunctionType fnType = typeRegistry.createConstructorType(\n        fnName, contents.getSourceNode(), parametersNode, returnType, null);\n    JSType existingType = typeRegistry.getType(fnName);\n\n    if (makesStructs) {\n      fnType.setStruct();\n    } else if (makesDicts) {\n      fnType.setDict();\n    }\n    if (existingType != null) {\n      boolean isInstanceObject = existingType.isInstanceType();\n      if (isInstanceObject || fnName.equals(\"Function\")) {\n        FunctionType existingFn =\n            isInstanceObject ?\n            existingType.toObjectType().getConstructor() :\n            typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n\n        if (existingFn.getSource() == null) {\n          existingFn.setSource(contents.getSourceNode());\n        }\n\n        if (!existingFn.hasEqualCallType(fnType)) {\n          reportWarning(TYPE_REDEFINITION, fnName,\n              fnType.toString(), existingFn.toString());\n        }\n\n        return existingFn;\n      } else {\n        // We fall through and return the created type, even though it will fail\n        // to register. We have no choice as we have to return a function. We\n        // issue an error elsewhere though, so the user should fix it.\n      }\n    }\n\n    maybeSetBaseType(fnType);\n\n    if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n      typeRegistry.declareType(fnName, fnType.getInstanceType());\n    }\n    return fnType;\n  }\n",
        "begin_line": 665,
        "end_line": 706,
        "comment": "\n   * Returns a constructor function either by returning it from the\n   * registry if it exists or creating and registering a new type. If\n   * there is already a type, then warn if the existing type is\n   * different than the one we are creating, though still return the\n   * existing function if possible.  The primary purpose of this is\n   * that registering a constructor will fail for all built-in types\n   * that are initialized in {@link JSTypeRegistry}.  We a) want to\n   * make sure that the type information specified in the externs file\n   * matches what is in the registry and b) annotate the externs with\n   * the {@link JSType} from the registry so that there are not two\n   * separate JSType objects for one type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.isOptionalParameter#352",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isOptionalParameter(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }\n",
        "begin_line": 352,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.isVarArgsParameter#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isVarArgsParameter(com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }\n",
        "begin_line": 357,
        "end_line": 360,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalNames.process#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalNames.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
        "signature": "com.google.javascript.jscomp.CheckGlobalNames.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (namespace == null) {\n      namespace = new GlobalNamespace(compiler, externs, root);\n    }\n\n    // Find prototype properties that will affect our analysis.\n    Preconditions.checkState(namespace.hasExternsRoot());\n    findPrototypeProps(\"Object\", objectPrototypeProps);\n    findPrototypeProps(\"Function\", functionPrototypeProps);\n    objectPrototypeProps.addAll(\n        convention.getIndirectlyDeclaredProperties());\n\n    for (Name name : namespace.getNameForest()) {\n      // Skip extern names. Externs are often not runnable as real code,\n      // and will do things like:\n      // var x;\n      // x.method;\n      // which this check forbids.\n      if (name.inExterns) {\n        continue;\n      }\n\n      checkDescendantNames(name, name.globalSets + name.localSets > 0);\n    }\n  }\n",
        "begin_line": 79,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalNames.checkDescendantNames#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalNames.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
        "signature": "com.google.javascript.jscomp.CheckGlobalNames.checkDescendantNames(com.google.javascript.jscomp.GlobalNamespace.Name, boolean)",
        "snippet": "  private void checkDescendantNames(Name name, boolean nameIsDefined) {\n    if (name.props != null) {\n      for (Name prop : name.props) {\n        // if the ancestor of a property is not defined, then we should emit\n        // warnings for all references to the property.\n        boolean propIsDefined = false;\n        if (nameIsDefined) {\n          // if the ancestor of a property is defined, then let's check that\n          // the property is also explicitly defined if it needs to be.\n          propIsDefined = (!propertyMustBeInitializedByFullName(prop) ||\n              prop.globalSets + prop.localSets > 0);\n        }\n\n        validateName(prop, propIsDefined);\n        checkDescendantNames(prop, propIsDefined);\n      }\n    }\n  }\n",
        "begin_line": 128,
        "end_line": 145,
        "comment": "\n   * Checks to make sure all the descendants of a name are defined if they\n   * are referenced.\n   *\n   * @param name A global name.\n   * @param nameIsDefined If true, {@code name} is defined. Otherwise, it's\n   *    undefined, and any references to descendant names should emit warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.Node#436",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, int, int)",
        "snippet": "  public Node(int nodeType, int lineno, int charno) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }\n",
        "begin_line": 436,
        "end_line": 440,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getParameterCount#1030",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
        "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }\n",
        "begin_line": 1030,
        "end_line": 1035,
        "comment": "\n   * Gets the number of parameters defined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasReturnType#1101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
        "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }\n",
        "begin_line": 1101,
        "end_line": 1103,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @return}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasThisType#1163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
        "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }\n",
        "begin_line": 1163,
        "end_line": 1165,
        "comment": "\n   * Returns whether this {@link JSDocInfo} contains a type for {@code @this}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.isJSDocString#279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
        "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }\n",
        "begin_line": 279,
        "end_line": 303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "SuppressDocWarningsGuard.level#51",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
        "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    Node node = error.node;\n    if (node != null) {\n      for (Node current = node;\n           current != null;\n           current = current.getParent()) {\n        int type = current.getType();\n        JSDocInfo info = null;\n\n        // We only care about function annotations at the FUNCTION and SCRIPT\n        // level. Otherwise, the @suppress annotation has an implicit\n        // dependency on the exact structure of our AST, and that seems like\n        // a bad idea.\n        if (type == Token.FUNCTION) {\n          info = NodeUtil.getFunctionJSDocInfo(current);\n        } else if (type == Token.SCRIPT) {\n          info = current.getJSDocInfo();\n        } else if (type == Token.ASSIGN) {\n          Node rhs = current.getLastChild();\n          if (rhs.isFunction()) {\n            info = NodeUtil.getFunctionJSDocInfo(rhs);\n          }\n        }\n\n        if (info != null) {\n          for (String suppressor : info.getSuppressions()) {\n            WarningsGuard guard = suppressors.get(suppressor);\n\n            // Some @suppress tags are for other tools, and\n            // may not have a warnings guard.\n            if (guard != null) {\n              CheckLevel newLevel = guard.level(error);\n              if (newLevel != null) {\n                return newLevel;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 51,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeTraversal.getInput#433",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
        "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(inputId);\n  }\n",
        "begin_line": 433,
        "end_line": 435,
        "comment": "\n   * Gets the current input source.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSError.getType#178",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.getType()",
        "snippet": "  public DiagnosticType getType() {\n    return type;\n  }\n",
        "begin_line": 178,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroupWarningsGuard.level#38",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
        "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.level(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    return group.matches(error) ? level : null;\n  }\n",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroup.matches#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(com.google.javascript.jscomp.JSError)",
        "snippet": "  public boolean matches(JSError error) {\n    return matches(error.getType());\n  }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n   * Returns whether the given error's type matches a type\n   * in this group.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 4
    },
    {
        "name": "CodeGenerator.isIndirectEval#811",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.isIndirectEval(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isIndirectEval(Node n) {\n    return n.isName() && \"eval\".equals(n.getString()) &&\n        !n.getBooleanProp(Node.DIRECT_EVAL);\n  }\n",
        "begin_line": 811,
        "end_line": 814,
        "comment": "\n   * @return Whether the name is an indirect eval.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0855
        },
        "num_failing_tests": 3
    },
    {
        "name": "Node.setLength#1117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setLength(int)",
        "snippet": "  public void setLength(int length) {\n    putIntProp(LENGTH, length);\n  }\n",
        "begin_line": 1117,
        "end_line": 1119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0853
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.lazyInitInfo#657",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
        "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }\n",
        "begin_line": 657,
        "end_line": 661,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0853
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSError.JSError#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.JSError(java.lang.String, com.google.javascript.rhino.Node, int, int, com.google.javascript.jscomp.DiagnosticType, com.google.javascript.jscomp.CheckLevel, java.lang.String...)",
        "snippet": "  private JSError(\n      String sourceName, @Nullable Node node, int lineno, int charno,\n      DiagnosticType type, CheckLevel level, String... arguments) {\n    this.type = type;\n    this.node = node;\n    this.description = type.format.format(arguments);\n    this.lineNumber = lineno;\n    this.charno = charno;\n    this.sourceName = sourceName;\n    this.defaultLevel = level == null ? type.level : level;\n    this.level = level == null ? type.level : level;\n  }\n",
        "begin_line": 152,
        "end_line": 163,
        "comment": "\n   * Creates a JSError at a CheckLevel for a source file location.\n   * Private to avoid any entanglement with code outside of the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0853
        },
        "num_failing_tests": 4
    },
    {
        "name": "Result.Result#39",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Result.java",
        "class_name": "com.google.javascript.jscomp.Result",
        "signature": "Result(JSError[], JSError[], String, VariableMap, VariableMap, VariableMap, VariableMap, FunctionInformationMap, SourceMap, String, Map, String)",
        "snippet": "  Result(JSError[] errors, JSError[] warnings, String debugLog,\n         VariableMap variableMap, VariableMap propertyMap,\n         VariableMap namedAnonFunctionMap,\n         VariableMap stringMap,\n         FunctionInformationMap functionInformationMap,\n         SourceMap sourceMap, String externExport,\n         Map<String, Integer> cssNames, String idGeneratorMap) {\n    this.success = errors.length == 0;\n    this.errors = errors;\n    this.warnings = warnings;\n    this.debugLog = debugLog;\n    this.variableMap = variableMap;\n    this.propertyMap = propertyMap;\n    this.namedAnonFunctionMap = namedAnonFunctionMap;\n    this.stringMap = stringMap;\n    this.functionInformationMap = functionInformationMap;\n    this.sourceMap = sourceMap;\n    this.externExport = externExport;\n    this.cssNames = cssNames;\n    this.idGeneratorMap = idGeneratorMap;\n  }\n",
        "begin_line": 39,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "PassConfig.State#295",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.State.State(java.util.Map<java.lang.String, java.lang.Integer>, java.util.Set<java.lang.String>, com.google.javascript.jscomp.CrossModuleMethodMotion.IdGenerator, com.google.javascript.jscomp.VariableMap, com.google.javascript.jscomp.VariableMap, com.google.javascript.jscomp.VariableMap, com.google.javascript.jscomp.VariableMap, com.google.javascript.jscomp.FunctionNames, java.lang.String)",
        "snippet": "    public State(Map<String, Integer> cssNames, Set<String> exportedNames,\n        CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator,\n        VariableMap variableMap, VariableMap propertyMap,\n        VariableMap anonymousFunctionNameMap,\n        VariableMap stringMap, FunctionNames functionNames,\n        String idGeneratorMap) {\n      this.cssNames = cssNames;\n      this.exportedNames = exportedNames;\n      this.crossModuleIdGenerator = crossModuleIdGenerator;\n      this.variableMap = variableMap;\n      this.propertyMap = propertyMap;\n      this.anonymousFunctionNameMap = anonymousFunctionNameMap;\n      this.stringMap = stringMap;\n      this.idGeneratorMap = idGeneratorMap;\n      this.functionNames = functionNames;\n    }\n",
        "begin_line": 295,
        "end_line": 310,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.getIntermediateState#139",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.getIntermediateState()",
        "snippet": "  @Override\n  protected State getIntermediateState() {\n    return new State(\n        cssNames == null ? null : Maps.newHashMap(cssNames),\n        exportedNames == null ? null :\n            Collections.unmodifiableSet(exportedNames),\n        crossModuleIdGenerator, variableMap, propertyMap,\n        anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap);\n  }\n",
        "begin_line": 139,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.call#655",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Anonymous-95f18194-d29e-4f35-b796-0900c5648bdf.call()",
        "snippet": "      @Override\n      public T call() {\n        try {\n          compilerThread = Thread.currentThread();\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          return callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          compilerThread = null;\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n            tracker.outputTracerReport(outStream == null ?\n                System.out : outStream);\n          }\n        }\n        return null;\n      }\n",
        "begin_line": 655,
        "end_line": 674,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.call#633",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Anonymous-1dc20619-1276-46e1-b344-2a1360c526b4.call()",
        "snippet": "      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n",
        "begin_line": 633,
        "end_line": 637,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getResult#965",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getResult()",
        "snippet": "  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n",
        "begin_line": 965,
        "end_line": 971,
        "comment": "\n   * Returns the result of the compilation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 4
    },
    {
        "name": "PassConfig.PassConfig#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.PassConfig(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public PassConfig(CompilerOptions options) {\n    this.options = options;\n  }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.HotSwapPassFactory#2307",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.HotSwapPassFactory.HotSwapPassFactory(java.lang.String, boolean)",
        "snippet": "    HotSwapPassFactory(String name, boolean isOneTimePass) {\n      super(name, isOneTimePass);\n    }\n",
        "begin_line": 2307,
        "end_line": 2309,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "DefaultPassConfig.DefaultPassConfig#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.DefaultPassConfig(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public DefaultPassConfig(CompilerOptions options) {\n    super(options);\n  }\n",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.compile#631",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.compile()",
        "snippet": "  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n",
        "begin_line": 631,
        "end_line": 639,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.newThread#197",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.Anonymous-286b4cca-4c76-4e74-9ae1-687d1a8db5c7.newThread(java.lang.Runnable)",
        "snippet": "    @Override public Thread newThread(Runnable r) {\n      return new Thread(null, r, \"jscompiler\", COMPILER_STACK_SIZE);\n    }\n",
        "begin_line": 197,
        "end_line": 199,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.parse#753",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.parse()",
        "snippet": "  public void parse() {\n    parseInputs();\n  }\n",
        "begin_line": 753,
        "end_line": 755,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.getPassConfig#757",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getPassConfig()",
        "snippet": "  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n",
        "begin_line": 757,
        "end_line": 762,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.createPassConfigInternal#768",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.createPassConfigInternal()",
        "snippet": "  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n",
        "begin_line": 768,
        "end_line": 770,
        "comment": "\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "Compiler.setProgress#2390",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.setProgress(double, java.lang.String)",
        "snippet": "  @Override\n  void setProgress(double newProgress, String passName) {\n    this.lastPassName = passName;\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n",
        "begin_line": 2390,
        "end_line": 2398,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "BasicErrorManager.generateReport#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.generateReport()",
        "snippet": "  @Override\n  public void generateReport() {\n    for (ErrorWithLevel message : messages) {\n      println(message.level, message.error);\n    }\n    printSummary();\n  }\n",
        "begin_line": 55,
        "end_line": 61,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.085
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateCall#373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateCall(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateCall(Node n) {\n    validateNodeType(Token.CALL, n);\n    validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateExpression(c);\n    }\n  }\n",
        "begin_line": 373,
        "end_line": 379,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0844
        },
        "num_failing_tests": 3
    },
    {
        "name": "CompilerOptions.disables#1117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.disables(com.google.javascript.jscomp.DiagnosticGroup)",
        "snippet": "  boolean disables(DiagnosticGroup type) {\n    return warningsGuard.disables(type);\n  }\n",
        "begin_line": 1117,
        "end_line": 1119,
        "comment": "\n   * Whether the warnings guard in this Options object disables the given\n   * group of warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0844
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.lazyInitDocumentation#667",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
        "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }\n",
        "begin_line": 667,
        "end_line": 677,
        "comment": "\n   * Lazily initializes the documentation information object, but only\n   * if the JSDocInfo was told to keep such information around.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.addMarker#683",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
        "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }\n",
        "begin_line": 683,
        "end_line": 695,
        "comment": "\n   * Adds a marker to the documentation (if it exists) and\n   * returns the marker. Returns null otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroup.DiagnosticGroup#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(com.google.javascript.jscomp.DiagnosticType)",
        "snippet": "  private DiagnosticGroup(DiagnosticType type) {\n    this.name = null;\n    this.types = ImmutableSet.of(type);\n  }\n",
        "begin_line": 60,
        "end_line": 63,
        "comment": "\n   * Create a diagnostic group with no name that only matches the given type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 4
    },
    {
        "name": "DiagnosticGroup.forType#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DiagnosticGroup.java",
        "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
        "signature": "com.google.javascript.jscomp.DiagnosticGroup.forType(com.google.javascript.jscomp.DiagnosticType)",
        "snippet": "  public static DiagnosticGroup forType(DiagnosticType type) {\n    if (!singletons.containsKey(type)) {\n      singletons.put(type, new DiagnosticGroup(type));\n    }\n    return singletons.get(type);\n  }\n",
        "begin_line": 70,
        "end_line": 75,
        "comment": " Create a diagnostic group that matches only the given type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateAssignmentExpression#600",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateAssignmentExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateAssignmentExpression(Node n) {\n    validateChildCount(n, 2);\n    validateAssignmentTarget(n.getFirstChild());\n    validateExpression(n.getLastChild());\n  }\n",
        "begin_line": 600,
        "end_line": 604,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0838
        },
        "num_failing_tests": 4
    },
    {
        "name": "AstValidator.validateAssignmentTarget#606",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateAssignmentTarget(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateAssignmentTarget(Node n) {\n    switch (n.getType()) {\n      case Token.NAME:\n      case Token.GETELEM:\n      case Token.GETPROP:\n        validateExpression(n);\n        return;\n      default:\n        violation(\"Expected assignment target expression but was \"\n            + Token.name(n.getType()), n);\n    }\n  }\n",
        "begin_line": 606,
        "end_line": 617,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0838
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.recordConstructor#718",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
        "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 718,
        "end_line": 727,
        "comment": "\n   * Records that the {@link JSDocInfo} being built should have its\n   * {@link JSDocInfo#isConstructor()} flag set to {@code true}.\n   *\n   * @return {@code true} if the constructor was recorded and {@code false}\n   *     if it was already defined or it was incompatible with the existing\n   *     flags\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.hasAnySingletonTypeTags#1029",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
        "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }\n",
        "begin_line": 1029,
        "end_line": 1033,
        "comment": "\n   * Whether the current doc info has any of the singleton type\n   * tags that may not appear with other type tags, like\n   * {@code @type} or {@code @typedef}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setConstructor#353",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
        "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }\n",
        "begin_line": 353,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setFlag#434",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean, int)",
        "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }\n",
        "begin_line": 434,
        "end_line": 440,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.JSDocInfoBuilder#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
        "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }\n",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.recordOriginalCommentString#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordOriginalCommentString(java.lang.String)",
        "snippet": "  public void recordOriginalCommentString(String sourceComment) {\n    if (parseDocumentation) {\n      currentInfo.setOriginalCommentString(sourceComment);\n    }\n  }\n",
        "begin_line": 78,
        "end_line": 82,
        "comment": "\n   * Sets the original JSDoc comment string. This is a no-op if the builder\n   * isn't configured to record documentation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.shouldParseDocumentation#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.shouldParseDocumentation()",
        "snippet": "  public boolean shouldParseDocumentation() {\n    return parseDocumentation;\n  }\n",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.isPopulated#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
        "snippet": "  public boolean isPopulated() {\n    return populated;\n  }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n   * Returns whether this builder is populated with information that can be\n   * used to {@link #build} a {@link JSDocInfo} object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.isPopulatedWithFileOverview#101",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
        "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns() ||\n         currentInfo.isNoCompile());\n  }\n",
        "begin_line": 101,
        "end_line": 105,
        "comment": "\n   * Returns whether this builder is populated with information that can be\n   * used to {@link #build} a {@link JSDocInfo} object that has a\n   * fileoverview tag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.build#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(com.google.javascript.rhino.Node)",
        "snippet": "  public JSDocInfo build(Node associatedNode) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setAssociatedNode(associatedNode);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }\n",
        "begin_line": 124,
        "end_line": 135,
        "comment": "\n   * Builds a {@link JSDocInfo} object based on the populated information and\n   * returns it. Once this method is called, the builder can be reused to build\n   * another {@link JSDocInfo} object.\n   *\n   * @param associatedNode The source node containing the JSDoc.\n   * @return a {@link JSDocInfo} object populated with the values given to this\n   *     builder. If no value was populated, this method simply returns\n   *     {@code null}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.populateDefaults#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }\n",
        "begin_line": 138,
        "end_line": 142,
        "comment": " Generate defaults when certain parameters are not specified. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfoBuilder.markAnnotation#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(java.lang.String, int, int)",
        "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(annotation);\n      position.setPositionInformation(lineno, charno, lineno,\n          charno + annotation.length());\n      marker.setAnnotation(position);\n      populated = true;\n    }\n\n    currentMarker = marker;\n  }\n",
        "begin_line": 148,
        "end_line": 162,
        "comment": "\n   * Adds a marker to the current JSDocInfo and populates the marker with the\n   * annotation information.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isConstructor#469",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
        "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }\n",
        "begin_line": 469,
        "end_line": 471,
        "comment": "\n   * Returns whether the {@code @constructor} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isInterface#550",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
        "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }\n",
        "begin_line": 550,
        "end_line": 552,
        "comment": "\n   * Returns whether the {@code @interface} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isExterns#606",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
        "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }\n",
        "begin_line": 606,
        "end_line": 608,
        "comment": "\n   * Returns whether the {@code @externs} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.isNoCompile#622",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoCompile()",
        "snippet": "  public boolean isNoCompile() {\n    return getFlag(MASK_NOCOMPILE);\n  }\n",
        "begin_line": 622,
        "end_line": 624,
        "comment": "\n   * Returns whether the {@code @nocompile} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setVisibility#653",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(com.google.javascript.rhino.JSDocInfo.Visibility)",
        "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }\n",
        "begin_line": 653,
        "end_line": 655,
        "comment": " Visible for testing.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasEnumParameterType#1085",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
        "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }\n",
        "begin_line": 1085,
        "end_line": 1087,
        "comment": "\n   * Returns whether an enum parameter type, specified using the {@code @enum}\n   * annotation, is present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasTypedefType#1093",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
        "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }\n",
        "begin_line": 1093,
        "end_line": 1095,
        "comment": "\n   * Returns whether a typedef parameter type, specified using the\n   * {@code @typedef} annotation, is present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasFileOverview#1425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
        "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }\n",
        "begin_line": 1425,
        "end_line": 1427,
        "comment": "\n   * Returns whether this has a fileoverview flag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.setAssociatedNode#1447",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setAssociatedNode(com.google.javascript.rhino.Node)",
        "snippet": "  public void setAssociatedNode(Node node) {\n    this.associatedNode = node;\n  }\n",
        "begin_line": 1447,
        "end_line": 1449,
        "comment": "\n   * Sets the node associated with this JSDoc.\n   * Notice that many nodes may have pointer to the same JSDocInfo\n   * object (because we propagate it across the type graph). But there\n   * is only one canonical \"owner\" node of the JSDocInfo, which corresponds\n   * to its original place in the syntax tree.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.JsDocTokenStream#45",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(java.lang.String, int, int)",
        "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }\n",
        "begin_line": 45,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getLineno#226",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
        "snippet": "  final int getLineno() { return lineno; }\n",
        "begin_line": 226,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getCharno#228",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
        "snippet": "  final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }\n",
        "begin_line": 228,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getString#232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
        "snippet": "  final String getString() { return string; }\n",
        "begin_line": 232,
        "end_line": 232,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getStringFromBuffer#236",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
        "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }\n",
        "begin_line": 236,
        "end_line": 239,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.addToString#241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
        "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }\n",
        "begin_line": 241,
        "end_line": 250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.ungetChar#252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
        "snippet": "  void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }\n",
        "begin_line": 252,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.isAlpha#270",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
        "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }\n",
        "begin_line": 270,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.isJSSpace#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
        "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }\n",
        "begin_line": 309,
        "end_line": 316,
        "comment": " As defined in ECMA.  jsscan.c uses C isspace() (which allows\n   * \\v, I think.)  note that code in getChar() implicitly accepts\n   * '\\r' == \\u000D as well.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getCharIgnoreLineEnd#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
        "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }\n",
        "begin_line": 392,
        "end_line": 436,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocTokenStream.getOffset#446",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
        "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
        "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }\n",
        "begin_line": 446,
        "end_line": 448,
        "comment": "\n   * Returns the offset into the current line.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.setFileLevelJsDocBuilder#107",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(com.google.javascript.rhino.Node.FileLevelJsDocBuilder)",
        "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }\n",
        "begin_line": 107,
        "end_line": 110,
        "comment": "\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in JsDoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.setFileOverviewJSDocInfo#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": "\n   * Sets the file overview JSDocInfo, in order to warn about multiple uses of\n   * the @fileoverview tag in a file.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.JsDocInfoParser#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(com.google.javascript.jscomp.parsing.JsDocTokenStream, com.google.javascript.rhino.head.ast.Comment, com.google.javascript.rhino.Node, com.google.javascript.jscomp.parsing.Config, com.google.javascript.rhino.head.ErrorReporter)",
        "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.associatedNode = associatedNode;\n\n    // Sometimes this will be null in tests.\n    this.sourceFile = associatedNode == null\n        ? null : associatedNode.getStaticSourceFile();\n\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    if (commentNode != null) {\n      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n    }\n    this.annotationNames = config.annotationNames;\n    this.suppressionNames = config.suppressionNames;\n\n    this.errorReporter = errorReporter;\n    this.templateNode = this.createTemplateNode();\n  }\n",
        "begin_line": 126,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.checkExtendedTypes#994",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.checkExtendedTypes(java.util.List<com.google.javascript.jscomp.parsing.JsDocInfoParser.ExtendedTypeInfo>)",
        "snippet": "  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      // If interface, record the multiple extended interfaces\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }\n",
        "begin_line": 994,
        "end_line": 1009,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.createTemplateNode#2245",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createTemplateNode()",
        "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = IR.script();\n    templateNode.setStaticSourceFile(\n      this.associatedNode != null ?\n      this.associatedNode.getStaticSourceFile() :\n      null);\n    return templateNode;\n  }\n",
        "begin_line": 2245,
        "end_line": 2253,
        "comment": " e.g., source-name, between all nodes.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.eatTokensUntilEOL#2268",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
        "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }\n",
        "begin_line": 2268,
        "end_line": 2270,
        "comment": "\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.match#2306",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }\n",
        "begin_line": 2306,
        "end_line": 2309,
        "comment": "\n   * Tests whether the next symbol of the token stream matches the specific\n   * token.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.next#2324",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
        "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }\n",
        "begin_line": 2324,
        "end_line": 2330,
        "comment": "\n   * Gets the next token of the token stream or the buffered token if a matching\n   * was previously made.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.current#2335",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
        "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }\n",
        "begin_line": 2335,
        "end_line": 2339,
        "comment": "\n   * Gets the current token, invalidating it in the process.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo#2358",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
        "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }\n",
        "begin_line": 2358,
        "end_line": 2360,
        "comment": "\n   * Determines whether the parser has been populated with docinfo with a\n   * fileoverview tag.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo#2366",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
        "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(associatedNode);\n  }\n",
        "begin_line": 2366,
        "end_line": 2368,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JsDocInfoParser.getFileOverviewJSDocInfo#2373",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
        "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }\n",
        "begin_line": 2373,
        "end_line": 2375,
        "comment": "\n   * Gets the fileoverview JSDocInfo, if any.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.handlePossibleFileOverviewJsDoc#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.handlePossibleFileOverviewJsDoc(com.google.javascript.jscomp.parsing.JsDocInfoParser)",
        "snippet": "  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 258,
        "end_line": 265,
        "comment": "\n   * @return true if the jsDocParser represents a fileoverview.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.maybeInjectCastNode#364",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeInjectCastNode(com.google.javascript.rhino.head.ast.AstNode, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "  private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n    if (node.getType() == com.google.javascript.rhino.head.Token.LP\n        && node instanceof ParenthesizedExpression\n        && info.hasType()\n        // TODO(johnlenz): for now, attach object literal type directly.\n        && !irNode.isObjectLit()) {\n      irNode = newNode(Token.CAST, irNode);\n    }\n    return irNode;\n  }\n",
        "begin_line": 364,
        "end_line": 373,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.createJsDocInfoParser#430",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.createJsDocInfoParser(com.google.javascript.rhino.head.ast.Comment, com.google.javascript.rhino.Node)",
        "snippet": "  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
        "begin_line": 430,
        "end_line": 450,
        "comment": "\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0835
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getVisibility#976",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
        "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }\n",
        "begin_line": 976,
        "end_line": 978,
        "comment": "\n   * Gets the visibility specified by {@code @private}, {@code @protected} or\n   * {@code @public} annotation. If no visibility is specified, visibility\n   * is inherited from the base class.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasType#1077",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
        "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1077,
        "end_line": 1079,
        "comment": "\n   * Returns whether a type, specified using the {@code @type} annotation, is\n   * present on this JSDoc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.hasType#1105",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
        "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }\n",
        "begin_line": 1105,
        "end_line": 1107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 4
    },
    {
        "name": "RemoveUnusedVars.apply#883",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.Continuation.apply()",
        "snippet": "    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }\n",
        "begin_line": 883,
        "end_line": 892,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 2
    },
    {
        "name": "RenameVars.getNewLocalName#398",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.getNewLocalName(com.google.javascript.rhino.Node)",
        "snippet": "  private String getNewLocalName(Node n) {\n    String oldTempName = n.getString();\n    Assignment a = assignments.get(oldTempName);\n    if (!a.newName.equals(oldTempName)) {\n      if (pseudoNameMap != null) {\n        return pseudoNameMap.get(n);\n      }\n      return a.newName;\n    }\n    return null;\n  }\n",
        "begin_line": 398,
        "end_line": 408,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.CheckMissingReturn#86",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.CheckMissingReturn(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n",
        "begin_line": 86,
        "end_line": 89,
        "comment": "\n   * @param level level of severity to report when a missing return statement\n   *     is discovered\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.enterScope#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    JSType returnType = explicitReturnExpected(t.getScopeRoot());\n    if (returnType == null) {\n      return;\n    }\n\n    if (fastAllPathsReturnCheck(t.getControlFlowGraph())) {\n      return;\n    }\n\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph(),\n            t.getControlFlowGraph().getEntry(),\n            t.getControlFlowGraph().getImplicitReturn(),\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n    if (!test.allPathsSatisfyPredicate()) {\n      compiler.report(\n          t.makeError(t.getScopeRoot(), level,\n              MISSING_RETURN_STATEMENT, returnType.toString()));\n    }\n  }\n",
        "begin_line": 91,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.exitScope#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.shouldTraverse#135",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    return true;\n  }\n",
        "begin_line": 135,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckMissingReturn.visit#141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckMissingReturn.java",
        "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
        "signature": "com.google.javascript.jscomp.CheckMissingReturn.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }\n",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.setJSDocInfo#1857",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  public Node setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n      return this;\n  }\n",
        "begin_line": 1857,
        "end_line": 1860,
        "comment": "\n   * Sets the {@link JSDocInfo} attached to this node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0832
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.JSDocInfo#334",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
        "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }\n",
        "begin_line": 334,
        "end_line": 336,
        "comment": "\n   * Creates a {@link JSDocInfo} object. This object should be created using\n   * a {@link JSDocInfoBuilder}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0832
        },
        "num_failing_tests": 4
    },
    {
        "name": "JSDocInfo.getFlag#648",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
        "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }\n",
        "begin_line": 648,
        "end_line": 650,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0832
        },
        "num_failing_tests": 4
    },
    {
        "name": "IR.script#124",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.script()",
        "snippet": "  public static Node script() {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    return block;\n  }\n",
        "begin_line": 124,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0829
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isSimpleOperator#705",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isSimpleOperator(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isSimpleOperator(Node n) {\n    return isSimpleOperatorType(n.getType());\n  }\n",
        "begin_line": 705,
        "end_line": 707,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isAssignmentOp#1489",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }\n",
        "begin_line": 1489,
        "end_line": 1506,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0818
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.addChildToFront#588",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.addChildToFront(com.google.javascript.rhino.Node)",
        "snippet": "  public void addChildToFront(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = first;\n    first = child;\n    if (last == null) {\n      last = child;\n    }\n  }\n",
        "begin_line": 588,
        "end_line": 597,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0816
        },
        "num_failing_tests": 2
    },
    {
        "name": "NoObjectType.resolveInternal#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NoObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
        "signature": "com.google.javascript.rhino.jstype.NoObjectType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 159,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getSource#1093",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSource()",
        "snippet": "  public Node getSource() {\n    return source;\n  }\n",
        "begin_line": 1093,
        "end_line": 1095,
        "comment": "\n   * Gets the source node or null if this is an unknown function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "JsFileLineParser.parseJsString#214",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/JsFileLineParser.java",
        "class_name": "com.google.javascript.jscomp.deps.JsFileLineParser",
        "signature": "com.google.javascript.jscomp.deps.JsFileLineParser.parseJsString(java.lang.String)",
        "snippet": "  String parseJsString(String jsStringLiteral) throws ParseException {\n    valueMatcher.reset(jsStringLiteral);\n    if (!valueMatcher.matches()) {\n      throw new ParseException(\"Syntax error in JS String literal\", true /* fatal */);\n    }\n    return valueMatcher.group(1) != null ? valueMatcher.group(1) : valueMatcher.group(2);\n  }\n",
        "begin_line": 214,
        "end_line": 220,
        "comment": "\n   * Parses a JS string literal.\n   *\n   * @param jsStringLiteral The literal. Must look like \"asdf\" or 'asdf'\n   * @throws ParseException Thrown if there is a string literal that cannot be\n   *     parsed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isInitializingDeclarationAt#357",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.isInitializingDeclarationAt(int)",
        "snippet": "    private boolean isInitializingDeclarationAt(int index) {\n      Reference maybeInit = references.get(index);\n      if (maybeInit.isInitializingDeclaration()) {\n        // This is a declaration that represents the initial value.\n        // Specifically, var declarations without assignments such as \"var a;\"\n        // are not.\n        return true;\n      }\n      return false;\n    }\n",
        "begin_line": 357,
        "end_line": 366,
        "comment": "\n     * @param index The index into the references array to look for an\n     * assigning declaration.\n     *\n     * This is either the declaration if a value is assigned (such as\n     * \"var a = 2\", \"function a()...\", \"... catch (a)...\").\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isVarDeclaration#564",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isVarDeclaration()",
        "snippet": "    boolean isVarDeclaration() {\n      return getParent().isVar();\n    }\n",
        "begin_line": 564,
        "end_line": 566,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.makeVarDeclNode#936",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.makeVarDeclNode()",
        "snippet": "    private Node makeVarDeclNode() {\n      Node name = IR.name(namespace);\n      name.addChildToFront(createNamespaceLiteral());\n\n      Node decl = IR.var(name);\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n\n      // TODO(nicksantos): ew ew ew. Create a mutator package.\n      if (compiler.getCodingConvention().isConstant(namespace)) {\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      if (candidateDefinition == null) {\n        name.setJSDocInfo(createConstantJsDoc());\n      }\n\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      setSourceInfo(decl);\n      return decl;\n    }\n",
        "begin_line": 936,
        "end_line": 954,
        "comment": "\n     * Creates a simple namespace variable declaration\n     * (e.g. <code>var foo = {};</code>).\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.hasExternsRoot#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.hasExternsRoot()",
        "snippet": "  boolean hasExternsRoot() {\n    return externsRoot != null;\n  }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.getSlot#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Name getSlot(String name) {\n    return getOwnSlot(name);\n  }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.getOwnSlot#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.getOwnSlot(java.lang.String)",
        "snippet": "  @Override\n  public Name getOwnSlot(String name) {\n    ensureGenerated();\n    return nameMap.get(name);\n  }\n",
        "begin_line": 121,
        "end_line": 125,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-40571456-3536-4b95-9870-7c3a3257a6f0.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(final AbstractCompiler compiler) {\n      return new CompilerPass() {\n        @Override\n        public void process(Node externs, Node jsRoot) {\n          // Create a global namespace for analysis by check passes.\n          // Note that this class does all heavy computation lazily,\n          // so it's OK to create it here.\n          namespaceForChecks = new GlobalNamespace(compiler, externs, jsRoot);\n          new CheckGlobalNames(compiler, options.checkGlobalNamesLevel)\n              .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n        }\n      };\n    }\n",
        "begin_line": 1279,
        "end_line": 1292,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.process#1282",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-fa8e3b3e-16cd-42f9-a984-84c00f9a0a88.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node jsRoot) {\n          // Create a global namespace for analysis by check passes.\n          // Note that this class does all heavy computation lazily,\n          // so it's OK to create it here.\n          namespaceForChecks = new GlobalNamespace(compiler, externs, jsRoot);\n          new CheckGlobalNames(compiler, options.checkGlobalNamesLevel)\n              .injectNamespace(namespaceForChecks).process(externs, jsRoot);\n        }\n",
        "begin_line": 1282,
        "end_line": 1290,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1232",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-ac7beeff-a1b6-4d55-bb9e-046fcb320a2e.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new CheckAccessControls(compiler);\n    }\n",
        "begin_line": 1232,
        "end_line": 1235,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.getIndirectlyDeclaredProperties#426",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getIndirectlyDeclaredProperties()",
        "snippet": "  @Override\n  public Collection<String> getIndirectlyDeclaredProperties() {\n    return indirectlyDeclaredProperties;\n  }\n",
        "begin_line": 426,
        "end_line": 429,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalNames.CheckGlobalNames#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalNames.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
        "signature": "com.google.javascript.jscomp.CheckGlobalNames.CheckGlobalNames(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  CheckGlobalNames(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.convention = compiler.getCodingConvention();\n    this.level = level;\n  }\n",
        "begin_line": 63,
        "end_line": 67,
        "comment": "\n   * Creates a pass to check global name references at the given warning level.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalNames.injectNamespace#73",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalNames.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
        "signature": "com.google.javascript.jscomp.CheckGlobalNames.injectNamespace(com.google.javascript.jscomp.GlobalNamespace)",
        "snippet": "  CheckGlobalNames injectNamespace(GlobalNamespace namespace) {\n    Preconditions.checkArgument(namespace.hasExternsRoot());\n    this.namespace = namespace;\n    return this;\n  }\n",
        "begin_line": 73,
        "end_line": 77,
        "comment": "\n   * Injects a pre-computed global namespace, so that the same namespace\n   * can be re-used for multiple check passes. Returns this for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.CheckAccessControls#122",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.CheckAccessControls(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  CheckAccessControls(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.initializedConstantProperties = HashMultimap.create();\n  }\n",
        "begin_line": 122,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.process#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n",
        "begin_line": 128,
        "end_line": 131,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckAccessControls.shouldTraverse#220",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckAccessControls.java",
        "class_name": "com.google.javascript.jscomp.CheckAccessControls",
        "signature": "com.google.javascript.jscomp.CheckAccessControls.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }\n",
        "begin_line": 220,
        "end_line": 223,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateObjectLitKey#674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateObjectLitKey(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateObjectLitKey(Node n) {\n    switch (n.getType()) {\n      case Token.GETTER_DEF:\n        validateObjectLitGetKey(n);\n        return;\n      case Token.SETTER_DEF:\n        validateObjectLitSetKey(n);\n        return;\n      case Token.STRING_KEY:\n        validateObjectLitStringKey(n);\n        return;\n      default:\n        violation(\"Expected object literal key expression but was \"\n              + Token.name(n.getType()), n);\n    }\n  }\n",
        "begin_line": 674,
        "end_line": 689,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateObjectLitStringKey#723",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateObjectLitStringKey(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateObjectLitStringKey(Node n) {\n    validateNodeType(Token.STRING_KEY, n);\n    validateChildCount(n, 1);\n    validateObjectLiteralKeyName(n);\n    validateExpression(n.getFirstChild());\n  }\n",
        "begin_line": 723,
        "end_line": 728,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0811
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processPropertyGet#958",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processPropertyGet(com.google.javascript.rhino.head.ast.PropertyGet)",
        "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      Node leftChild = transform(getNode.getTarget());\n      Node newNode = newNode(\n          Token.GETPROP, leftChild, transformAsString(getNode.getProperty()));\n      newNode.setLineno(leftChild.getLineno());\n      newNode.setCharno(leftChild.getCharno());\n      maybeSetLengthFrom(newNode, getNode);\n      return newNode;\n    }\n",
        "begin_line": 958,
        "end_line": 967,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0808
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.transformAsString#492",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.transformAsString(com.google.javascript.rhino.head.ast.AstNode)",
        "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name)n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral)n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.isString());\n      return ret;\n    }\n",
        "begin_line": 492,
        "end_line": 505,
        "comment": "\n     * Transforms the given node and then sets its type to Token.STRING if it\n     * was Token.NAME. If its type was already Token.STRING, then quotes it.\n     * Used for properties, as the old AST uses String tokens, while the new one\n     * uses Name tokens for unquoted strings. For example, in\n     * var o = {'a' : 1, b: 2};\n     * the string 'a' is quoted, while the name b is turned into a string, but\n     * unquoted.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0803
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.transformNameAsString#375",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformNameAsString(com.google.javascript.rhino.head.ast.Name)",
        "snippet": "  private Node transformNameAsString(Name node) {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
        "begin_line": 375,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0803
        },
        "num_failing_tests": 4
    },
    {
        "name": "PeepholeRemoveDeadCode.tryFoldExpr#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldExpr(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldExpr(Node subtree) {\n    Node result = trySimplifyUnusedResult(subtree.getFirstChild());\n    if (result == null) {\n      Node parent = subtree.getParent();\n      // If the EXPR_RESULT no longer has any children, remove it as well.\n      if (parent.isLabel()) {\n        Node replacement = IR.block().srcref(subtree);\n        parent.replaceChild(subtree, replacement);\n        subtree = replacement;\n      } else {\n        subtree.detachFromParent();\n        subtree = null;\n      }\n    }\n    return subtree;\n  }\n",
        "begin_line": 137,
        "end_line": 152,
        "comment": "\n   * Try folding EXPR_RESULT nodes by removing useless Ops and expressions.\n   * @return the replacement node, if changed, or the original if not\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0801
        },
        "num_failing_tests": 2
    },
    {
        "name": "PeepholeRemoveDeadCode.trySimplifyUnusedResult#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java",
        "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
        "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.trySimplifyUnusedResult(com.google.javascript.rhino.Node)",
        "snippet": "  private Node trySimplifyUnusedResult(Node n) {\n    return trySimplifyUnusedResult(n, true);\n  }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n   * General cascading unused operation node removal.\n   * @param n The root of the expression to simplify.\n   * @return The replacement node, or null if the node was is not useful.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0801
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractPeepholeOptimization.nodeTypeMayHaveSideEffects#127",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.nodeTypeMayHaveSideEffects(com.google.javascript.rhino.Node)",
        "snippet": "  boolean nodeTypeMayHaveSideEffects(Node n) {\n    return NodeUtil.nodeTypeMayHaveSideEffects(n, compiler);\n  }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n   * Returns true if the current node's type implies side effects.\n   *\n   * This is a non-recursive version of the may have side effects\n   * check; used to check wherever the current node's type is one of\n   * the reason's why a subtree has side effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0801
        },
        "num_failing_tests": 2
    },
    {
        "name": "AstValidator.validateObjectLit#667",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateObjectLit(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateObjectLit(Node n) {\n    validateNodeType(Token.OBJECTLIT, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateObjectLitKey(c);\n    }\n  }\n",
        "begin_line": 667,
        "end_line": 672,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0796
        },
        "num_failing_tests": 2
    },
    {
        "name": "IRFactory.processAssignment#521",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processAssignment(com.google.javascript.rhino.head.ast.Assignment)",
        "snippet": "    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n      return assign;\n    }\n",
        "begin_line": 521,
        "end_line": 532,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 4
    },
    {
        "name": "IRFactory.validAssignmentTarget#1142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.validAssignmentTarget(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n",
        "begin_line": 1142,
        "end_line": 1150,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 4
    },
    {
        "name": "RemoveUnusedVars.Assign#919",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.Assign.Assign(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, boolean)",
        "snippet": "    Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n      this.assignNode = assignNode;\n      this.nameNode = nameNode;\n      this.isPropertyAssign = isPropertyAssign;\n\n      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n      this.mayHaveSecondarySideEffects =\n          maybeAliased ||\n          NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n          NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n    }\n",
        "begin_line": 919,
        "end_line": 930,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemoveUnusedVars.maybeCreateAssign#936",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.Assign.maybeCreateAssign(com.google.javascript.rhino.Node)",
        "snippet": "    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      // Skip one level of GETPROPs or GETELEMs.\n      //\n      // Don't skip more than one level, because then we get into\n      // situations where assigns to properties of properties will always\n      // trigger side-effects, and the variable they're on cannot be removed.\n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.isGetProp() &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          // Prototype properties sets should be considered like normal\n          // property sets.\n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.isName()) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }\n",
        "begin_line": 936,
        "end_line": 962,
        "comment": "\n     * If this is an assign to a variable or its property, return it.\n     * Otherwise, return null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 2
    },
    {
        "name": "SortedDependencies.compare#254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/deps/SortedDependencies.java",
        "class_name": "com.google.javascript.jscomp.deps.SortedDependencies",
        "signature": "com.google.javascript.jscomp.deps.SortedDependencies.Anonymous-426e11f9-1572-4f7b-b673-3f945e6c7c35.compare(T, T)",
        "snippet": "      @Override\n      public int compare(T a, T b) {\n        return originalIndex.get(a).intValue() -\n            originalIndex.get(b).intValue();\n      }\n",
        "begin_line": 254,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "WarningLevel.addVerboseWarnings#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/WarningLevel.java",
        "class_name": "com.google.javascript.jscomp.WarningLevel",
        "signature": "com.google.javascript.jscomp.WarningLevel.addVerboseWarnings(com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  private static void addVerboseWarnings(CompilerOptions options) {\n    addDefaultWarnings(options);\n\n    // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n    options.checkSuspiciousCode = true;\n    options.checkGlobalThisLevel = CheckLevel.WARNING;\n    options.checkSymbols = true;\n    options.checkMissingReturn = CheckLevel.WARNING;\n\n    // checkTypes has the side-effect of asserting that the\n    // correct number of arguments are passed to a function.\n    // Because the CodingConvention used with the web service does not provide a\n    // way for optional arguments to be specified, these warnings may result in\n    // false positives.\n    options.checkTypes = true;\n    options.checkGlobalNamesLevel = CheckLevel.WARNING;\n    options.aggressiveVarCheck = CheckLevel.WARNING;\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n    options.setWarningLevel(\n        DiagnosticGroups.DEPRECATED, CheckLevel.WARNING);\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT, CheckLevel.WARNING);\n  }\n",
        "begin_line": 94,
        "end_line": 117,
        "comment": "\n   * Add all the check pass that are possibly relevant to a non-googler.\n   * @param options The CompilerOptions object to set the options on.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "VariableReferenceCheck.checkVar#104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
        "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
        "signature": "com.google.javascript.jscomp.VariableReferenceCheck.ReferenceCheckingBehavior.checkVar(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.Scope.Var, java.util.List<com.google.javascript.jscomp.ReferenceCollectingCallback.Reference>)",
        "snippet": "    private void checkVar(NodeTraversal t, Var v, List<Reference> references) {\n      blocksWithDeclarations.clear();\n      boolean isDeclaredInScope = false;\n      boolean isUnhoistedNamedFunction = false;\n      Reference hoistedFn = null;\n\n      // Look for hoisted functions.\n      for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n          blocksWithDeclarations.add(reference.getBasicBlock());\n          isDeclaredInScope = true;\n          hoistedFn = reference;\n          break;\n        } else if (NodeUtil.isFunctionDeclaration(\n            reference.getNode().getParent())) {\n          isUnhoistedNamedFunction = true;\n        }\n      }\n\n      for (Reference reference : references) {\n        if (reference == hoistedFn) {\n          continue;\n        }\n\n        BasicBlock basicBlock = reference.getBasicBlock();\n        boolean isDeclaration = reference.isDeclaration();\n\n        boolean allowDupe =\n            SyntacticScopeCreator.hasDuplicateDeclarationSuppression(\n                reference.getNode(), v);\n        if (isDeclaration && !allowDupe) {\n          // Look through all the declarations we've found so far, and\n          // check if any of them are before this block.\n          for (BasicBlock declaredBlock : blocksWithDeclarations) {\n            if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n              // TODO(johnlenz): Fix AST generating clients that so they would\n              // have property StaticSourceFile attached at each node. Or\n              // better yet, make sure the generated code never violates\n              // the requirement to pass aggressive var check!\n              String filename = NodeUtil.getSourceName(reference.getNode());\n              compiler.report(\n                  JSError.make(filename,\n                      reference.getNode(),\n                      checkLevel,\n                      REDECLARED_VARIABLE, v.name));\n              break;\n            }\n          }\n        }\n\n        if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {\n          // Only allow an unhoisted named function to be used within the\n          // block it is declared.\n          for (BasicBlock declaredBlock : blocksWithDeclarations) {\n            if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n              String filename = NodeUtil.getSourceName(reference.getNode());\n              compiler.report(\n                  JSError.make(filename,\n                      reference.getNode(),\n                      AMBIGUOUS_FUNCTION_DECL, v.name));\n              break;\n            }\n          }\n        }\n\n        if (!isDeclaration && !isDeclaredInScope) {\n          // Don't check the order of refer in externs files.\n          if (!reference.getNode().isFromExterns()) {\n            // Special case to deal with var goog = goog || {}\n            Node grandparent = reference.getGrandparent();\n            if (grandparent.isName()\n                && grandparent.getString() == v.name) {\n              continue;\n            }\n\n            // Only generate warnings if the scopes do not match in order\n            // to deal with possible forward declarations and recursion\n            if (reference.getScope() == v.scope) {\n              String filename = NodeUtil.getSourceName(reference.getNode());\n              compiler.report(\n                  JSError.make(filename,\n                               reference.getNode(),\n                               checkLevel,\n                               UNDECLARED_REFERENCE, v.name));\n            }\n          }\n        }\n\n        if (isDeclaration) {\n          blocksWithDeclarations.add(basicBlock);\n          isDeclaredInScope = true;\n        }\n      }\n    }\n",
        "begin_line": 104,
        "end_line": 197,
        "comment": "\n     * If the variable is declared more than once in a basic block, generate a\n     * warning. Also check if a variable is used in a given scope before it is\n     * declared, which suggest a likely error. Relies on the fact that\n     * references is in parse-tree order.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryReduceReturn#418",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReduceReturn(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryReduceReturn(Node n) {\n    Node result = n.getFirstChild();\n\n    if (result != null) {\n      switch (result.getType()) {\n        case Token.VOID:\n          Node operand = result.getFirstChild();\n          if (!mayHaveSideEffects(operand)) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n        case Token.NAME:\n          String name = result.getString();\n          if (name.equals(\"undefined\")) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n      }\n    }\n\n    return n;\n  }\n",
        "begin_line": 418,
        "end_line": 441,
        "comment": "\n   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n   *\n   * @return The original node, maybe simplified.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "DependencyOptions.setEntryPoints#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.setEntryPoints(java.util.Collection<java.lang.String>)",
        "snippet": "  public DependencyOptions setEntryPoints(Collection<String> symbols) {\n    entryPoints.clear();\n    entryPoints.addAll(symbols);\n    return this;\n  }\n",
        "begin_line": 112,
        "end_line": 116,
        "comment": "\n   * Adds a collection of symbols to always keep.\n   *\n   * In dependency pruning mode, we will automatically keep all the\n   * transitive dependencies of these symbols.\n   *\n   * The syntactic form of a symbol depends on the type of dependency\n   * primitives we're using. For example, goog.provide('foo.bar')\n   * provides the symbol 'foo.bar'.\n   *\n   * @return this for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "CompilerOptions.setDependencyOptions#1376",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CompilerOptions.java",
        "class_name": "com.google.javascript.jscomp.CompilerOptions",
        "signature": "com.google.javascript.jscomp.CompilerOptions.setDependencyOptions(com.google.javascript.jscomp.DependencyOptions)",
        "snippet": "  public void setDependencyOptions(DependencyOptions options) {\n    Preconditions.checkNotNull(options);\n    this.dependencyOptions = options;\n  }\n",
        "begin_line": 1376,
        "end_line": 1379,
        "comment": "\n   * Sets dependency options. See the DependencyOptions class for more info.\n   * This supersedes manageClosureDependencies.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0791
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processInfixExpression#804",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processInfixExpression(com.google.javascript.rhino.head.ast.InfixExpression)",
        "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      n.setLineno(exprNode.getLineno());\n      n.setCharno(position2charno(exprNode.getAbsolutePosition()));\n      maybeSetLengthFrom(n, exprNode);\n      return n;\n    }\n",
        "begin_line": 804,
        "end_line": 814,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.mayHaveSideEffects#783",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(com.google.javascript.rhino.Node, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    return checkForStateChangeHelper(n, false, compiler);\n  }\n",
        "begin_line": 783,
        "end_line": 785,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.078
        },
        "num_failing_tests": 4
    },
    {
        "name": "InstanceObjectType.isInstanceType#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/InstanceObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
        "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isInstanceType()",
        "snippet": "  @Override\n  public boolean isInstanceType() {\n    return true;\n  }\n",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.removeChildAfter#1653",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeChildAfter(com.google.javascript.rhino.Node)",
        "snippet": "  public Node removeChildAfter(Node prev) {\n    Preconditions.checkArgument(prev.parent == this,\n        \"prev is not a child of this node.\");\n    Preconditions.checkArgument(prev.next != null,\n        \"no next sibling.\");\n\n    Node child = prev.next;\n    prev.next = child.next;\n    if (child == last) last = prev;\n    child.next = null;\n    child.parent = null;\n    return child;\n  }\n",
        "begin_line": 1653,
        "end_line": 1665,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isVarArgs#1876",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isVarArgs()",
        "snippet": "  public boolean isVarArgs() {\n    return getBooleanProp(VAR_ARGS_NAME);\n  }\n",
        "begin_line": 1876,
        "end_line": 1878,
        "comment": "\n   * Returns whether this node is a variable length argument node. This\n   * method's return value is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isOptionalArg#1894",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isOptionalArg()",
        "snippet": "  public boolean isOptionalArg() {\n    return getBooleanProp(OPT_ARG_NAME);\n  }\n",
        "begin_line": 1894,
        "end_line": 1896,
        "comment": "\n   * Returns whether this node is an optional argument node. This\n   * method's return value is meaningful only on {@link Token#NAME} nodes\n   * used to define a {@link Token#FUNCTION}'s argument list.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isGetterDef#2241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isGetterDef()",
        "snippet": "  public boolean isGetterDef() {\n    return this.getType() == Token.GETTER_DEF;\n  }\n",
        "begin_line": 2241,
        "end_line": 2243,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isSetterDef#2329",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isSetterDef()",
        "snippet": "  public boolean isSetterDef() {\n    return this.getType() == Token.SETTER_DEF;\n  }\n",
        "begin_line": 2329,
        "end_line": 2331,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeExpression.isOptionalArg#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
        "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "\n   * @return Whether this expression denotes an optional {@code @param}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeExpression.isVarArgs#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
        "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n   * @return Whether this expression denotes a rest args {@code @param}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getParameterType#986",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(java.lang.String)",
        "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }\n",
        "begin_line": 986,
        "end_line": 991,
        "comment": "\n   * Gets the parameter type.\n   * @param parameter the parameter's name\n   * @return the parameter's type or {@code null} if this parameter is not\n   *     defined or has a {@code null} type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.hasParameterType#1009",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.hasParameterType(java.lang.String)",
        "snippet": "  public boolean hasParameterType(String parameter) {\n    return getParameterType(parameter) != null;\n  }\n",
        "begin_line": 1009,
        "end_line": 1011,
        "comment": "\n   * Returns whether the parameter has an attached type.\n   *\n   * @return {@code true} if the parameter has an attached type, {@code false}\n   *     if the parameter has no attached type or does not exist.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getParameterNames#1020",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getParameterNames()",
        "snippet": "  public Set<String> getParameterNames() {\n    if (info == null || info.parameters == null) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(info.parameters.keySet());\n  }\n",
        "begin_line": 1020,
        "end_line": 1025,
        "comment": "\n   * Returns the set of names of the defined parameters. The iteration order\n   * of the returned set is not the order in which parameters are defined.\n   *\n   * @return the set of names of the defined parameters. The returned set is\n   *     immutable.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "VariableReferenceCheck.afterExitScope#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
        "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
        "signature": "com.google.javascript.jscomp.VariableReferenceCheck.ReferenceCheckingBehavior.afterExitScope(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap)",
        "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      // TODO(bashir) In hot-swap version this means that for global scope we\n      // only go through all global variables accessed in the modified file not\n      // all global variables. This should be fixed.\n\n      // Check all vars after finishing a scope\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        checkVar(t, v, referenceMap.getReferences(v).references);\n      }\n    }\n",
        "begin_line": 85,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "VariableReferenceCheck.VariableReferenceCheck#59",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
        "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
        "signature": "com.google.javascript.jscomp.VariableReferenceCheck.VariableReferenceCheck(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public VariableReferenceCheck(AbstractCompiler compiler,\n      CheckLevel checkLevel) {\n    this.compiler = compiler;\n    this.checkLevel = checkLevel;\n  }\n",
        "begin_line": 59,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "VariableReferenceCheck.process#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VariableReferenceCheck.java",
        "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
        "signature": "com.google.javascript.jscomp.VariableReferenceCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new ReferenceCheckingBehavior());\n    callback.process(externs, root);\n  }\n",
        "begin_line": 65,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.visit#230",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.NonExternChecks.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((n.isName()) && isDeclaration(n)) {\n        checkDeclaration(t, n);\n      } else if (n.isGetProp()) {\n        checkProperty(t, n);\n      }\n    }\n",
        "begin_line": 230,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.checkDeclaration#239",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.NonExternChecks.checkDeclaration(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "    private void checkDeclaration(NodeTraversal t, Node n) {\n      if (\"eval\".equals(n.getString())) {\n        t.report(n, EVAL_DECLARATION);\n      } else if (\"arguments\".equals(n.getString())) {\n        t.report(n, ARGUMENTS_DECLARATION);\n      } else if (n.getString().endsWith(\"__\")) {\n        if (!noCajaChecks) {\n          t.report(n, ILLEGAL_NAME);\n        }\n      }\n    }\n",
        "begin_line": 239,
        "end_line": 249,
        "comment": " Checks for illegal declarations. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.getLocalVarIndex#544",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.getLocalVarIndex(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private int getLocalVarIndex(Var v) {\n    int num = v.index;\n    Scope s = v.scope.getParent();\n    if (s == null) {\n      throw new IllegalArgumentException(\"Var is not local\");\n    }\n\n    boolean isBleedingIntoScope = s.getParent() != null &&\n        localBleedingFunctions.contains(v);\n\n    while (s.getParent() != null) {\n      if (isBleedingIntoScope) {\n        num += localBleedingFunctionsPerScope.get(s).indexOf(v) + 1;\n        isBleedingIntoScope = false;\n      } else {\n        num += localBleedingFunctionsPerScope.get(s).size();\n      }\n\n      num += s.getVarCount();\n      s = s.getParent();\n    }\n    return num;\n  }\n",
        "begin_line": 544,
        "end_line": 566,
        "comment": "\n   * Returns the index within the scope stack.\n   * e.g. function Foo(a) { var b; function c(d) { } }\n   * a = 0, b = 1, c = 2, d = 3\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isHoistedFunction#568",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isHoistedFunction()",
        "snippet": "    boolean isHoistedFunction() {\n      return NodeUtil.isHoistedFunctionDeclaration(getParent());\n    }\n",
        "begin_line": 568,
        "end_line": 570,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.createDeclarationNode#924",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.createDeclarationNode()",
        "snippet": "    private Node createDeclarationNode() {\n      if (namespace.indexOf('.') == -1) {\n        return makeVarDeclNode();\n      } else {\n        return makeAssignmentExprNode();\n      }\n    }\n",
        "begin_line": 924,
        "end_line": 930,
        "comment": "\n     * Create the declaration node for this name, without inserting it\n     * into the AST.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.createConstantJsDoc#989",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.createConstantJsDoc()",
        "snippet": "    private JSDocInfo createConstantJsDoc() {\n      JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n      builder.recordConstancy();\n      return builder.build(null);\n    }\n",
        "begin_line": 989,
        "end_line": 993,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.isNamespacePlaceholder#1038",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.isNamespacePlaceholder(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean isNamespacePlaceholder(Node n) {\n    if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n      return false;\n    }\n\n    Node value = null;\n    if (n.isExprResult()) {\n      Node assign = n.getFirstChild();\n      value = assign.getLastChild();\n    } else if (n.isVar()) {\n      Node name = n.getFirstChild();\n      value = name.getFirstChild();\n    }\n\n    return value != null\n      && value.isObjectLit()\n      && !value.hasChildren();\n  }\n",
        "begin_line": 1038,
        "end_line": 1055,
        "comment": "\n   * @return Whether the node is namespace placeholder.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferParameterTypes#427",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferParameterTypes(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
        "begin_line": 427,
        "end_line": 495,
        "comment": "\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "DependencyOptions.setDependencyPruning#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.setDependencyPruning(boolean)",
        "snippet": "  public DependencyOptions setDependencyPruning(boolean enabled) {\n    this.pruneDependencies = enabled;\n    return this;\n  }\n",
        "begin_line": 72,
        "end_line": 75,
        "comment": "\n   * Enables or disables dependency pruning mode.\n   *\n   * In dependency pruning mode, we will look for all files that provide a\n   * symbol. Unless that file is a transitive dependency of a file that\n   * we're using, we will remove it from the compilation job.\n   *\n   * This does not affect how we handle files that do not provide symbols.\n   * See setMoocherDropping for information on how these are handled.\n   *\n   * @return this for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "DependencyOptions.setMoocherDropping#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DependencyOptions.java",
        "class_name": "com.google.javascript.jscomp.DependencyOptions",
        "signature": "com.google.javascript.jscomp.DependencyOptions.setMoocherDropping(boolean)",
        "snippet": "  public DependencyOptions setMoocherDropping(boolean enabled) {\n    this.dropMoochers = enabled;\n    return this;\n  }\n",
        "begin_line": 95,
        "end_line": 98,
        "comment": "\n   * Enables or disables moocher dropping mode.\n   *\n   * A 'moocher' is a file that does not provide any symbols (though they\n   * may require symbols). This is usually because they don't want to\n   * tie themselves to a particular dependency system (e.g., Closure's\n   * goog.provide, CommonJS modules). So they rely on other people to\n   * manage dependencies on them.\n   *\n   * If true, we drop these files when we prune dependencies.\n   * If false, we always keep these files an anything they depend on.\n   * The default is false.\n   *\n   * Notice that this option only makes sense if dependency pruning is on,\n   * and a set of entry points is specified.\n   *\n   * @return this for easy chaining.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-1503d09d-f9e4-4360-b2f5-bf4ab5888fd8.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new VariableReferenceCheck(\n          compiler, options.aggressiveVarCheck);\n    }\n",
        "begin_line": 1110,
        "end_line": 1114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0772
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.newNode#1430",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1430,
        "end_line": 1432,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.077
        },
        "num_failing_tests": 4
    },
    {
        "name": "Node.Node#372",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.Node(int, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }\n",
        "begin_line": 372,
        "end_line": 390,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0767
        },
        "num_failing_tests": 4
    },
    {
        "name": "NodeUtil.isImmutableValue#494",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isImmutableValue(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.CAST:\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }\n",
        "begin_line": 494,
        "end_line": 518,
        "comment": "\n   * Returns true if this is an immutable value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0762
        },
        "num_failing_tests": 2
    },
    {
        "name": "NodeUtil.mayHaveSideEffects#779",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean mayHaveSideEffects(Node n) {\n    return mayHaveSideEffects(n, null);\n  }\n",
        "begin_line": 779,
        "end_line": 781,
        "comment": "\n   * Returns true if the node which may have side effects when executed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0758
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.SiblingNodeIterable#1252",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.SiblingNodeIterable(com.google.javascript.rhino.Node)",
        "snippet": "    SiblingNodeIterable(Node start) {\n      this.start = start;\n      this.current = start;\n      this.used = false;\n    }\n",
        "begin_line": 1252,
        "end_line": 1256,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.iterator#1258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.iterator()",
        "snippet": "    @Override\n    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }\n",
        "begin_line": 1258,
        "end_line": 1272,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.hasNext#1274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.hasNext()",
        "snippet": "    @Override\n    public boolean hasNext() {\n      return current != null;\n    }\n",
        "begin_line": 1274,
        "end_line": 1277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.next#1279",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.SiblingNodeIterable.next()",
        "snippet": "    @Override\n    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }\n",
        "begin_line": 1279,
        "end_line": 1289,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.children#1222",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.children()",
        "snippet": "  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }\n",
        "begin_line": 1222,
        "end_line": 1228,
        "comment": "\n   * <p>Return an iterable object that iterates over this node's children.\n   * The iterator does not support the optional operation\n   * {@link Iterator#remove()}.</p>\n   *\n   * <p>To iterate over a node's siblings, one can write</p>\n   * <pre>Node n = ...;\n   * for (Node child : n.children()) { ...</pre>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 2
    },
    {
        "name": "StrictModeCheck.checkFunctionUse#120",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.checkFunctionUse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkFunctionUse(NodeTraversal t, Node n) {\n    if (NodeUtil.isFunctionDeclaration(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n      t.report(n, BAD_FUNCTION_DECLARATION);\n    }\n  }\n",
        "begin_line": 120,
        "end_line": 124,
        "comment": " Checks that the function is used legally. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.isDeclaration#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.isDeclaration(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean isDeclaration(Node n) {\n    switch (n.getParent().getType()) {\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.CATCH:\n        return true;\n\n      case Token.PARAM_LIST:\n        return n.getParent().getParent().isFunction();\n\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 130,
        "end_line": 143,
        "comment": "\n   * Determines if the given name is a declaration, which can be a declaration\n   * of a variable, function, or argument.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.checkAssignment#166",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.checkAssignment(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkAssignment(NodeTraversal t, Node n) {\n    if (n.getFirstChild().isName()) {\n      if (\"arguments\".equals(n.getFirstChild().getString())) {\n        t.report(n, ARGUMENTS_ASSIGNMENT);\n      } else if (\"eval\".equals(n.getFirstChild().getString())) {\n        // Note that assignment to eval is already illegal because any use of\n        // that name is illegal.\n        if (noCajaChecks) {\n          t.report(n, EVAL_ASSIGNMENT);\n        }\n      }\n    }\n  }\n",
        "begin_line": 166,
        "end_line": 178,
        "comment": " Checks that an assignment is not to the \"arguments\" object. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryReplaceExitWithBreak#454",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReplaceExitWithBreak(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryReplaceExitWithBreak(Node n) {\n    Node result = n.getFirstChild();\n\n    // Find the enclosing control structure, if any, that a \"break\" would exit\n    // from.\n    Node breakTarget = n;\n    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n        breakTarget = breakTarget.getParent()) {\n      if (breakTarget.isFunction() || breakTarget.isScript()) {\n        // No break target.\n        return n;\n      }\n    }\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n\n    // Skip pass all the finally blocks because both the break and return will\n    // also trigger all the finally blocks. However, the order of execution is\n    // slightly changed. Consider:\n    //\n    // return a() -> finally { b() } -> return a()\n    //\n    // which would call a() first. However, changing the first return to a\n    // break will result in calling b().\n\n    Node prefinallyFollows = follow;\n    follow = skipFinallyNodes(follow);\n\n    if (prefinallyFollows != follow) {\n      // There were finally clauses\n      if (!isPure(result)) {\n        // Can't defer the exit\n        return n;\n      }\n    }\n\n    if (follow == null && (n.isThrow() || result != null)) {\n      // Can't complete remove a throw here or a return with a result.\n      return n;\n    }\n\n    // When follow is null, this mean the follow of a break target is the\n    // end of a function. This means a break is same as return.\n    if (follow == null || areMatchingExits(n, follow)) {\n      Node replacement = IR.breakNode();\n      n.getParent().replaceChild(n, replacement);\n      this.reportCodeChange();\n      return replacement;\n    }\n\n    return n;\n  }\n",
        "begin_line": 454,
        "end_line": 505,
        "comment": "\n   * Replace duplicate exits in control structures.  If the node following\n   * the exit node expression has the same effect as exit node, the node can\n   * be replaced or removed.\n   * For example:\n   *   \"while (a) {return f()} return f();\" ==> \"while (a) {break} return f();\"\n   *   \"while (a) {throw 'ow'} throw 'ow';\" ==> \"while (a) {break} throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryRemoveRedundantExit#517",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryRemoveRedundantExit(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryRemoveRedundantExit(Node n) {\n    Node exitExpr = n.getFirstChild();\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n\n    // Skip pass all the finally blocks because both the fall through and return\n    // will also trigger all the finally blocks.\n    Node prefinallyFollows = follow;\n    follow = skipFinallyNodes(follow);\n    if (prefinallyFollows != follow) {\n      // There were finally clauses\n      if (!isPure(exitExpr)) {\n        // Can't replace the return\n        return n;\n      }\n    }\n\n    if (follow == null && (n.isThrow() || exitExpr != null)) {\n      // Can't complete remove a throw here or a return with a result.\n      return n;\n    }\n\n    // When follow is null, this mean the follow of a break target is the\n    // end of a function. This means a break is same as return.\n    if (follow == null || areMatchingExits(n, follow)) {\n      n.detachFromParent();\n      reportCodeChange();\n      return null;\n    }\n\n    return n;\n  }\n",
        "begin_line": 517,
        "end_line": 548,
        "comment": "\n   * Remove duplicate exits.  If the node following the exit node expression\n   * has the same effect as exit node, the node can be removed.\n   * For example:\n   *   \"if (a) {return f()} return f();\" ==> \"if (a) {} return f();\"\n   *   \"if (a) {throw 'ow'} throw 'ow';\" ==> \"if (a) {} throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.skipFinallyNodes#563",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.skipFinallyNodes(com.google.javascript.rhino.Node)",
        "snippet": "  Node skipFinallyNodes(Node n) {\n    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n      n = ControlFlowAnalysis.computeFollowNode(n);\n    }\n    return n;\n  }\n",
        "begin_line": 563,
        "end_line": 568,
        "comment": "\n   * @return n or the node following any following finally nodes.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.isInlinableFunction#162",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.isInlinableFunction(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean isInlinableFunction(Node n) {\n      return nextConvention.isInlinableFunction(n);\n    }\n",
        "begin_line": 162,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.isInlinableFunction#355",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.isInlinableFunction(com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public boolean isInlinableFunction(Node n) {\n      Preconditions.checkState(n.isFunction());\n      return true;\n    }\n",
        "begin_line": 355,
        "end_line": 359,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateObjectLiteralKeyName#730",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateObjectLiteralKeyName(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateObjectLiteralKeyName(Node n) {\n    if (n.isQuotedString()) {\n      try {\n        // Validate that getString doesn't throw\n        n.getString();\n      } catch (UnsupportedOperationException e) {\n        violation(\"getString failed for\" + Token.name(n.getType()), n);\n      }\n    } else {\n      validateNonEmptyString(n);\n    }\n  }\n",
        "begin_line": 730,
        "end_line": 741,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0754
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnionType.restrictByNotNullOrUndefined#206",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.restrictByNotNullOrUndefined()",
        "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    UnionTypeBuilder restricted = new UnionTypeBuilder(registry);\n    for (JSType t : alternates) {\n      restricted.addAlternate(t.restrictByNotNullOrUndefined());\n    }\n    return restricted.build();\n  }\n",
        "begin_line": 206,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.getSourcePosition#1141",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getSourcePosition()",
        "snippet": "  public int getSourcePosition() {\n    return sourcePosition;\n  }\n",
        "begin_line": 1141,
        "end_line": 1143,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.setSourceEncodedPositionForTree#1161",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setSourceEncodedPositionForTree(int)",
        "snippet": "  public void setSourceEncodedPositionForTree(int sourcePosition) {\n    this.sourcePosition = sourcePosition;\n\n    for (Node child = getFirstChild();\n         child != null; child = child.getNext()) {\n      child.setSourceEncodedPositionForTree(sourcePosition);\n    }\n  }\n",
        "begin_line": 1161,
        "end_line": 1168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitVar#1503",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitVar(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n\n        checkEnumAlias(t, info, value);\n        if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n",
        "begin_line": 1503,
        "end_line": 1532,
        "comment": "\n   * Visits a VAR node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.StrictModeCheck#88",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.StrictModeCheck(com.google.javascript.jscomp.AbstractCompiler, boolean, boolean)",
        "snippet": "  StrictModeCheck(\n      AbstractCompiler compiler, boolean noVarCheck, boolean noCajaChecks) {\n    this.compiler = compiler;\n    this.noVarCheck = noVarCheck;\n    this.noCajaChecks = noCajaChecks;\n  }\n",
        "begin_line": 88,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.process#95",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n    NodeTraversal.traverse(compiler, root, new NonExternChecks());\n  }\n",
        "begin_line": 95,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "StrictModeCheck.checkNameUse#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/StrictModeCheck.java",
        "class_name": "com.google.javascript.jscomp.StrictModeCheck",
        "signature": "com.google.javascript.jscomp.StrictModeCheck.checkNameUse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkNameUse(NodeTraversal t, Node n) {\n    Var v = t.getScope().getVar(n.getString());\n    if (v == null) {\n      // In particular, this prevents creating a global variable by assigning\n      // to it without a declaration.\n      if (!noVarCheck) {\n        t.report(n, UNKNOWN_VARIABLE, n.getString());\n      }\n    }\n\n    if (!noCajaChecks) {\n      if (\"eval\".equals(n.getString())) {\n        t.report(n, EVAL_USE);\n      } else if (n.getString().endsWith(\"__\")) {\n        t.report(n, ILLEGAL_NAME);\n      }\n    }\n  }\n",
        "begin_line": 146,
        "end_line": 163,
        "comment": " Checks that the given name is used legally. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.createNamespaceLiteral#961",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.createNamespaceLiteral()",
        "snippet": "    private Node createNamespaceLiteral() {\n      Node objlit = IR.objectlit();\n      objlit.setJSType(\n          compiler.getTypeRegistry().createAnonymousObjectType(null));\n      return objlit;\n    }\n",
        "begin_line": 961,
        "end_line": 966,
        "comment": "\n     * There are some special cases where clients of the compiler\n     * do not run TypedScopeCreator after running this pass.\n     * So always give the namespace literal a type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.setSourceInfo#998",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.setSourceInfo(com.google.javascript.rhino.Node)",
        "snippet": "    private void setSourceInfo(Node newNode) {\n      Node provideStringNode = getProvideStringNode();\n      int offset = getSourceInfoOffset(provideStringNode);\n      Node sourceInfoNode = provideStringNode == null\n          ? firstNode : provideStringNode;\n      newNode.copyInformationFromForTree(sourceInfoNode);\n      if (offset != 0) {\n        newNode.setSourceEncodedPositionForTree(\n            sourceInfoNode.getSourcePosition() + offset);\n      }\n    }\n",
        "begin_line": 998,
        "end_line": 1008,
        "comment": "\n     * Copy source info to the new node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.getSourceInfoOffset#1013",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.getSourceInfoOffset(com.google.javascript.rhino.Node)",
        "snippet": "    private int getSourceInfoOffset(Node provideStringNode) {\n      if (provideStringNode == null) {\n        return 0;\n      }\n\n      int indexOfLastDot = namespace.lastIndexOf('.');\n\n      // +1 for the opening quote\n      // +1 for the dot\n      // if there's no dot, then the -1 index cancels it out\n      // so elegant!\n      return 2 + indexOfLastDot;\n    }\n",
        "begin_line": 1013,
        "end_line": 1025,
        "comment": "\n     * Get the offset into the provide node where the symbol appears.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.getProvideStringNode#1027",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProvidedName.getProvideStringNode()",
        "snippet": "    private Node getProvideStringNode() {\n      return (firstNode.getFirstChild() != null &&\n              NodeUtil.isExprCall(firstNode)) ?\n          firstNode.getFirstChild().getLastChild() :\n          null;\n    }\n",
        "begin_line": 1027,
        "end_line": 1032,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1298",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-d9d2f0dd-3176-455e-a1d3-0194b353afc1.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new StrictModeCheck(compiler,\n          !options.checkSymbols,  // don't check variables twice\n          !options.checkCaja);    // disable eval check if not Caja\n    }\n",
        "begin_line": 1298,
        "end_line": 1303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.computeFollowNode#678",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(com.google.javascript.rhino.Node)",
        "snippet": "  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n",
        "begin_line": 678,
        "end_line": 680,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.isBreakTarget#877",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.isBreakTarget(com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n",
        "begin_line": 877,
        "end_line": 880,
        "comment": "\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.isBreakStructure#936",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.isBreakStructure(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 936,
        "end_line": 950,
        "comment": "\n   * Determines whether the given node can be terminated with a BREAK node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0737
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.var#155",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.var(com.google.javascript.rhino.Node)",
        "snippet": "  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n",
        "begin_line": 155,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0729
        },
        "num_failing_tests": 2
    },
    {
        "name": "GraphColoring.getGraph#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/GraphColoring.java",
        "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
        "signature": "com.google.javascript.jscomp.graph.GraphColoring.getGraph()",
        "snippet": "  public AdjacencyGraph<N, E> getGraph() {\n    return graph;\n  }\n",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "MustBeReachingVariableDef.getDef#417",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MustBeReachingVariableDef.java",
        "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
        "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.getDef(java.lang.String, com.google.javascript.rhino.Node)",
        "snippet": "  Definition getDef(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    return state.getIn().reachingDef.get(jsScope.getVar(name));\n  }\n",
        "begin_line": 417,
        "end_line": 422,
        "comment": "\n   * Gets the must reaching definition of a given node.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param useNode the location of the use where the definition reaches.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.isValidReference#674",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isValidReference(com.google.javascript.jscomp.ReferenceCollectingCallback.Reference)",
        "snippet": "    private boolean isValidReference(Reference reference) {\n      return !reference.isDeclaration() && !reference.isLvalue();\n    }\n",
        "begin_line": 674,
        "end_line": 676,
        "comment": "\n     * @return true if the reference is a candidate for inlining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.buildAndRegister#582",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister()",
        "snippet": "  FunctionType buildAndRegister() {\n    if (returnType == null) {\n      // Infer return types.\n      // We need to be extremely conservative about this, because of two\n      // competing needs.\n      // 1) If we infer the return type of f too widely, then we won't be able\n      //    to assign f to other functions.\n      // 2) If we infer the return type of f too narrowly, then we won't be\n      //    able to override f in subclasses.\n      // So we only infer in cases where the user doesn't expect to write\n      // @return annotations--when it's very obvious that the function returns\n      // nothing.\n      if (!contents.mayHaveNonEmptyReturns() &&\n          !contents.mayHaveSingleThrow() &&\n          !contents.mayBeFromExterns()) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred = true;\n      }\n    }\n\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(\n          fnName, contents.getSourceNode());\n      if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(contents.getSourceNode())\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType, returnTypeInferred)\n          .withTypeOfThis(thisType)\n          .withTemplateKeys(templateTypeNames)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    if (extendedInterfaces != null) {\n      fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeNames();\n\n    return fnType;\n  }\n",
        "begin_line": 582,
        "end_line": 644,
        "comment": "\n   * Builds the function type, and puts it in the registry.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0722
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.addRef#931",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.addRef(com.google.javascript.jscomp.GlobalNamespace.Ref)",
        "snippet": "    void addRef(Ref ref) {\n      addRefInternal(ref);\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          callGets++;\n          totalGets++;\n          break;\n        case DELETE_PROP:\n          deleteProps++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n",
        "begin_line": 931,
        "end_line": 962,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.072
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.handleSetFromGlobal#552",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.handleSetFromGlobal(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, boolean, com.google.javascript.jscomp.GlobalNamespace.Name.Type)",
        "snippet": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }\n",
        "begin_line": 552,
        "end_line": 573,
        "comment": "\n     * Updates our representation of the global namespace to reflect an\n     * assignment to a global name in global scope.\n     *\n     * @param t The traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param isPropAssign Whether this set corresponds to a property\n     *     assignment of the form <code>a.b.c = ...;</code>\n     * @param type The type of the value that the name is being assigned\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.072
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.isTypeDeclaration#585",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.isTypeDeclaration(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isTypeDeclaration(Node n, Node parent) {\n      Node valueNode = NodeUtil.getRValueOfLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      // Heed the annotations only if they're sensibly used.\n      return info != null && valueNode != null &&\n             (info.isConstructor() && valueNode.isFunction() ||\n              info.isInterface() && valueNode.isFunction() ||\n              info.hasEnumParameterType() && valueNode.isObjectLit());\n    }\n",
        "begin_line": 585,
        "end_line": 593,
        "comment": "\n     * Determines whether a set operation is a constructor or enumeration\n     * or interface declaration. The set operation may either be an assignment\n     * to a name, a variable declaration, or an object literal key mapping.\n     *\n     * @param n The node that represents the name being set\n     * @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node)\n     * @return Whether the set operation is either a constructor or enum\n     *     declaration\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.072
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.isNestedAssign#817",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.isNestedAssign(com.google.javascript.rhino.Node)",
        "snippet": "    boolean isNestedAssign(Node parent) {\n      return parent.isAssign() &&\n             !parent.getParent().isExprResult();\n    }\n",
        "begin_line": 817,
        "end_line": 820,
        "comment": "\n     * Determines whether an assignment is nested (i.e. whether its return\n     * value is used).\n     *\n     * @param parent The parent of the current traversal node (not null)\n     * @return Whether it appears that the return value of the assignment is\n     *     used\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.072
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.isGlobalScope#275",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalScope(com.google.javascript.jscomp.Scope)",
        "snippet": "  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }\n",
        "begin_line": 275,
        "end_line": 277,
        "comment": "\n   * Gets whether a scope is the global scope.\n   *\n   * @param s A scope\n   * @return Whether the scope is the global scope\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.072
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.Ref#1196",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Ref.Ref(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.jscomp.GlobalNamespace.Name, com.google.javascript.jscomp.GlobalNamespace.Ref.Type, int)",
        "snippet": "    Ref(NodeTraversal t, Node node, Name name, Type type, int index) {\n      this.node = node;\n      this.name = name;\n      this.module = t.getInput() == null ? null : t.getInput().getModule();\n      this.source = node.getStaticSourceFile();\n      this.type = type;\n      this.scope = t.getScope();\n      this.preOrderIndex = index;\n    }\n",
        "begin_line": 1196,
        "end_line": 1204,
        "comment": "\n     * Creates a reference at the current node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.Name#887",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.Name(java.lang.String, com.google.javascript.jscomp.GlobalNamespace.Name, boolean)",
        "snippet": "    Name(String name, Name parent, boolean inExterns) {\n      this.baseName = name;\n      this.parent = parent;\n      this.type = Type.OTHER;\n      this.inExterns = inExterns;\n    }\n",
        "begin_line": 887,
        "end_line": 892,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.getDeclaration#916",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.getDeclaration()",
        "snippet": "    @Override\n    public Ref getDeclaration() {\n      return declaration;\n    }\n",
        "begin_line": 916,
        "end_line": 919,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.getRefs#1006",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.getRefs()",
        "snippet": "    List<Ref> getRefs() {\n      return refs == null ? ImmutableList.<Ref>of() : refs;\n    }\n",
        "begin_line": 1006,
        "end_line": 1008,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.addRefInternal#1010",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.addRefInternal(com.google.javascript.jscomp.GlobalNamespace.Ref)",
        "snippet": "    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = Lists.newArrayList();\n      }\n      refs.add(ref);\n    }\n",
        "begin_line": 1010,
        "end_line": 1015,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.maybeHandlePrototypePrefix#769",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.maybeHandlePrototypePrefix(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n        String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }\n",
        "begin_line": 769,
        "end_line": 807,
        "comment": "\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name's longest prefix before the \"prototype\" property if the\n     * name includes the \"prototype\" property. Does nothing otherwise.\n     *\n     * @param t The current node traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @return Whether the name was handled\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "GlobalNamespace.getOrCreateName#829",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.getOrCreateName(java.lang.String)",
        "snippet": "    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }\n",
        "begin_line": 829,
        "end_line": 844,
        "comment": "\n     * Gets a {@link Name} instance for a global name. Creates it if necessary,\n     * as well as instances for any of its prefixes that are not yet defined.\n     *\n     * @param name A global name (e.g. \"a\", \"a.b.c.d\")\n     * @return The {@link Name} instance for {@code name}\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 3
    },
    {
        "name": "PrepareAst.normalizeObjectLiteralAnnotations#145",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.normalizeObjectLiteralAnnotations(com.google.javascript.rhino.Node)",
        "snippet": "    private void normalizeObjectLiteralAnnotations(Node objlit) {\n      Preconditions.checkState(objlit.isObjectLit());\n      for (Node key = objlit.getFirstChild();\n           key != null; key = key.getNext()) {\n        Node value = key.getFirstChild();\n        normalizeObjectLiteralKeyAnnotations(objlit, key, value);\n      }\n    }\n",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 2
    },
    {
        "name": "Normalize.isMarkedExpose#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Normalize.java",
        "class_name": "com.google.javascript.jscomp.Normalize",
        "signature": "com.google.javascript.jscomp.Normalize.FindExposeAnnotations.isMarkedExpose(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isMarkedExpose(Node n) {\n      JSDocInfo info = n.getJSDocInfo();\n      return info != null && info.isExpose();\n    }\n",
        "begin_line": 179,
        "end_line": 182,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0718
        },
        "num_failing_tests": 2
    },
    {
        "name": "RemoveUnusedVars.Continuation#878",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java",
        "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
        "signature": "com.google.javascript.jscomp.RemoveUnusedVars.Continuation.Continuation(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "    Continuation(Node node, Scope scope) {\n      this.node = node;\n      this.scope = scope;\n    }\n",
        "begin_line": 878,
        "end_line": 881,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0714
        },
        "num_failing_tests": 2
    },
    {
        "name": "LinkedUndirectedGraph.getUndirectedGraphNode#148",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.getUndirectedGraphNode(N)",
        "snippet": "  @Override\n  public UndiGraphNode<N, E> getUndirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }\n",
        "begin_line": 148,
        "end_line": 151,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0707
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedUndirectedGraph.getNode#182",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/LinkedUndirectedGraph.java",
        "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
        "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.getNode(N)",
        "snippet": "  @Override\n  public GraphNode<N, E> getNode(N value) {\n    return getUndirectedGraphNode(value);\n  }\n",
        "begin_line": 182,
        "end_line": 185,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0707
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntacticScopeCreator.hasDuplicateDeclarationSuppression#254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntacticScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
        "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.hasDuplicateDeclarationSuppression(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n    Preconditions.checkState(n.isName());\n    Node parent = n.getParent();\n    Node origParent = origVar.getParentNode();\n\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      info = parent.getJSDocInfo();\n    }\n    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n      return true;\n    }\n\n    info = origVar.nameNode.getJSDocInfo();\n    if (info == null) {\n      info = origParent.getJSDocInfo();\n    }\n    return (info != null && info.getSuppressions().contains(\"duplicate\"));\n  }\n",
        "begin_line": 254,
        "end_line": 272,
        "comment": "\n   * @param n The name node to check.\n   * @param origVar The associated Var.\n   * @return Whether duplicated declarations warnings should be suppressed\n   *     for the given node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0707
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrepareAst.normalizeObjectLiteralKeyAnnotations#205",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PrepareAst.java",
        "class_name": "com.google.javascript.jscomp.PrepareAst",
        "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAnnotations.normalizeObjectLiteralKeyAnnotations(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    private void normalizeObjectLiteralKeyAnnotations(\n        Node objlit, Node key, Node value) {\n      Preconditions.checkState(objlit.isObjectLit());\n      if (key.getJSDocInfo() != null &&\n          value.isFunction()) {\n        value.setJSDocInfo(key.getJSDocInfo());\n      }\n    }\n",
        "begin_line": 205,
        "end_line": 212,
        "comment": "\n     * In the AST that Rhino gives us, it needs to make a distinction\n     * between JsDoc on the object literal node and JsDoc on the object literal\n     * value. For example,\n     * <pre>\n     * var x = {\n     *   / JSDOC /\n     *   a: 'b',\n     *   c: / JSDOC / 'd'\n     * };\n     * </pre>\n     *\n     * But in few narrow cases (in particular, function literals), it's\n     * a lot easier for us if the doc is attached to the value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0707
        },
        "num_failing_tests": 1
    },
    {
        "name": "LiveVariablesAnalysis.isArgumentsName#300",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java",
        "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
        "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.isArgumentsName(com.google.javascript.rhino.Node)",
        "snippet": "  private boolean isArgumentsName(Node n) {\n    if (!n.isName()||\n        !n.getString().equals(ARGUMENT_ARRAY_ALIAS) ||\n        jsScope.isDeclared(ARGUMENT_ARRAY_ALIAS, false)) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n",
        "begin_line": 300,
        "end_line": 308,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0707
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.GlobalNamespace#81",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node)",
        "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node root) {\n    this(compiler, null, root);\n  }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param root The root of the rest of the code to build a namespace for.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 3
    },
    {
        "name": "Node.isQuotedString#236",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.StringNode.isQuotedString()",
        "snippet": "    @Override\n    public boolean isQuotedString() {\n      return getBooleanProp(QUOTED_PROP);\n    }\n",
        "begin_line": 236,
        "end_line": 239,
        "comment": "\n     * If the property is not defined, this was not a quoted key.  The\n     * QUOTED_PROP int property is only assigned to STRING tokens used as\n     * object lit keys.\n     * @return true if this was a quoted string key in an object literal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfoBuilder.recordConstancy#602",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstancy()",
        "snippet": "  public boolean recordConstancy() {\n    if (!currentInfo.isConstant()) {\n      currentInfo.setConstant(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 602,
        "end_line": 610,
        "comment": "\n   * Records that the {@link JSDocInfo} being built should have its\n   * {@link JSDocInfo#isConstant()} flag set to {@code true}.\n   *\n   * @return {@code true} if the constancy was recorded and {@code false}\n   *     if it was already defined\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.setConstant#349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setConstant(boolean)",
        "snippet": "  void setConstant(boolean value) {\n    setFlag(value, MASK_CONSTANT);\n  }\n",
        "begin_line": 349,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureReverseAbstractInterpreter.ClosureReverseAbstractInterpreter#128",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.ClosureReverseAbstractInterpreter(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public ClosureReverseAbstractInterpreter(CodingConvention convention,\n      final JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n    this.restricters =\n      new ImmutableMap.Builder<String, Function<TypeRestriction, JSType>>()\n      .put(\"isDef\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return getRestrictedWithoutUndefined(p.type);\n          } else {\n            return  p.type != null ?\n                getNativeType(VOID_TYPE).getGreatestSubtype(p.type) : null;\n          }\n         }\n      })\n      .put(\"isNull\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return p.type != null ?\n                getNativeType(NULL_TYPE).getGreatestSubtype(p.type) : null;\n          } else {\n            return getRestrictedWithoutNull(p.type);\n          }\n        }\n      })\n      .put(\"isDefAndNotNull\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return getRestrictedWithoutUndefined(\n                getRestrictedWithoutNull(p.type));\n          } else {\n            return p.type != null ?\n                getNativeType(NULL_VOID).getGreatestSubtype(p.type) : null;\n          }\n        }\n      })\n      .put(\"isString\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"string\", p.outcome);\n        }\n      })\n      .put(\"isBoolean\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"boolean\", p.outcome);\n        }\n      })\n      .put(\"isNumber\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"number\", p.outcome);\n        }\n      })\n      .put(\"isFunction\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"function\", p.outcome);\n        }\n      })\n      .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          if (p.type == null) {\n            return p.outcome ? getNativeType(ARRAY_TYPE) : null;\n          }\n\n          Visitor<JSType> visitor = p.outcome ? restrictToArrayVisitor :\n              restrictToNotArrayVisitor;\n          return p.type.visit(visitor);\n        }\n      })\n      .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n        @Override\n        public JSType apply(TypeRestriction p) {\n          if (p.type == null) {\n            return p.outcome ? getNativeType(OBJECT_TYPE) : null;\n          }\n\n          Visitor<JSType> visitor = p.outcome ? restrictToObjectVisitor :\n              restrictToNotObjectVisitor;\n          return p.type.visit(visitor);\n        }\n      })\n      .build();\n  }\n",
        "begin_line": 128,
        "end_line": 216,
        "comment": "\n   * Creates a {@link ClosureReverseAbstractInterpreter}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "ChainableReverseAbstractInterpreter.append#80",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.append(com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter)",
        "snippet": "  public ChainableReverseAbstractInterpreter append(\n      ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }\n",
        "begin_line": 80,
        "end_line": 86,
        "comment": "\n   * Appends a link to {@code this}, returning the updated last link.\n   * <p>\n   * The pattern {@code new X().append(new Y())...append(new Z())} forms a\n   * chain starting with X, then Y, then ... Z.\n   * @param lastLink a chainable interpreter, with no next link\n   * @return the updated last link\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "ChainableReverseAbstractInterpreter.getFirst#91",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.getFirst()",
        "snippet": "  public ChainableReverseAbstractInterpreter getFirst() {\n    return firstLink;\n  }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n   * Gets the first link of this chain.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processScope#996",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processScope(com.google.javascript.rhino.head.ast.Scope)",
        "snippet": "    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }\n",
        "begin_line": 996,
        "end_line": 999,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectCanAssignTo#399",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignTo(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, java.lang.String)",
        "snippet": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.isSubtype(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 399,
        "end_line": 406,
        "comment": "\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.incCount#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.ProcessVars.incCount(java.lang.String)",
        "snippet": "    void incCount(String name) {\n      Assignment s = assignments.get(name);\n      if (s == null) {\n        s = new Assignment(name);\n        assignments.put(name, s);\n      }\n      s.count++;\n    }\n",
        "begin_line": 284,
        "end_line": 291,
        "comment": " Increment count of an assignment",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.Assignment#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.Assignment.Assignment(java.lang.String)",
        "snippet": "    Assignment(String name) {\n      this.oldName = name;\n      this.newName = null;\n      this.count = 0;\n\n      // Represents the order at which a symbol appears in the source.\n      this.orderOfOccurrence = assignmentCount++;\n    }\n",
        "begin_line": 94,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.setNewName#106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.Assignment.setNewName(java.lang.String)",
        "snippet": "    void setNewName(String newName) {\n      Preconditions.checkState(this.newName == null);\n      this.newName = newName;\n    }\n",
        "begin_line": 106,
        "end_line": 109,
        "comment": "\n     * Assigns the new name.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.compare#317",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.Anonymous-b8797c4e-849b-495f-b9fa-f9ee13f11967.compare(com.google.javascript.jscomp.RenameVars.Assignment, com.google.javascript.jscomp.RenameVars.Assignment)",
        "snippet": "        @Override\n        public int compare(Assignment a1, Assignment a2) {\n          return a1.orderOfOccurrence - a2.orderOfOccurrence;\n        }\n",
        "begin_line": 317,
        "end_line": 320,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "RenameVars.finalizeNameAssignment#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/RenameVars.java",
        "class_name": "com.google.javascript.jscomp.RenameVars",
        "signature": "com.google.javascript.jscomp.RenameVars.finalizeNameAssignment(com.google.javascript.jscomp.RenameVars.Assignment, java.lang.String)",
        "snippet": "  private void finalizeNameAssignment(Assignment a, String newName) {\n    a.setNewName(newName);\n\n    // Keep track of the mapping\n    renameMap.put(a.oldName, newName);\n\n    // Log the mapping\n    assignmentLog.append(a.oldName).append(\" => \").append(newName).append('\\n');\n  }\n",
        "begin_line": 515,
        "end_line": 523,
        "comment": "\n   * Makes a final name assignment.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.getReverseAbstractInterpreter#1248",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getReverseAbstractInterpreter()",
        "snippet": "  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n",
        "begin_line": 1248,
        "end_line": 1262,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureRewriteClass.maybeRewriteClassDefinition#133",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureRewriteClass.java",
        "class_name": "com.google.javascript.jscomp.ClosureRewriteClass",
        "signature": "com.google.javascript.jscomp.ClosureRewriteClass.maybeRewriteClassDefinition(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void maybeRewriteClassDefinition(\n      Node n, Node target, Node value) {\n    if (isGoogDefineClass(value)) {\n      if (!target.isQualifiedName()) {\n        compiler.report(JSError.make(n, GOOG_CLASS_TARGET_INVALID));\n      }\n      ClassDefinition def = extractClassDefinition(target, value);\n      if (def != null) {\n        value.detachFromParent();\n        target.detachFromParent();\n        rewriteGoogDefineClass(n, def);\n      }\n    }\n  }\n",
        "begin_line": 133,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0687
        },
        "num_failing_tests": 2
    },
    {
        "name": "ControlFlowAnalysis.handleStmt#668",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n",
        "begin_line": 668,
        "end_line": 672,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.068
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSTypeRegistry.forwardDeclareType#858",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.forwardDeclareType(java.lang.String)",
        "snippet": "  public void forwardDeclareType(String name) {\n    forwardDeclaredTypes.add(name);\n  }\n",
        "begin_line": 858,
        "end_line": 860,
        "comment": "\n   * Records a forward-declared type name. We will not emit errors if this\n   * type name never resolves to anything.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.068
        },
        "num_failing_tests": 1
    },
    {
        "name": "Graph.hasNode#191",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/graph/Graph.java",
        "class_name": "com.google.javascript.jscomp.graph.Graph",
        "signature": "com.google.javascript.jscomp.graph.Graph.hasNode(N)",
        "snippet": "  public final boolean hasNode(N n) {\n    return getNode(n) != null;\n  }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": "\n   * Checks whether the node exists in the graph ({@link #createNode(Object)}\n   * has been called with that value).\n   *\n   * @param n Node.\n   * @return <code>true</code> if it exist.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.068
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isSimpleAssignmentToName#614",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isSimpleAssignmentToName()",
        "snippet": "    boolean isSimpleAssignmentToName() {\n      Node parent = getParent();\n      return parent.isAssign()\n          && parent.getFirstChild() == nameNode;\n    }\n",
        "begin_line": 614,
        "end_line": 618,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.068
        },
        "num_failing_tests": 1
    },
    {
        "name": "ControlFlowAnalysis.handleReturn#639",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
        "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleReturn(com.google.javascript.rhino.Node)",
        "snippet": "  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n",
        "begin_line": 639,
        "end_line": 666,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.068
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.copyInformationFrom#1712",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.copyInformationFrom(com.google.javascript.rhino.Node)",
        "snippet": "  public Node copyInformationFrom(Node other) {\n    if (getProp(ORIGINALNAME_PROP) == null) {\n      putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n    }\n\n    if (getProp(STATIC_SOURCE_FILE) == null) {\n      putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));\n      sourcePosition = other.sourcePosition;\n    }\n\n    return this;\n  }\n",
        "begin_line": 1712,
        "end_line": 1723,
        "comment": " TODO(nicksantos): The semantics of this method are ill-defined. Delete it.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0671
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSType.isInstanceType#602",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isInstanceType()",
        "snippet": "  public boolean isInstanceType() {\n    return false;\n  }\n",
        "begin_line": 602,
        "end_line": 604,
        "comment": "\n   * Whether this type is an Instance object of some constructor.\n   * Does not necessarily mean this is an {@link InstanceObjectType}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0668
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.inlineNonConstants#254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.inlineNonConstants(com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection, boolean)",
        "snippet": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) && referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }\n",
        "begin_line": 254,
        "end_line": 323,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0668
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.name#318",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.name(java.lang.String)",
        "snippet": "  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n",
        "begin_line": 318,
        "end_line": 320,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0659
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.isNeverAssigned#463",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.isNeverAssigned()",
        "snippet": "    boolean isNeverAssigned() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        Reference ref = references.get(i);\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          return false;\n        }\n      }\n      return true;\n    }\n",
        "begin_line": 463,
        "end_line": 472,
        "comment": "\n     * @return Whether the variable is never assigned a value.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.processProvideCall#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.processProvideCall(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n        }\n      } else {\n        registerAnyProvidedPrefixes(ns, parent, t.getModule());\n        providedNames.put(\n            ns, new ProvidedName(ns, parent, t.getModule(), true));\n      }\n    }\n  }\n",
        "begin_line": 309,
        "end_line": 332,
        "comment": "\n   * Handles a goog.provide call.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.verifyProvide#657",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyProvide(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n    if (!verifyArgument(t, methodName, arg)) {\n      return false;\n    }\n\n    for (String part : arg.getString().split(\"\\\\.\")) {\n      if (!NodeUtil.isValidPropertyName(part)) {\n        compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR, part));\n        return false;\n      }\n    }\n    return true;\n  }\n",
        "begin_line": 657,
        "end_line": 669,
        "comment": "\n   * Verifies that a provide method call has exactly one argument,\n   * and that it's a string literal and that the contents of the string are\n   * valid JS tokens. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.registerAnyProvidedPrefixes#744",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.registerAnyProvidedPrefixes(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.JSModule)",
        "snippet": "  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module) {\n    int pos = ns.indexOf('.');\n    while (pos != -1) {\n      String prefixNs = ns.substring(0, pos);\n      pos = ns.indexOf('.', pos + 1);\n      if (providedNames.containsKey(prefixNs)) {\n        providedNames.get(prefixNs).addProvide(\n            node, module, false /* implicit */);\n      } else {\n        providedNames.put(\n            prefixNs,\n            new ProvidedName(prefixNs, node, module, false /* implicit */));\n      }\n    }\n  }\n",
        "begin_line": 744,
        "end_line": 759,
        "comment": "\n   * Registers ProvidedNames for prefix namespaces if they haven't\n   * already been defined. The prefix namespaces must be registered in\n   * order from shortest to longest.\n   *\n   * @param ns The namespace whose prefixes may need to be provided.\n   * @param node The EXPR of the provide call.\n   * @param module The current module.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineObjectLiterals.isVarOrAssignExprLhs#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java",
        "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
        "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InliningBehavior.isVarOrAssignExprLhs(com.google.javascript.rhino.Node)",
        "snippet": "    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      return parent.isVar() ||\n          (parent.isAssign()\n              && parent.getFirstChild() == n\n              && parent.getParent().isExprResult());\n    }\n",
        "begin_line": 258,
        "end_line": 264,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodeGenerator.unrollBinaryOperator#765",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeGenerator.java",
        "class_name": "com.google.javascript.jscomp.CodeGenerator",
        "signature": "com.google.javascript.jscomp.CodeGenerator.unrollBinaryOperator(com.google.javascript.rhino.Node, int, java.lang.String, com.google.javascript.jscomp.CodeGenerator.Context, com.google.javascript.jscomp.CodeGenerator.Context, int, int)",
        "snippet": "  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.addOp(opStr, true);\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n",
        "begin_line": 765,
        "end_line": 781,
        "comment": "\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0654
        },
        "num_failing_tests": 2
    },
    {
        "name": "ReferenceCollectingCallback.isAssignedOnceInLifetime#421",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.isAssignedOnceInLifetime()",
        "snippet": "    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
        "begin_line": 421,
        "end_line": 438,
        "comment": "\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.verifyArgument#677",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyArgument(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg) {\n    return verifyArgument(t, methodName, arg, Token.STRING);\n  }\n",
        "begin_line": 677,
        "end_line": 679,
        "comment": "\n   * Verifies that a method call has exactly one argument, and that it's a\n   * string literal. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.verifyArgument#687",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyArgument(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, int)",
        "snippet": "  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg,\n      int desiredType) {\n    DiagnosticType diagnostic = null;\n    if (arg == null) {\n      diagnostic = NULL_ARGUMENT_ERROR;\n    } else if (arg.getType() != desiredType) {\n      diagnostic = INVALID_ARGUMENT_ERROR;\n    } else if (arg.getNext() != null) {\n      diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n    }\n    if (diagnostic != null) {\n      compiler.report(\n          t.makeError(methodName,\n              diagnostic, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 687,
        "end_line": 704,
        "comment": "\n   * Verifies that a method call has exactly one argument, and that it is of the\n   * desired type. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.maybeAddStringNodeToSymbolTable#1062",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.maybeAddStringNodeToSymbolTable(com.google.javascript.rhino.Node)",
        "snippet": "  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (preprocessorSymbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    Node syntheticRef = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), name,\n        n /* real source offsets will be filled in below */,\n        name);\n\n    // Offsets to add to source. Named for documentation purposes.\n    final int FOR_QUOTE = 1;\n    final int FOR_DOT = 1;\n\n    Node current = null;\n    for (current = syntheticRef;\n         current.isGetProp();\n         current = current.getFirstChild()) {\n      int fullLen = current.getQualifiedName().length();\n      int namespaceLen = current.getFirstChild().getQualifiedName().length();\n\n      current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n      current.setLength(fullLen);\n\n      current.getLastChild().setSourceEncodedPosition(\n          n.getSourcePosition() + namespaceLen + FOR_QUOTE + FOR_DOT);\n      current.getLastChild().setLength(\n          current.getLastChild().getString().length());\n    }\n\n    current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE);\n    current.setLength(current.getString().length());\n\n    maybeAddToSymbolTable(syntheticRef);\n  }\n",
        "begin_line": 1062,
        "end_line": 1097,
        "comment": "\n   * The string in {@code n} is a reference name. Create a synthetic\n   * node for it with all the proper source info, and add it to the symbol\n   * table.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "ProcessClosurePrimitives.maybeAddToSymbolTable#1102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java",
        "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
        "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.maybeAddToSymbolTable(com.google.javascript.rhino.Node)",
        "snippet": "  private void maybeAddToSymbolTable(Node n) {\n    if (preprocessorSymbolTable != null) {\n      preprocessorSymbolTable.addReference(n);\n    }\n  }\n",
        "begin_line": 1102,
        "end_line": 1106,
        "comment": "\n   * Add the given qualified name node to the symbol table.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalThis.shouldTraverse#79",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
        "signature": "com.google.javascript.jscomp.CheckGlobalThis.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.isFunction()) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING_KEY)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n    }\n\n    if (parent != null && parent.isAssign()) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.isGetProp() &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.isGetProp() &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n",
        "begin_line": 79,
        "end_line": 152,
        "comment": "\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0645
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.setType#523",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.setType(int)",
        "snippet": "  public void setType(int type) {\n    this.type = type;\n  }\n",
        "begin_line": 523,
        "end_line": 525,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0635
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isDelProp#2213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isDelProp()",
        "snippet": "  public boolean isDelProp() {\n    return this.getType() == Token.DELPROP;\n  }\n",
        "begin_line": 2213,
        "end_line": 2215,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0635
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isLiteralValue#591",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isLiteralValue(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.CAST:\n        return isLiteralValue(n.getFirstChild(), includeFunctions);\n\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }\n",
        "begin_line": 591,
        "end_line": 631,
        "comment": "\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() { return a; }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured variables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0625
        },
        "num_failing_tests": 2
    },
    {
        "name": "TypedScopeCreator.visit#512",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      attachLiteralTypes(t, n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n, parent);\n          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // Hoisted functions are handled during pre-traversal.\n          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n            defineFunctionLiteral(n);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.isGetProp() &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n);\n          break;\n\n        case Token.VAR:\n          defineVar(n);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.isExprResult() &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n\n      // Analyze any @lends object literals in this statement.\n      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n          lentObjectLiterals != null) {\n        for (Node objLit : lentObjectLiterals) {\n          defineObjectLiteral(objLit);\n        }\n        lentObjectLiterals.clear();\n      }\n    }\n",
        "begin_line": 512,
        "end_line": 569,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0615
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.createScope#197",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      JSType globalThis =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n\n      // Mark the main root, the externs root, and the src root\n      // with the global this type.\n      root.setJSType(globalThis);\n      root.getFirstChild().setJSType(globalThis);\n      root.getLastChild().setJSType(globalThis);\n\n      // Run a first-order analysis over the syntax tree.\n      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\n          .process(root.getFirstChild(), root.getLastChild());\n\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type.isFunctionType()) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        JSType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes,\n          delegateCallingConventions);\n    }\n    return newScope;\n  }\n",
        "begin_line": 197,
        "end_line": 255,
        "comment": "\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0615
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverseName#670",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseName(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped and assigned in an inner scope, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable. That variable is assigned more than once,\n        // and we can't know which type we're getting.\n        //\n        // var t = null; function f() { (t); } doStuff(); t = {};\n        //\n        // Notice that this heuristic isn't perfect. For example, you might\n        // have:\n        //\n        // function f() { (t); } f(); var t = 3;\n        //\n        // In this case, we would infer the first reference to t as\n        // type {number}, even though it's undefined.\n        boolean nonLocalInferredSlot = false;\n        if (isInferred && syntacticScope.isLocal()) {\n          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n          if (var == maybeOuterVar &&\n              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n            nonLocalInferredSlot = true;\n          }\n        }\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n",
        "begin_line": 670,
        "end_line": 723,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0615
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isNumber#2301",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isNumber()",
        "snippet": "  public boolean isNumber() {\n    return this.getType() == Token.NUMBER;\n  }\n",
        "begin_line": 2301,
        "end_line": 2303,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0611
        },
        "num_failing_tests": 2
    },
    {
        "name": "JSDocInfo.getSuppressions#1350",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getSuppressions()",
        "snippet": "  public Set<String> getSuppressions() {\n    Set<String> suppressions = info == null ? null : info.suppressions;\n    return suppressions == null ? Collections.<String>emptySet() : suppressions;\n  }\n",
        "begin_line": 1350,
        "end_line": 1353,
        "comment": "\n   * Returns the set of suppressed warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0606
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.updateScopeForTypeChange#532",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.updateScopeForTypeChange(com.google.javascript.jscomp.type.FlowScope, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n",
        "begin_line": 532,
        "end_line": 575,
        "comment": "\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0606
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalThis.getFunctionJsDocInfo#184",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
        "signature": "com.google.javascript.jscomp.CheckGlobalThis.getFunctionJsDocInfo(com.google.javascript.rhino.Node)",
        "snippet": "  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.isVar()) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n",
        "begin_line": 184,
        "end_line": 200,
        "comment": "\n   * Gets a function's JSDoc information, if it has any. Checks for a few\n   * patterns (ellipses show where JSDoc would be):\n   * <pre>\n   * ... function() {}\n   * ... x = function() {};\n   * var ... x = function() {};\n   * ... var x = function() {};\n   * </pre>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0606
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getTypeOfThis#1084",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getTypeOfThis()",
        "snippet": "  @Override\n  public JSType getTypeOfThis() {\n    return typeOfThis.isEmptyType() ?\n        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;\n  }\n",
        "begin_line": 1084,
        "end_line": 1088,
        "comment": "\n   * Gets the type of {@code this} in this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.objectlit#400",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.objectlit(com.google.javascript.rhino.Node...)",
        "snippet": "  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n",
        "begin_line": 400,
        "end_line": 410,
        "comment": " literals",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0598
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createAnonymousObjectType#1374",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createAnonymousObjectType(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  public ObjectType createAnonymousObjectType(JSDocInfo info) {\n    PrototypeObjectType type = new PrototypeObjectType(this, null, null);\n    type.setPrettyPrint(true);\n    type.setJSDocInfo(info);\n    return type;\n  }\n",
        "begin_line": 1374,
        "end_line": 1379,
        "comment": "\n   * Create an anonymous object type.\n   * @param info Used to mark object literals as structs; can be {@code null}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0589
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.getParent#683",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.BasicBlock.getParent()",
        "snippet": "    BasicBlock getParent() {\n      return parent;\n    }\n",
        "begin_line": 683,
        "end_line": 685,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0589
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.functionCallHasSideEffects#998",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.functionCallHasSideEffects(com.google.javascript.rhino.Node, com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (!callNode.isCall()) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Math.floor has no side-effects.\n      // TODO(nicksantos): This is a terrible terrible hack, until\n      // I create a definitionProvider that understands namespacing.\n      if (nameNode.getFirstChild().isName()) {\n        if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n          return false;\n        }\n      }\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp()\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString()\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n",
        "begin_line": 998,
        "end_line": 1055,
        "comment": "\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0587
        },
        "num_failing_tests": 2
    },
    {
        "name": "UnknownType.visit#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.visit(com.google.javascript.rhino.jstype.RelationshipVisitor<T>, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n    return visitor.caseUnknownType(this, that);\n  }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getOwnPropertyJSDocInfo#398",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyJSDocInfo(java.lang.String)",
        "snippet": "  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    Property p = getOwnSlot(propertyName);\n    return p == null ? null : p.getJSDocInfo();\n  }\n",
        "begin_line": 398,
        "end_line": 401,
        "comment": "\n   * Gets the docInfo on the specified property on this type.  This should not\n   * be implemented recursively, as you generally need to know exactly on\n   * which type in the prototype chain the JSDocInfo exists.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.isPropertyTypeInferred#469",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isPropertyTypeInferred(java.lang.String)",
        "snippet": "  public boolean isPropertyTypeInferred(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : slot.isTypeInferred();\n  }\n",
        "begin_line": 469,
        "end_line": 472,
        "comment": "\n   * Checks whether the property's type is inferred.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isDict#322",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isDict()",
        "snippet": "  public boolean isDict() {\n    if (isObject()) {\n      ObjectType objType = toObjectType();\n      ObjectType iproto = objType.getImplicitPrototype();\n      // For the case when a @dict constructor is assigned to a function's\n      // prototype property\n      if (iproto != null && iproto.isDict()) {\n        return true;\n      }\n      FunctionType ctor = objType.getConstructor();\n      // This test is true for object literals\n      if (ctor == null) {\n        JSDocInfo info = objType.getJSDocInfo();\n        return info != null && info.makesDicts();\n      } else {\n        return ctor.makesDicts();\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 322,
        "end_line": 341,
        "comment": "\n   * Returns true iff {@code this} can be a {@code dict}.\n   * UnionType overrides the method, assume {@code this} is not a union here.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.canCastTo#847",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.canCastTo(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean canCastTo(JSType that) {\n    return this.visit(CAN_CAST_TO_VISITOR, that);\n  }\n",
        "begin_line": 847,
        "end_line": 849,
        "comment": "\n   * Tests whether values of {@code this} type can be safely assigned\n   * to values of {@code that} type.<p>\n   *\n   * The default implementation verifies that {@code this} is a subtype\n   * of {@code that}.<p>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.makesDicts#229",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.makesDicts()",
        "snippet": "  public boolean makesDicts() {\n    if (!isConstructor()) {\n      return false;\n    }\n    if (propAccess == PropAccess.DICT) {\n      return true;\n    }\n    FunctionType superc = getSuperClassConstructor();\n    if (superc != null && superc.makesDicts()) {\n      setDict();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 229,
        "end_line": 242,
        "comment": "\n   * When a class B inherits from A and A is annotated as a dict, then B\n   * automatically gets the annotation, even if B's constructor is not\n   * explicitly annotated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getAllImplementedInterfaces#482",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getAllImplementedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getAllImplementedInterfaces() {\n    // Store them in a linked hash set, so that the compile job is\n    // deterministic.\n    Set<ObjectType> interfaces = Sets.newLinkedHashSet();\n\n    for (ObjectType type : getImplementedInterfaces()) {\n      addRelatedInterfaces(type, interfaces);\n    }\n    return interfaces;\n  }\n",
        "begin_line": 482,
        "end_line": 491,
        "comment": "\n   * Returns all interfaces implemented by a class or its superclass and any\n   * superclasses for any of those interfaces. If this is called before all\n   * types are resolved, it may return an incomplete set.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.isSubtype#1005",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      FunctionType other = that.toMaybeFunctionType();\n      if (other.isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      boolean treatThisTypesAsCovariant =\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.toObjectType() != null &&\n             other.typeOfThis.toObjectType().getConstructor() != null &&\n             other.typeOfThis.toObjectType().getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n",
        "begin_line": 1005,
        "end_line": 1045,
        "comment": "\n   * A function is a subtype of another if their call methods are related via\n   * subtyping and {@code this} is a subtype of {@code that} with regard to\n   * the prototype chain.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "CanCastToVisitor.caseUnknownType#47",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/CanCastToVisitor.java",
        "class_name": "com.google.javascript.rhino.jstype.CanCastToVisitor",
        "signature": "com.google.javascript.rhino.jstype.CanCastToVisitor.caseUnknownType(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public Boolean caseUnknownType(JSType thisType, JSType thatType) {\n    return true;\n  }\n",
        "begin_line": 47,
        "end_line": 50,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.isNoTypeCheck#510",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isNoTypeCheck()",
        "snippet": "  public boolean isNoTypeCheck() {\n    return getFlag(MASK_NOCHECK);\n  }\n",
        "begin_line": 510,
        "end_line": 512,
        "comment": "\n   * Returns whether the {@code @nocheck} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.isOverride#526",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isOverride()",
        "snippet": "  public boolean isOverride() {\n    return getFlag(MASK_OVERRIDE);\n  }\n",
        "begin_line": 526,
        "end_line": 528,
        "comment": "\n   * Returns whether the {@code @override} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectCanAssignToPropertyOf#363",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignToPropertyOf(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 363,
        "end_line": 386,
        "comment": "\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectCanCast#495",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectCanCast(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) {\n    if (!type.canCastTo(castType)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          type.toString(), castType.toString())));\n    }\n  }\n",
        "begin_line": 495,
        "end_line": 500,
        "comment": "\n   * Expect that the first type can be cast to the second type. The first type\n   * must have some relationship with the second.\n   *\n   * @param t The node traversal.\n   * @param n The node where warnings should point.\n   * @param type The type being cast from.\n   * @param castType The type being cast to.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectAllInterfaceProperties#582",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectAllInterfaceProperties(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }\n",
        "begin_line": 582,
        "end_line": 593,
        "comment": "\n   * Expect that all properties on interfaces that this type implements are\n   * implemented and correctly typed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.shouldTraverse#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // normal type checking\n        final Scope outerScope = t.getScope();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            // Ideally, we would want to check whether the type in the scope\n            // differs from the type being defined, but then the extern\n            // redeclarations of built-in types generates spurious warnings.\n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        // TODO(user): Only traverse the function's body. The function's\n        // name and arguments are traversed by the scope creator, and ideally\n        // should not be traversed by the type checker.\n        break;\n    }\n    return true;\n  }\n",
        "begin_line": 440,
        "end_line": 465,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.doPercentTypedAccounting#868",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.doPercentTypedAccounting(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n",
        "begin_line": 868,
        "end_line": 881,
        "comment": "\n   * Counts the given node in the typed statistics.\n   * @param n a node that should be typed\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitAssign#891",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitAssign(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    // Check property sets to 'object.property' when 'object' is known.\n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      Node property = lvalue.getLastChild();\n      String pname = property.getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\n        }\n      }\n\n      checkEnumAlias(t, info, rvalue);\n      checkPropCreation(t, lvalue);\n\n      // Prototype assignments are special, because they actually affect\n      // the definition of a class. These are mostly validated\n      // during TypedScopeCreator, and we only look for the \"dumb\" cases here.\n      // object.prototype = ...;\n      if (pname.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n            // Only assign structs to the prototype of a @struct constructor\n            if (functionType.makesStructs() && !rvalueType.isStruct()) {\n              String funName = functionType.getTypeOfThis().toString();\n              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\n                                          \"struct\", funName));\n            }\n            return;\n          }\n        }\n      }\n\n      // The generic checks for 'object.property' when 'object' is known,\n      // and 'property' is declared on it.\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(pname) &&\n            !type.isPropertyTypeInferred(pname) &&\n            !propertyIsImplicitCast(type, pname)) {\n          JSType expectedType = type.getPropertyType(pname);\n          if (!expectedType.isUnknownType()) {\n            validator.expectCanAssignToPropertyOf(\n                t, assign, getJSType(rvalue),\n                expectedType, object, pname);\n            checkPropertyInheritanceOnGetpropAssign(\n                t, assign, object, pname, info, expectedType);\n            return;\n          }\n        }\n      }\n\n      // If we couldn't get the property type with normal object property\n      // lookups, then check inheritance anyway with the unknown type.\n      checkPropertyInheritanceOnGetpropAssign(\n          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\n    }\n\n    // Check qualified name sets to 'object' and 'object.property'.\n    // This can sometimes handle cases when the type of 'object' is not known.\n    // e.g.,\n    // var obj = createUnknownType();\n    // /** @type {number} */ obj.foo = true;\n    JSType leftType = getJSType(lvalue);\n    if (lvalue.isQualifiedName()) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n            t.getScope() != var.getScope()) {\n          // Don't look at \"this.foo\" variables from other scopes.\n          return;\n        }\n\n        if (var.getType() != null) {\n          leftType = var.getType();\n        }\n      }\n    }\n\n    // Fall through case for arbitrary LHS and arbitrary RHS.\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n",
        "begin_line": 891,
        "end_line": 1001,
        "comment": "\n   * Visits an assignment <code>lvalue = rvalue</code>. If the\n   * <code>lvalue</code> is a prototype modification, we change the schema\n   * of the object type it is referring to.\n   * @param t the traversal\n   * @param assign the assign node\n   * (<code>assign.isAssign()</code> is an implicit invariant)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkPropCreation#1004",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropCreation(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n    if (lvalue.isGetProp()) {\n      Node obj = lvalue.getFirstChild();\n      Node prop = lvalue.getLastChild();\n      JSType objType = getJSType(obj);\n      String pname = prop.getString();\n      if (objType.isStruct() && !objType.hasProperty(pname)) {\n        if (!(obj.isThis() &&\n              getJSType(t.getScope().getRootNode()).isConstructor())) {\n          report(t, prop, ILLEGAL_PROPERTY_CREATION);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1004,
        "end_line": 1017,
        "comment": " Check that we don't create new properties on structs. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkPropertyInheritanceOnGetpropAssign#1019",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyInheritanceOnGetpropAssign(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void checkPropertyInheritanceOnGetpropAssign(\n      NodeTraversal t, Node assign, Node object, String property,\n      JSDocInfo info, JSType propertyType) {\n    // Inheritance checks for prototype properties.\n    //\n    // TODO(nicksantos): This isn't the right place to do this check. We\n    // really want to do this when we're looking at the constructor.\n    // We'd find all its properties and make sure they followed inheritance\n    // rules, like we currently do for @implements to make sure\n    // all the methods are implemented.\n    //\n    // As-is, this misses many other ways to override a property.\n    //\n    // object.prototype.property = ...;\n    if (object.isGetProp()) {\n      Node object2 = object.getFirstChild();\n      String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n      if (\"prototype\".equals(property2)) {\n        JSType jsType = getJSType(object2);\n        if (jsType.isFunctionType()) {\n          FunctionType functionType = jsType.toMaybeFunctionType();\n          if (functionType.isConstructor() || functionType.isInterface()) {\n            checkDeclaredPropertyInheritance(\n                t, assign, functionType, property, info, propertyType);\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 1019,
        "end_line": 1048,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.propertyIsImplicitCast#1134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.propertyIsImplicitCast(com.google.javascript.rhino.jstype.ObjectType, java.lang.String)",
        "snippet": "  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 1134,
        "end_line": 1142,
        "comment": "\n   * Returns true if any type in the chain has an implicitCast annotation for\n   * the given property.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkDeclaredPropertyInheritance#1150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkDeclaredPropertyInheritance(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.FunctionType, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getInstanceType().hasProperty(propertyName);\n    boolean superClassHasDeclaredProperty = superClass != null &&\n        superClass.getInstanceType().isPropertyTypeDeclared(propertyName);\n\n    // For interface\n    boolean superInterfaceHasProperty = false;\n    boolean superInterfaceHasDeclaredProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfaceHasProperty =\n            superInterfaceHasProperty ||\n            interfaceType.hasProperty(propertyName);\n        superInterfaceHasDeclaredProperty =\n            superInterfaceHasDeclaredProperty ||\n            interfaceType.isPropertyTypeDeclared(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty ||\n            interfaceHasProperty;\n        if (reportMissingOverride.isOn()\n            && !declaredOverride\n            && interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    ObjectType topInstanceType = superClassHasDeclaredProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    boolean declaredLocally =\n        ctorType.isConstructor() &&\n        (ctorType.getPrototype().hasOwnProperty(propertyName) ||\n         ctorType.getInstanceType().hasOwnProperty(propertyName));\n    if (reportMissingOverride.isOn()\n        && !declaredOverride\n        && superClassHasDeclaredProperty\n        && declaredLocally) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n\n    // @override is present and we have to check that it is ok\n    if (superClassHasDeclaredProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getInstanceType().getPropertyType(propertyName);\n      if (!propertyType.isSubtype(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfaceHasDeclaredProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n              interfaceType.getPropertyType(propertyName);\n          if (!propertyType.isSubtype(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty\n        && !superClassHasProperty\n        && !superInterfaceHasProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n",
        "begin_line": 1150,
        "end_line": 1268,
        "comment": "\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.hasUnknownOrEmptySupertype#1274",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.hasUnknownOrEmptySupertype(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    // The type system should notice inheritance cycles on its own\n    // and break the cycle.\n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }\n",
        "begin_line": 1274,
        "end_line": 1296,
        "comment": "\n   * Given a constructor or an interface type, find out whether the unknown\n   * type is a supertype of the current type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitFunction#1605",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitFunction(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          baseConstructor != null &&\n          baseConstructor.isInterface()) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                        \"constructor\", functionPrivateName));\n      } else {\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n          ObjectType proto = functionType.getPrototype();\n          if (functionType.makesStructs() && !proto.isStruct()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"struct\", functionPrivateName));\n          } else if (functionType.makesDicts() && !proto.isDict()) {\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                                        \"dict\", functionPrivateName));\n          }\n        }\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n                          \"interface\", functionPrivateName));\n        }\n      }\n\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n",
        "begin_line": 1605,
        "end_line": 1674,
        "comment": "\n   * Visits a {@link Token#FUNCTION} node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.ensureTyped#1967",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(!n.isFunction() ||\n            type.isFunctionType() ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        // TODO(johnlenz): Change this so that we only look for casts on CAST\n        // nodes one the misplaced type annotation warning is on by default and\n        // people have been given a chance to fix them.  As is, this is here\n        // simply for legacy casts.\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.isGetProp() ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n",
        "begin_line": 1967,
        "end_line": 1995,
        "comment": "\n   * Enforces type casts, and ensures the node is typed.\n   *\n   * A cast in the way that we use it in JSDoc annotations never\n   * alters the generated code and therefore never can induce any runtime\n   * operation. What this means is that a 'cast' is really just a compile\n   * time constraint on the underlying value. In the future, we may add\n   * support for run-time casts for compiled tests.\n   *\n   * To ensure some shred of sanity, we enforce the notion that the\n   * type you are casting to may only meaningfully be a narrower type\n   * than the underlying declared type. We also invalidate optimizations\n   * on bad type casts.\n   *\n   * @param t The traversal object needed to report errors.\n   * @param n The node getting a type assigned to it.\n   * @param type The type to be assigned.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isObjectCallMethod#1989",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isObjectCallMethod(com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "  static boolean isObjectCallMethod(Node callNode, String methodName) {\n    if (callNode.isCall()) {\n      Node functionIndentifyingExpression = callNode.getFirstChild();\n      if (isGet(functionIndentifyingExpression)) {\n        Node last = functionIndentifyingExpression.getLastChild();\n        if (last != null && last.isString()) {\n          String propName = last.getString();\n          return (propName.equals(methodName));\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 1989,
        "end_line": 2001,
        "comment": "\n   * @return Whether node is a call to methodName.\n   *    a.f(...)\n   *    a['f'](...)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getBestLValue#3077",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValue(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parent.isName()) {\n      return parent;\n    } else if (parent.isAssign()) {\n      return parent.getFirstChild();\n    } else if (isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    } else if (\n        (parent.isHook() && parent.getFirstChild() != n) ||\n        parent.isOr() ||\n        parent.isAnd() ||\n        (parent.isComma() && parent.getFirstChild() != n)) {\n      return getBestLValue(parent);\n    } else if (parent.isCast()) {\n      return getBestLValue(parent);\n    }\n    return null;\n  }\n",
        "begin_line": 3077,
        "end_line": 3098,
        "comment": " Find the l-value that the given r-value is being assigned to. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0581
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConstCheck.isConstant#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ConstCheck.java",
        "class_name": "com.google.javascript.jscomp.ConstCheck",
        "signature": "com.google.javascript.jscomp.ConstCheck.isConstant(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  private boolean isConstant(Scope.Var var) {\n    return var != null && var.isConst();\n  }\n",
        "begin_line": 123,
        "end_line": 125,
        "comment": "\n   * Gets whether a variable is a constant initialized to a literal value at\n   * the point where it is declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0579
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.getSideEffectFlags#2001",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getSideEffectFlags()",
        "snippet": "  public int getSideEffectFlags() {\n    return getIntProp(SIDE_EFFECT_FLAGS);\n  }\n",
        "begin_line": 2001,
        "end_line": 2003,
        "comment": "\n   * Returns the side effects flags for this node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0577
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.isNoSideEffectsCall#2088",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isNoSideEffectsCall()",
        "snippet": "  public boolean isNoSideEffectsCall() {\n    return areBitFlagsSet(getSideEffectFlags(), NO_SIDE_EFFECTS);\n  }\n",
        "begin_line": 2088,
        "end_line": 2090,
        "comment": "\n   * Returns true if this node is a function or constructor call that\n   * has no side effects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0577
        },
        "num_failing_tests": 2
    },
    {
        "name": "Node.areBitFlagsSet#2104",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.areBitFlagsSet(int, int)",
        "snippet": "  private boolean areBitFlagsSet(int value, int flags) {\n    return (value & flags) == flags;\n  }\n",
        "begin_line": 2104,
        "end_line": 2106,
        "comment": "\n   * returns true if all the flags are set in value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0577
        },
        "num_failing_tests": 2
    },
    {
        "name": "Property.getJSDocInfo#130",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.getJSDocInfo()",
        "snippet": "  @Override public JSDocInfo getJSDocInfo() {\n    return this.docInfo;\n  }\n",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.getConstructor#526",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.Anonymous-bc7c5e57-8070-4b05-abaf-deb1a8bd43b8.getConstructor()",
        "snippet": "          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n",
        "begin_line": 526,
        "end_line": 529,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.isImplicitCast#590",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.isImplicitCast()",
        "snippet": "  public boolean isImplicitCast() {\n    return getFlag(MASK_IMPLICITCAST);\n  }\n",
        "begin_line": 590,
        "end_line": 592,
        "comment": "\n   * Returns whether the {@code @implicitCast} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.setShouldReport#156",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.setShouldReport(boolean)",
        "snippet": "  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }\n",
        "begin_line": 156,
        "end_line": 158,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectNotNullOrUndefined#256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectNotNullOrUndefined(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
        "begin_line": 256,
        "end_line": 282,
        "comment": "\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.TypeCheck#315",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.MemoizedScopeCreator, com.google.javascript.jscomp.CheckLevel, com.google.javascript.jscomp.CheckLevel)",
        "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      MemoizedScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }\n",
        "begin_line": 315,
        "end_line": 331,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.reportMissingProperties#350",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.reportMissingProperties(boolean)",
        "snippet": "  TypeCheck reportMissingProperties(boolean report) {\n    reportMissingProperties = report;\n    return this;\n  }\n",
        "begin_line": 350,
        "end_line": 353,
        "comment": " Turn on the missing property check. Returns this for easy chaining. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.process#362",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }\n",
        "begin_line": 362,
        "end_line": 376,
        "comment": "\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.check#399",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.check(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }\n",
        "begin_line": 399,
        "end_line": 410,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkNoTypeCheckSection#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkNoTypeCheckSection(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }\n",
        "begin_line": 413,
        "end_line": 431,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitName#1344",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.PARAM_LIST ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n",
        "begin_line": 1344,
        "end_line": 1373,
        "comment": "\n   * Visits a NAME node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   * @return whether the node is typeable or not\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.visitGetProp#1383",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.visitGetProp(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n",
        "begin_line": 1383,
        "end_line": 1399,
        "comment": "\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkPropertyAccess#1408",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyAccess(com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    // If the property type is unknown, check the object type to see if it\n    // can ever be defined. We explicitly exclude CHECKED_UNKNOWN (for\n    // properties where we've checked that it exists, or for properties on\n    // objects that aren't in this binary).\n    JSType propType = getJSType(n);\n    if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n      childType = childType.autobox();\n      ObjectType objectType = ObjectType.cast(childType);\n      if (objectType != null) {\n        // We special-case object types so that checks on enums can be\n        // much stricter, and so that we can use hasProperty (which is much\n        // faster in most cases).\n        if (!objectType.hasProperty(propName) ||\n            objectType.isEquivalentTo(\n                typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n          if (objectType instanceof EnumType) {\n            report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n          } else {\n            checkPropertyAccessHelper(objectType, propName, t, n);\n          }\n        }\n\n      } else {\n        checkPropertyAccessHelper(childType, propName, t, n);\n      }\n    }\n  }\n",
        "begin_line": 1408,
        "end_line": 1436,
        "comment": "\n   * Emit a warning if we can prove that a property cannot possibly be\n   * defined on an object. Note the difference between JS and a strictly\n   * statically typed language: we're checking if the property\n   * *cannot be defined*, whereas a java compiler would check if the\n   * property *can be undefined*.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.checkEnumAlias#1895",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.checkEnumAlias(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "  private void checkEnumAlias(\n      NodeTraversal t, JSDocInfo declInfo, Node value) {\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\n      return;\n    }\n\n    JSType valueType = getJSType(value);\n    if (!valueType.isEnumType()) {\n      return;\n    }\n\n    EnumType valueEnumType = valueType.toMaybeEnumType();\n    JSType valueEnumPrimitiveType =\n        valueEnumType.getElementsType().getPrimitiveType();\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\n        \"incompatible enum element types\");\n  }\n",
        "begin_line": 1895,
        "end_line": 1912,
        "comment": "\n   * <p>Checks enum aliases.\n   *\n   * <p>We verify that the enum element type of the enum used\n   * for initialization is a subtype of the enum element type of\n   * the enum the value is being copied in.</p>\n   *\n   * <p>Example:</p>\n   * <pre>var myEnum = myOtherEnum;</pre>\n   *\n   * <p>Enum aliases are irregular, so we need special code for this :(</p>\n   *\n   * @param value the value used for initialization of the enum\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.getJSType#1918",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.getJSType(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n",
        "begin_line": 1918,
        "end_line": 1929,
        "comment": "\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.ensureTyped#1941",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }\n",
        "begin_line": 1941,
        "end_line": 1943,
        "comment": "\n   * Ensure that the given node has a type. If it does not have one,\n   * attach the UNKNOWN_TYPE.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.ensureTyped#1945",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }\n",
        "begin_line": 1945,
        "end_line": 1947,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.getTypedPercent#2001",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.getTypedPercent()",
        "snippet": "  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;\n  }\n",
        "begin_line": 2001,
        "end_line": 2004,
        "comment": "\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeCheck.getNativeType#2006",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeCheck.java",
        "class_name": "com.google.javascript.jscomp.TypeCheck",
        "signature": "com.google.javascript.jscomp.TypeCheck.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n",
        "begin_line": 2006,
        "end_line": 2008,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "PassConfig.makeTypeCheck#172",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.makeTypeCheck(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  final TypeCheck makeTypeCheck(AbstractCompiler compiler) {\n    return new TypeCheck(\n        compiler,\n        compiler.getReverseAbstractInterpreter(),\n        compiler.getTypeRegistry(),\n        topScope,\n        typedScopeCreator,\n        options.reportMissingOverride,\n        options.reportUnknownTypes)\n        .reportMissingProperties(options.enables(\n            DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY)));\n  }\n",
        "begin_line": 172,
        "end_line": 183,
        "comment": "\n   * Create a type-checking pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getFunctionJSDocInfo#2843",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionJSDocInfo(com.google.javascript.rhino.Node)",
        "snippet": "  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.isFunction());\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.isName()) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }\n",
        "begin_line": 2843,
        "end_line": 2858,
        "comment": "\n   * Get the JSDocInfo for a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "NameGenerator.generateNextName#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NameGenerator.java",
        "class_name": "com.google.javascript.jscomp.NameGenerator",
        "signature": "com.google.javascript.jscomp.NameGenerator.generateNextName()",
        "snippet": "  String generateNextName() {\n    while (true) {\n      String name = prefix;\n\n      int i = nameCount;\n\n      if (name.isEmpty()) {\n        int pos = i % firstChars.length;\n        name += firstChars[pos];\n        i /= firstChars.length;\n      }\n\n      while (i > 0) {\n        i--;\n        int pos = i % nonFirstChars.length;\n        name += nonFirstChars[pos];\n        i /= nonFirstChars.length;\n      }\n\n      nameCount++;\n\n      // Make sure it's not a JS keyword or reserved name.\n      if (TokenStream.isKeyword(name) || reservedNames.contains(name)) {\n        continue;\n      }\n\n      return name;\n    }\n  }\n",
        "begin_line": 119,
        "end_line": 147,
        "comment": "\n   * Generates the next short name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.setDeclaredType#1096",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.Name.setDeclaredType()",
        "snippet": "    void setDeclaredType() {\n      declaredType = true;\n      for (Name ancestor = parent; ancestor != null;\n           ancestor = ancestor.parent) {\n        ancestor.hasDeclaredTypeDescendant = true;\n      }\n    }\n",
        "begin_line": 1096,
        "end_line": 1102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1188",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-84e77ce4-3ed9-4c79-8500-27fb82cd5f8a.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n      return new HotSwapCompilerPass() {\n        @Override\n        public void process(Node externs, Node root) {\n          Preconditions.checkNotNull(topScope);\n          Preconditions.checkNotNull(getTypedScopeCreator());\n\n          TypeCheck check = makeTypeCheck(compiler);\n          check.process(externs, root);\n          compiler.getErrorManager().setTypedPercent(check.getTypedPercent());\n        }\n        @Override\n        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n          makeTypeCheck(compiler).check(scriptRoot, false);\n        }\n      };\n    }\n",
        "begin_line": 1188,
        "end_line": 1205,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.process#1191",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-9f81849b-5b5c-4b9a-bb04-25bd26614ff0.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node root) {\n          Preconditions.checkNotNull(topScope);\n          Preconditions.checkNotNull(getTypedScopeCreator());\n\n          TypeCheck check = makeTypeCheck(compiler);\n          check.process(externs, root);\n          compiler.getErrorManager().setTypedPercent(check.getTypedPercent());\n        }\n",
        "begin_line": 1191,
        "end_line": 1199,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "BasicErrorManager.setTypedPercent#94",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.setTypedPercent(double)",
        "snippet": "  @Override\n  public void setTypedPercent(double typedPercent) {\n    this.typedPercent = typedPercent;\n  }\n",
        "begin_line": 94,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0574
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.exprResult#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.exprResult(com.google.javascript.rhino.Node)",
        "snippet": "  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n",
        "begin_line": 174,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getStringValue#176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getStringValue(com.google.javascript.rhino.Node)",
        "snippet": "  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.STRING_KEY:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n        return \"false\";\n\n      case Token.TRUE:\n        return \"true\";\n\n      case Token.NULL:\n        return \"null\";\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }\n",
        "begin_line": 176,
        "end_line": 221,
        "comment": "\n   * Gets the value of a node as a String, or null if it cannot be converted.\n   * When it returns a non-null String, this method effectively emulates the\n   * <code>String()</code> JavaScript cast function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.isInlineableDeclaredConstant#454",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isInlineableDeclaredConstant(com.google.javascript.jscomp.Scope.Var, com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection)",
        "snippet": "    private boolean isInlineableDeclaredConstant(Var var,\n        ReferenceCollection refInfo) {\n      if (!identifyConstants.apply(var)) {\n        return false;\n      }\n\n      if (!refInfo.isAssignedOnceInLifetime()) {\n        return false;\n      }\n\n      Reference init = refInfo.getInitializingReferenceForConstants();\n      if (init == null) {\n        return false;\n      }\n\n      Node value = init.getAssignedValue();\n      if (value == null) {\n        // This constant is either externally defined or initialized indirectly\n        // (e.g. in an function expression used to hide\n        // temporary variables), so the constant is ineligible for inlining.\n        return false;\n      }\n\n      // Is the constant's value immutable?\n      if (!NodeUtil.isImmutableValue(value)) {\n        return false;\n      }\n\n      // Determine if we should really inline a String or not.\n      return !value.isString() ||\n          isStringWorthInlining(var, refInfo.references);\n    }\n",
        "begin_line": 454,
        "end_line": 485,
        "comment": "\n     * Determines whether the given variable is declared as a constant\n     * and may be inlined.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.isValidDeclaration#637",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.InliningBehavior.isValidDeclaration(com.google.javascript.jscomp.ReferenceCollectingCallback.Reference)",
        "snippet": "    private boolean isValidDeclaration(Reference declaration) {\n      return (declaration.getParent().isVar()\n          && !declaration.getGrandparent().isFor())\n          || NodeUtil.isFunctionDeclaration(declaration.getParent());\n    }\n",
        "begin_line": 637,
        "end_line": 641,
        "comment": "\n     * @return true if the reference is a normal VAR or FUNCTION declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0566
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryFoldLiteralConstructor#1367",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryFoldLiteralConstructor(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.isCall()\n        || n.isNew());\n\n    Node constructorNameNode = n.getFirstChild();\n\n    Node newLiteralNode = null;\n\n    // We require the AST to be normalized to ensure that, say,\n    // Object() really refers to the built-in Object constructor\n    // and not a user-defined constructor with the same name.\n\n    if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {\n\n      String className = constructorNameNode.getString();\n\n      if (\"RegExp\".equals(className)) {\n        // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n        return tryFoldRegularExpressionConstructor(n);\n      } else {\n        boolean constructorHasArgs = constructorNameNode.getNext() != null;\n\n        if (\"Object\".equals(className) && !constructorHasArgs) {\n          // \"Object()\" --> \"{}\"\n          newLiteralNode = IR.objectlit();\n        } else if (\"Array\".equals(className)) {\n          // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n          Node arg0 = constructorNameNode.getNext();\n          FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);\n\n          if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n              action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n            newLiteralNode = IR.arraylit();\n            n.removeChildren();\n            if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n              newLiteralNode.addChildrenToFront(arg0);\n            }\n          }\n        }\n\n        if (newLiteralNode != null) {\n          n.getParent().replaceChild(n, newLiteralNode);\n          reportCodeChange();\n          return newLiteralNode;\n        }\n      }\n    }\n    return n;\n  }\n",
        "begin_line": 1367,
        "end_line": 1415,
        "comment": "\n   * Replaces a new Array or Object node with an object literal, unless the\n   * call to Array or Object is to a local function with the same name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeReplaceKnownMethods.tryFoldKnownNumericMethods#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
        "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.tryFoldKnownNumericMethods(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldKnownNumericMethods(Node subtree) {\n    Preconditions.checkArgument(subtree.isCall());\n\n    if (isASTNormalized()) {\n      // check if this is a call on a string method\n      // then dispatch to specific folding method.\n      Node callTarget = subtree.getFirstChild();\n\n      if (!callTarget.isName()) {\n        return subtree;\n      }\n\n      String functionNameString = callTarget.getString();\n      Node firstArgument = callTarget.getNext();\n      if ((firstArgument != null) &&\n          (firstArgument.isString() ||\n           firstArgument.isNumber())) {\n        if (functionNameString.equals(\"parseInt\") ||\n            functionNameString.equals(\"parseFloat\")) {\n          subtree = tryFoldParseNumber(subtree, functionNameString,\n              firstArgument);\n        }\n      }\n    }\n    return subtree;\n  }\n",
        "begin_line": 137,
        "end_line": 162,
        "comment": "\n   * Try to evaluate known Numeric methods\n   *    .parseInt(), parseFloat()\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "PassConfig.clearTypedScope#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.clearTypedScope()",
        "snippet": "  void clearTypedScope() {\n    internalScopeCreator = null;\n    typedScopeCreator = null;\n    topScope = null;\n  }\n",
        "begin_line": 71,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isFunctionObjectCall#2009",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionObjectCall(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isFunctionObjectCall(Node callNode) {\n    return isObjectCallMethod(callNode, \"call\");\n  }\n",
        "begin_line": 2009,
        "end_line": 2011,
        "comment": "\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.call(...)\n   *    x['call'](...)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.process#1270",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.ClearTypedScope.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      clearTypedScope();\n    }\n",
        "begin_line": 1270,
        "end_line": 1273,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-abd49b83-87d1-4229-bf9f-eda4f1ac8130.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected CompilerPass create(AbstractCompiler compiler) {\n      return new ClearTypedScope();\n    }\n",
        "begin_line": 1138,
        "end_line": 1141,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "CreateSyntheticBlocks.visit#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CreateSyntheticBlocks.java",
        "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks",
        "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks.Callback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall() || !n.getFirstChild().isName()) {\n        return;\n      }\n\n      Node callTarget = n.getFirstChild();\n      String callName = callTarget.getString();\n\n      if (startMarkerName.equals(callName)) {\n        if (!parent.isExprResult()) {\n          compiler.report(\n              t.makeError(n, INVALID_MARKER_USAGE, startMarkerName));\n          return;\n        }\n        markerStack.push(parent);\n        return;\n      }\n\n      if (!endMarkerName.equals(callName)) {\n        return;\n      }\n\n      Node endMarkerNode = parent;\n      if (!endMarkerNode.isExprResult()) {\n        compiler.report(\n            t.makeError(n, INVALID_MARKER_USAGE, endMarkerName));\n        return;\n      }\n\n      if (markerStack.isEmpty()) {\n        compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n            startMarkerName, endMarkerName));\n        return;\n      }\n\n      Node startMarkerNode = markerStack.pop();\n      if (endMarkerNode.getParent() != startMarkerNode.getParent()) {\n        // The end marker isn't in the same block as the start marker.\n        compiler.report(t.makeError(n, UNMATCHED_END_MARKER,\n            startMarkerName, endMarkerName));\n        return;\n      }\n\n      // This is a valid marker set add it to the list of markers to process.\n      validMarkers.add(new Marker(startMarkerNode, endMarkerNode));\n    }\n",
        "begin_line": 169,
        "end_line": 215,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0559
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.isConst#213",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isConst()",
        "snippet": "    public boolean isConst() {\n      return nameNode != null && NodeUtil.isConstantName(nameNode);\n    }\n",
        "begin_line": 213,
        "end_line": 215,
        "comment": "\n     * Returns {@code true} if the variable is declared as a constant,\n     * based on the value reported by {@code NodeUtil}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0557
        },
        "num_failing_tests": 2
    },
    {
        "name": "VarCheck.createSynthesizedExternVar#209",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.createSynthesizedExternVar(java.lang.String)",
        "snippet": "  private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n\n    getSynthesizedExternsRoot().addChildToBack(\n        IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n    compiler.reportCodeChange();\n  }\n",
        "begin_line": 209,
        "end_line": 226,
        "comment": "\n   * Create a new variable in a synthetic script. This will prevent\n   * subsequent compiler passes from crashing.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 1
    },
    {
        "name": "VarCheck.getSynthesizedExternsInput#267",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.getSynthesizedExternsInput()",
        "snippet": "  private CompilerInput getSynthesizedExternsInput() {\n    return compiler.getSynthesizedExternsInput();\n  }\n",
        "begin_line": 267,
        "end_line": 269,
        "comment": " Lazily create a \"new\" externs input for undeclared variables. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 1
    },
    {
        "name": "VarCheck.getSynthesizedExternsRoot#272",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/VarCheck.java",
        "class_name": "com.google.javascript.jscomp.VarCheck",
        "signature": "com.google.javascript.jscomp.VarCheck.getSynthesizedExternsRoot()",
        "snippet": "  private Node getSynthesizedExternsRoot() {\n    if (synthesizedExternsRoot == null) {\n      CompilerInput synthesizedExterns = getSynthesizedExternsInput();\n      synthesizedExternsRoot = synthesizedExterns.getAstRoot(compiler);\n    }\n    return synthesizedExternsRoot;\n  }\n",
        "begin_line": 272,
        "end_line": 278,
        "comment": " Lazily create a \"new\" externs root for undeclared variables. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnionType.autobox#197",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.autobox()",
        "snippet": "  @Override\n  public JSType autobox() {\n    UnionTypeBuilder restricted = new UnionTypeBuilder(registry);\n    for (JSType t : alternates) {\n      restricted.addAlternate(t.autobox());\n    }\n    return restricted.build();\n  }\n",
        "begin_line": 197,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "StringType.autoboxesTo#100",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/StringType.java",
        "class_name": "com.google.javascript.rhino.jstype.StringType",
        "signature": "com.google.javascript.rhino.jstype.StringType.autoboxesTo()",
        "snippet": "  @Override\n  public JSType autoboxesTo() {\n    return getNativeType(JSTypeNative.STRING_OBJECT_TYPE);\n  }\n",
        "begin_line": 100,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrototypeObjectType.setPropertyJSDocInfo#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPropertyJSDocInfo(java.lang.String, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  @Override\n  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (properties.getOwnProperty(propertyName) == null) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.getOwnProperty(propertyName);\n      if (property != null) {\n        property.setJSDocInfo(info);\n      }\n    }\n  }\n",
        "begin_line": 152,
        "end_line": 170,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrototypeObjectType.getCtorImplementedInterfaces#399",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorImplementedInterfaces()",
        "snippet": "  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getImplementedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n",
        "begin_line": 399,
        "end_line": 404,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "Property.setNode#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setNode(com.google.javascript.rhino.Node)",
        "snippet": "  public void setNode(Node n) {\n    this.propertyNode = n;\n  }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.clearCachedValues#598",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.clearCachedValues()",
        "snippet": "  public void clearCachedValues() {\n    unknown = true;\n  }\n",
        "begin_line": 598,
        "end_line": 600,
        "comment": "\n   * Clear cached values. Should be called before making changes to a prototype\n   * that may have been changed since creation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "NullType.restrictByNotNullOrUndefined#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/NullType.java",
        "class_name": "com.google.javascript.rhino.jstype.NullType",
        "signature": "com.google.javascript.rhino.jstype.NullType.restrictByNotNullOrUndefined()",
        "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    return registry.getNativeType(JSTypeNative.NO_TYPE);\n  }\n",
        "begin_line": 82,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.shouldTolerateUndefinedValues#228",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.shouldTolerateUndefinedValues()",
        "snippet": "  public boolean shouldTolerateUndefinedValues() {\n    return tolerateUndefinedValues;\n  }\n",
        "begin_line": 228,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.declareType#837",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.declareType(java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public boolean declareType(String name, JSType t) {\n    if (namesToTypes.containsKey(name)) {\n      return false;\n    }\n    register(t, name);\n    return true;\n  }\n",
        "begin_line": 837,
        "end_line": 843,
        "comment": "\n   * Records declared global type names. This makes resolution faster\n   * and more robust in the common case.\n   *\n   * @param name The name of the type to be recorded.\n   * @param t The actual type being associated with the name.\n   * @return True if this name is not already defined, false otherwise.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createDefaultObjectUnion#983",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createDefaultObjectUnion(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public JSType createDefaultObjectUnion(JSType type) {\n    if (type.isTemplateType()) {\n      // Template types represent the substituted type exactly and should\n      // not be wrapped.\n      return type;\n    } else {\n      return shouldTolerateUndefinedValues()\n        ? createOptionalNullableType(type)\n        : createNullableType(type);\n    }\n  }\n",
        "begin_line": 983,
        "end_line": 993,
        "comment": "\n   * Creates a type representing nullable values of the given type.\n   * @return the union of the type and the Null type\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createConstructorType#1422",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createConstructorType(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, com.google.common.collect.ImmutableList<java.lang.String>)",
        "snippet": "  public FunctionType createConstructorType(String name, Node source,\n      Node parameters, JSType returnType, ImmutableList<String> templateKeys) {\n    return new FunctionType(this, name, source,\n        createArrowType(parameters, returnType), null,\n        templateKeys, true, false);\n  }\n",
        "begin_line": 1422,
        "end_line": 1427,
        "comment": "\n   * Creates a constructor function type.\n   * @param name the function's name or {@code null} to indicate that the\n   *     function is anonymous.\n   * @param source the node defining this function. Its type\n   *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n   * @param parameters the function's parameters or {@code null}\n   *     to indicate that the parameter types are unknown.\n   * @param returnType the function's return type or {@code null} to indicate\n   *     that the return type is unknown.\n   * @param templateKeys the templatized type keys for the class.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.setTemplateTypeNames#1738",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.setTemplateTypeNames(java.util.List<java.lang.String>)",
        "snippet": "  public void setTemplateTypeNames(List<String> names) {\n    Preconditions.checkNotNull(names);\n    for (String name : names) {\n      templateTypes.put(name, new TemplateType(this, name));\n    }\n  }\n",
        "begin_line": 1738,
        "end_line": 1743,
        "comment": "\n   * Sets the template type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.clearTemplateTypeNames#1748",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.clearTemplateTypeNames()",
        "snippet": "  public void clearTemplateTypeNames() {\n    templateTypes.clear();\n  }\n",
        "begin_line": 1748,
        "end_line": 1750,
        "comment": "\n   * Clears the template type name.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isCheckedUnknownType#285",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isCheckedUnknownType()",
        "snippet": "  public boolean isCheckedUnknownType() {\n    return false;\n  }\n",
        "begin_line": 285,
        "end_line": 287,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isStruct#297",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isStruct()",
        "snippet": "  public boolean isStruct() {\n    if (isObject()) {\n      ObjectType objType = toObjectType();\n      ObjectType iproto = objType.getImplicitPrototype();\n      // For the case when a @struct constructor is assigned to a function's\n      // prototype property\n      if (iproto != null && iproto.isStruct()) {\n        return true;\n      }\n      FunctionType ctor = objType.getConstructor();\n      // This test is true for object literals\n      if (ctor == null) {\n        JSDocInfo info = objType.getJSDocInfo();\n        return info != null && info.makesStructs();\n      } else {\n        return ctor.makesStructs();\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 297,
        "end_line": 316,
        "comment": "\n   * Returns true iff {@code this} can be a {@code struct}.\n   * UnionType overrides the method, assume {@code this} is not a union here.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isEnumType#396",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isEnumType()",
        "snippet": "  public boolean isEnumType() {\n    return toMaybeEnumType() != null;\n  }\n",
        "begin_line": 396,
        "end_line": 398,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.toMaybeEnumType#403",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeEnumType()",
        "snippet": "  public EnumType toMaybeEnumType() {\n    return null;\n  }\n",
        "begin_line": 403,
        "end_line": 405,
        "comment": "\n   * Downcasts this to an EnumType, or returns null if this is not an EnumType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isTemplateType#442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isTemplateType()",
        "snippet": "  public final boolean isTemplateType() {\n    return toMaybeTemplateType() != null;\n  }\n",
        "begin_line": 442,
        "end_line": 444,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.toMaybeTemplateType#450",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeTemplateType()",
        "snippet": "  public TemplateType toMaybeTemplateType() {\n    return null;\n  }\n",
        "begin_line": 450,
        "end_line": 452,
        "comment": "\n   * Downcasts this to a TemplateType, or returns null if this is not\n   * a function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isConstructor#562",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isConstructor()",
        "snippet": "  public boolean isConstructor() {\n    return false;\n  }\n",
        "begin_line": 562,
        "end_line": 564,
        "comment": "\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.isInterface#610",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.isInterface()",
        "snippet": "  public boolean isInterface() {\n    return false;\n  }\n",
        "begin_line": 610,
        "end_line": 612,
        "comment": "\n   * Whether this type is a {@link FunctionType} that is an interface or a named\n   * type that points to such a type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.makesStructs#209",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.makesStructs()",
        "snippet": "  public boolean makesStructs() {\n    if (!isConstructor()) {\n      return false;\n    }\n    if (propAccess == PropAccess.STRUCT) {\n      return true;\n    }\n    FunctionType superc = getSuperClassConstructor();\n    if (superc != null && superc.makesStructs()) {\n      setStruct();\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 209,
        "end_line": 222,
        "comment": "\n   * When a class B inherits from A and A is annotated as a struct, then B\n   * automatically gets the annotation, even if B's constructor is not\n   * explicitly annotated.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getParametersNode#284",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getParametersNode()",
        "snippet": "  public Node getParametersNode() {\n    return call.parameters;\n  }\n",
        "begin_line": 284,
        "end_line": 286,
        "comment": " Gets an LP node that contains all params. May be null. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getSlot#333",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getSlot(String name) {\n    if (\"prototype\".equals(name)) {\n      // Lazy initialization of the prototype field.\n      getPrototype();\n      return prototypeSlot;\n    } else {\n      return super.getSlot(name);\n    }\n  }\n",
        "begin_line": 333,
        "end_line": 342,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getImplementedInterfaces#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getImplementedInterfaces()",
        "snippet": "  public Iterable<ObjectType> getImplementedInterfaces() {\n    FunctionType superCtor = isConstructor() ?\n        getSuperClassConstructor() : null;\n    if (superCtor == null) {\n      return implementedInterfaces;\n    } else {\n      return Iterables.concat(\n          implementedInterfaces, superCtor.getImplementedInterfaces());\n    }\n  }\n",
        "begin_line": 509,
        "end_line": 518,
        "comment": " Returns interfaces implemented directly by a class or its superclass. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.getPropertyType#584",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.getPropertyType(java.lang.String)",
        "snippet": "  @Override\n  public JSType getPropertyType(String name) {\n    if (!hasOwnProperty(name)) {\n      // Define the \"call\", \"apply\", and \"bind\" functions lazily.\n      boolean isCall = \"call\".equals(name);\n      boolean isBind = \"bind\".equals(name);\n      if (isCall || isBind) {\n        defineDeclaredProperty(name, getCallOrBindSignature(isCall), source);\n      } else if (\"apply\".equals(name)) {\n        // Define the \"apply\" function lazily.\n        FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n\n        // ECMA-262 says that apply's second argument must be an Array\n        // or an arguments object. We don't model the arguments object,\n        // so let's just be forgiving for now.\n        // TODO(nicksantos): Model the Arguments object.\n        builder.addOptionalParams(\n            registry.createNullableType(getTypeOfThis()),\n            registry.createNullableType(\n                registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n\n        defineDeclaredProperty(name,\n            new FunctionBuilder(registry)\n            .withParams(builder)\n            .withReturnType(getReturnType())\n            .withTemplateKeys(getTemplateKeys())\n            .build(),\n            source);\n      }\n    }\n\n    return super.getPropertyType(name);\n  }\n",
        "begin_line": 584,
        "end_line": 616,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.clearCachedValues#1123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.clearCachedValues()",
        "snippet": "  @Override\n  public void clearCachedValues() {\n    super.clearCachedValues();\n\n    if (subTypes != null) {\n      for (FunctionType subType : subTypes) {\n        subType.clearCachedValues();\n      }\n    }\n\n    if (!isNativeObjectType()) {\n      if (hasInstanceType()) {\n        getInstanceType().clearCachedValues();\n      }\n\n      if (prototypeSlot != null) {\n        ((ObjectType) prototypeSlot.getType()).clearCachedValues();\n      }\n    }\n  }\n",
        "begin_line": 1123,
        "end_line": 1142,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withName#70",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withName(java.lang.String)",
        "snippet": "  public FunctionBuilder withName(String name) {\n    this.name = name;\n    return this;\n  }\n",
        "begin_line": 70,
        "end_line": 73,
        "comment": " Set the name of the function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withSourceNode#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withSourceNode(com.google.javascript.rhino.Node)",
        "snippet": "  public FunctionBuilder withSourceNode(Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }\n",
        "begin_line": 76,
        "end_line": 79,
        "comment": " Set the source node of the function type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withReturnType#102",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n    this.returnType = returnType;\n    this.inferredReturnType = inferred;\n    return this;\n  }\n",
        "begin_line": 102,
        "end_line": 106,
        "comment": " Set the return type and whether it's inferred. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withTypeOfThis#116",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTypeOfThis(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public FunctionBuilder withTypeOfThis(JSType typeOfThis) {\n    this.typeOfThis = typeOfThis;\n    return this;\n  }\n",
        "begin_line": 116,
        "end_line": 119,
        "comment": " Set the \"this\" type. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionBuilder.withTemplateKeys#122",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionBuilder.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
        "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTemplateKeys(com.google.common.collect.ImmutableList<java.lang.String>)",
        "snippet": "  public FunctionBuilder withTemplateKeys(\n      ImmutableList<String> templateKeys) {\n    this.templateKeys = templateKeys;\n    return this;\n  }\n",
        "begin_line": 122,
        "end_line": 126,
        "comment": " Set the template name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.makesStructs#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.makesStructs()",
        "snippet": "  public boolean makesStructs() {\n    return getFlag(MASK_STRUCT);\n  }\n",
        "begin_line": 477,
        "end_line": 479,
        "comment": "\n   * Returns whether the {@code @struct} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.makesDicts#485",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.makesDicts()",
        "snippet": "  public boolean makesDicts() {\n    return getFlag(MASK_DICT);\n  }\n",
        "begin_line": 485,
        "end_line": 487,
        "comment": "\n   * Returns whether the {@code @dict} annotation is present on this\n   * {@link JSDocInfo}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getImplementedInterfaceCount#1293",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaceCount()",
        "snippet": "  public int getImplementedInterfaceCount() {\n    if (info == null || info.implementedInterfaces == null) {\n      return 0;\n    }\n    return info.implementedInterfaces.size();\n  }\n",
        "begin_line": 1293,
        "end_line": 1298,
        "comment": "\n   * Gets the number of interfaces specified by the {@code @implements}\n   * annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getTemplateTypeNames#1464",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getTemplateTypeNames()",
        "snippet": "  public ImmutableList<String> getTemplateTypeNames() {\n    if (info == null || info.templateTypeNames == null) {\n      return ImmutableList.of();\n    }\n    return info.templateTypeNames;\n  }\n",
        "begin_line": 1464,
        "end_line": 1469,
        "comment": " Gets the template type name. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.LocalScopeBuilder#1871",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.LocalScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private LocalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n",
        "begin_line": 1871,
        "end_line": 1873,
        "comment": "\n     * @param scope The scope that we're building.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.build#1878",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.build()",
        "snippet": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents != null) {\n        for (String varName : contents.getEscapedVarNames()) {\n          Var v = scope.getVar(varName);\n          Preconditions.checkState(v.getScope() == scope);\n          v.markEscaped();\n        }\n\n        for (Multiset.Entry<String> entry :\n                 contents.getAssignedNameCounts().entrySet()) {\n          Var v = scope.getVar(entry.getElement());\n          Preconditions.checkState(v.getScope() == scope);\n          if (entry.getCount() == 1) {\n            v.markAssignedExactlyOnce();\n          }\n        }\n      }\n    }\n",
        "begin_line": 1878,
        "end_line": 1899,
        "comment": "\n     * Traverse the scope root and build it.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.visit#1909",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.isParamList() && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }\n",
        "begin_line": 1909,
        "end_line": 1918,
        "comment": "\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.handleFunctionInputs#1921",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.handleFunctionInputs(com.google.javascript.rhino.Node)",
        "snippet": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n",
        "begin_line": 1921,
        "end_line": 1940,
        "comment": " Handle bleeding functions and function parameters. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.declareArguments#1945",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.LocalScopeBuilder.declareArguments(com.google.javascript.rhino.Node)",
        "snippet": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node iifeArgumentNode = null;\n\n      if (NodeUtil.isCallOrNewTarget(functionNode)) {\n        iifeArgumentNode = functionNode.getNext();\n      }\n\n      Node body = astParameters.getNext();\n      FunctionType functionType =\n          JSType.toMaybeFunctionType(functionNode.getJSType());\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            JSType paramType = jsDocParameter == null ?\n                unknownType : jsDocParameter.getJSType();\n            boolean inferred = paramType == null || paramType == unknownType;\n\n            if (iifeArgumentNode != null && inferred) {\n              String argumentName = iifeArgumentNode.getQualifiedName();\n              Var argumentVar =\n                  argumentName == null || scope.getParent() == null\n                  ? null : scope.getParent().getVar(argumentName);\n              if (argumentVar != null && !argumentVar.isTypeInferred()) {\n                paramType = argumentVar.getType();\n              }\n            }\n\n            if (paramType == null) {\n              paramType = unknownType;\n            }\n\n            defineSlot(astParameter, functionNode, paramType, inferred);\n\n            if (jsDocParameter != null) {\n              jsDocParameter = jsDocParameter.getNext();\n            }\n            if (iifeArgumentNode != null) {\n              iifeArgumentNode = iifeArgumentNode.getNext();\n            }\n          }\n        }\n      }\n    } // end declareArguments\n",
        "begin_line": 1945,
        "end_line": 1990,
        "comment": "\n     * Declares all of a function's arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.enterScope#2017",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override public void enterScope(NodeTraversal t) {\n      if (!t.inGlobalScope()) {\n        Node n = t.getScopeRoot();\n        data.put(n, new AstFunctionContents(n));\n      }\n    }\n",
        "begin_line": 2017,
        "end_line": 2022,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.visit#2024",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }\n",
        "begin_line": 2024,
        "end_line": 2075,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.visit#365",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      Node nameNode = null;\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, child.getFirstChild(),\n                NodeUtil.getBestJSDocInfo(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.isAssign()) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getLastChild(),\n                firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, null, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 365,
        "end_line": 389,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.shouldTraverse#481",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      inputId = t.getInputId();\n      if (n.isFunction() ||\n          n.isScript()) {\n        Preconditions.checkNotNull(inputId);\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }\n",
        "begin_line": 481,
        "end_line": 510,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.getDeclaredTypeInAnnotation#708",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getDeclaredTypeInAnnotation(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode =\n          node.isGetProp() ? node.getFirstChild() :\n          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n          null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }\n",
        "begin_line": 708,
        "end_line": 725,
        "comment": "\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineFunctionLiteral#770",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineFunctionLiteral(com.google.javascript.rhino.Node)",
        "snippet": "    void defineFunctionLiteral(Node n) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and l-value for the function.\n      // Any of these may be null.\n      Node lValue = NodeUtil.getBestLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      String functionName = NodeUtil.getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }\n",
        "begin_line": 770,
        "end_line": 790,
        "comment": "\n     * Defines a function literal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.shouldUseFunctionLiteralType#819",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.shouldUseFunctionLiteralType(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }\n",
        "begin_line": 819,
        "end_line": 829,
        "comment": "\n     * If a variable is assigned a function literal in the global scope,\n     * make that a declared type (even if there's no doc info).\n     * There's only one exception to this rule:\n     * if the return type is inferred, and we're in a local\n     * scope, we should assume the whole function is inferred.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.createFunctionTypeFromNodes#853",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.createFunctionTypeFromNodes(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node)",
        "snippet": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() != null &&\n            var.getType().isFunctionType()) {\n          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.isFunction();\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = type.toMaybeFunctionType();\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          Var ownerVar = null;\n          String propName = null;\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = ObjectType.cast(ownerVar.getType());\n            }\n            if (name != null) {\n              propName = name.substring(ownerName.length() + 1);\n            }\n          }\n\n          FunctionType overriddenType = null;\n          if (ownerType != null && propName != null) {\n            overriddenType = findOverriddenFunction(ownerType, propName);\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setContents(getFunctionAnalysisResults(fnRoot))\n              .inferFromOverriddenFunction(overriddenType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (ownerType != null && ownerType.isFunctionPrototypeType() &&\n              ownerType.getOwnerFunction().hasInstanceType()) {\n            builder.inferThisType(\n                info, ownerType.getOwnerFunction().getInstanceType());\n            searchedForThisType = true;\n          } else if (ownerNode != null && ownerNode.isThis()) {\n            // If 'this' has a type, use that instead.\n            // This is a hack, necessary because CollectProperties (below)\n            // doesn't run with the scope that it's building,\n            // so scope.getTypeOfThis() will be wrong.\n            JSType injectedThisType = ownerNode.getJSType();\n            builder.inferThisType(\n                info,\n                injectedThisType == null ?\n                scope.getTypeOfThis() : injectedThisType);\n            searchedForThisType = true;\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }\n",
        "begin_line": 853,
        "end_line": 961,
        "comment": "\n     * Creates a new function type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - A function literal that needs a type attached to it.\n     * - An assignment expression with function-type info in the JsDoc.\n     *\n     * All parameters are optional, and we will do the best we can to create\n     * a function type.\n     *\n     * This function will always create a function type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The function node.\n     * @param name the function's name\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.findOverriddenFunction#966",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.findOverriddenFunction(com.google.javascript.rhino.jstype.ObjectType, java.lang.String)",
        "snippet": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType != null && propType.isFunctionType()) {\n        return propType.toMaybeFunctionType();\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType != null && propType.isFunctionType()) {\n            return propType.toMaybeFunctionType();\n          }\n        }\n      }\n\n      return null;\n    }\n",
        "begin_line": 966,
        "end_line": 986,
        "comment": "\n     * Find the function that's being overridden on this type, if any.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineSlot#1106",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.isName() && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.isVar() ||\n           parent.isFunction());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.isGetProp() && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // The input may be null if we are working with a AST snippet. So read\n      // the extern info from the node.\n      boolean isExtern = n.isFromExterns();\n      Var newVar = null;\n\n      // declared in closest scope?\n      CompilerInput input = compiler.getInput(inputId);\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        newVar = validator.expectUndeclaredVariable(\n            sourceName, input, n, parent, oldVar, variableName, type);\n      } else {\n        if (type != null) {\n          setDeferredType(n, type);\n        }\n\n        newVar =\n          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.isObjectLit() ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n      }\n\n      // We need to do some additional work for constructors and interfaces.\n      FunctionType fnType = JSType.toMaybeFunctionType(type);\n      if (fnType != null &&\n          // We don't want to look at empty function types.\n          !type.isEmptyType()) {\n\n        // We want to make sure that when we declare a new instance type\n        // (with @constructor) that there's actually a ctor for it.\n        // This doesn't apply to structural constructors (like\n        // function(new:Array). Checking the constructed type against\n        // the variable name is a sufficient check for this.\n        if ((fnType.isConstructor() || fnType.isInterface()) &&\n            variableName.equals(fnType.getReferenceName())) {\n          finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn,\n                                      input, newVar);\n        }\n      }\n\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS);\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n              getNativeType(JSTypeNative.NO_TYPE) :\n              type,\n              n);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, n);\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type != null\n          && type.isFunctionType()\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n      }\n    }\n",
        "begin_line": 1106,
        "end_line": 1204,
        "comment": "\n     * Defines a symbol in the current scope.\n     *\n     * @param n the defining NAME or GETPROP or object literal key node.\n     * @param parent the {@code n}'s parent.\n     * @param variableName The name that this should be known by.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred or declared.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.maybeDeclareQualifiedName#1484",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.maybeDeclareQualifiedName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
        "begin_line": 1484,
        "end_line": 1591,
        "comment": "\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.isQualifiedNameInferred#1620",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.isQualifiedNameInferred(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }\n",
        "begin_line": 1620,
        "end_line": 1663,
        "comment": "\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.resolveStubDeclarations#1684",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.resolveStubDeclarations()",
        "snippet": "    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }\n",
        "begin_line": 1684,
        "end_line": 1713,
        "comment": "\n     * Resolve any stub declarations to unknown types if we could not\n     * find types for them during traversal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.getFunctionAnalysisResults#2078",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.getFunctionAnalysisResults(com.google.javascript.rhino.Node)",
        "snippet": "  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n    if (n == null) {\n      return null;\n    }\n\n    // Sometimes this will return null in things like\n    // NameReferenceGraphConstruction that build partial scopes.\n    return functionAnalysisResults.get(n);\n  }\n",
        "begin_line": 2078,
        "end_line": 2086,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.expectUndeclaredVariable#516",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.expectUndeclaredVariable(java.lang.String, com.google.javascript.jscomp.CompilerInput, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope.Var, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type. We should redeclare it at the new input site.\n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }\n",
        "begin_line": 516,
        "end_line": 576,
        "comment": "\n   * Expect that the given variable has not been declared with a type.\n   *\n   * @param sourceName The name of the source file we're in.\n   * @param n The node where warnings should point to.\n   * @param parent The parent of {@code n}.\n   * @param var The variable that we're checking.\n   * @param variableName The name of the variable.\n   * @param newType The type being applied to the variable. Mostly just here\n   *     for the benefit of the warning.\n   * @return The variable we end up with. Most of the time, this will just\n   *     be {@code var}, but in some rare cases we will need to declare\n   *     a new var with new source info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.inferArguments#121",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.inferArguments(com.google.javascript.jscomp.Scope)",
        "snippet": "  private void inferArguments(Scope functionScope) {\n    Node functionNode = functionScope.getRootNode();\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType != null) {\n      Node parameterTypes = functionType.getParametersNode();\n      if (parameterTypes != null) {\n        Node parameterTypeNode = parameterTypes.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          Var var = functionScope.getVar(astParameter.getString());\n          Preconditions.checkNotNull(var);\n          if (var.isTypeInferred() &&\n              var.getType() == unknownType) {\n            JSType newType = null;\n\n            if (iifeArgumentNode != null) {\n              newType = iifeArgumentNode.getJSType();\n            } else if (parameterTypeNode != null) {\n              newType = parameterTypeNode.getJSType();\n            }\n\n            if (newType != null) {\n              var.setType(newType);\n              astParameter.setJSType(newType);\n            }\n          }\n\n          if (parameterTypeNode != null) {\n            parameterTypeNode = parameterTypeNode.getNext();\n          }\n          if (iifeArgumentNode != null) {\n            iifeArgumentNode = iifeArgumentNode.getNext();\n          }\n        }\n      }\n    }\n  }\n",
        "begin_line": 121,
        "end_line": 164,
        "comment": "\n   * Infers all of a function's arguments if their types aren't declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverseAssign#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseAssign(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }\n",
        "begin_line": 515,
        "end_line": 526,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.ensurePropertyDefined#580",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDefined(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      // Don't add the property to @struct objects outside a constructor\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        if (!(obj.isThis() &&\n              getJSType(syntacticScope.getRootNode()).isConstructor())) {\n          return;\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (obj.isThis() &&\n                   getJSType(syntacticScope.getRootNode()).isConstructor()) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }\n",
        "begin_line": 580,
        "end_line": 628,
        "comment": "\n   * Defines a property if the property has not been defined yet.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.ensurePropertyDeclaredHelper#649",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclaredHelper(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.ObjectType)",
        "snippet": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 649,
        "end_line": 668,
        "comment": "\n   * Declares a property on its owner, if necessary.\n   * @return True if a property was declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.getPropertyType#1305",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.getPropertyType(com.google.javascript.rhino.jstype.JSType, java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return unknownType;\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }\n",
        "begin_line": 1305,
        "end_line": 1355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.markAssignedExactlyOnce#335",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.markAssignedExactlyOnce()",
        "snippet": "    void markAssignedExactlyOnce() {\n      markedAssignedExactlyOnce = true;\n    }\n",
        "begin_line": 335,
        "end_line": 337,
        "comment": "\n     * Record that this is assigned exactly once..\n     *\n     * In other words, it's assigned in an inner scope so that it's much harder\n     * to make assertions about its value at a given point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.undeclare#509",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.undeclare(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "  void undeclare(Var var) {\n    Preconditions.checkState(var.scope == this);\n    Preconditions.checkState(vars.get(var.name) == var);\n    vars.remove(var.name);\n  }\n",
        "begin_line": 509,
        "end_line": 513,
        "comment": "\n   * Undeclares a variable, to be used when the compiler optimizes out\n   * a variable and removes it from the scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeReplaceKnownMethods.tryFoldKnownMethods#54",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
        "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.tryFoldKnownMethods(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldKnownMethods(Node subtree) {\n    // For now we only support string methods .join(),\n    // .indexOf(), .substring() and .substr()\n    // and numeric methods parseInt() and parseFloat().\n\n    subtree = tryFoldArrayJoin(subtree);\n\n    if (subtree.isCall()) {\n      Node callTarget = subtree.getFirstChild();\n      if (callTarget == null) {\n        return subtree;\n      }\n\n      if (NodeUtil.isGet(callTarget)) {\n        subtree = tryFoldKnownStringMethods(subtree);\n      } else {\n        subtree = tryFoldKnownNumericMethods(subtree);\n      }\n    }\n\n    return subtree;\n  }\n",
        "begin_line": 54,
        "end_line": 75,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeReplaceKnownMethods.tryFoldArrayJoin#393",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java",
        "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
        "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.tryFoldArrayJoin(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !callTarget.isGetProp()) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if (!arrayNode.isArrayLit() ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    if (right != null && right.isString()\n        && \",\".equals(right.getString())) {\n      // \",\" is the default, it doesn't need to be explicit\n      n.removeChild(right);\n      reportCodeChange();\n    }\n\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              IR.string(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          IR.string(sb.toString()).copyInformationFrom(prev));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = IR.string(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (!foldedStringNode.isString()) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = IR.add(\n              IR.string(\"\").srcref(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }\n",
        "begin_line": 393,
        "end_line": 507,
        "comment": "\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isBleedingFunctionName#1956",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isBleedingFunctionName(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }\n",
        "begin_line": 1956,
        "end_line": 1959,
        "comment": "\n   * Returns whether this is a bleeding function (an anonymous named function\n   * that bleeds into the inner scope).\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getBestLValueOwner#3115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueOwner(com.google.javascript.rhino.Node)",
        "snippet": "  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }\n",
        "begin_line": 3115,
        "end_line": 3126,
        "comment": " Get the owner of the given l-value node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "MemoizedScopeCreator.createScope#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MemoizedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
        "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.createScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }\n",
        "begin_line": 78,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "MakeDeclaredNamesUnique.handleScopeVar#341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.handleScopeVar(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    void handleScopeVar(Var v) {\n      String name  = v.getName();\n      if (containsSeparator(name) && !getOrginalName(name).isEmpty()) {\n        String newName = findReplacementName(name);\n        referencedNames.remove(name);\n        // Adding a reference to the new name to prevent either the parent\n        // scopes or the current scope renaming another var to this new name.\n        referencedNames.add(newName);\n        List<Node> references = nameMap.get(name);\n        Preconditions.checkState(references != null);\n        for (Node n : references) {\n          Preconditions.checkState(n.isName());\n          n.setString(newName);\n        }\n        compiler.reportCodeChange();\n        nameMap.remove(name);\n      }\n    }\n",
        "begin_line": 341,
        "end_line": 358,
        "comment": "\n     * For the Var declared in the current scope determine if it is possible\n     * to revert the name to its original form without conflicting with other\n     * values.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.inferQualifiedSlot#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferQualifiedSlot(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  @Override\n  public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n      JSType inferredType) {\n    Scope functionScope = getFunctionScope();\n    if (functionScope.isLocal()) {\n      if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {\n        functionScope.declare(symbol, node, bottomType, null);\n      }\n\n      inferSlotType(symbol, inferredType);\n    }\n  }\n",
        "begin_line": 111,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "InferJSDocInfo.visit#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSDocInfo docInfo;\n\n    switch (n.getType()) {\n      // Infer JSDocInfo on types of all type declarations on variables.\n      case Token.NAME:\n        if (parent == null) {\n          return;\n        }\n\n        // Only allow JSDoc on VARs, function declarations, and assigns.\n        if (!parent.isVar() &&\n            !NodeUtil.isFunctionDeclaration(parent) &&\n            !(parent.isAssign() &&\n              n == parent.getFirstChild())) {\n          return;\n        }\n\n        // There are four places the doc info could live.\n        // 1) A FUNCTION node.\n        // /** ... */ function f() { ... }\n        // 2) An ASSIGN parent.\n        // /** ... */ x = function () { ... }\n        // 3) A NAME parent.\n        // var x, /** ... */ y = function() { ... }\n        // 4) A VAR gramps.\n        // /** ... */ var x = function() { ... }\n        docInfo = n.getJSDocInfo();\n        if (docInfo == null &&\n            !(parent.isVar() &&\n                !parent.hasOneChild())) {\n          docInfo = parent.getJSDocInfo();\n        }\n\n        // Try to find the type of the NAME.\n        JSType varType = n.getJSType();\n        if (varType == null && parent.isFunction()) {\n          varType = parent.getJSType();\n        }\n\n        // If we have no type to attach JSDocInfo to, then there's nothing\n        // we can do.\n        if (varType == null || docInfo == null) {\n          return;\n        }\n\n        // Dereference the type. If the result is not an object, or already\n        // has docs attached, then do nothing.\n        ObjectType objType = dereferenceToObject(varType);\n        if (objType == null || objType.getJSDocInfo() != null) {\n          return;\n        }\n\n        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n        break;\n\n      case Token.GETPROP:\n        // Infer JSDocInfo on properties.\n        // There are two ways to write doc comments on a property.\n        //\n        // 1)\n        // /** @deprecated */\n        // obj.prop = ...\n        //\n        // 2)\n        // /** @deprecated */\n        // obj.prop;\n        if (parent.isExprResult() ||\n            (parent.isAssign() &&\n             parent.getFirstChild() == n)) {\n          docInfo = n.getJSDocInfo();\n          if (docInfo == null) {\n            docInfo = parent.getJSDocInfo();\n          }\n          if (docInfo != null) {\n            ObjectType lhsType =\n                dereferenceToObject(n.getFirstChild().getJSType());\n            if (lhsType != null) {\n              // Put the JSDoc in the property slot, if there is one.\n              String propName = n.getLastChild().getString();\n              if (lhsType.hasOwnProperty(propName)) {\n                lhsType.setPropertyJSDocInfo(propName, docInfo);\n              }\n\n              // Put the JSDoc in any constructors or function shapes as well.\n              ObjectType propType =\n                  dereferenceToObject(lhsType.getPropertyType(propName));\n              if (propType != null) {\n                attachJSDocInfoToNominalTypeOrShape(\n                    propType, docInfo, n.getQualifiedName());\n              }\n            }\n          }\n        }\n        break;\n    }\n  }\n",
        "begin_line": 92,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape(com.google.javascript.rhino.jstype.ObjectType, com.google.javascript.rhino.JSDocInfo, java.lang.String)",
        "snippet": "  private void attachJSDocInfoToNominalTypeOrShape(\n      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n    if (objType.isConstructor() ||\n        objType.isEnumType() ||\n        objType.isInterface()) {\n      // Named types.\n      if (objType.hasReferenceName() &&\n          objType.getReferenceName().equals(qName)) {\n        objType.setJSDocInfo(docInfo);\n\n        if (objType.isConstructor() || objType.isInterface()) {\n          JSType.toMaybeFunctionType(objType).getInstanceType().setJSDocInfo(\n              docInfo);\n        } else if (objType instanceof EnumType) {\n          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n        }\n      }\n    } else if (!objType.isNativeObjectType() &&\n        objType.isFunctionType()) {\n      // Structural functions.\n      objType.setJSDocInfo(docInfo);\n    }\n  }\n",
        "begin_line": 201,
        "end_line": 223,
        "comment": "\n   * Handle cases #1 and #3 in the class doc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.get#802",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.UnknownFunctionContents.get()",
        "snippet": "    static FunctionContents get() {\n      return singleton;\n    }\n",
        "begin_line": 802,
        "end_line": 804,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.AstFunctionContents#849",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.AstFunctionContents(com.google.javascript.rhino.Node)",
        "snippet": "    AstFunctionContents(Node n) {\n      this.n = n;\n    }\n",
        "begin_line": 849,
        "end_line": 851,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.getSourceNode#853",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getSourceNode()",
        "snippet": "    @Override\n    public Node getSourceNode() {\n      return n;\n    }\n",
        "begin_line": 853,
        "end_line": 856,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.mayBeFromExterns#858",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayBeFromExterns()",
        "snippet": "    @Override\n    public boolean mayBeFromExterns() {\n      return n.isFromExterns();\n    }\n",
        "begin_line": 858,
        "end_line": 861,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.mayHaveNonEmptyReturns#863",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayHaveNonEmptyReturns()",
        "snippet": "    @Override\n    public boolean mayHaveNonEmptyReturns() {\n      return hasNonEmptyReturns;\n    }\n",
        "begin_line": 863,
        "end_line": 866,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.mayHaveSingleThrow#872",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.mayHaveSingleThrow()",
        "snippet": "    @Override\n    public boolean mayHaveSingleThrow() {\n      Node block = n.getLastChild();\n      return block.hasOneChild() && block.getFirstChild().isThrow();\n    }\n",
        "begin_line": 872,
        "end_line": 876,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.getEscapedVarNames#878",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getEscapedVarNames()",
        "snippet": "    @Override\n    public Iterable<String> getEscapedVarNames() {\n      return escapedVarNames == null\n          ? ImmutableList.<String>of() : escapedVarNames;\n    }\n",
        "begin_line": 878,
        "end_line": 882,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.getAssignedNameCounts#904",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.getAssignedNameCounts()",
        "snippet": "    @Override\n    public Multiset<String> getAssignedNameCounts() {\n      return assignedVarNames;\n    }\n",
        "begin_line": 904,
        "end_line": 907,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.recordAssignedName#909",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents.recordAssignedName(java.lang.String)",
        "snippet": "    void recordAssignedName(String name) {\n      assignedVarNames.add(name);\n    }\n",
        "begin_line": 909,
        "end_line": 911,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.FunctionTypeBuilder#201",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.FunctionTypeBuilder(java.lang.String, com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.jscomp.Scope)",
        "snippet": "  FunctionTypeBuilder(String fnName, AbstractCompiler compiler,\n      Node errorRoot, String sourceName, Scope scope) {\n    Preconditions.checkNotNull(errorRoot);\n\n    this.fnName = fnName == null ? \"\" : fnName;\n    this.codingConvention = compiler.getCodingConvention();\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.errorRoot = errorRoot;\n    this.sourceName = sourceName;\n    this.compiler = compiler;\n    this.scope = scope;\n  }\n",
        "begin_line": 201,
        "end_line": 212,
        "comment": "\n   * @param fnName The function name.\n   * @param compiler The compiler.\n   * @param errorRoot The node to associate with any warning generated by\n   *     this builder.\n   * @param sourceName A source name for associating any warnings that\n   *     we have to emit.\n   * @param scope The syntactic scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.setContents#217",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.setContents(com.google.javascript.jscomp.FunctionTypeBuilder.FunctionContents)",
        "snippet": "  FunctionTypeBuilder setContents(@Nullable FunctionContents contents) {\n    if (contents != null) {\n      this.contents = contents;\n    }\n    return this;\n  }\n",
        "begin_line": 217,
        "end_line": 222,
        "comment": "\n   * Sets the contents of this function.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferFromOverriddenFunction#233",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferFromOverriddenFunction(com.google.javascript.rhino.jstype.FunctionType, com.google.javascript.rhino.Node)",
        "snippet": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal,\n      // but make them optional.\n      while (oldParams.hasNext()) {\n        paramBuilder.newOptionalParameterFromNode(oldParams.next());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
        "begin_line": 233,
        "end_line": 291,
        "comment": "\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferReturnType#296",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    if (info != null && info.hasReturnType()) {\n      returnType = info.getReturnType().evaluate(scope, typeRegistry);\n      returnTypeInferred = false;\n    }\n\n    return this;\n  }\n",
        "begin_line": 296,
        "end_line": 303,
        "comment": "\n   * Infer the return type from JSDocInfo.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferInheritance#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferInheritance(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\n      if (makesStructs && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n",
        "begin_line": 309,
        "end_line": 370,
        "comment": "\n   * Infer the role of the function (whether it's a constructor or interface)\n   * and what it inherits from in JSDocInfo.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferThisType#376",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) {\n    // Look at the @this annotation first.\n    inferThisType(info);\n\n    if (thisType == null) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null && (info == null || !info.hasType())) {\n        thisType = objType;\n      }\n    }\n\n    return this;\n  }\n",
        "begin_line": 376,
        "end_line": 388,
        "comment": "\n   * Infers the type of {@code this}.\n   * @param type The type of this if the info is missing.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.isOptionalParameter#500",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isOptionalParameter(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private boolean isOptionalParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isOptionalParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isOptionalArg();\n  }\n",
        "begin_line": 500,
        "end_line": 509,
        "comment": "\n   * @return Whether the given param is an optional param.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.isVarArgsParameter#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isVarArgsParameter(com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  private boolean isVarArgsParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isVarArgsParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isVarArgs();\n  }\n",
        "begin_line": 515,
        "end_line": 524,
        "comment": "\n   * Determine whether this is a var args parameter.\n   * @return Whether the given param is a var args param.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.inferTemplateTypeName#529",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferTemplateTypeName(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n    if (info != null) {\n      templateTypeNames = info.getTemplateTypeNames();\n      typeRegistry.setTemplateTypeNames(templateTypeNames);\n    }\n    return this;\n  }\n",
        "begin_line": 529,
        "end_line": 535,
        "comment": "\n   * Infer the template type from the doc info.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.maybeSetBaseType#646",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.maybeSetBaseType(com.google.javascript.rhino.jstype.FunctionType)",
        "snippet": "  private void maybeSetBaseType(FunctionType fnType) {\n    if (!fnType.isInterface() && baseType != null) {\n      fnType.setPrototypeBasedOn(baseType);\n    }\n  }\n",
        "begin_line": 646,
        "end_line": 650,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.getScopeDeclaredIn#732",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getScopeDeclaredIn()",
        "snippet": "  private Scope getScopeDeclaredIn() {\n    int dotIndex = fnName.indexOf(\".\");\n    if (dotIndex != -1) {\n      String rootVarName = fnName.substring(0, dotIndex);\n      Var rootVar = scope.getVar(rootVarName);\n      if (rootVar != null) {\n        return rootVar.getScope();\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 732,
        "end_line": 742,
        "comment": "\n   * The scope that we should declare this function in, if it needs\n   * to be declared in a scope. Notice that TypedScopeCreator takes\n   * care of most scope-declaring.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 1
    },
    {
        "name": "ValueType.resolveInternal#52",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ValueType.java",
        "class_name": "com.google.javascript.rhino.jstype.ValueType",
        "signature": "com.google.javascript.rhino.jstype.ValueType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnknownType.isUnknownType#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    return true;\n  }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnknownType.resolveInternal#157",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnknownType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnknownType",
        "signature": "com.google.javascript.rhino.jstype.UnknownType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 157,
        "end_line": 160,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PrototypeObjectType.resolveInternal#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
        "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }\n",
        "begin_line": 413,
        "end_line": 426,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.getPrimaryParent#98",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getPrimaryParent()",
        "snippet": "  PropertyMap getPrimaryParent() {\n    if (parentSource == null) {\n      return null;\n    }\n    ObjectType iProto = parentSource.getImplicitPrototype();\n    return iProto == null ? null : iProto.getPropertyMap();\n  }\n",
        "begin_line": 98,
        "end_line": 104,
        "comment": " Returns the direct parent of this property map. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.getSecondaryParents#110",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getSecondaryParents()",
        "snippet": "  Iterable<PropertyMap> getSecondaryParents() {\n    if (parentSource == null) {\n      return ImmutableList.of();\n    }\n    Iterable<ObjectType> extendedInterfaces =\n        parentSource.getCtorExtendedInterfaces();\n\n    // Most of the time, this will be empty.\n    if (Iterables.isEmpty(extendedInterfaces)) {\n      return ImmutableList.of();\n    }\n\n    return Iterables.transform(extendedInterfaces, PROP_MAP_FROM_TYPE);\n  }\n",
        "begin_line": 110,
        "end_line": 123,
        "comment": "\n   * Returns the secondary parents of this property map, for interfaces that\n   * need multiple inheritance.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.getSlot#125",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.getSlot(java.lang.String)",
        "snippet": "  Property getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    PropertyMap primaryParent = getPrimaryParent();\n    if (primaryParent != null) {\n      Property prop = primaryParent.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (PropertyMap p : getSecondaryParents()) {\n      if (p != null) {\n        Property prop = p.getSlot(name);\n        if (prop != null) {\n          return prop;\n        }\n      }\n    }\n    return null;\n  }\n",
        "begin_line": 125,
        "end_line": 145,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PropertyMap.values#202",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/PropertyMap.java",
        "class_name": "com.google.javascript.rhino.jstype.PropertyMap",
        "signature": "com.google.javascript.rhino.jstype.PropertyMap.values()",
        "snippet": "  Iterable<Property> values() {\n    return properties.values();\n  }\n",
        "begin_line": 202,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Property.isTypeInferred#117",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.isTypeInferred()",
        "snippet": "  @Override\n      public boolean isTypeInferred() {\n    return inferred;\n  }\n",
        "begin_line": 117,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Property.setType#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setType(JSType type) {\n    this.type = type;\n  }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Property.setJSDocInfo#134",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/Property.java",
        "class_name": "com.google.javascript.rhino.jstype.Property",
        "signature": "com.google.javascript.rhino.jstype.Property.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  void setJSDocInfo(JSDocInfo info) {\n    this.docInfo = info;\n  }\n",
        "begin_line": 134,
        "end_line": 136,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getSlot#115",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Property getSlot(String name) {\n    return getPropertyMap().getSlot(name);\n  }\n",
        "begin_line": 115,
        "end_line": 118,
        "comment": "\n   * Default getSlot implementation. This gets overridden by FunctionType\n   * for lazily-resolved prototypes.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getJSDocInfo#149",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getJSDocInfo()",
        "snippet": "  @Override\n  public JSDocInfo getJSDocInfo() {\n    return docInfo;\n  }\n",
        "begin_line": 149,
        "end_line": 152,
        "comment": "\n   * Gets the docInfo for this type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.defineInferredProperty#321",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.defineInferredProperty(java.lang.String, com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.Node)",
        "snippet": "  public final boolean defineInferredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    StaticSlot<JSType> originalSlot = getSlot(propertyName);\n    if (hasProperty(propertyName)) {\n      if (isPropertyTypeDeclared(propertyName)) {\n        // We never want to hide a declared property with an inferred property.\n        return true;\n      }\n      JSType originalType = getPropertyType(propertyName);\n      type = originalType == null ? type :\n          originalType.getLeastSupertype(type);\n    }\n\n    boolean result = defineProperty(propertyName, type, true,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }\n",
        "begin_line": 321,
        "end_line": 344,
        "comment": "\n   * Defines a property whose type is inferred.\n   * @param propertyName the property's name\n   * @param type the type\n   * @param propertyNode the node corresponding to the inferred definition of\n   *        property that might later be accessed using {@code getPropertyNode}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.findPropertyType#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.findPropertyType(java.lang.String)",
        "snippet": "  @Override\n  public JSType findPropertyType(String propertyName) {\n    return hasProperty(propertyName) ?\n        getPropertyType(propertyName) : null;\n  }\n",
        "begin_line": 413,
        "end_line": 417,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.getPropertyType#430",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.getPropertyType(java.lang.String)",
        "snippet": "  public JSType getPropertyType(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    if (slot == null) {\n      if (isNoResolvedType() || isCheckedUnknownType()) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n      } else if (isEmptyType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }\n",
        "begin_line": 430,
        "end_line": 441,
        "comment": "\n   * Gets the property type of the property whose name is given. If the\n   * underlying object does not have this property, the Unknown type is\n   * returned to indicate that no information is available on this property.\n   *\n   * This gets overridden by FunctionType for lazily-resolved call() and\n   * bind() functions.\n   *\n   * @return the property's type or {@link UnknownType}. This method never\n   *         returns {@code null}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.hasProperty#443",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.hasProperty(java.lang.String)",
        "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isEmptyType() || isUnknownType() || getSlot(propertyName) != null;\n  }\n",
        "begin_line": 443,
        "end_line": 447,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.isPropertyTypeDeclared#477",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isPropertyTypeDeclared(java.lang.String)",
        "snippet": "  public boolean isPropertyTypeDeclared(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : !slot.isTypeInferred();\n  }\n",
        "begin_line": 477,
        "end_line": 480,
        "comment": "\n   * Checks whether the property's type is declared.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.isObject#580",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.isObject()",
        "snippet": "  @Override\n  public boolean isObject() {\n    return true;\n  }\n",
        "begin_line": 580,
        "end_line": 583,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.cast#610",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }\n",
        "begin_line": 610,
        "end_line": 612,
        "comment": "\n   * A null-safe version of JSType#toObjectType.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.getErrorReporter#224",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getErrorReporter()",
        "snippet": "  public ErrorReporter getErrorReporter() {\n    return reporter;\n  }\n",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createUnionType#1027",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(com.google.javascript.rhino.jstype.JSTypeNative...)",
        "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }\n",
        "begin_line": 1027,
        "end_line": 1033,
        "comment": "\n   * Creates a union type whose variants are the built-in types specified\n   * by the arguments.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.autoboxesTo#856",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.autoboxesTo()",
        "snippet": "  public JSType autoboxesTo() {\n    return null;\n  }\n",
        "begin_line": 856,
        "end_line": 858,
        "comment": "\n   * Turn a scalar type to the corresponding object type.\n   *\n   * @return the auto-boxed type or {@code null} if this type is not a scalar.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.autobox#885",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.autobox()",
        "snippet": "  public JSType autobox() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return autobox == null ? restricted : autobox;\n  }\n",
        "begin_line": 885,
        "end_line": 889,
        "comment": "\n   * Dereference a type for property access.\n   *\n   * Filters null/undefined and autoboxes the resulting type.\n   * Never returns null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.dereference#897",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.dereference()",
        "snippet": "  public final ObjectType dereference() {\n    return autobox().toObjectType();\n  }\n",
        "begin_line": 897,
        "end_line": 899,
        "comment": "\n   * Dereference a type for property access.\n   *\n   * Filters null/undefined, autoboxes the resulting type, and returns it\n   * iff it's an object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.restrictByNotNullOrUndefined#1302",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.restrictByNotNullOrUndefined()",
        "snippet": "  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }\n",
        "begin_line": 1302,
        "end_line": 1304,
        "comment": "\n   * If this is a union type, returns a union type that does not include\n   * the null or undefined type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.resolve#1419",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.resolve(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }\n",
        "begin_line": 1419,
        "end_line": 1432,
        "comment": "\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.setResolvedTypeInternal#1439",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.setResolvedTypeInternal(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }\n",
        "begin_line": 1439,
        "end_line": 1442,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.safeResolve#1459",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.safeResolve(com.google.javascript.rhino.jstype.JSType, com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }\n",
        "begin_line": 1459,
        "end_line": 1462,
        "comment": "\n   * A null-safe resolve.\n   * @see #resolve\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionType.resolveInternal#1158",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
        "class_name": "com.google.javascript.rhino.jstype.FunctionType",
        "signature": "com.google.javascript.rhino.jstype.FunctionType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    if (prototypeSlot != null) {\n      prototypeSlot.setType(\n          safeResolve(prototypeSlot.getType(), t, scope));\n    }\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the run-time coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(\n            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
        "begin_line": 1158,
        "end_line": 1207,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ArrowType.resolveInternal#273",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ArrowType.java",
        "class_name": "com.google.javascript.rhino.jstype.ArrowType",
        "signature": "com.google.javascript.rhino.jstype.ArrowType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    returnType = safeResolve(returnType, t, scope);\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n      }\n    }\n    return this;\n  }\n",
        "begin_line": 273,
        "end_line": 283,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "AllType.resolveInternal#112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/AllType.java",
        "class_name": "com.google.javascript.rhino.jstype.AllType",
        "signature": "com.google.javascript.rhino.jstype.AllType.resolveInternal(com.google.javascript.rhino.ErrorReporter, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }\n",
        "begin_line": 112,
        "end_line": 115,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter#119",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public SemanticReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n  }\n",
        "begin_line": 119,
        "end_line": 122,
        "comment": "\n   * Creates a semantic reverse abstract interpreter.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java",
        "class_name": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter",
        "signature": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter(com.google.javascript.jscomp.CodingConvention, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }\n",
        "begin_line": 63,
        "end_line": 70,
        "comment": "\n   * Constructs an interpreter, which is the only link in a chain. Interpreters\n   * can be appended using {@link #append}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.StubDeclaration#1779",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.StubDeclaration.StubDeclaration(com.google.javascript.rhino.Node, boolean, java.lang.String)",
        "snippet": "    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n      this.node = node;\n      this.isExtern = isExtern;\n      this.ownerName = ownerName;\n    }\n",
        "begin_line": 1779,
        "end_line": 1783,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.GlobalScopeBuilder#1792",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.GlobalScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private GlobalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n",
        "begin_line": 1792,
        "end_line": 1794,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.visit#1804",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }\n",
        "begin_line": 1804,
        "end_line": 1816,
        "comment": "\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.maybeDeclareQualifiedName#1818",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.maybeDeclareQualifiedName(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.JSDocInfo, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }\n",
        "begin_line": 1818,
        "end_line": 1824,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.checkForTypedef#1832",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.GlobalScopeBuilder.checkForTypedef(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recursive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, unknownType);\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.isGetProp()) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }\n",
        "begin_line": 1832,
        "end_line": 1860,
        "comment": "\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.FirstOrderFunctionAnalyzer#2002",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.FirstOrderFunctionAnalyzer(com.google.javascript.jscomp.AbstractCompiler, java.util.Map<com.google.javascript.rhino.Node, com.google.javascript.jscomp.FunctionTypeBuilder.AstFunctionContents>)",
        "snippet": "    FirstOrderFunctionAnalyzer(\n        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {\n      this.compiler = compiler;\n      this.data = outParam;\n    }\n",
        "begin_line": 2002,
        "end_line": 2006,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.process#2008",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.FirstOrderFunctionAnalyzer.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override public void process(Node externs, Node root) {\n      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }\n",
        "begin_line": 2008,
        "end_line": 2015,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.DiscoverEnumsAndTypedefs#361",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.DiscoverEnumsAndTypedefs(com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n      this.registry = registry;\n    }\n",
        "begin_line": 361,
        "end_line": 363,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.identifyNameNode#391",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DiscoverEnumsAndTypedefs.identifyNameNode(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }\n",
        "begin_line": 391,
        "end_line": 402,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.DeferredSetType#163",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DeferredSetType.DeferredSetType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    DeferredSetType(Node node, JSType type) {\n      Preconditions.checkNotNull(node);\n      Preconditions.checkNotNull(type);\n      this.node = node;\n      this.type = type;\n\n      // Other parts of this pass may read off the node.\n      // (like when we set the LHS of an assign with a typed RHS function.)\n      node.setJSType(type);\n    }\n",
        "begin_line": 163,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.resolve#174",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.DeferredSetType.resolve(com.google.javascript.jscomp.Scope)",
        "snippet": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }\n",
        "begin_line": 174,
        "end_line": 176,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.AbstractScopeBuilder#456",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.AbstractScopeBuilder(com.google.javascript.jscomp.Scope)",
        "snippet": "    private AbstractScopeBuilder(Scope scope) {\n      this.scope = scope;\n    }\n",
        "begin_line": 456,
        "end_line": 458,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.setDeferredType#460",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.setDeferredType(com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }\n",
        "begin_line": 460,
        "end_line": 462,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.resolveTypes#464",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.resolveTypes()",
        "snippet": "    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n",
        "begin_line": 464,
        "end_line": 479,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.assertDefinitionNode#731",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.assertDefinitionNode(com.google.javascript.rhino.Node, int)",
        "snippet": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }\n",
        "begin_line": 731,
        "end_line": 734,
        "comment": "\n     * Asserts that it's OK to define this node's name.\n     * The node should have a source name and be of the specified type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineVar#750",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineVar(com.google.javascript.rhino.Node)",
        "snippet": "    void defineVar(Node n) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, (info != null) ? info : name.getJSDocInfo());\n      }\n    }\n",
        "begin_line": 750,
        "end_line": 765,
        "comment": "\n     * Defines a VAR initialization.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineName#800",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineName(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.JSDocInfo)",
        "snippet": "    private void defineName(Node name, Node var, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(sourceName, info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        type = name.isFromExterns() ? unknownType : null;\n      }\n      defineSlot(name, var, type);\n    }\n",
        "begin_line": 800,
        "end_line": 810,
        "comment": "\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineSlot#1059",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n",
        "begin_line": 1059,
        "end_line": 1061,
        "comment": "\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.defineSlot#1075",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.defineSlot(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.jstype.JSType, boolean)",
        "snippet": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() ||\n            parent.isCatch());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() &&\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }\n",
        "begin_line": 1075,
        "end_line": 1093,
        "comment": "\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.getObjectSlot#1670",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.AbstractScopeBuilder.getObjectSlot(java.lang.String)",
        "snippet": "    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }\n",
        "begin_line": 1670,
        "end_line": 1678,
        "comment": "\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.TypedScopeCreator#179",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }\n",
        "begin_line": 179,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.TypedScopeCreator#183",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.CodingConvention)",
        "snippet": "  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n    this.unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n  }\n",
        "begin_line": 183,
        "end_line": 191,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.createInitialScope#309",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.createInitialScope(com.google.javascript.rhino.Node)",
        "snippet": "  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = Scope.createGlobalScope(root);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // There is no longer a need to special case ActiveXObject\n    // but this remains here until we can get the extern forks\n    // cleaned up.\n    declareNativeValueType(s, \"ActiveXObject\", FUNCTION_INSTANCE_TYPE);\n\n    return s;\n  }\n",
        "begin_line": 309,
        "end_line": 339,
        "comment": "\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.declareNativeFunctionType#341",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeFunctionType(com.google.javascript.jscomp.Scope, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }\n",
        "begin_line": 341,
        "end_line": 346,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.declareNativeValueType#348",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeValueType(com.google.javascript.jscomp.Scope, java.lang.String, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }\n",
        "begin_line": 348,
        "end_line": 351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.declareNativeType#353",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeType(com.google.javascript.jscomp.Scope, java.lang.String, com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }\n",
        "begin_line": 353,
        "end_line": 355,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypedScopeCreator.getNativeType#405",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
        "signature": "com.google.javascript.jscomp.TypedScopeCreator.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }\n",
        "begin_line": 405,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeValidator.TypeValidator#137",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeValidator.java",
        "class_name": "com.google.javascript.jscomp.TypeValidator",
        "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }\n",
        "begin_line": 137,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.enterScope#138",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.SecondScopeBuildingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Only infer the entry root, rather than the scope root.\n      // This ensures that incremental compilation only touches the root\n      // that's been swapped out.\n      inferScope(t.getCurrentNode(), t.getScope());\n    }\n",
        "begin_line": 138,
        "end_line": 144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.visit#146",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.SecondScopeBuildingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }\n",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.enterScope#126",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.FirstScopeBuildingCallback.enterScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      t.getScope();\n    }\n",
        "begin_line": 126,
        "end_line": 129,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.visit#131",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.FirstScopeBuildingCallback.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }\n",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.TypeInferencePass#44",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.TypeInferencePass(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.jscomp.Scope, com.google.javascript.jscomp.MemoizedScopeCreator)",
        "snippet": "  TypeInferencePass(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      Scope topScope, MemoizedScopeCreator scopeCreator) {\n    this.compiler = compiler;\n    this.reverseInterpreter = reverseInterpreter;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n\n    assertionFunctionsMap = Maps.newHashMap();\n    for (AssertionFunctionSpec assertionFucntion :\n        compiler.getCodingConvention().getAssertionFunctions()) {\n      assertionFunctionsMap.put(assertionFucntion.getFunctionName(),\n          assertionFucntion);\n    }\n  }\n",
        "begin_line": 44,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.process#66",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    inferAllScopes(externsAndJs);\n  }\n",
        "begin_line": 66,
        "end_line": 74,
        "comment": "\n   * Main entry point for type inference when running over the whole tree.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.inferAllScopes#77",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.inferAllScopes(com.google.javascript.rhino.Node)",
        "snippet": "  void inferAllScopes(Node node) {\n    // Type analysis happens in two major phases.\n    // 1) Finding all the symbols.\n    // 2) Propagating all the inferred types.\n    //\n    // The order of this analysis is non-obvious. In a complete inference\n    // system, we may need to backtrack arbitrarily far. But the compile-time\n    // costs would be unacceptable.\n    //\n    // We do one pass where we do typed scope creation for all scopes\n    // in pre-order.\n    //\n    // Then we do a second pass where we do all type inference\n    // (type propagation) in pre-order.\n    //\n    // We use a memoized scope creator so that we never create a scope\n    // more than once.\n    //\n    // This will allow us to handle cases like:\n    // var ns = {};\n    // (function() { /** JSDoc */ ns.method = function() {}; })();\n    // ns.method();\n    // In this code, we need to build the symbol table for the inner scope in\n    // order to propagate the type of ns.method in the outer scope.\n    (new NodeTraversal(\n        compiler, new FirstScopeBuildingCallback(), scopeCreator))\n        .traverseWithScope(node, topScope);\n    (new NodeTraversal(\n        compiler, new SecondScopeBuildingCallback(), scopeCreator))\n        .traverseWithScope(node, topScope);\n  }\n",
        "begin_line": 77,
        "end_line": 107,
        "comment": " Entry point for type inference when running over part of the tree. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.inferScope#109",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.inferScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  void inferScope(Node n, Scope scope) {\n    TypeInference typeInference =\n        new TypeInference(\n            compiler, computeCfg(n), reverseInterpreter, scope,\n            assertionFunctionsMap);\n    try {\n      typeInference.analyze();\n\n      // Resolve any new type names found during the inference.\n      compiler.getTypeRegistry().resolveTypesInScope(scope);\n\n    } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n      compiler.report(JSError.make(n.getSourceFileName(), n, DATAFLOW_ERROR));\n    }\n  }\n",
        "begin_line": 109,
        "end_line": 123,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInferencePass.computeCfg#152",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInferencePass.java",
        "class_name": "com.google.javascript.jscomp.TypeInferencePass",
        "signature": "com.google.javascript.jscomp.TypeInferencePass.computeCfg(com.google.javascript.rhino.Node)",
        "snippet": "  private ControlFlowGraph<Node> computeCfg(Node n) {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    return cfa.getCfg();\n  }\n",
        "begin_line": 152,
        "end_line": 156,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.branchedFlowThrough#189",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.branchedFlowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  @Override\n  @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"})\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably to expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getIndexType();\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }\n",
        "begin_line": 189,
        "end_line": 301,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.TypeInference#84",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.TypeInference(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node>, com.google.javascript.jscomp.type.ReverseAbstractInterpreter, com.google.javascript.jscomp.Scope, java.util.Map<java.lang.String, com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec>)",
        "snippet": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);\n\n    this.syntacticScope = functionScope;\n    inferArguments(functionScope);\n\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (isUnflowable(var)) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        Scope.createLatticeBottom(functionScope.getRootNode()));\n  }\n",
        "begin_line": 84,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.createInitialEstimateLattice#166",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.createInitialEstimateLattice()",
        "snippet": "  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }\n",
        "begin_line": 166,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.createEntryLattice#171",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.createEntryLattice()",
        "snippet": "  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }\n",
        "begin_line": 171,
        "end_line": 174,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.flowThrough#176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.flowThrough(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }\n",
        "begin_line": 176,
        "end_line": 187,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.ensurePropertyDeclared#637",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclared(com.google.javascript.rhino.Node)",
        "snippet": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }\n",
        "begin_line": 637,
        "end_line": 643,
        "comment": "\n   * Defines a declared property if it has not been defined yet.\n   *\n   * This handles the case where a property is declared on an object where\n   * the object type is inferred, and so the object type will not\n   * be known in {@code TypedScopeCreator}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverseChildren#1236",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseChildren(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }\n",
        "begin_line": 1236,
        "end_line": 1241,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.traverseGetProp#1256",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.traverseGetProp(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n",
        "begin_line": 1256,
        "end_line": 1265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.dereferencePointer#1294",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.dereferencePointer(com.google.javascript.rhino.Node, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }\n",
        "begin_line": 1294,
        "end_line": 1303,
        "comment": "\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "TypeInference.getJSType#1564",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/TypeInference.java",
        "class_name": "com.google.javascript.jscomp.TypeInference",
        "signature": "com.google.javascript.jscomp.TypeInference.getJSType(com.google.javascript.rhino.Node)",
        "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return unknownType;\n    } else {\n      return jsType;\n    }\n  }\n",
        "begin_line": 1564,
        "end_line": 1575,
        "comment": "\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getType#234",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getType()",
        "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }\n",
        "begin_line": 234,
        "end_line": 237,
        "comment": "\n     * Gets this variable's type. To know whether this type has been inferred,\n     * see {@code #isTypeInferred()}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.resolveType#266",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.resolveType(com.google.javascript.rhino.ErrorReporter)",
        "snippet": "    void resolveType(ErrorReporter errorReporter) {\n      if (type != null) {\n        type = type.resolve(errorReporter, scope);\n      }\n    }\n",
        "begin_line": 266,
        "end_line": 270,
        "comment": "\n     * Resolve this variable's type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.isTypeInferred#276",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.isTypeInferred()",
        "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return typeInferred;\n    }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": "\n     * Returns whether this variable's type is inferred. To get the variable's\n     * type, see {@link #getType()}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.apply#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Anonymous-c109aa7d-c2c8-4b92-ab7f-588e4e9248a7.apply(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    @Override public boolean apply(Var var) {\n      return var.getParentNode() != null &&\n          var.getType() == null && // no declared type\n          var.getParentNode().isVar() &&\n          !var.isExtern();\n    }\n",
        "begin_line": 68,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.createLatticeBottom#413",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.createLatticeBottom(com.google.javascript.rhino.Node)",
        "snippet": "  static Scope createLatticeBottom(Node rootNode) {\n    return new Scope(rootNode, true);\n  }\n",
        "begin_line": 413,
        "end_line": 415,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getParentScope#448",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getParentScope()",
        "snippet": "  @Override\n  public StaticScope<JSType> getParentScope() {\n    return parent;\n  }\n",
        "begin_line": 448,
        "end_line": 451,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getSlot#515",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public Var getSlot(String name) {\n    return getVar(name);\n  }\n",
        "begin_line": 515,
        "end_line": 518,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getDeclarativelyUnboundVarsWithoutTypes#616",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.getDeclarativelyUnboundVarsWithoutTypes()",
        "snippet": "  public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() {\n    return Iterators.filter(\n        getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n  }\n",
        "begin_line": 616,
        "end_line": 619,
        "comment": "\n   * Gets all variables declared with \"var\" but without declared types attached.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.getGrandparent#601",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.getGrandparent()",
        "snippet": "    Node getGrandparent() {\n      Node parent = getParent();\n      return parent == null ? null : parent.getParent();\n    }\n",
        "begin_line": 601,
        "end_line": 604,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PassConfig.regenerateGlobalTypedScope#65",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.regenerateGlobalTypedScope(com.google.javascript.jscomp.AbstractCompiler, com.google.javascript.rhino.Node)",
        "snippet": "  void regenerateGlobalTypedScope(AbstractCompiler compiler, Node root) {\n    internalScopeCreator = new TypedScopeCreator(compiler);\n    typedScopeCreator = new MemoizedScopeCreator(internalScopeCreator);\n    topScope = typedScopeCreator.createScope(root, null);\n  }\n",
        "begin_line": 65,
        "end_line": 69,
        "comment": "\n   * Regenerates the top scope from scratch.\n   *\n   * @param compiler The compiler for which the global scope is regenerated.\n   * @param root The root of the AST.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PassConfig.getTypedScopeCreator#92",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.getTypedScopeCreator()",
        "snippet": "  MemoizedScopeCreator getTypedScopeCreator() {\n    return typedScopeCreator;\n  }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n   * Gets the scope creator for typed scopes.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PassConfig.makeTypeInference#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PassConfig.java",
        "class_name": "com.google.javascript.jscomp.PassConfig",
        "signature": "com.google.javascript.jscomp.PassConfig.makeTypeInference(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  final TypeInferencePass makeTypeInference(AbstractCompiler compiler) {\n    return new TypeInferencePass(\n        compiler, compiler.getReverseAbstractInterpreter(),\n        topScope, typedScopeCreator);\n  }\n",
        "begin_line": 159,
        "end_line": 163,
        "comment": "\n   * Create a type inference pass.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isLValue#2049",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isLValue(com.google.javascript.rhino.Node)",
        "snippet": "  public static boolean isLValue(Node n) {\n    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n        n.isGetElem());\n    Node parent = n.getParent();\n    if (parent == null) {\n      return false;\n    }\n    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n        || parent.isVar()\n        || (parent.isFunction() && parent.getFirstChild() == n)\n        || parent.isDec()\n        || parent.isInc()\n        || parent.isParamList()\n        || parent.isCatch();\n  }\n",
        "begin_line": 2049,
        "end_line": 2064,
        "comment": "\n   * Determines whether this node is used as an L-value. Notice that sometimes\n   * names are used as both L-values and R-values.\n   *\n   * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n   * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n   * we're honest with ourselves, it doesn't make sense, and we only do this\n   * because it makes sense to treat this as syntactically similar to\n   * \"var x = 0;\".\n   *\n   * @param n The node\n   * @return True if n is an L-value.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isCallOrNewTarget#3029",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isCallOrNewTarget(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n  }\n",
        "begin_line": 3029,
        "end_line": 3034,
        "comment": "\n   * Returns whether this is a target of a call or new.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getBestLValueName#3129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getBestLValueName(com.google.javascript.rhino.Node)",
        "snippet": "  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }\n",
        "begin_line": 3129,
        "end_line": 3144,
        "comment": " Get the name of the given l-value node. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.shouldTraverse#142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n",
        "begin_line": 142,
        "end_line": 146,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.exitScope#151",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback.exitScope(com.google.javascript.jscomp.NodeTraversal)",
        "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}\n",
        "begin_line": 151,
        "end_line": 152,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.traverseWithScope#336",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.traverseWithScope(com.google.javascript.rhino.Node, com.google.javascript.jscomp.Scope)",
        "snippet": "  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    inputId = null;\n    sourceName = \"\";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }\n",
        "begin_line": 336,
        "end_line": 345,
        "comment": "\n   * Traverses a parse tree recursively with a scope, starting with the given\n   * root. This should only be used in the global scope. Otherwise, use\n   * {@link #traverseAtScope}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.getInputId#660",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getInputId()",
        "snippet": "  InputId getInputId() {\n    return inputId;\n  }\n",
        "begin_line": 660,
        "end_line": 662,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "MemoizedScopeCreator.MemoizedScopeCreator#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MemoizedScopeCreator.java",
        "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
        "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.MemoizedScopeCreator(com.google.javascript.jscomp.ScopeCreator)",
        "snippet": "  MemoizedScopeCreator(ScopeCreator delegate) {\n    this.delegate = delegate;\n  }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n   * @param delegate The real source of Scope objects.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.apply#243",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.FlowScopeJoinOp.apply(com.google.javascript.jscomp.type.FlowScope, com.google.javascript.jscomp.type.FlowScope)",
        "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public FlowScope apply(FlowScope a, FlowScope b) {\n      // To join the two scopes, we have to\n      LinkedFlowScope linkedA = (LinkedFlowScope) a;\n      LinkedFlowScope linkedB = (LinkedFlowScope) b;\n      linkedA.frozen = true;\n      linkedB.frozen = true;\n      if (linkedA.optimize() == linkedB.optimize()) {\n        return linkedA.createChildFlowScope();\n      }\n      return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n    }\n",
        "begin_line": 243,
        "end_line": 255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.FlatFlowScopeCache#402",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache.FlatFlowScopeCache(com.google.javascript.jscomp.Scope)",
        "snippet": "    FlatFlowScopeCache(Scope functionScope) {\n      this.functionScope = functionScope;\n      symbols = ImmutableMap.of();\n      linkedEquivalent = null;\n    }\n",
        "begin_line": 402,
        "end_line": 406,
        "comment": " The cache at the bottom of the lattice.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.getSlot#487",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache.getSlot(java.lang.String)",
        "snippet": "    public StaticSlot<JSType> getSlot(String name) {\n      if (symbols.containsKey(name)) {\n        return symbols.get(name);\n      } else {\n        return functionScope.getSlot(name);\n      }\n    }\n",
        "begin_line": 487,
        "end_line": 493,
        "comment": "\n     * Get the slot for the given symbol.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#64",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache, com.google.javascript.jscomp.LinkedFlowScope)",
        "snippet": "  private LinkedFlowScope(FlatFlowScopeCache cache,\n      LinkedFlowScope directParent) {\n    this.cache = cache;\n    if (directParent == null) {\n      this.lastSlot = null;\n      this.depth = 0;\n      this.parent = cache.linkedEquivalent;\n    } else {\n      this.lastSlot = directParent.lastSlot;\n      this.depth = directParent.depth + 1;\n      this.parent = directParent;\n    }\n  }\n",
        "begin_line": 64,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#78",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope.FlatFlowScopeCache)",
        "snippet": "  LinkedFlowScope(FlatFlowScopeCache cache) {\n    this(cache, null);\n  }\n",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.LinkedFlowScope#82",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(com.google.javascript.jscomp.LinkedFlowScope)",
        "snippet": "  LinkedFlowScope(LinkedFlowScope directParent) {\n    this(directParent.cache, directParent);\n  }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.getFunctionScope#87",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.getFunctionScope()",
        "snippet": "  private Scope getFunctionScope() {\n    return cache.functionScope;\n  }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": " Gets the function scope for this flow scope. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.createEntryLattice#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.createEntryLattice(com.google.javascript.jscomp.Scope)",
        "snippet": "  public static LinkedFlowScope createEntryLattice(Scope scope) {\n    return new LinkedFlowScope(new FlatFlowScopeCache(scope));\n  }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n   * Creates an entry lattice for the flow.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.getSlot#142",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.getSlot(java.lang.String)",
        "snippet": "  @Override\n  public StaticSlot<JSType> getSlot(String name) {\n    if (cache.dirtySymbols.contains(name)) {\n      for (LinkedFlowSlot slot = lastSlot;\n           slot != null; slot = slot.parent) {\n        if (slot.getName().equals(name)) {\n          return slot;\n        }\n      }\n    }\n    return cache.getSlot(name);\n  }\n",
        "begin_line": 142,
        "end_line": 153,
        "comment": "\n   * Get the slot for the given symbol.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.createChildFlowScope#160",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.createChildFlowScope()",
        "snippet": "  @Override\n  public FlowScope createChildFlowScope() {\n    frozen = true;\n\n    if (depth > MAX_DEPTH) {\n      if (flattened == null) {\n        flattened = new FlatFlowScopeCache(this);\n      }\n      return new LinkedFlowScope(flattened);\n    }\n\n    return new LinkedFlowScope(this);\n  }\n",
        "begin_line": 160,
        "end_line": 172,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.optimize#231",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.optimize()",
        "snippet": "  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }\n",
        "begin_line": 231,
        "end_line": 239,
        "comment": " a findUniqueRefinedSlot on it.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "LinkedFlowScope.equals#258",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LinkedFlowScope.java",
        "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
        "signature": "com.google.javascript.jscomp.LinkedFlowScope.equals(java.lang.Object)",
        "snippet": "  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate through all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n",
        "begin_line": 258,
        "end_line": 308,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "InferJSDocInfo.InferJSDocInfo#68",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.InferJSDocInfo(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  InferJSDocInfo(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "InferJSDocInfo.process#72",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      inExterns = false;\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }\n",
        "begin_line": 72,
        "end_line": 82,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "InferJSDocInfo.dereferenceToObject#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InferJSDocInfo.java",
        "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
        "signature": "com.google.javascript.jscomp.InferJSDocInfo.dereferenceToObject(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  private ObjectType dereferenceToObject(JSType type) {\n    return ObjectType.cast(type == null ? null : type.dereference());\n  }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": "\n   * Dereferences the given type to an object, or returns null.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "FunctionTypeBuilder.isFunctionTypeDeclaration#719",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
        "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
        "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isFunctionTypeDeclaration(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n    return info.getParameterCount() > 0 ||\n        info.hasReturnType() ||\n        info.hasThisType() ||\n        info.isConstructor() ||\n        info.isInterface();\n  }\n",
        "begin_line": 719,
        "end_line": 725,
        "comment": "\n   * Determines whether the given JsDoc info declares a function type.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.GlobalTypeResolver#1250",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.GlobalTypeResolver.GlobalTypeResolver(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    GlobalTypeResolver(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n",
        "begin_line": 1250,
        "end_line": 1252,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.process#1254",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.GlobalTypeResolver.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      if (topScope == null) {\n        regenerateGlobalTypedScope(compiler, root.getParent());\n      } else {\n        compiler.getTypeRegistry().resolveTypesInScope(topScope);\n      }\n    }\n",
        "begin_line": 1254,
        "end_line": 1261,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1147",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-1cc04a20-8ac2-4157-9190-4f00b31bec74.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n      return new HotSwapCompilerPass() {\n        @Override\n        public void process(Node externs, Node root) {\n          Preconditions.checkNotNull(topScope);\n          Preconditions.checkNotNull(getTypedScopeCreator());\n\n          makeTypeInference(compiler).process(externs, root);\n        }\n        @Override\n        public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n          makeTypeInference(compiler).inferAllScopes(scriptRoot);\n        }\n      };\n    }\n",
        "begin_line": 1147,
        "end_line": 1162,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.process#1150",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-ad96a5c4-311e-44a4-bd4b-cb9e7a242aa9.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "        @Override\n        public void process(Node externs, Node root) {\n          Preconditions.checkNotNull(topScope);\n          Preconditions.checkNotNull(getTypedScopeCreator());\n\n          makeTypeInference(compiler).process(externs, root);\n        }\n",
        "begin_line": 1150,
        "end_line": 1156,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultPassConfig.create#1129",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DefaultPassConfig.java",
        "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
        "signature": "com.google.javascript.jscomp.DefaultPassConfig.Anonymous-88fb2f6b-a344-46dc-998d-e7c7d055055e.create(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "    @Override\n    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n      return new GlobalTypeResolver(compiler);\n    }\n",
        "begin_line": 1129,
        "end_line": 1132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.initialize#392",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.initialize()",
        "snippet": "    @Override\n    protected void initialize() {\n      orderedWorkSet.clear();\n      for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n        int outEdgeCount = getCfg().getOutEdges(node.getValue()).size();\n        List<L> outLattices = Lists.newArrayList();\n        for (int i = 0; i < outEdgeCount; i++) {\n          outLattices.add(createInitialEstimateLattice());\n        }\n        node.setAnnotation(new BranchedFlowState<L>(\n            createInitialEstimateLattice(), outLattices));\n        if (node != getCfg().getImplicitReturn()) {\n          orderedWorkSet.add(node);\n        }\n      }\n    }\n",
        "begin_line": 392,
        "end_line": 407,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.BranchedForwardDataFlowAnalysis#409",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.BranchedForwardDataFlowAnalysis(com.google.javascript.jscomp.ControlFlowGraph<N>, com.google.javascript.jscomp.JoinOp<L>)",
        "snippet": "    BranchedForwardDataFlowAnalysis(ControlFlowGraph<N> targetCfg,\n                                    JoinOp<L> joinOp) {\n      super(targetCfg, joinOp);\n    }\n",
        "begin_line": 409,
        "end_line": 412,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.isForward#425",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.isForward()",
        "snippet": "    @Override\n    final boolean isForward() {\n      return true;\n    }\n",
        "begin_line": 425,
        "end_line": 428,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.flow#443",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.flow(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    protected final boolean flow(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<L> outBefore = state.out;\n      state.out = branchedFlowThrough(node.getValue(), state.in);\n      Preconditions.checkState(outBefore.size() == state.out.size());\n      for (int i = 0; i < outBefore.size(); i++) {\n        if (!outBefore.get(i).equals(state.out.get(i))) {\n          return true;\n        }\n      }\n      return false;\n    }\n",
        "begin_line": 443,
        "end_line": 455,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.joinInputs#457",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis.joinInputs(com.google.javascript.jscomp.graph.DiGraph.DiGraphNode<N, com.google.javascript.jscomp.ControlFlowGraph.Branch>)",
        "snippet": "    @Override\n    protected void joinInputs(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<DiGraphNode<N, Branch>> predNodes =\n          getCfg().getDirectedPredNodes(node);\n      List<L> values = new ArrayList<L>(predNodes.size());\n\n      for (DiGraphNode<N, Branch> predNode : predNodes) {\n        BranchedFlowState<L> predNodeState = predNode.getAnnotation();\n\n        L in = predNodeState.out.get(\n            getCfg().getDirectedSuccNodes(predNode).indexOf(node));\n\n        values.add(in);\n      }\n      if (getCfg().getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else if (!values.isEmpty()) {\n        state.setIn(joinOp.apply(values));\n      }\n    }\n",
        "begin_line": 457,
        "end_line": 477,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.BranchedFlowState#496",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState.BranchedFlowState(L, java.util.List<L>)",
        "snippet": "    private BranchedFlowState(L inState, List<L> outState) {\n      Preconditions.checkNotNull(inState);\n      Preconditions.checkNotNull(outState);\n      this.in = inState;\n      this.out = outState;\n    }\n",
        "begin_line": 496,
        "end_line": 501,
        "comment": "\n     * Private constructor. No other classes should create new states.\n     *\n     * @param inState Input.\n     * @param outState Output.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "DataFlowAnalysis.setIn#507",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/DataFlowAnalysis.java",
        "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
        "signature": "com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState.setIn(L)",
        "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }\n",
        "begin_line": 507,
        "end_line": 510,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.getTypeValidator#1264",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getTypeValidator()",
        "snippet": "  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n",
        "begin_line": 1264,
        "end_line": 1270,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.defineDelegateProxyPrototypeProperties#194",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.defineDelegateProxyPrototypeProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.util.List<com.google.javascript.rhino.jstype.ObjectType>, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      nextConvention.defineDelegateProxyPrototypeProperties(\n          registry, scope, delegateProxyPrototypes, delegateCallingConventions);\n    }\n",
        "begin_line": 194,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.defineDelegateProxyPrototypeProperties#385",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.defineDelegateProxyPrototypeProperties(com.google.javascript.rhino.jstype.JSTypeRegistry, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, java.util.List<com.google.javascript.rhino.jstype.ObjectType>, java.util.Map<java.lang.String, java.lang.String>)",
        "snippet": "    @Override\n    public void defineDelegateProxyPrototypeProperties(\n        JSTypeRegistry registry, StaticScope<JSType> scope,\n        List<ObjectType> delegateProxyPrototypes,\n        Map<String, String> delegateCallingConventions) {\n      // do nothing.\n    }\n",
        "begin_line": 385,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeOptimizationsPass.reportChange#85",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java",
        "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
        "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.PeepholeChangeHandler.reportChange()",
        "snippet": "    @Override\n    public void reportChange() {\n      traversalState.peek().changed = true;\n    }\n",
        "begin_line": 85,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0533
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractPeepholeOptimization.reportCodeChange#61",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.reportCodeChange()",
        "snippet": "  protected void reportCodeChange() {\n    Preconditions.checkNotNull(compiler);\n    compiler.reportCodeChange();\n  }\n",
        "begin_line": 61,
        "end_line": 64,
        "comment": "\n   * Helper method for telling the compiler that something has changed.\n   * Subclasses must call these if they have changed the AST.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0533
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isFromExterns#1108",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isFromExterns()",
        "snippet": "  public boolean isFromExterns() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? false : file.isExtern();\n  }\n",
        "begin_line": 1108,
        "end_line": 1111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0527
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.getOneAndOnlyAssignment#444",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection.getOneAndOnlyAssignment()",
        "snippet": "    private Reference getOneAndOnlyAssignment() {\n      Reference assignment = null;\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        Reference ref = references.get(i);\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          if (assignment == null) {\n            assignment = ref;\n          } else {\n            return null;\n          }\n        }\n      }\n      return assignment;\n    }\n",
        "begin_line": 444,
        "end_line": 458,
        "comment": "\n     * @return The one and only assignment. Returns if there are 0 or 2+\n     *    assignments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0527
        },
        "num_failing_tests": 1
    },
    {
        "name": "InlineVariables.apply#111",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/InlineVariables.java",
        "class_name": "com.google.javascript.jscomp.InlineVariables",
        "signature": "com.google.javascript.jscomp.InlineVariables.IdentifyConstants.apply(com.google.javascript.jscomp.Scope.Var)",
        "snippet": "    @Override\n    public boolean apply(Var var) {\n      return var.isConst();\n    }\n",
        "begin_line": 111,
        "end_line": 114,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0527
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.shouldTraverse#176",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback.shouldTraverse(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }\n",
        "begin_line": 176,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.getSynthesizedExternsInput#2372",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.getSynthesizedExternsInput()",
        "snippet": "  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n",
        "begin_line": 2372,
        "end_line": 2378,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodeConsumer.listSeparator#123",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodeConsumer.java",
        "class_name": "com.google.javascript.jscomp.CodeConsumer",
        "signature": "com.google.javascript.jscomp.CodeConsumer.listSeparator()",
        "snippet": "  void listSeparator() {\n    add(\",\");\n    maybeLineBreak();\n  }\n",
        "begin_line": 123,
        "end_line": 126,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 1
    },
    {
        "name": "Scope.getNameNode#242",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Scope.java",
        "class_name": "com.google.javascript.jscomp.Scope",
        "signature": "com.google.javascript.jscomp.Scope.Var.getNameNode()",
        "snippet": "    public Node getNameNode() {\n      return nameNode;\n    }\n",
        "begin_line": 242,
        "end_line": 244,
        "comment": "\n     * Returns the name node that produced this variable.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isInitializingDeclaration#575",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isInitializingDeclaration()",
        "snippet": "    boolean isInitializingDeclaration() {\n      // VAR is the only type of variable declaration that may not initialize\n      // its variable. Catch blocks, named functions, and parameters all do.\n      return isDeclaration() &&\n          !getParent().isVar() ||\n          nameNode.getFirstChild() != null;\n    }\n",
        "begin_line": 575,
        "end_line": 581,
        "comment": "\n     * Determines whether the variable is initialized at the declaration.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.getAssignedValue#587",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.getAssignedValue()",
        "snippet": "    Node getAssignedValue() {\n      Node parent = getParent();\n      return (parent.isFunction())\n          ? parent : NodeUtil.getAssignedValue(nameNode);\n    }\n",
        "begin_line": 587,
        "end_line": 591,
        "comment": "\n    * @return For an assignment, variable declaration, or function declaration\n    * return the assigned value, otherwise null.\n    ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "ReferenceCollectingCallback.isLvalue#620",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java",
        "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
        "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.isLvalue()",
        "snippet": "    boolean isLvalue() {\n      Node parent = getParent();\n      int parentType = parent.getType();\n      return (parentType == Token.VAR && nameNode.getFirstChild() != null)\n          || parentType == Token.INC\n          || parentType == Token.DEC\n          || (NodeUtil.isAssignmentOp(parent)\n              && parent.getFirstChild() == nameNode)\n          || isLhsOfForInExpression(nameNode);\n    }\n",
        "begin_line": 620,
        "end_line": 629,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalThis.CheckGlobalThis#71",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
        "signature": "com.google.javascript.jscomp.CheckGlobalThis.CheckGlobalThis(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  CheckGlobalThis(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "CheckGlobalThis.visit#154",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java",
        "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
        "signature": "com.google.javascript.jscomp.CheckGlobalThis.visit(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isThis() && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n",
        "begin_line": 154,
        "end_line": 162,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0516
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntheticAst.SyntheticAst#37",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntheticAst.java",
        "class_name": "com.google.javascript.jscomp.SyntheticAst",
        "signature": "com.google.javascript.jscomp.SyntheticAst.SyntheticAst(java.lang.String)",
        "snippet": "  SyntheticAst(String sourceName) {\n    this.inputId = new InputId(sourceName);\n    this.sourceFile = new SourceFile(sourceName);\n    clearAst();\n  }\n",
        "begin_line": 37,
        "end_line": 41,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntheticAst.getAstRoot#43",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntheticAst.java",
        "class_name": "com.google.javascript.jscomp.SyntheticAst",
        "signature": "com.google.javascript.jscomp.SyntheticAst.getAstRoot(com.google.javascript.jscomp.AbstractCompiler)",
        "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return root;\n  }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntheticAst.clearAst#48",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntheticAst.java",
        "class_name": "com.google.javascript.jscomp.SyntheticAst",
        "signature": "com.google.javascript.jscomp.SyntheticAst.clearAst()",
        "snippet": "  @Override\n  public void clearAst() {\n    root = IR.script();\n    root.setInputId(inputId);\n    root.setStaticSourceFile(sourceFile);\n  }\n",
        "begin_line": 48,
        "end_line": 53,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntheticAst.getInputId#55",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntheticAst.java",
        "class_name": "com.google.javascript.jscomp.SyntheticAst",
        "signature": "com.google.javascript.jscomp.SyntheticAst.getInputId()",
        "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }\n",
        "begin_line": 55,
        "end_line": 58,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "SyntheticAst.getSourceFile#60",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/SyntheticAst.java",
        "class_name": "com.google.javascript.jscomp.SyntheticAst",
        "signature": "com.google.javascript.jscomp.SyntheticAst.getSourceFile()",
        "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }\n",
        "begin_line": 60,
        "end_line": 63,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.getSourceName#2864",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.getSourceName(com.google.javascript.rhino.Node)",
        "snippet": "  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }\n",
        "begin_line": 2864,
        "end_line": 2871,
        "comment": "\n   * @param n The node.\n   * @return The source name property on the node or its ancestors.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.newExternInput#1067",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.newExternInput(java.lang.String)",
        "snippet": "  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n",
        "begin_line": 1067,
        "end_line": 1078,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.051
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.report#648",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.report(com.google.javascript.rhino.Node, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  public void report(Node n, DiagnosticType diagnosticType,\n      String... arguments) {\n    JSError error = JSError.make(getBestSourceFileName(n),\n        n, diagnosticType, arguments);\n    compiler.report(error);\n  }\n",
        "begin_line": 648,
        "end_line": 653,
        "comment": " Reports a diagnostic (error or warning) ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.05
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnionType.isUnknownType#247",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.isUnknownType()",
        "snippet": "  @Override\n  public boolean isUnknownType() {\n    for (JSType t : alternates) {\n      if (t.isUnknownType()) {\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "begin_line": 247,
        "end_line": 255,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0495
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isThrow#2349",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isThrow()",
        "snippet": "  public boolean isThrow() {\n    return this.getType() == Token.THROW;\n  }\n",
        "begin_line": 2349,
        "end_line": 2351,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0495
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateBinaryOp#748",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateBinaryOp(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateBinaryOp(Node n) {\n    validateChildCount(n, 2);\n    validateExpression(n.getFirstChild());\n    validateExpression(n.getLastChild());\n  }\n",
        "begin_line": 748,
        "end_line": 752,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0495
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.replaceChild#704",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.replaceChild(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  public void replaceChild(Node child, Node newChild) {\n    Preconditions.checkArgument(newChild.next == null,\n        \"The new child node has siblings.\");\n    Preconditions.checkArgument(newChild.parent == null,\n        \"The new child node already has a parent.\");\n\n    // Copy over important information.\n    newChild.copyInformationFrom(child);\n\n    newChild.next = child.next;\n    newChild.parent = this;\n    if (child == first) {\n        first = newChild;\n    } else {\n        Node prev = getChildBefore(child);\n        prev.next = newChild;\n    }\n    if (child == last)\n        last = newChild;\n    child.next = null;\n    child.parent = null;\n  }\n",
        "begin_line": 704,
        "end_line": 725,
        "comment": "\n   * Detaches child from Node and replaces it with newChild.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.049
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.removeFirstChild#1617",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.removeFirstChild()",
        "snippet": "  public Node removeFirstChild() {\n    Node child = first;\n    if (child != null) {\n      removeChild(child);\n    }\n    return child;\n  }\n",
        "begin_line": 1617,
        "end_line": 1623,
        "comment": "\n   * Removes the first child of Node. Equivalent to:\n   * node.removeChild(node.getFirstChild());\n   *\n   * @return The removed Node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0486
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isExprCall#1606",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isExprCall(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isExprCall(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isCall();\n  }\n",
        "begin_line": 1606,
        "end_line": 1609,
        "comment": "\n   * Is this node a call expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is CALL\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0486
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.evaluatesToLocalValue#2924",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(com.google.javascript.rhino.Node, com.google.common.base.Predicate<com.google.javascript.rhino.Node>)",
        "snippet": "  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.CAST:\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        return newHasLocalResult(value)\n               || locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.DELPROP:\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n",
        "begin_line": 2924,
        "end_line": 2990,
        "comment": "\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0486
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnionType.toMaybeUnionType#359",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/UnionType.java",
        "class_name": "com.google.javascript.rhino.jstype.UnionType",
        "signature": "com.google.javascript.rhino.jstype.UnionType.toMaybeUnionType()",
        "snippet": "  @Override\n  public UnionType toMaybeUnionType() {\n    return this;\n  }\n",
        "begin_line": 359,
        "end_line": 362,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0481
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeFoldConstants.tryFoldGetProp#1338",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java",
        "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
        "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldGetProp(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldGetProp(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.isGetProp());\n\n    if (left.isObjectLit()) {\n      return tryFoldObjectPropAccess(n, left, right);\n    }\n\n    if (right.isString() &&\n        right.getString().equals(\"length\")) {\n      int knownLength = -1;\n      switch (left.getType()) {\n        case Token.ARRAYLIT:\n          if (mayHaveSideEffects(left)) {\n            // Nope, can't fold this, without handling the side-effects.\n            return n;\n          }\n          knownLength = left.getChildCount();\n          break;\n        case Token.STRING:\n          knownLength = left.getString().length();\n          break;\n        default:\n          // Not a foldable case, forget it.\n          return n;\n      }\n\n      Preconditions.checkState(knownLength != -1);\n      Node lengthNode = IR.number(knownLength);\n      n.getParent().replaceChild(n, lengthNode);\n      reportCodeChange();\n\n      return lengthNode;\n    }\n\n    return n;\n  }\n",
        "begin_line": 1338,
        "end_line": 1373,
        "comment": "\n   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0481
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.createFromTypeNodes#1491",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodes(com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>)",
        "snippet": "  public JSType createFromTypeNodes(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n      // If the type expression doesn't contain any names, just\n      // resolve it anyway.\n      boolean hasNames = hasTypeName(n);\n      if (hasNames) {\n        return new UnresolvedTypeExpression(this, n, sourceName);\n      }\n    }\n    return createFromTypeNodesInternal(n, sourceName, scope);\n  }\n",
        "begin_line": 1491,
        "end_line": 1502,
        "comment": "\n   * Creates a JSType from the nodes representing a type.\n   * @param n The node with type info.\n   * @param sourceName The source file name.\n   * @param scope A scope for doing type name lookups.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0477
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeExpression.evaluate#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSTypeExpression.java",
        "class_name": "com.google.javascript.rhino.JSTypeExpression",
        "signature": "com.google.javascript.rhino.JSTypeExpression.evaluate(com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType>, com.google.javascript.rhino.jstype.JSTypeRegistry)",
        "snippet": "  public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n    root.setJSType(type);\n    return type;\n  }\n",
        "begin_line": 99,
        "end_line": 103,
        "comment": "\n   * Evaluates the type expression into a {@code JSType} object.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0477
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.getType#1112",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.getType()",
        "snippet": "  public JSTypeExpression getType() {\n    return getType(TYPEFIELD_TYPE);\n  }\n",
        "begin_line": 1112,
        "end_line": 1114,
        "comment": "\n   * Gets the type specified by the {@code @type} annotation.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0477
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSTypeRegistry.getType#880",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSTypeRegistry.java",
        "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(java.lang.String)",
        "snippet": "  public JSType getType(String jsTypeName) {\n    // TODO(user): Push every local type name out of namesToTypes so that\n    // NamedType#resolve is correct.\n    TemplateType templateType = templateTypes.get(jsTypeName);\n    if (templateType != null) {\n      return templateType;\n    }\n    return namesToTypes.get(jsTypeName);\n  }\n",
        "begin_line": 880,
        "end_line": 888,
        "comment": "\n   * Looks up a type by name.\n   *\n   * @param jsTypeName The name string.\n   * @return the corresponding JSType object or {@code null} it cannot be found\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0472
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.useSourceInfoFrom#1745",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.useSourceInfoFrom(com.google.javascript.rhino.Node)",
        "snippet": "  public Node useSourceInfoFrom(Node other) {\n    putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n    putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE));\n    sourcePosition = other.sourcePosition;\n    return this;\n  }\n",
        "begin_line": 1745,
        "end_line": 1750,
        "comment": "\n   * Overwrite all the source information in this node with\n   * that of {@code other}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0468
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.srcref#1752",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.srcref(com.google.javascript.rhino.Node)",
        "snippet": "  public Node srcref(Node other) {\n    return useSourceInfoFrom(other);\n  }\n",
        "begin_line": 1752,
        "end_line": 1754,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0468
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryFoldSimpleFunctionCall#211",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryFoldSimpleFunctionCall(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }\n",
        "begin_line": 211,
        "end_line": 234,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0468
        },
        "num_failing_tests": 1
    },
    {
        "name": "PeepholeSubstituteAlternateSyntax.tryFoldImmediateCallToBoundFunction#236",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java",
        "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
        "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryFoldImmediateCallToBoundFunction(com.google.javascript.rhino.Node)",
        "snippet": "  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n    // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    Bind bind = getCodingConvention().describeFunctionBind(callTarget, false);\n    if (bind != null) {\n      // replace the call target\n      bind.target.detachFromParent();\n      n.replaceChild(callTarget, bind.target);\n      callTarget = bind.target;\n\n      // push the parameters\n      addParameterAfter(bind.parameters, callTarget);\n\n      // add the this value before the parameters if necessary\n      if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n        // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n        Node newCallTarget = IR.getprop(\n            callTarget.cloneTree(),\n            IR.string(\"call\").srcref(callTarget));\n        n.replaceChild(callTarget, newCallTarget);\n        n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n        n.putBooleanProp(Node.FREE_CALL, false);\n      } else {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n      reportCodeChange();\n    }\n    return n;\n  }\n",
        "begin_line": 236,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0468
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractPeepholeOptimization.getCodingConvention#144",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java",
        "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
        "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.getCodingConvention()",
        "snippet": "  CodingConvention getCodingConvention() {\n    // Note: this assumes a thread safe coding convention object.\n    return compiler.getCodingConvention();\n  }\n",
        "begin_line": 144,
        "end_line": 147,
        "comment": "\n   * @return the current coding convention.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0468
        },
        "num_failing_tests": 1
    },
    {
        "name": "AstValidator.validateReturn#479",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/AstValidator.java",
        "class_name": "com.google.javascript.jscomp.AstValidator",
        "signature": "com.google.javascript.jscomp.AstValidator.validateReturn(com.google.javascript.rhino.Node)",
        "snippet": "  private void validateReturn(Node n) {\n    validateNodeType(Token.RETURN, n);\n    validateMaximumChildCount(n, 1);\n    if (n.hasChildren()) {\n      validateExpression(n.getFirstChild());\n    }\n  }\n",
        "begin_line": 479,
        "end_line": 485,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.046
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.getNameForest#159",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameForest()",
        "snippet": "  List<Name> getNameForest() {\n    ensureGenerated();\n    return globalNames;\n  }\n",
        "begin_line": 159,
        "end_line": 162,
        "comment": "\n   * Gets a list of the roots of the forest of the global names, where the\n   * roots are the top-level names.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0456
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.isCallOrNew#1893",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.isCallOrNew(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean isCallOrNew(Node node) {\n    return node.isCall() || node.isNew();\n  }\n",
        "begin_line": 1893,
        "end_line": 1895,
        "comment": "\n   * @param node A node\n   * @return Whether the call is a NEW or CALL node.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0453
        },
        "num_failing_tests": 1
    },
    {
        "name": "MakeDeclaredNamesUnique.containsSeparator#292",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java",
        "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
        "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenameInverter.containsSeparator(java.lang.String)",
        "snippet": "    private boolean containsSeparator(String name) {\n      return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;\n    }\n",
        "begin_line": 292,
        "end_line": 294,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0453
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.describeFunctionBind#423",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.DefaultCodingConvention.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "    @Override\n    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n      if (!n.isCall()) {\n        return null;\n      }\n\n      Node callTarget = n.getFirstChild();\n      String name = callTarget.getQualifiedName();\n      if (name != null) {\n        if (name.equals(\"Function.prototype.bind.call\")) {\n          // goog.bind(fn, self, args...);\n          Node fn = callTarget.getNext();\n          if (fn == null) {\n            return null;\n          }\n          Node thisValue = safeNext(fn);\n          Node parameters = safeNext(thisValue);\n          return new Bind(fn, thisValue, parameters);\n        }\n      }\n\n      if (callTarget.isGetProp()\n          && callTarget.getLastChild().getString().equals(\"bind\")) {\n        Node maybeFn = callTarget.getFirstChild();\n        JSType maybeFnType = maybeFn.getJSType();\n        FunctionType fnType = null;\n        if (useTypeInfo && maybeFnType != null) {\n          fnType = maybeFnType.restrictByNotNullOrUndefined()\n              .toMaybeFunctionType();\n        }\n\n        if (fnType != null || maybeFn.isFunction()) {\n          // (function(){}).bind(self, args...);\n          Node thisValue = callTarget.getNext();\n          Node parameters = safeNext(thisValue);\n          return new Bind(maybeFn, thisValue, parameters);\n        }\n      }\n\n      return null;\n    }\n",
        "begin_line": 423,
        "end_line": 463,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0453
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.describeFunctionBind#385",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "  @Override\n  public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n    Bind result = super.describeFunctionBind(n, useTypeInfo);\n    if (result != null) {\n      return result;\n    }\n\n    if (!n.isCall()) {\n      return null;\n    }\n\n    Node callTarget = n.getFirstChild();\n    String name = callTarget.getQualifiedName();\n    if (name != null) {\n      if (name.equals(\"goog.bind\")\n          || name.equals(\"goog$bind\")) {\n        // goog.bind(fn, self, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = safeNext(fn);\n        Node parameters = safeNext(thisValue);\n        return new Bind(fn, thisValue, parameters);\n      }\n\n      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n        // goog.partial(fn, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = null;\n        Node parameters = safeNext(fn);\n        return new Bind(fn, thisValue, parameters);\n      }\n    }\n\n    return null;\n  }\n",
        "begin_line": 385,
        "end_line": 424,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0453
        },
        "num_failing_tests": 1
    },
    {
        "name": "ObjectType.setJSDocInfo#158",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/ObjectType.java",
        "class_name": "com.google.javascript.rhino.jstype.ObjectType",
        "signature": "com.google.javascript.rhino.jstype.ObjectType.setJSDocInfo(com.google.javascript.rhino.JSDocInfo)",
        "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n    docInfo = info;\n  }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n   * Sets the docInfo for this type from the given\n   * {@link JSDocInfo}. The {@code JSDocInfo} may be {@code null}.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.report#2067",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.report(com.google.javascript.jscomp.JSError)",
        "snippet": "  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n",
        "begin_line": 2067,
        "end_line": 2083,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConvention.AssertionFunctionSpec#383",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.AssertionFunctionSpec(java.lang.String)",
        "snippet": "    public AssertionFunctionSpec(String functionName) {\n      this(functionName, null);\n    }\n",
        "begin_line": 383,
        "end_line": 385,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConvention.AssertionFunctionSpec#387",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.AssertionFunctionSpec(java.lang.String, com.google.javascript.rhino.jstype.JSTypeNative)",
        "snippet": "    public AssertionFunctionSpec(String functionName,\n        JSTypeNative assertedType) {\n      this.functionName = functionName;\n      this.assertedType = assertedType;\n    }\n",
        "begin_line": 387,
        "end_line": 391,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConvention.getFunctionName#394",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConvention.java",
        "class_name": "com.google.javascript.jscomp.CodingConvention",
        "signature": "com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec.getFunctionName()",
        "snippet": "    public String getFunctionName() {\n      return functionName;\n    }\n",
        "begin_line": 394,
        "end_line": 396,
        "comment": " Returns the name of the function. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.AssertInstanceofSpec#443",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.AssertInstanceofSpec.AssertInstanceofSpec(java.lang.String)",
        "snippet": "    public AssertInstanceofSpec(String functionName) {\n      super(functionName, JSTypeNative.OBJECT_TYPE);\n    }\n",
        "begin_line": 443,
        "end_line": 445,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "ClosureCodingConvention.getAssertionFunctions#367",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java",
        "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
        "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getAssertionFunctions()",
        "snippet": "  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        new AssertInstanceofSpec(\"goog.asserts.assertInstanceof\")\n    );\n  }\n",
        "begin_line": 367,
        "end_line": 383,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0442
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processKeywordLiteral#816",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processKeywordLiteral(com.google.javascript.rhino.head.ast.KeywordLiteral)",
        "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }\n",
        "begin_line": 816,
        "end_line": 819,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0435
        },
        "num_failing_tests": 1
    },
    {
        "name": "CodingConventions.describeFunctionBind#218",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CodingConventions.java",
        "class_name": "com.google.javascript.jscomp.CodingConventions",
        "signature": "com.google.javascript.jscomp.CodingConventions.Proxy.describeFunctionBind(com.google.javascript.rhino.Node, boolean)",
        "snippet": "    @Override\n    public Bind describeFunctionBind(Node n, boolean useTypeInfo) {\n      return nextConvention.describeFunctionBind(n, useTypeInfo);\n    }\n",
        "begin_line": 218,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0435
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processReturnStatement#987",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processReturnStatement(com.google.javascript.rhino.head.ast.ReturnStatement)",
        "snippet": "    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n",
        "begin_line": 987,
        "end_line": 994,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0432
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.hasRegExpGlobalReferences#2345",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.hasRegExpGlobalReferences()",
        "snippet": "  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n",
        "begin_line": 2345,
        "end_line": 2348,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.042
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.getSourceName#426",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
        "snippet": "  public String getSourceName() {\n    return sourceName;\n  }\n",
        "begin_line": 426,
        "end_line": 428,
        "comment": "\n   * Gets the current input source name.\n   *\n   * @return A string that may be empty, but not null\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0417
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isOnlyModifiesThisCall#2076",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isOnlyModifiesThisCall()",
        "snippet": "  public boolean isOnlyModifiesThisCall() {\n    return areBitFlagsSet(\n        getSideEffectFlags() & Node.NO_SIDE_EFFECTS,\n        Node.FLAG_GLOBAL_STATE_UNMODIFIED\n            | Node.FLAG_ARGUMENTS_UNMODIFIED\n            | Node.FLAG_NO_THROWS);\n  }\n",
        "begin_line": 2076,
        "end_line": 2082,
        "comment": "\n   * @return Whether the only side-effect is \"modifies this\"\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0411
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSType.toMaybeFunctionType#381",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/jstype/JSType.java",
        "class_name": "com.google.javascript.rhino.jstype.JSType",
        "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType(com.google.javascript.rhino.jstype.JSType)",
        "snippet": "  public static FunctionType toMaybeFunctionType(JSType type) {\n    return type == null ? null : type.toMaybeFunctionType();\n  }\n",
        "begin_line": 381,
        "end_line": 383,
        "comment": "\n   * Null-safe version of toMaybeFunctionType().\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0408
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSError.make#113",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.make(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  public static JSError make(String sourceName, Node n,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, n, type, arguments);\n  }\n",
        "begin_line": 113,
        "end_line": 116,
        "comment": "\n   * Creates a JSError from a file and Node position.\n   *\n   * @param sourceName The source file name\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0406
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSError.JSError#169",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.JSError(java.lang.String, com.google.javascript.rhino.Node, com.google.javascript.jscomp.DiagnosticType, java.lang.String...)",
        "snippet": "  private JSError(String sourceName, @Nullable Node node,\n                  DiagnosticType type, String... arguments) {\n    this(sourceName,\n         node,\n         (node != null) ? node.getLineno() : -1,\n         (node != null) ? node.getCharno() : -1,\n         type, null, arguments);\n  }\n",
        "begin_line": 169,
        "end_line": 176,
        "comment": "\n   * Creates a JSError for a source file location.  Private to avoid\n   * any entanglement with code outside of the compiler.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0406
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.mayBeExpression#545",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.mayBeExpression(com.google.javascript.rhino.Node)",
        "snippet": "  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n",
        "begin_line": 545,
        "end_line": 617,
        "comment": "\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0395
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.getJSType#1808",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.getJSType()",
        "snippet": "  public JSType getJSType() {\n      return jsType;\n  }\n",
        "begin_line": 1808,
        "end_line": 1810,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.039
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.getBestSourceFileName#687",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getBestSourceFileName(com.google.javascript.rhino.Node)",
        "snippet": "  private String getBestSourceFileName(Node n) {\n    return n == null ? sourceName : n.getSourceFileName();\n  }\n",
        "begin_line": 687,
        "end_line": 689,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.039
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isReturn#2321",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isReturn()",
        "snippet": "  public boolean isReturn() {\n    return this.getType() == Token.RETURN;\n  }\n",
        "begin_line": 2321,
        "end_line": 2323,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0388
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.isNew#2289",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.isNew()",
        "snippet": "  public boolean isNew() {\n    return this.getType() == Token.NEW;\n  }\n",
        "begin_line": 2289,
        "end_line": 2291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0381
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.processStringLiteral#1001",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.TransformDispatcher.processStringLiteral(com.google.javascript.rhino.head.ast.StringLiteral)",
        "snippet": "    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n      String value = literalNode.getValue();\n      Node n = newStringNode(value);\n      if (value.indexOf('\\u000B') != -1) {\n        // NOTE(nicksantos): In JavaScript, there are 3 ways to\n        // represent a vertical tab: \\v, \\x0B, \\u000B.\n        // The \\v notation was added later, and is not understood\n        // on IE. So we need to preserve it as-is. This is really\n        // obnoxious, because we do not have a good way to represent\n        // how the original string was encoded without making the\n        // representation of strings much more complicated.\n        //\n        // To handle this, we look at the original source test, and\n        // mark the string as \\v-encoded or not. If a string is\n        // \\v encoded, then all the vertical tabs in that string\n        // will be encoded with a \\v.\n        int start = literalNode.getAbsolutePosition();\n        int end = start + literalNode.getLength();\n        if (start < sourceString.length() &&\n            (sourceString.substring(\n                 start, Math.min(sourceString.length(), end))\n             .indexOf(\"\\\\v\") != -1)) {\n          n.putBooleanProp(Node.SLASH_V, true);\n        }\n      }\n      return n;\n    }\n",
        "begin_line": 1001,
        "end_line": 1028,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0375
        },
        "num_failing_tests": 1
    },
    {
        "name": "IRFactory.newStringNode#1438",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
        "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
        "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(java.lang.String)",
        "snippet": "  private Node newStringNode(String value) {\n    return IR.string(value).clonePropsFrom(templateNode);\n  }\n",
        "begin_line": 1438,
        "end_line": 1440,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0375
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeUtil.evaluatesToLocalValue#2915",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeUtil.java",
        "class_name": "com.google.javascript.jscomp.NodeUtil",
        "signature": "com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(com.google.javascript.rhino.Node)",
        "snippet": "  static boolean evaluatesToLocalValue(Node value) {\n    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n  }\n",
        "begin_line": 2915,
        "end_line": 2917,
        "comment": "\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0371
        },
        "num_failing_tests": 1
    },
    {
        "name": "NodeTraversal.getModule#440",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/NodeTraversal.java",
        "class_name": "com.google.javascript.jscomp.NodeTraversal",
        "signature": "com.google.javascript.jscomp.NodeTraversal.getModule()",
        "snippet": "  public JSModule getModule() {\n    CompilerInput input = getInput();\n    return input == null ? null : input.getModule();\n  }\n",
        "begin_line": 440,
        "end_line": 443,
        "comment": "\n   * Gets the current input module.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0355
        },
        "num_failing_tests": 1
    },
    {
        "name": "Node.newString#503",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/Node.java",
        "class_name": "com.google.javascript.rhino.Node",
        "signature": "com.google.javascript.rhino.Node.newString(java.lang.String)",
        "snippet": "  public static Node newString(String str) {\n    return new StringNode(Token.STRING, str);\n  }\n",
        "begin_line": 503,
        "end_line": 505,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0354
        },
        "num_failing_tests": 1
    },
    {
        "name": "IR.string#442",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/IR.java",
        "class_name": "com.google.javascript.rhino.IR",
        "signature": "com.google.javascript.rhino.IR.string(java.lang.String)",
        "snippet": "  public static Node string(String s) {\n    return Node.newString(s);\n  }\n",
        "begin_line": 442,
        "end_line": 444,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0354
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.handleGet#631",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.handleGet(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String)",
        "snippet": "    void handleGet(NodeTraversal t, Node n, Node parent, String name) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Ref.Type type = Ref.Type.DIRECT_GET;\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.IF:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            break;\n          case Token.CALL:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.CALL_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.NEW:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.DIRECT_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.OR:\n          case Token.AND:\n            // This node is x or y in (x||y) or (x&&y). We only know that an\n            // alias is not getting created for this name if the result is used\n            // in a boolean context or assigned to the same name\n            // (e.g. var a = a || {}).\n            type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            break;\n          case Token.HOOK:\n            if (n != parent.getFirstChild()) {\n              // This node is y or z in (x?y:z). We only know that an alias is\n              // not getting created for this name if the result is assigned to\n              // the same name (e.g. var a = a ? a : {}).\n              type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            }\n            break;\n          case Token.DELPROP:\n            type = Ref.Type.DELETE_PROP;\n            break;\n          default:\n            type = Ref.Type.ALIASING_GET;\n            break;\n        }\n      }\n\n      handleGet(t, n, parent, name, type);\n    }\n",
        "begin_line": 631,
        "end_line": 681,
        "comment": "\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param t The traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0345
        },
        "num_failing_tests": 1
    },
    {
        "name": "GlobalNamespace.handleGet#750",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
        "class_name": "com.google.javascript.jscomp.GlobalNamespace",
        "signature": "com.google.javascript.jscomp.GlobalNamespace.BuildGlobalNamespace.handleGet(com.google.javascript.jscomp.NodeTraversal, com.google.javascript.rhino.Node, com.google.javascript.rhino.Node, java.lang.String, com.google.javascript.jscomp.GlobalNamespace.Ref.Type)",
        "snippet": "    void handleGet(NodeTraversal t, Node n, Node parent,\n        String name, Ref.Type type) {\n      Name nameObj = getOrCreateName(name);\n\n      // No need to look up additional ancestors, since they won't be used.\n      nameObj.addRef(new Ref(t, n, nameObj, type, currentPreOrderIndex++));\n    }\n",
        "begin_line": 750,
        "end_line": 756,
        "comment": "\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param t The current node traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param type The reference type\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0337
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSError.getDefaultLevel#241",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/JSError.java",
        "class_name": "com.google.javascript.jscomp.JSError",
        "signature": "com.google.javascript.jscomp.JSError.getDefaultLevel()",
        "snippet": "  public CheckLevel getDefaultLevel() {\n    return defaultLevel;\n  }\n",
        "begin_line": 241,
        "end_line": 243,
        "comment": " The default level, before any of the WarningsGuards are applied. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.032
        },
        "num_failing_tests": 1
    },
    {
        "name": "CreateSyntheticBlocks.CreateSyntheticBlocks#69",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CreateSyntheticBlocks.java",
        "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks",
        "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks.CreateSyntheticBlocks(com.google.javascript.jscomp.AbstractCompiler, java.lang.String, java.lang.String)",
        "snippet": "  public CreateSyntheticBlocks(AbstractCompiler compiler,\n      String startMarkerName, String endMarkerName) {\n    this.compiler = compiler;\n    this.startMarkerName = startMarkerName;\n    this.endMarkerName = endMarkerName;\n  }\n",
        "begin_line": 69,
        "end_line": 74,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 1
    },
    {
        "name": "CreateSyntheticBlocks.process#76",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/CreateSyntheticBlocks.java",
        "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks",
        "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks.process(com.google.javascript.rhino.Node, com.google.javascript.rhino.Node)",
        "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Find and validate the markers.\n    NodeTraversal.traverse(compiler, root, new Callback());\n\n    // Complain about any unmatched markers.\n    for (Node node : markerStack) {\n      compiler.report(\n          JSError.make(NodeUtil.getSourceName(node),\n          node,\n          UNMATCHED_START_MARKER, startMarkerName));\n    }\n\n    // Add the block for the valid marker sets.\n    for (Marker marker : validMarkers) {\n      addBlocks(marker);\n    }\n  }\n",
        "begin_line": 76,
        "end_line": 93,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0297
        },
        "num_failing_tests": 1
    },
    {
        "name": "LoggerErrorManager.printSummary#63",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/LoggerErrorManager.java",
        "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
        "signature": "com.google.javascript.jscomp.LoggerErrorManager.printSummary()",
        "snippet": "  @Override\n  protected void printSummary() {\n    Level level = (getErrorCount() + getWarningCount() == 0) ?\n        Level.INFO : Level.WARNING;\n    if (getTypedPercent() > 0.0) {\n      logger.log(level, \"{0} error(s), {1} warning(s), {2,number,#.#}% typed\",\n          new Object[] {getErrorCount(), getWarningCount(), getTypedPercent()});\n    } else {\n      if (getErrorCount() + getWarningCount() > 0) {\n        logger.log(level, \"{0} error(s), {1} warning(s)\",\n            new Object[] {getErrorCount(), getWarningCount()});\n      }\n    }\n  }\n",
        "begin_line": 63,
        "end_line": 76,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0286
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfoBuilder.recordModifies#435",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfoBuilder.java",
        "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
        "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordModifies(java.util.Set<java.lang.String>)",
        "snippet": "  public boolean recordModifies(Set<String> modifies) {\n    if (!hasAnySingletonSideEffectTags()\n        && currentInfo.setModifies(modifies)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }\n",
        "begin_line": 435,
        "end_line": 443,
        "comment": "\n   * Records the list of modifies warnings.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 1
    },
    {
        "name": "JSDocInfo.setModifies#756",
        "is_bug": false,
        "src_path": "src/com/google/javascript/rhino/JSDocInfo.java",
        "class_name": "com.google.javascript.rhino.JSDocInfo",
        "signature": "com.google.javascript.rhino.JSDocInfo.setModifies(java.util.Set<java.lang.String>)",
        "snippet": "  boolean setModifies(Set<String> modifies) {\n    lazyInitInfo();\n\n    if (info.modifies != null) {\n      return false;\n    }\n\n    info.modifies = modifies;\n    return true;\n  }\n",
        "begin_line": 756,
        "end_line": 765,
        "comment": "\n   * Sets modifies values.\n   * @param modifies A list of modifies types.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 1
    },
    {
        "name": "JsDocInfoParser.parseModifiesTag#1063",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
        "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
        "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseModifiesTag(com.google.javascript.jscomp.parsing.JsDocToken)",
        "snippet": "  private JsDocToken parseModifiesTag(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      Set<String> modifies = new HashSet<String>();\n      while (true) {\n        if (match(JsDocToken.STRING)) {\n          String name = stream.getString();\n          if (!modifiesAnnotationKeywords.contains(name)\n              && !jsdocBuilder.hasParameter(name)) {\n              parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n                  stream.getLineno(), stream.getCharno());\n          }\n\n          modifies.add(stream.getString());\n          token = next();\n        } else {\n          parser.addParserWarning(\"msg.jsdoc.modifies\",\n              stream.getLineno(), stream.getCharno());\n          return token;\n        }\n\n        if (match(JsDocToken.PIPE)) {\n          token = next();\n        } else {\n          break;\n        }\n      }\n\n      if (!match(JsDocToken.RC)) {\n        parser.addParserWarning(\"msg.jsdoc.modifies\",\n            stream.getLineno(), stream.getCharno());\n      } else {\n        token = next();\n        if (!jsdocBuilder.recordModifies(modifies)) {\n          parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n              stream.getLineno(), stream.getCharno());\n        }\n      }\n    }\n    return token;\n  }\n",
        "begin_line": 1063,
        "end_line": 1102,
        "comment": "\n   * Parse a {@code @modifies} tag of the form\n   * {@code @modifies&#123;this|arguments|param&#125;}.\n   *\n   * @param token The current token.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0275
        },
        "num_failing_tests": 1
    },
    {
        "name": "Compiler.compileModules#613",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/Compiler.java",
        "class_name": "com.google.javascript.jscomp.Compiler",
        "signature": "com.google.javascript.jscomp.Compiler.compileModules(java.util.List<T>, java.util.List<com.google.javascript.jscomp.JSModule>, com.google.javascript.jscomp.CompilerOptions)",
        "snippet": "  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n",
        "begin_line": 613,
        "end_line": 629,
        "comment": "\n   * Compiles a list of modules.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0268
        },
        "num_failing_tests": 1
    },
    {
        "name": "BasicErrorManager.getTypedPercent#99",
        "is_bug": false,
        "src_path": "src/com/google/javascript/jscomp/BasicErrorManager.java",
        "class_name": "com.google.javascript.jscomp.BasicErrorManager",
        "signature": "com.google.javascript.jscomp.BasicErrorManager.getTypedPercent()",
        "snippet": "  @Override\n  public double getTypedPercent() {\n    return typedPercent;\n  }\n",
        "begin_line": 99,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0249
        },
        "num_failing_tests": 1
    }
]