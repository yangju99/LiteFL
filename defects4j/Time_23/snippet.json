[
    {
        "name": "DateTimeZone.forTimeZone#301",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forTimeZone(java.util.TimeZone)",
        "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n",
        "begin_line": 301,
        "end_line": 338,
        "comment": "\n     * Gets a time zone instance for a JDK TimeZone.\n     * <p>\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n     * excluded IDs are the short three letter form (except UTC). This \n     * method will attempt to convert between time zones created using the\n     * short IDs and the full version.\n     * <p>\n     * This method is not designed to parse time zones with rules created by\n     * applications using <code>SimpleTimeZone</code> directly.\n     * \n     * @param zone  the zone to convert, null means default\n     * @return the DateTimeZone object for the zone\n     * @throws IllegalArgumentException if the zone is not recognised\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.getConvertedId#558",
        "is_bug": true,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getConvertedId(java.lang.String)",
        "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n",
        "begin_line": 558,
        "end_line": 598,
        "comment": "\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.setDefault#173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)",
        "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n",
        "begin_line": 173,
        "end_line": 184,
        "comment": "\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0186
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.getDefault#132",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefault()",
        "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n",
        "begin_line": 132,
        "end_line": 162,
        "comment": "\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0176
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.getZone#135",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(java.lang.String)",
        "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }\n",
        "begin_line": 135,
        "end_line": 163,
        "comment": "\n     * If an error is thrown while loading zone data, uncaughtException is\n     * called to log the error and null is returned for this and all future\n     * requests.\n     * \n     * @param id  the id to load\n     * @return the loaded zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.loadZoneData#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)",
        "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException e) {\n            uncaughtException(e);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n    }\n",
        "begin_line": 223,
        "end_line": 242,
        "comment": "\n     * Loads the time zone data for one id.\n     * \n     * @param id  the id to load\n     * @return the zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#739",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.readFrom(java.io.DataInput)",
        "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }\n",
        "begin_line": 739,
        "end_line": 741,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.Recurrence#747",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear, java.lang.String, int)",
        "snippet": "        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\n            iOfYear = ofYear;\n            iNameKey = nameKey;\n            iSaveMillis = saveMillis;\n        }\n",
        "begin_line": 747,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1339",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }\n",
        "begin_line": 1339,
        "end_line": 1377,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.PrecalculatedZone#1497",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder.DSTZone)",
        "snippet": "        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n        {\n            super(id);\n            iTransitions = transitions;\n            iWallOffsets = wallOffsets;\n            iStandardOffsets = standardOffsets;\n            iNameKeys = nameKeys;\n            iTailZone = tailZone;\n        }\n",
        "begin_line": 1497,
        "end_line": 1506,
        "comment": "\n         * Constructor used ONLY for valid input, loaded via static methods.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#481",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(java.io.DataInput)",
        "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }\n",
        "begin_line": 481,
        "end_line": 488,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.OfYear#499",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.OfYear(char, int, int, int, boolean, int)",
        "snippet": "        OfYear(char mode,\n               int monthOfYear,\n               int dayOfMonth,\n               int dayOfWeek, boolean advanceDayOfWeek,\n               int millisOfDay)\n        {\n            if (mode != 'u' && mode != 'w' && mode != 's') {\n                throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n            }\n\n            iMode = mode;\n            iMonthOfYear = monthOfYear;\n            iDayOfMonth = dayOfMonth;\n            iDayOfWeek = dayOfWeek;\n            iAdvance = advanceDayOfWeek;\n            iMillisOfDay = millisOfDay;\n        }\n",
        "begin_line": 499,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1165",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }\n",
        "begin_line": 1165,
        "end_line": 1168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.DSTZone#1174",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder.Recurrence, org.joda.time.tz.DateTimeZoneBuilder.Recurrence)",
        "snippet": "        DSTZone(String id, int standardOffset,\n                Recurrence startRecurrence, Recurrence endRecurrence) {\n            super(id);\n            iStandardOffset = standardOffset;\n            iStartRecurrence = startRecurrence;\n            iEndRecurrence = endRecurrence;\n        }\n",
        "begin_line": 1174,
        "end_line": 1180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }\n",
        "begin_line": 94,
        "end_line": 100,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#109",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }\n",
        "begin_line": 109,
        "end_line": 125,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZoneBuilder.readMillis#182",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)",
        "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }\n",
        "begin_line": 182,
        "end_line": 211,
        "comment": "\n     * Reads encoding generated by writeMillis.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "CachedDateTimeZone.forZone#67",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)",
        "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }\n",
        "begin_line": 67,
        "end_line": 72,
        "comment": "\n     * Returns a new CachedDateTimeZone unless given zone is already cached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "CachedDateTimeZone.CachedDateTimeZone#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)",
        "snippet": "    private CachedDateTimeZone(DateTimeZone zone) {\n        super(zone.getID());\n        iZone = zone;\n        iInfoCache = new Info[cInfoCacheMask + 1];\n    }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.forID#202",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forID(java.lang.String)",
        "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n",
        "begin_line": 202,
        "end_line": 224,
        "comment": "\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0169
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.getID#703",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getID()",
        "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }\n",
        "begin_line": 703,
        "end_line": 706,
        "comment": "\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)",
        "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * ZoneInfoProvider searches the given ClassLoader resource path for\n     * compiled data files. Resources are loaded from the ClassLoader that\n     * loaded this class.\n     *\n     * @throws IOException if directory or map file cannot be read\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)",
        "snippet": "    private ZoneInfoProvider(String resourcePath,\n                             ClassLoader loader, boolean favorSystemLoader) \n        throws IOException\n    {\n        if (resourcePath == null) {\n            throw new IllegalArgumentException(\"No resource path provided\");\n        }\n        if (!resourcePath.endsWith(\"/\")) {\n            resourcePath += '/';\n        }\n\n        iFileDir = null;\n        iResourcePath = resourcePath;\n\n        if (loader == null && !favorSystemLoader) {\n            loader = getClass().getClassLoader();\n        }\n\n        iLoader = loader;\n\n        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n    }\n",
        "begin_line": 103,
        "end_line": 124,
        "comment": "\n     * @param favorSystemLoader when true, use the system class loader if\n     * loader null. When false, use the current class loader if loader is null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.getAvailableIDs#170",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
        "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }\n",
        "begin_line": 170,
        "end_line": 175,
        "comment": "\n     * Gets a list of all the available zone ids.\n     * \n     * @return the zone ids\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.openResource#194",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)",
        "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuffer buf = new StringBuffer(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }\n",
        "begin_line": 194,
        "end_line": 215,
        "comment": "\n     * Opens a resource from file or classpath.\n     * \n     * @param name  the name to open\n     * @return the input stream\n     * @throws IOException if an error occurs\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.loadZoneInfoMap#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)",
        "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException e) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }\n",
        "begin_line": 251,
        "end_line": 264,
        "comment": "\n     * Loads the zone info map.\n     * \n     * @param in  the input stream\n     * @return the map\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "ZoneInfoProvider.readZoneInfoMap#272",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(java.io.DataInputStream, java.util.Map<java.lang.String, java.lang.Object>)",
        "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }\n",
        "begin_line": 272,
        "end_line": 289,
        "comment": "\n     * Reads the zone info map from file.\n     * \n     * @param din  the input stream\n     * @param zimap  gets filled with string id to string id mappings\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "FixedDateTimeZone.FixedDateTimeZone#36",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)",
        "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }\n",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "FixedDateTimeZone.equals#87",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }\n",
        "begin_line": 87,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultNameProvider.DefaultNameProvider#39",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
        "snippet": "    public DefaultNameProvider() {\n    }\n",
        "begin_line": 39,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DefaultNameProvider.createCache#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
        "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.setProvider0#414",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)",
        "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n",
        "begin_line": 414,
        "end_line": 431,
        "comment": "\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.getDefaultProvider#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
        "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n",
        "begin_line": 442,
        "end_line": 474,
        "comment": "\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.setNameProvider0#513",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)",
        "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n",
        "begin_line": 513,
        "end_line": 518,
        "comment": "\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.getDefaultNameProvider#528",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
        "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n",
        "begin_line": 528,
        "end_line": 549,
        "comment": "\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    },
    {
        "name": "DateTimeZone.DateTimeZone#688",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)",
        "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n",
        "begin_line": 688,
        "end_line": 693,
        "comment": "\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0167
        },
        "num_failing_tests": 1
    }
]