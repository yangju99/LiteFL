[
    {
        "name": "FastMath.nextAfter#3249",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.nextAfter(double, double)",
        "snippet": "    public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n\n    }\n",
        "begin_line": 3249,
        "end_line": 3272,
        "comment": "\n     * Get the next machine representable number after a number, moving\n     * in the direction of another number.\n     * <p>\n     * The ordering is as follows (increasing):\n     * <ul>\n     * <li>-INFINITY</li>\n     * <li>-MAX_VALUE</li>\n     * <li>-MIN_VALUE</li>\n     * <li>-0.0</li>\n     * <li>+0.0</li>\n     * <li>+MIN_VALUE</li>\n     * <li>+MAX_VALUE</li>\n     * <li>+INFINITY</li>\n     * <li></li>\n     * <p>\n     * If arguments compare equal, then the second argument is returned.\n     * <p>\n     * If {@code direction} is greater than {@code d},\n     * the smallest machine representable number strictly greater than\n     * {@code d} is returned; if less, then the largest representable number\n     * strictly less than {@code d} is returned.</p>\n     * <p>\n     * If {@code d} is infinite and direction does not\n     * bring it back to finite numbers, it is returned unchanged.</p>\n     *\n     * @param d base number\n     * @param direction (the only important thing is whether\n     * {@code direction} is greater or smaller than {@code d})\n     * @return the next machine representable number in the specified direction\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#242",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator(org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator)",
        "snippet": "  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState == null) {\n\n      yDotKLast = null;\n      v         = null;\n      vectorsInitialized = false;\n\n    } else {\n\n      final int dimension = interpolator.currentState.length;\n\n      yDotKLast    = new double[3][];\n      for (int k = 0; k < yDotKLast.length; ++k) {\n        yDotKLast[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n                         dimension);\n      }\n\n      v = new double[7][];\n      for (int k = 0; k < v.length; ++k) {\n        v[k] = new double[dimension];\n        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n      }\n\n      vectorsInitialized = interpolator.vectorsInitialized;\n\n    }\n\n  }\n",
        "begin_line": 242,
        "end_line": 273,
        "comment": " Copy constructor.\n   * @param interpolator interpolator to copy from. The copy is a deep\n   * copy: its arrays are separated from the original arrays of the\n   * instance\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doCopy#276",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doCopy()",
        "snippet": "  @Override\n  protected StepInterpolator doCopy() {\n    return new DormandPrince853StepInterpolator(this);\n  }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Really copy the finalized instance.\n    * <p>This method is called by {@link #copy()} after the\n    * step has been finalized. It must perform a deep copy\n    * to have an new instance completely independent for the\n    * original instance.\n    * @return a copy of the finalized instance\n    "
        },
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.reinitialize#282",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  @Override\n  public void reinitialize(final AbstractIntegrator integrator,\n                           final double[] y, final double[][] yDotK, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n\n    super.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\n\n    final int dimension = currentState.length;\n\n    yDotKLast = new double[3][];\n    for (int k = 0; k < yDotKLast.length; ++k) {\n      yDotKLast[k] = new double[dimension];\n    }\n\n    v = new double[7][];\n    for (int k = 0; k < v.length; ++k) {\n      v[k]  = new double[dimension];\n    }\n\n    vectorsInitialized = false;\n\n  }\n",
        "begin_line": 282,
        "end_line": 304,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   "
        },
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.storeTime#307",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.storeTime(double)",
        "snippet": "  @Override\n  public void storeTime(final double t) {\n    super.storeTime(t);\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 307,
        "end_line": 311,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Store the current step time.\n   * @param t current time\n   "
        },
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doFinalize#404",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doFinalize()",
        "snippet": "  @Override\n  protected void doFinalize() {\n\n    if (currentState == null) {\n      // we are finalizing an uninitialized instance\n      return;\n    }\n\n    double s;\n    final double[] yTmp = new double[currentState.length];\n    final double pT = getGlobalPreviousTime();\n\n    // k14\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n\n    // k15\n    for (int j = 0; j < currentState.length; ++j) {\n     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n         K15_14 * yDotKLast[0][j];\n     yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n\n    // k16\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n\n  }\n",
        "begin_line": 404,
        "end_line": 445,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": "\n   * Really finalize the step.\n   * The default implementation of this method does nothing.\n   "
        },
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.DormandPrince853Integrator#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator(double, double, double, double)",
        "snippet": "  public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n          new DormandPrince853StepInterpolator(),\n          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n  }\n",
        "begin_line": 217,
        "end_line": 223,
        "comment": " Simple constructor.\n   * Build an eighth order Dormand-Prince integrator with the given step bounds\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1826
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#230",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator()",
        "snippet": "  public DormandPrince853StepInterpolator() {\n    super();\n    yDotKLast = null;\n    v         = null;\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 230,
        "end_line": 235,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n   * prototyping design pattern to create the step interpolators by\n   * cloning an uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.getOrder#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.getOrder()",
        "snippet": "  @Override\n  public int getOrder() {\n    return 8;\n  }\n",
        "begin_line": 245,
        "end_line": 248,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator": " Get the order of the method.\n   * @return order of the method\n   "
        },
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3469",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.min(double, double)",
        "snippet": "    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n",
        "begin_line": 3469,
        "end_line": 3487,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1622
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.integrate#190",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // local error is small enough: accept the step, trigger events and step handlers\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              // save the last evaluation for the next step\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // stepsize control for next step\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n",
        "begin_line": 190,
        "end_line": 328,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": " {@inheritDoc} ",
            "org.apache.commons.math.ode.AbstractIntegrator": " Integrate a set of differential equations up to the given time.\n     * <p>This method solves an Initial Value Problem (IVP).</p>\n     * <p>The set of differential equations is composed of a main set, which\n     * can be extended by some sets of secondary equations. The set of\n     * equations must be already set up with initial time and partial states.\n     * At integration completion, the final time and partial states will be\n     * available in the same object.</p>\n     * <p>Since this method stores some internal state variables made\n     * available in its public interface during integration ({@link\n     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n     * @param equations complete set of differential equations to integrate\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws MathIllegalStateException if the integrator cannot perform integration\n     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n     * too small integration span)\n     "
        },
        "susp": {
            "ochiai_susp": 0.1459
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator#108",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator(java.lang.String, boolean, double[], double[][], double[], org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator, double, double, double, double)",
        "snippet": "  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n",
        "begin_line": 108,
        "end_line": 130,
        "comment": " Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1361
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator(java.lang.String, double, double, double, double)",
        "snippet": "  public AdaptiveStepsizeIntegrator(final String name,\n                                    final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n\n    super(name);\n    setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n    resetInternalState();\n\n  }\n",
        "begin_line": 105,
        "end_line": 114,
        "comment": " Build an integrator with the given stepsize bounds.\n   * The default step handler does nothing.\n   * @param name name of the method\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.setStepSizeControl#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.setStepSizeControl(double, double, double, double)",
        "snippet": "  public void setStepSizeControl(final double minimalStep, final double maximalStep,\n                                 final double absoluteTolerance,\n                                 final double relativeTolerance) {\n\n      minStep     = FastMath.abs(minimalStep);\n      maxStep     = FastMath.abs(maximalStep);\n      initialStep = -1;\n\n      scalAbsoluteTolerance = absoluteTolerance;\n      scalRelativeTolerance = relativeTolerance;\n      vecAbsoluteTolerance  = null;\n      vecRelativeTolerance  = null;\n\n  }\n",
        "begin_line": 153,
        "end_line": 166,
        "comment": " Set the adaptive step size control parameters.\n   * <p>\n   * A side effect of this method is to also reset the initial\n   * step so it will be automatically computed by the integrator\n   * if {@link #setInitialStepSize(double) setInitialStepSize}\n   * is not called by the user.\n   * </p>\n   * @param minimalStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maximalStep maximal step (must be positive even for backward\n   * integration)\n   * @param absoluteTolerance allowed absolute error\n   * @param relativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1348
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.exp#817",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.exp(double, double, double[])",
        "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n",
        "begin_line": 817,
        "end_line": 932,
        "comment": "\n     * Internal helper method for exponential function.\n     * @param x original argument of the exponential function\n     * @param extra extra bits of precision on input (To Be Confirmed)\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.initializeStep#246",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.initializeStep(boolean, int, double[], double, double[], double[], double[], double[])",
        "snippet": "  public double initializeStep(final boolean forward, final int order, final double[] scale,\n                               final double t0, final double[] y0, final double[] yDot0,\n                               final double[] y1, final double[] yDot1) {\n\n    if (initialStep > 0) {\n      // use the user provided value\n      return forward ? initialStep : -initialStep;\n    }\n\n    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n    // this guess will be used to perform an Euler step\n    double ratio;\n    double yOnScale2 = 0;\n    double yDotOnScale2 = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = y0[j] / scale[j];\n      yOnScale2    += ratio * ratio;\n      ratio         = yDot0[j] / scale[j];\n      yDotOnScale2 += ratio * ratio;\n    }\n\n    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n               1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\n    if (! forward) {\n      h = -h;\n    }\n\n    // perform an Euler step using the preceding rough guess\n    for (int j = 0; j < y0.length; ++j) {\n      y1[j] = y0[j] + h * yDot0[j];\n    }\n    computeDerivatives(t0 + h, y1, yDot1);\n\n    // estimate the second derivative of the solution\n    double yDDotOnScale = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n      yDDotOnScale += ratio * ratio;\n    }\n    yDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\n\n    // step size is computed such that\n    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n    final double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\n    final double h1 = (maxInv2 < 1.0e-15) ?\n                      FastMath.max(1.0e-6, 0.001 * FastMath.abs(h)) :\n                      FastMath.pow(0.01 / maxInv2, 1.0 / order);\n    h = FastMath.min(100.0 * FastMath.abs(h), h1);\n    h = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\n    if (h < getMinStep()) {\n      h = getMinStep();\n    }\n    if (h > getMaxStep()) {\n      h = getMaxStep();\n    }\n    if (! forward) {\n      h = -h;\n    }\n\n    return h;\n\n  }\n",
        "begin_line": 246,
        "end_line": 307,
        "comment": " Initialize the integration step.\n   * @param forward forward integration indicator\n   * @param order order of the method\n   * @param scale scaling vector for the state vector (can be shorter than state vector)\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param yDot0 first time derivative of y0\n   * @param y1 work array for a state vector\n   * @param yDot1 work array for the first time derivative of y1\n   * @return first integration step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.getMinStep#361",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMinStep()",
        "snippet": "  public double getMinStep() {\n    return minStep;\n  }\n",
        "begin_line": 361,
        "end_line": 363,
        "comment": " Get the minimal step.\n   * @return minimal step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.getMaxStep#368",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMaxStep()",
        "snippet": "  public double getMaxStep() {\n    return maxStep;\n  }\n",
        "begin_line": 368,
        "end_line": 370,
        "comment": " Get the maximal step.\n   * @return maximal step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getTotalDimension#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getTotalDimension()",
        "snippet": "    public int getTotalDimension() {\n        if (components.isEmpty()) {\n            // there are no secondary equations, the complete set is limited to the primary set\n            return primaryMapper.getDimension();\n        } else {\n            // there are secondary equations, the complete set ends after the last set\n            final EquationsMapper lastMapper = components.get(components.size() - 1).mapper;\n            return lastMapper.getFirstIndex() + lastMapper.getDimension();\n        }\n    }\n",
        "begin_line": 95,
        "end_line": 104,
        "comment": " Return the dimension of the complete set of equations.\n     * <p>\n     * The complete set of equations correspond to the primary set plus all secondary sets.\n     * </p>\n     * @return dimension of the complete set of equations\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1325
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.integrate#211",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0, final double t, final double[] y)\n        throws MathIllegalStateException, MathIllegalArgumentException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        // prepare expandable stateful equations\n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        // perform integration\n        integrate(expandableODE, t);\n\n        // extract results back from the stateful equations\n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n",
        "begin_line": 211,
        "end_line": 234,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": " Integrate the differential equations up to the given time.\n   * <p>This method solves an Initial Value Problem (IVP).</p>\n   * <p>Since this method stores some internal state variables made\n   * available in its public interface during integration ({@link\n   * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n   * @param equations differential equations to integrate\n   * @param t0 initial time\n   * @param y0 initial value of the state vector at t0\n   * @param t target time for the integration\n   * (can be set to a value smaller than <code>t0</code> for backward integration)\n   * @param y placeholder where to put the state vector at each successful\n   *  step (and hence at the end of integration), can be the same object as y0\n   * @return stop time, will be the same as target time if integration reached its\n   * target, but may be different if some {@link\n   * org.apache.commons.math.ode.events.EventHandler} stops it at some point.\n   * @throws MathIllegalStateException if the integrator cannot perform integration\n   * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n   * too small integration span)\n   "
        },
        "susp": {
            "ochiai_susp": 0.1302
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator(org.apache.commons.math.ode.sampling.AbstractStepInterpolator)",
        "snippet": "  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\n    globalPreviousTime = interpolator.globalPreviousTime;\n    globalCurrentTime  = interpolator.globalCurrentTime;\n    softPreviousTime   = interpolator.softPreviousTime;\n    softCurrentTime    = interpolator.softCurrentTime;\n    h                  = interpolator.h;\n    interpolatedTime   = interpolator.interpolatedTime;\n\n    if (interpolator.currentState == null) {\n        currentState     = null;\n        primaryMapper    = null;\n        secondaryMappers = null;\n        allocateInterpolatedArrays(-1);\n    } else {\n      currentState                     = interpolator.currentState.clone();\n      interpolatedState                = interpolator.interpolatedState.clone();\n      interpolatedDerivatives          = interpolator.interpolatedDerivatives.clone();\n      interpolatedPrimaryState         = interpolator.interpolatedPrimaryState.clone();\n      interpolatedPrimaryDerivatives   = interpolator.interpolatedPrimaryDerivatives.clone();\n      interpolatedSecondaryState       = new double[interpolator.interpolatedSecondaryState.length][];\n      interpolatedSecondaryDerivatives = new double[interpolator.interpolatedSecondaryDerivatives.length][];\n      for (int i = 0; i < interpolatedSecondaryState.length; ++i) {\n          interpolatedSecondaryState[i]       = interpolator.interpolatedSecondaryState[i].clone();\n          interpolatedSecondaryDerivatives[i] = interpolator.interpolatedSecondaryDerivatives[i].clone();\n      }\n    }\n\n    finalized        = interpolator.finalized;\n    forward          = interpolator.forward;\n    dirtyState       = interpolator.dirtyState;\n    primaryMapper    = interpolator.primaryMapper;\n    secondaryMappers = (interpolator.secondaryMappers == null) ?\n                       null : interpolator.secondaryMappers.clone();\n\n  }\n",
        "begin_line": 171,
        "end_line": 206,
        "comment": " Copy constructor.\n\n   * <p>The copied interpolator should have been finalized before the\n   * copy, otherwise the copy will not be able to perform correctly\n   * any derivative computation and will throw a {@link\n   * NullPointerException} later. Since we don't want this constructor\n   * to throw the exceptions finalization may involve and since we\n   * don't want this method to modify the state of the copied\n   * interpolator, finalization is <strong>not</strong> done\n   * automatically, it remains under user control.</p>\n\n   * <p>The copy is a deep copy: its arrays are separated from the\n   * original arrays of the instance.</p>\n\n   * @param interpolator interpolator to copy from.\n\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.reinitialize#244",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.reinitialize(double[], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  protected void reinitialize(final double[] y, final boolean isForward,\n                              final EquationsMapper primary,\n                              final EquationsMapper[] secondary) {\n\n    globalPreviousTime    = Double.NaN;\n    globalCurrentTime     = Double.NaN;\n    softPreviousTime      = Double.NaN;\n    softCurrentTime       = Double.NaN;\n    h                     = Double.NaN;\n    interpolatedTime      = Double.NaN;\n    currentState          = y;\n    finalized             = false;\n    this.forward          = isForward;\n    this.dirtyState       = true;\n    this.primaryMapper    = primary;\n    this.secondaryMappers = secondary.clone();\n    allocateInterpolatedArrays(y.length);\n\n  }\n",
        "begin_line": 244,
        "end_line": 262,
        "comment": " Reinitialize the instance\n   * @param y reference to the integrator array holding the state at the end of the step\n   * @param isForward integration direction indicator\n   * @param primary equations mapper for the primary equations set\n   * @param secondary equations mappers for the secondary equations sets\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator(org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator)",
        "snippet": "  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState != null) {\n\n      previousState = interpolator.previousState.clone();\n\n      yDotK = new double[interpolator.yDotK.length][];\n      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n        yDotK[k] = interpolator.yDotK[k].clone();\n      }\n\n    } else {\n      previousState = null;\n      yDotK = null;\n    }\n\n    // we cannot keep any reference to the equations in the copy\n    // the interpolator should have been finalized before\n    integrator = null;\n\n  }\n",
        "begin_line": 83,
        "end_line": 105,
        "comment": " Copy constructor.\n\n  * <p>The copied interpolator should have been finalized before the\n  * copy, otherwise the copy will not be able to perform correctly any\n  * interpolation and will throw a {@link NullPointerException}\n  * later. Since we don't want this constructor to throw the\n  * exceptions finalization may involve and since we don't want this\n  * method to modify the state of the copied interpolator,\n  * finalization is <strong>not</strong> done automatically, it\n  * remains under user control.</p>\n\n  * <p>The copy is a deep copy: its arrays are separated from the\n  * original arrays of the instance.</p>\n\n  * @param interpolator interpolator to copy from.\n\n  ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.reinitialize#130",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
        "begin_line": 130,
        "end_line": 138,
        "comment": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.shift#141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.shift()",
        "snippet": "  @Override\n  public void shift() {\n    previousState = currentState.clone();\n    super.shift();\n  }\n",
        "begin_line": 141,
        "end_line": 145,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Shift one step forward.\n   * Copy the current time into the previous time, hence preparing the\n   * interpolator for future calls to {@link #storeTime storeTime}\n   "
        },
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.computeDerivatives#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.computeDerivatives(double, double[], double[])",
        "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n\n        // compute derivatives of the primary equations\n        primaryMapper.extractEquationData(y, primaryState);\n        primary.computeDerivatives(t, primaryState, primaryStateDot);\n        primaryMapper.insertEquationData(primaryStateDot, yDot);\n\n        // Add contribution for secondary equations\n        for (final SecondaryComponent component : components) {\n            component.mapper.extractEquationData(y, component.state);\n            component.equation.computeDerivatives(t, primaryState, primaryStateDot,\n                                                  component.state, component.stateDot);\n            component.mapper.insertEquationData(component.stateDot, yDot);\n        }\n\n    }\n",
        "begin_line": 111,
        "end_line": 126,
        "comment": " Get the current time derivative of the complete state vector.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the complete state vector\n     * @param yDot placeholder array where to put the time derivative of the complete state vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.computeDerivatives#262",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.computeDerivatives(double, double[], double[])",
        "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws MaxCountExceededException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n",
        "begin_line": 262,
        "end_line": 266,
        "comment": " Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntA#6141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntA()",
        "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A;\n    }\n",
        "begin_line": 6141,
        "end_line": 6143,
        "comment": "\n     * Load \"EXP_INT_A\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntB#6149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntB()",
        "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B;\n    }\n",
        "begin_line": 6149,
        "end_line": 6151,
        "comment": "\n     * Load \"EXP_INT_B\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracA#6157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracA()",
        "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A;\n    }\n",
        "begin_line": 6157,
        "end_line": 6159,
        "comment": "\n     * Load \"EXP_FRAC_A\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracB#6165",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracB()",
        "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B;\n    }\n",
        "begin_line": 6165,
        "end_line": 6167,
        "comment": "\n     * Load \"EXP_FRAC_B\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT;\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            double numer = bits & 0x3ffffffffffL;\n            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1105,
        "end_line": 1325,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.pow#1419",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.pow(double, double)",
        "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n",
        "begin_line": 1419,
        "end_line": 1577,
        "comment": "\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3537",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3537,
        "end_line": 3555,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.copy#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.copy()",
        "snippet": "   public StepInterpolator copy() {\n\n     // finalize the step before performing copy\n     finalizeStep();\n\n     // create the new independent instance\n     return doCopy();\n\n   }\n",
        "begin_line": 265,
        "end_line": 273,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": " Copy the instance.\n   * <p>The copied instance is guaranteed to be independent from the\n   * original one. Both can be used with different settings for\n   * interpolated time without any side effect.</p>\n   * @return a deep copy of the instance, which can be used independently.\n   * @see #setInterpolatedTime(double)\n   "
        },
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.finalizeStep#481",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.finalizeStep()",
        "snippet": "  public final void finalizeStep() {\n    if (! finalized) {\n      doFinalize();\n      finalized = true;\n    }\n  }\n",
        "begin_line": 481,
        "end_line": 486,
        "comment": "\n   * Finalize the step.\n\n   * <p>Some embedded Runge-Kutta integrators need fewer functions\n   * evaluations than their counterpart step interpolators. These\n   * interpolators should perform the last evaluations they need by\n   * themselves only if they need them. This method triggers these\n   * extra evaluations. It can be called directly by the user step\n   * handler and it is called automatically if {@link\n   * #setInterpolatedTime} is called.</p>\n\n   * <p>Once this method has been called, <strong>no</strong> other\n   * evaluation will be performed on this step. If there is a need to\n   * have some side effects between the step handler and the\n   * differential equations (for example update some data in the\n   * equations once the step has been done), it is advised to call\n   * this method explicitly from the step handler before these side\n   * effects are set up. If the step handler induces no side effect,\n   * then this method can safely be ignored, it will be called\n   * transparently as needed.</p>\n\n   * <p><strong>Warning</strong>: since the step interpolator provided\n   * to the step handler as a parameter of the {@link\n   * StepHandler#handleStep handleStep} is valid only for the duration\n   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n   * simply store a reference and reuse it later. One should first\n   * finalize the instance, then copy this finalized instance into a\n   * new object that can be kept.</p>\n\n   * <p>This method calls the protected <code>doFinalize</code> method\n   * if it has never been called during this step and set a flag\n   * indicating that it has been called once. It is the <code>\n   * doFinalize</code> method which should perform the evaluations.\n   * This wrapping prevents from calling <code>doFinalize</code> several\n   * times and hence evaluating the differential equations too often.\n   * Therefore, subclasses are not allowed not reimplement it, they\n   * should rather reimplement <code>doFinalize</code>.</p>\n\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.sanityChecks#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.sanityChecks(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "  @Override\n  protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n      throws DimensionMismatchException, NumberIsTooSmallException {\n\n      super.sanityChecks(equations, t);\n\n      mainSetDimension = equations.getPrimaryMapper().getDimension();\n\n      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\n          throw new DimensionMismatchException(mainSetDimension, vecAbsoluteTolerance.length);\n      }\n\n      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != mainSetDimension)) {\n          throw new DimensionMismatchException(mainSetDimension, vecRelativeTolerance.length);\n      }\n\n  }\n",
        "begin_line": 217,
        "end_line": 233,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.AbstractIntegrator": " Integrate a set of differential equations up to the given time.\n     * <p>This method solves an Initial Value Problem (IVP).</p>\n     * <p>The set of differential equations is composed of a main set, which\n     * can be extended by some sets of secondary equations. The set of\n     * equations must be already set up with initial time and partial states.\n     * At integration completion, the final time and partial states will be\n     * available in the same object.</p>\n     * <p>Since this method stores some internal state variables made\n     * available in its public interface during integration ({@link\n     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n     * @param equations complete set of differential equations to integrate\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws MathIllegalStateException if the integrator cannot perform integration\n     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n     * too small integration span)\n     "
        },
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getSecondaryMappers#162",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getSecondaryMappers()",
        "snippet": "    public EquationsMapper[] getSecondaryMappers() {\n        final EquationsMapper[] mappers = new EquationsMapper[components.size()];\n        for (int i = 0; i < mappers.length; ++i) {\n            mappers[i] = components.get(i).mapper;\n        }\n        return mappers;\n    }\n",
        "begin_line": 162,
        "end_line": 168,
        "comment": " Get the equations mappers for the secondary equations sets.\n     * @return equations mappers for the secondary equations sets\n     * @see #getPrimaryMapper()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getCompleteState#282",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getCompleteState()",
        "snippet": "    public double[] getCompleteState() {\n\n        // allocate complete array\n        double[] completeState = new double[getTotalDimension()];\n\n        // set the data\n        primaryMapper.insertEquationData(primaryState, completeState);\n        for (final SecondaryComponent component : components) {\n            component.mapper.insertEquationData(component.state, completeState);\n        }\n\n        return completeState;\n\n    }\n",
        "begin_line": 282,
        "end_line": 295,
        "comment": " Get the complete current state.\n     * @return complete current state\n     * @throws DimensionMismatchException if the dimension of the complete state does not\n     * match the complete equations sets dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.insertEquationData#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.insertEquationData(double[], double[])",
        "snippet": "    public void insertEquationData(double[] equationData, double[] complete)\n        throws DimensionMismatchException {\n        if (equationData.length != dimension) {\n            throw new DimensionMismatchException(equationData.length, dimension);\n        }\n        System.arraycopy(equationData, 0, complete, firstIndex, dimension);\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": " Insert equation data into a complete state or derivative array.\n     * @param equationData equation data to be inserted into the complete array\n     * @param complete placeholder where to put equation data (only the\n     * part corresponding to the equation will be overwritten)\n     * @throws DimensionMismatchException if the dimension of the equation data does not\n     * match the mapper dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.initIntegration#187",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.initIntegration(double, double[], double)",
        "snippet": "    protected void initIntegration(final double t0, final double[] y0, final double t) {\n\n        evaluations.resetCount();\n\n        for (final EventState state : eventsStates) {\n            state.getEventHandler().init(t0, y0, t);\n        }\n\n        for (StepHandler handler : stepHandlers) {\n            handler.init(t0, y0, t);\n        }\n\n        setStateInitialized(false);\n\n    }\n",
        "begin_line": 187,
        "end_line": 201,
        "comment": " Prepare the start of an integration.\n     * @param t0 start value of the independent <i>time</i> variable\n     * @param y0 array containing the start value of the state vector\n     * @param t target time for the integration\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setEquations#206",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setEquations(org.apache.commons.math.ode.ExpandableStatefulODE)",
        "snippet": "    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n",
        "begin_line": 206,
        "end_line": 208,
        "comment": " Set the equations.\n     * @param equations equations to set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setStateInitialized#275",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setStateInitialized(boolean)",
        "snippet": "    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n",
        "begin_line": 275,
        "end_line": 277,
        "comment": " Set the stateInitialized flag.\n     * <p>This method must be called by integrators with the value\n     * {@code false} before they start integration, so a proper lazy\n     * initialization is done automatically on the first step.</p>\n     * @param stateInitialized new value for the flag\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getPrimaryMapper#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getPrimaryMapper()",
        "snippet": "    public EquationsMapper getPrimaryMapper() {\n        return primaryMapper;\n    }\n",
        "begin_line": 154,
        "end_line": 156,
        "comment": " Get an equations mapper for the primary equations set.\n     * @return mapper for the primary set\n     * @see #getSecondaryMappers()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.sanityChecks#401",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.sanityChecks(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "    protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n        throws NumberIsTooSmallException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n",
        "begin_line": 401,
        "end_line": 412,
        "comment": " Check the integration span.\n     * @param equations set of differential equations\n     * @param t target time for the integration\n     * @exception NumberIsTooSmallException if integration span is too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ulp#3031",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.ulp(double)",
        "snippet": "    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n",
        "begin_line": 3031,
        "end_line": 3036,
        "comment": "\n     * Compute least significant bit (Unit in Last Position) for a number.\n     * @param x number from which ulp is requested\n     * @return ulp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.allocateInterpolatedArrays#211",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.allocateInterpolatedArrays(int)",
        "snippet": "  private void allocateInterpolatedArrays(final int dimension) {\n      if (dimension < 0) {\n          interpolatedState                = null;\n          interpolatedDerivatives          = null;\n          interpolatedPrimaryState         = null;\n          interpolatedPrimaryDerivatives   = null;\n          interpolatedSecondaryState       = null;\n          interpolatedSecondaryDerivatives = null;\n      } else {\n          interpolatedState                = new double[dimension];\n          interpolatedDerivatives          = new double[dimension];\n          interpolatedPrimaryState         = new double[primaryMapper.getDimension()];\n          interpolatedPrimaryDerivatives   = new double[primaryMapper.getDimension()];\n          if (secondaryMappers == null) {\n              interpolatedSecondaryState       = null;\n              interpolatedSecondaryDerivatives = null;\n          } else {\n              interpolatedSecondaryState       = new double[secondaryMappers.length][];\n              interpolatedSecondaryDerivatives = new double[secondaryMappers.length][];\n              for (int i = 0; i < secondaryMappers.length; ++i) {\n                  interpolatedSecondaryState[i]       = new double[secondaryMappers[i].getDimension()];\n                  interpolatedSecondaryDerivatives[i] = new double[secondaryMappers[i].getDimension()];\n              }\n          }\n      }\n  }\n",
        "begin_line": 211,
        "end_line": 236,
        "comment": " Allocate the various interpolated states arrays.\n   * @param dimension total dimension (negative if arrays should be set to null)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.shift#288",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.shift()",
        "snippet": "  public void shift() {\n    globalPreviousTime = globalCurrentTime;\n    softPreviousTime   = globalPreviousTime;\n    softCurrentTime    = globalCurrentTime;\n  }\n",
        "begin_line": 288,
        "end_line": 292,
        "comment": " Shift one step forward.\n   * Copy the current time into the previous time, hence preparing the\n   * interpolator for future calls to {@link #storeTime storeTime}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.storeTime#297",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.storeTime(double)",
        "snippet": "  public void storeTime(final double t) {\n\n    globalCurrentTime = t;\n    softCurrentTime   = globalCurrentTime;\n    h                 = globalCurrentTime - globalPreviousTime;\n    setInterpolatedTime(t);\n\n    // the step is not finalized anymore\n    finalized  = false;\n\n  }\n",
        "begin_line": 297,
        "end_line": 307,
        "comment": " Store the current step time.\n   * @param t current time\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.setInterpolatedTime#377",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setInterpolatedTime(double)",
        "snippet": "  public void setInterpolatedTime(final double time) {\n      interpolatedTime = time;\n      dirtyState       = true;\n  }\n",
        "begin_line": 377,
        "end_line": 380,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Set the time of the interpolated point.\n   * <p>Setting the time outside of the current step is now allowed, but\n   * should be used with care since the accuracy of the interpolator will\n   * probably be very poor far from this step. This allowance has been\n   * added to simplify implementation of search algorithms near the\n   * step endpoints.</p>\n   * <p>Setting the time changes the instance internal state. If a\n   * specific state must be preserved, a copy of the instance must be\n   * created using {@link #copy()}.</p>\n   * @param time time of the interpolated point\n   "
        },
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.ExpandableStatefulODE#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.ExpandableStatefulODE(org.apache.commons.math.ode.FirstOrderDifferentialEquations)",
        "snippet": "    public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {\n        final int n          = primary.getDimension();\n        this.primary         = primary;\n        this.primaryMapper   = new EquationsMapper(0, n);\n        this.time            = Double.NaN;\n        this.primaryState    = new double[n];\n        this.primaryStateDot = new double[n];\n        this.components      = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();\n    }\n",
        "begin_line": 72,
        "end_line": 80,
        "comment": " Build an expandable set from its primary ODE set.\n     * @param primary the primary set of differential equations to be integrated.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.setTime#173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.setTime(double)",
        "snippet": "    public void setTime(final double time) {\n        this.time = time;\n    }\n",
        "begin_line": 173,
        "end_line": 175,
        "comment": " Set current time.\n     * @param time current time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getTime#180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getTime()",
        "snippet": "    public double getTime() {\n        return time;\n    }\n",
        "begin_line": 180,
        "end_line": 182,
        "comment": " Get current time.\n     * @return current time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.setPrimaryState#189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.setPrimaryState(double[])",
        "snippet": "    public void setPrimaryState(final double[] primaryState) throws DimensionMismatchException {\n\n        // safety checks\n        if (primaryState.length != this.primaryState.length) {\n            throw new DimensionMismatchException(primaryState.length, this.primaryState.length);\n        }\n\n        // set the data\n        System.arraycopy(primaryState, 0, this.primaryState, 0, primaryState.length);\n\n    }\n",
        "begin_line": 189,
        "end_line": 199,
        "comment": " Set primary part of the current state.\n     * @param primaryState primary part of the current state\n     * @throws DimensionMismatchException if the dimension of the array does not\n     * match the primary set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.extractEquationData#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.extractEquationData(double[], double[])",
        "snippet": "    public void extractEquationData(double[] complete, double[] equationData)\n        throws DimensionMismatchException {\n        if (equationData.length != dimension) {\n            throw new DimensionMismatchException(equationData.length, dimension);\n        }\n        System.arraycopy(complete, firstIndex, equationData, 0, dimension);\n    }\n",
        "begin_line": 75,
        "end_line": 81,
        "comment": " Extract equation data from a complete state or derivative array.\n     * @param complete complete state or derivative array from which\n     * equation data should be retrieved\n     * @param equationData placeholder where to put equation data\n     * @throws DimensionMismatchException if the dimension of the equation data does not\n     * match the mapper dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.126
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.getDimension#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.getDimension()",
        "snippet": "    public int getDimension() {\n        return dimension;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": " Get the dimension of the secondary state parameters.\n     * @return dimension of the secondary state parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.125
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.EquationsMapper#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.EquationsMapper(int, int)",
        "snippet": "    public EquationsMapper(final int firstIndex, final int dimension) {\n        this.firstIndex = firstIndex;\n        this.dimension  = dimension;\n    }\n",
        "begin_line": 49,
        "end_line": 52,
        "comment": " simple constructor.\n     * @param firstIndex index of the first equation element in complete state arrays\n     * @param dimension dimension of the secondary state parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator()",
        "snippet": "  protected AbstractStepInterpolator() {\n    globalPreviousTime = Double.NaN;\n    globalCurrentTime  = Double.NaN;\n    softPreviousTime   = Double.NaN;\n    softCurrentTime    = Double.NaN;\n    h                  = Double.NaN;\n    interpolatedTime   = Double.NaN;\n    currentState       = null;\n    finalized          = false;\n    this.forward       = true;\n    this.dirtyState    = true;\n    primaryMapper      = null;\n    secondaryMappers   = null;\n    allocateInterpolatedArrays(-1);\n  }\n",
        "begin_line": 111,
        "end_line": 125,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. As an example, the {@link\n   * org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator}\n   * class uses the prototyping design pattern to create the step\n   * interpolators by cloning an uninitialized model and latter\n   * initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator()",
        "snippet": "  protected RungeKuttaStepInterpolator() {\n    previousState = null;\n    yDotK         = null;\n    integrator    = null;\n  }\n",
        "begin_line": 60,
        "end_line": 64,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n   * pattern to create the step interpolators by cloning an\n   * uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setSafety#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setSafety(double)",
        "snippet": "  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n",
        "begin_line": 185,
        "end_line": 187,
        "comment": " Set the safety factor for stepsize control.\n   * @param safety safety factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMinReduction#340",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMinReduction(double)",
        "snippet": "  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n",
        "begin_line": 340,
        "end_line": 342,
        "comment": " Set the minimal reduction factor for stepsize control.\n   * @param minReduction minimal reduction factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMaxGrowth#354",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMaxGrowth(double)",
        "snippet": "  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n",
        "begin_line": 354,
        "end_line": 356,
        "comment": " Set the maximal growth factor for stepsize control.\n   * @param maxGrowth maximal growth factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1222
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.resetInternalState#353",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.resetInternalState()",
        "snippet": "  protected void resetInternalState() {\n    stepStart = Double.NaN;\n    stepSize  = FastMath.sqrt(minStep * maxStep);\n  }\n",
        "begin_line": 353,
        "end_line": 356,
        "comment": " Reset internal state to dummy values. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.AbstractIntegrator#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.AbstractIntegrator(java.lang.String)",
        "snippet": "    public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 85,
        "end_line": 95,
        "comment": " Build an instance.\n     * @param name name of the method\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setMaxEvaluations#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n",
        "begin_line": 168,
        "end_line": 170,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Set the maximal number of differential equations function evaluations.\n     * <p>The purpose of this method is to avoid infinite loops which can occur\n     * for example when stringent error constraints are set or when lots of\n     * discrete events are triggered, thus leading to many rejected steps.</p>\n     * @param maxEvaluations maximal number of function evaluations (negative\n     * values are silently converted to maximal integer value, thus representing\n     * almost unlimited evaluations)\n     "
        },
        "susp": {
            "ochiai_susp": 0.1213
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 60,
        "end_line": 68,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int, org.apache.commons.math.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3022",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3022,
        "end_line": 3024,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    }
]