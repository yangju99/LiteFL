[
    {
        "name": "DateTimeFormatter.parseInto#697",
        "is_bug": true,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)",
        "snippet": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n",
        "begin_line": 697,
        "end_line": 724,
        "comment": "\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6831
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.computeMillis#343",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.computeMillis(boolean, java.lang.String)",
        "snippet": "    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iOffset != null) {\n            millis -= iOffset;\n        } else if (iZone != null) {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n",
        "begin_line": 343,
        "end_line": 395,
        "comment": "\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.6236
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.setChronology#328",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.setChronology(org.joda.time.Chronology)",
        "snippet": "    protected void setChronology(Chronology chronology) {\n        iChronology = checkChronology(chronology);\n    }\n",
        "begin_line": 328,
        "end_line": 330,
        "comment": "\n     * Sets the chronology of the datetime.\n     * <p>\n     * All changes to the chronology field occurs via this method.\n     * Override and block this method to make a subclass immutable.\n     *\n     * @param chronology  the chronology to set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5517
        },
        "num_failing_tests": 7
    },
    {
        "name": "MutableDateTime.setChronology#563",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/MutableDateTime.java",
        "class_name": "org.joda.time.MutableDateTime",
        "signature": "org.joda.time.MutableDateTime.setChronology(org.joda.time.Chronology)",
        "snippet": "    public void setChronology(Chronology chronology) {\n        super.setChronology(chronology);\n    }\n",
        "begin_line": 563,
        "end_line": 565,
        "comment": "\n     * Set the chronology of the datetime.\n     * <p>\n     * All changes to the chronology occur via this method.\n     * \n     * @param chronology  the chronology to use, null means ISOChronology in default zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5517
        },
        "num_failing_tests": 7
    },
    {
        "name": "MutableDateTime.MutableDateTime#342",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/MutableDateTime.java",
        "class_name": "org.joda.time.MutableDateTime",
        "signature": "org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)",
        "snippet": "    public MutableDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n    }\n",
        "begin_line": 342,
        "end_line": 353,
        "comment": "\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param zone  the time zone, null means default time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5189
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDurationField.compareTo#145",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.compareTo(org.joda.time.DurationField)",
        "snippet": "    public int compareTo(DurationField otherField) {\n        long otherMillis = otherField.getUnitMillis();\n        long thisMillis = getUnitMillis();\n        // cannot do (thisMillis - otherMillis) as can overflow\n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n",
        "begin_line": 145,
        "end_line": 157,
        "comment": "------------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4606
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.compareReverse#510",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.compareReverse(org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n",
        "begin_line": 510,
        "end_line": 521,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4183
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.sort#415",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.sort(org.joda.time.format.DateTimeParserBucket.SavedField[], int)",
        "snippet": "    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n",
        "begin_line": 415,
        "end_line": 427,
        "comment": "\n     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n     * choice since it always creates an internal copy of the array, even if it\n     * doesn't need to. If the array slice is small enough, an insertion sort\n     * is chosen instead, but it doesn't need a copy!\n     * <p>\n     * This method has a modified version of that insertion sort, except it\n     * doesn't create an unnecessary array copy. If high is over 10, then\n     * java.util.Arrays is called, which will perform a merge sort, which is\n     * faster than insertion sort on large lists.\n     * <p>\n     * The end result is much greater performance when computeMillis is called.\n     * Since the amount of saved fields is small, the insertion sort is a\n     * better choice. Additional performance is gained since there is no extra\n     * array allocation and copying. Also, the insertion sort here does not\n     * perform any casting operations. The version in java.util.Arrays performs\n     * casts within the insertion sort loop.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3859
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.dateTimeNoMillis#970",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.dateTimeNoMillis()",
        "snippet": "    public static DateTimeFormatter dateTimeNoMillis() {\n        if (dtx == null) {\n            dtx = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(tTimeNoMillis())\n                .toFormatter();\n        }\n        return dtx;\n    }\n",
        "begin_line": 970,
        "end_line": 978,
        "comment": "\n     * Returns a formatter that combines a full date and time without millis,\n     * separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3257
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.tTimeNoMillis#934",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.tTimeNoMillis()",
        "snippet": "    public static DateTimeFormatter tTimeNoMillis() {\n        if (ttx == null) {\n            ttx = new DateTimeFormatterBuilder()\n                .append(literalTElement())\n                .append(timeNoMillis())\n                .toFormatter();\n        }\n        return ttx;\n    }\n",
        "begin_line": 934,
        "end_line": 942,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, two digit second of minute, and time zone offset prefixed\n     * by 'T' ('T'HH:mm:ssZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for 'T'HH:mm:ssZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3118
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendDayOfWeekShortText#937",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()",
        "snippet": "    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n",
        "begin_line": 937,
        "end_line": 939,
        "comment": "\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3076
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.timeNoMillis#896",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.timeNoMillis()",
        "snippet": "    public static DateTimeFormatter timeNoMillis() {\n        if (tx == null) {\n            tx = new DateTimeFormatterBuilder()\n                .append(hourMinuteSecond())\n                .append(offsetElement())\n                .toFormatter();\n        }\n        return tx;\n    }\n",
        "begin_line": 896,
        "end_line": 904,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for HH:mm:ssZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3055
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.hourMinuteSecond#1441",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()",
        "snippet": "    public static DateTimeFormatter hourMinuteSecond() {\n        if (hms == null) {\n            hms = new DateTimeFormatterBuilder()\n                .append(hourElement())\n                .append(minuteElement())\n                .append(secondElement())\n                .toFormatter();\n        }\n        return hms;\n    }\n",
        "begin_line": 1441,
        "end_line": 1450,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, and two digit second of minute. (HH:mm:ss)\n     * \n     * @return a formatter for HH:mm:ss\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2996
        },
        "num_failing_tests": 7
    },
    {
        "name": "MutableDateTime.toString#1222",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/MutableDateTime.java",
        "class_name": "org.joda.time.MutableDateTime",
        "signature": "org.joda.time.MutableDateTime.toString()",
        "snippet": "    @ToString\n    public String toString() {\n        return ISODateTimeFormat.dateTime().print(this);\n    }\n",
        "begin_line": 1222,
        "end_line": 1225,
        "comment": "\n     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).\n     * \n     * @return ISO8601 time formatted string.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.287
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.previousTransition#1586",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.previousTransition(long)",
        "snippet": "        public long previousTransition(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            if (i >= 0) {\n                if (instant > Long.MIN_VALUE) {\n                    return instant - 1;\n                }\n                return instant;\n            }\n            i = ~i;\n            if (i < transitions.length) {\n                if (i > 0) {\n                    long prev = transitions[i - 1];\n                    if (prev > Long.MIN_VALUE) {\n                        return prev - 1;\n                    }\n                }\n                return instant;\n            }\n            if (iTailZone != null) {\n                long prev = iTailZone.previousTransition(instant);\n                if (prev < instant) {\n                    return prev;\n                }\n            }\n            long prev = transitions[i - 1];\n            if (prev > Long.MIN_VALUE) {\n                return prev - 1;\n            }\n            return instant;\n        }\n",
        "begin_line": 1586,
        "end_line": 1616,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.276
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendShortText#510",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeFieldType)",
        "snippet": "    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n",
        "begin_line": 510,
        "end_line": 515,
        "comment": "\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2758
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimateParsedLength#1783",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TextField.estimateParsedLength()",
        "snippet": "        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n",
        "begin_line": 1783,
        "end_line": 1785,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2511
        },
        "num_failing_tests": 7
    },
    {
        "name": "MutableDateTime.setMillis#453",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/MutableDateTime.java",
        "class_name": "org.joda.time.MutableDateTime",
        "signature": "org.joda.time.MutableDateTime.setMillis(long)",
        "snippet": "    public void setMillis(long instant) {\n        switch (iRoundingMode) {\n            case ROUND_NONE:\n                break;\n            case ROUND_FLOOR:\n                instant = iRoundingField.roundFloor(instant);\n                break;\n            case ROUND_CEILING:\n                instant = iRoundingField.roundCeiling(instant);\n                break;\n            case ROUND_HALF_FLOOR:\n                instant = iRoundingField.roundHalfFloor(instant);\n                break;\n            case ROUND_HALF_CEILING:\n                instant = iRoundingField.roundHalfCeiling(instant);\n                break;\n            case ROUND_HALF_EVEN:\n                instant = iRoundingField.roundHalfEven(instant);\n                break;\n        }\n\n        super.setMillis(instant);\n    }\n",
        "begin_line": 453,
        "end_line": 475,
        "comment": "\n     * Set the milliseconds of the datetime.\n     * <p>\n     * All changes to the millisecond field occurs via this method.\n     *\n     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n     * datetime to\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2405
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.TextField#1715",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TextField.TextField(org.joda.time.DateTimeFieldType, boolean)",
        "snippet": "        TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n",
        "begin_line": 1715,
        "end_line": 1719,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2395
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#1721",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TextField.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n",
        "begin_line": 1721,
        "end_line": 1723,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2395
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.setMillis#316",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.setMillis(long)",
        "snippet": "    protected void setMillis(long instant) {\n        iMillis = checkInstant(instant, iChronology);\n    }\n",
        "begin_line": 316,
        "end_line": 318,
        "comment": "\n     * Sets the milliseconds of the datetime.\n     * <p>\n     * All changes to the millisecond field occurs via this method.\n     * Override and block this method to make a subclass immutable.\n     *\n     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the datetime to\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2348
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getYear#393",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getYear(long)",
        "snippet": "    int getYear(long instant) {\n        // Get an initial estimate of the year, and the millis value that\n        // represents the start of that year. Then verify estimate and fix if\n        // necessary.\n\n        // Initial estimate uses values divided by two to avoid overflow.\n        long unitMillis = getAverageMillisPerYearDividedByTwo();\n        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n        if (i2 < 0) {\n            i2 = i2 - unitMillis + 1;\n        }\n        int year = (int) (i2 / unitMillis);\n\n        long yearStart = getYearMillis(year);\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            // One year may need to be added to fix estimate.\n            long oneYear;\n            if (isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n\n            if (yearStart <= instant) {\n                // Didn't go too far, so actually add one year.\n                year++;\n            }\n        }\n\n        return year;\n    }\n",
        "begin_line": 393,
        "end_line": 429,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2279
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.withLocale#187",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.withLocale(java.util.Locale)",
        "snippet": "    public DateTimeFormatter withLocale(Locale locale) {\n        if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n            return this;\n        }\n        return new DateTimeFormatter(iPrinter, iParser, locale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n    }\n",
        "begin_line": 187,
        "end_line": 193,
        "comment": "\n     * Returns a new formatter with a different locale that will be used\n     * for printing and parsing.\n     * <p>\n     * A DateTimeFormatter is immutable, so a new instance is returned,\n     * and the original is unaltered and still usable.\n     * \n     * @param locale the locale to use; if null, formatter uses default locale\n     * at invocation time\n     * @return the new formatter\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2268
        },
        "num_failing_tests": 6
    },
    {
        "name": "DateTimeFormatter.getLocale#201",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.getLocale()",
        "snippet": "    public Locale getLocale() {\n        return iLocale;\n    }\n",
        "begin_line": 201,
        "end_line": 203,
        "comment": "\n     * Gets the locale that will be used for printing and parsing.\n     * \n     * @return the locale to use; if null, formatter uses default locale at\n     * invocation time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2268
        },
        "num_failing_tests": 6
    },
    {
        "name": "DateTimeParserBucket.getZone#151",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        return iZone;\n    }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": "\n     * Returns the time zone used by computeMillis.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2085
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormat.parsePatternTo#399",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormat.java",
        "class_name": "org.joda.time.format.DateTimeFormat",
        "signature": "org.joda.time.format.DateTimeFormat.parsePatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)",
        "snippet": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }\n",
        "begin_line": 399,
        "end_line": 563,
        "comment": "\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #forPattern\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.withDefaultYear#436",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.withDefaultYear(int)",
        "snippet": "    public DateTimeFormatter withDefaultYear(int defaultYear) {\n        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n    }\n",
        "begin_line": 436,
        "end_line": 439,
        "comment": "\n     * Returns a new formatter that will use the specified default year.\n     * <p>\n     * The default year is used when parsing in the case where there is a\n     * month or a day but not a year. Specifically, it is used if there is\n     * a field parsed with a duration between the length of a month and the\n     * length of a day inclusive.\n     * <p>\n     * This value is typically used to move the year from 1970 to a leap year\n     * to enable February 29th to be parsed.\n     * Unless customised, the year 2000 is used.\n     * <p>\n     * This setting has no effect when printing.\n     *\n     * @param defaultYear  the default year to use\n     * @return the new formatter, not null\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "ISOChronology.withZone#142",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.withZone(org.joda.time.DateTimeZone)",
        "snippet": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone);\n    }\n",
        "begin_line": 142,
        "end_line": 150,
        "comment": "\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.188
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#1905",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long, org.joda.time.Chronology)",
        "snippet": "        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n            throws IOException\n        {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                // Chop off as many trailing zero digits as necessary.\n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n",
        "begin_line": 1905,
        "end_line": 1987,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.169
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormat.createFormatterForPattern#673",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormat.java",
        "class_name": "org.joda.time.format.DateTimeFormat",
        "signature": "org.joda.time.format.DateTimeFormat.createFormatterForPattern(java.lang.String)",
        "snippet": "    private static DateTimeFormatter createFormatterForPattern(String pattern) {\n        if (pattern == null || pattern.length() == 0) {\n            throw new IllegalArgumentException(\"Invalid pattern specification\");\n        }\n        DateTimeFormatter formatter = null;\n        synchronized (cPatternedCache) {\n            formatter = cPatternedCache.get(pattern);\n            if (formatter == null) {\n                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                parsePatternTo(builder, pattern);\n                formatter = builder.toFormatter();\n\n                cPatternedCache.put(pattern, formatter);\n            }\n        }\n        return formatter;\n    }\n",
        "begin_line": 673,
        "end_line": 689,
        "comment": "\n     * Select a format from a custom pattern.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see #appendPatternTo\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1654
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormat.forPattern#169",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormat.java",
        "class_name": "org.joda.time.format.DateTimeFormat",
        "signature": "org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)",
        "snippet": "    public static DateTimeFormatter forPattern(String pattern) {\n        return createFormatterForPattern(pattern);\n    }\n",
        "begin_line": 169,
        "end_line": 171,
        "comment": "\n     * Factory to create a formatter from a pattern string.\n     * The pattern string is described above in the class level javadoc.\n     * It is very similar to SimpleDateFormat patterns.\n     * <p>\n     * The format may contain locale specific output, and this will change as\n     * you change the locale of the formatter.\n     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n     * For example:\n     * <pre>\n     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);\n     * </pre>\n     *\n     * @param pattern  pattern specification\n     * @return the formatter\n     * @throws IllegalArgumentException if the pattern is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.165
        },
        "num_failing_tests": 7
    },
    {
        "name": "AbstractInstant.equals#257",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractInstant.java",
        "class_name": "org.joda.time.base.AbstractInstant",
        "signature": "org.joda.time.base.AbstractInstant.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object readableInstant) {\n        // must be to fulfil ReadableInstant contract\n        if (this == readableInstant) {\n            return true;\n        }\n        if (readableInstant instanceof ReadableInstant == false) {\n            return false;\n        }\n        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n        return\n            getMillis() == otherInstant.getMillis() &&\n            FieldUtils.equals(getChronology(), otherInstant.getChronology());\n    }\n",
        "begin_line": 257,
        "end_line": 269,
        "comment": "\n     * Compares this object with the specified object for equality based\n     * on the millisecond instant, chronology and time zone.\n     * <p>\n     * Two objects which represent the same instant in time, but are in\n     * different time zones (based on time zone id), will be considered to\n     * be different. Only two objects with the same {@link DateTimeZone},\n     * {@link Chronology} and instant are equal.\n     * <p>\n     * See {@link #isEqual(ReadableInstant)} for an equals method that\n     * ignores the Chronology and time zone.\n     * <p>\n     * All ReadableInstant instances are accepted.\n     *\n     * @param readableInstant  a readable instant to check against\n     * @return true if millisecond and chronology are equal, false if\n     *  not or the instant is null or of an incorrect type\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1613
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormat.parseToken#573",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormat.java",
        "class_name": "org.joda.time.format.DateTimeFormat",
        "signature": "org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])",
        "snippet": "    private static String parseToken(String pattern, int[] indexRef) {\n        StringBuffer buf = new StringBuffer();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }\n",
        "begin_line": 573,
        "end_line": 623,
        "comment": "\n     * Parses an individual token.\n     * \n     * @param pattern  the pattern string\n     * @param indexRef  a single element array, where the input is the start\n     *  location and the output is the location after parsing the token\n     * @return the parsed token\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1607
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.compareTo#498",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.SavedField.compareTo(org.joda.time.format.DateTimeParserBucket.SavedField)",
        "snippet": "        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n",
        "begin_line": 498,
        "end_line": 507,
        "comment": "\n         * The field with the longer range duration is ordered first, where\n         * null is considered infinite. If the ranges match, then the field\n         * with the longer duration is ordered first.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1598
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.BaseDateTime#214",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.BaseDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)",
        "snippet": "    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n    }\n",
        "begin_line": 214,
        "end_line": 225,
        "comment": "\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param zone  the time zone, null means default time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1567
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.set#481",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.SavedField.set(long, boolean)",
        "snippet": "        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n",
        "begin_line": 481,
        "end_line": 491,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1564
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.parseInto#1291",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)",
        "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                // Since value may exceed integer limits, use stock parser\n                // which checks for this.\n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n",
        "begin_line": 1291,
        "end_line": 1354,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1498
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.SavedField#467",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.SavedField.SavedField(org.joda.time.DateTimeField, int)",
        "snippet": "        SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n",
        "begin_line": 467,
        "end_line": 472,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.saveField#245",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n",
        "begin_line": 245,
        "end_line": 247,
        "comment": "\n     * Saves a datetime field value.\n     * \n     * @param fieldType  the field type\n     * @param value  the value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.saveField#260",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket.SavedField)",
        "snippet": "    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            // Expand capacity or merely copy if saved fields are shared.\n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n",
        "begin_line": 260,
        "end_line": 276,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1491
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.dateTime#952",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.dateTime()",
        "snippet": "    public static DateTimeFormatter dateTime() {\n        if (dt == null) {\n            dt = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(tTime())\n                .toFormatter();\n        }\n        return dt;\n    }\n",
        "begin_line": 952,
        "end_line": 960,
        "comment": "\n     * Returns a formatter that combines a full date and time, separated by a 'T'\n     * (yyyy-MM-dd'T'HH:mm:ss.SSSZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1477
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.tTime#915",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.tTime()",
        "snippet": "    public static DateTimeFormatter tTime() {\n        if (tt == null) {\n            tt = new DateTimeFormatterBuilder()\n                .append(literalTElement())\n                .append(time())\n                .toFormatter();\n        }\n        return tt;\n    }\n",
        "begin_line": 915,
        "end_line": 923,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, two digit second of minute, three digit fraction of second, and\n     * time zone offset prefixed by 'T' ('T'HH:mm:ss.SSSZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for 'T'HH:mm:ss.SSSZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1454
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.time#878",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.time()",
        "snippet": "    public static DateTimeFormatter time() {\n        if (t == null) {\n            t = new DateTimeFormatterBuilder()\n                .append(hourMinuteSecondFraction())\n                .append(offsetElement())\n                .toFormatter();\n        }\n        return t;\n    }\n",
        "begin_line": 878,
        "end_line": 886,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, two digit second of minute, three digit fraction of second, and\n     * time zone offset (HH:mm:ss.SSSZZ).\n     * The time zone offset is 'Z' for zero, and of the form '\\u00b1HH:mm' for non-zero.\n     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.\n     * \n     * @return a formatter for HH:mm:ss.SSSZZ\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1437
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#1871",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology, int, org.joda.time.DateTimeZone, java.util.Locale)",
        "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n",
        "begin_line": 1871,
        "end_line": 1879,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1437
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.hourMinuteSecondFraction#1481",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()",
        "snippet": "    public static DateTimeFormatter hourMinuteSecondFraction() {\n        if (hmsf == null) {\n            hmsf = new DateTimeFormatterBuilder()\n                .append(hourElement())\n                .append(minuteElement())\n                .append(secondElement())\n                .append(fractionElement())\n                .toFormatter();\n        }\n        return hmsf;\n    }\n",
        "begin_line": 1481,
        "end_line": 1491,
        "comment": "\n     * Returns a formatter for a two digit hour of day, two digit minute of\n     * hour, two digit second of minute, and three digit fraction of\n     * second (HH:mm:ss.SSS). Parsing will parse up to 9 fractional second\n     * digits, throwing away all except the first three.\n     * \n     * @return a formatter for HH:mm:ss.SSS\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.fractionElement#1690",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.fractionElement()",
        "snippet": "    private static DateTimeFormatter fractionElement() {\n        if (fse == null) {\n            fse = new DateTimeFormatterBuilder()\n                .appendLiteral('.')\n                // Support parsing up to nanosecond precision even though\n                // those extra digits will be dropped.\n                .appendFractionOfSecond(3, 9)\n                .toFormatter();\n        }\n        return fse;\n    }\n",
        "begin_line": 1690,
        "end_line": 1700,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1429
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#2109",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology, int, org.joda.time.DateTimeZone, java.util.Locale)",
        "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n",
        "begin_line": 2109,
        "end_line": 2166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1418
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeParserBucket.DateTimeParserBucket#117",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java",
        "class_name": "org.joda.time.format.DateTimeParserBucket",
        "signature": "org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long, org.joda.time.Chronology, java.util.Locale, java.lang.Integer, int)",
        "snippet": "    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iZone = chrono.getZone();\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n",
        "begin_line": 117,
        "end_line": 127,
        "comment": "\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.141
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.requireParser#923",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.requireParser()",
        "snippet": "    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }\n",
        "begin_line": 923,
        "end_line": 929,
        "comment": "\n     * Checks whether parsing is supported.\n     * \n     * @throws UnsupportedOperationException if parsing is not supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.141
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendDecimal#394",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeFieldType, int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n",
        "begin_line": 394,
        "end_line": 410,
        "comment": "\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1406
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.UnpaddedNumber#1360",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber.UnpaddedNumber(org.joda.time.DateTimeFieldType, int, boolean)",
        "snippet": "        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                       int maxParsedDigits, boolean signed)\n        {\n            super(fieldType, maxParsedDigits, signed);\n        }\n",
        "begin_line": 1360,
        "end_line": 1364,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.14
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.remainder#125",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.remainder(long)",
        "snippet": "    public long remainder(long instant) {\n        if (instant >= 0) {\n            return instant % iUnitMillis;\n        } else {\n            return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n        }\n    }\n",
        "begin_line": 125,
        "end_line": 131,
        "comment": "\n     * This method assumes that this field is properly rounded on\n     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n     * method as follows:\n     * <pre>\n     * return super.remainder(instant + ALIGNMENT_MILLIS);\n     * </pre>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1379
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.date#865",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.date()",
        "snippet": "    public static DateTimeFormatter date() {\n        return yearMonthDay();\n    }\n",
        "begin_line": 865,
        "end_line": 867,
        "comment": "\n     * Returns a formatter for a full date as four digit year, two digit month\n     * of year, and two digit day of month (yyyy-MM-dd).\n     * \n     * @return a formatter for yyyy-MM-dd\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1331
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.getField#281",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.StandardDurationFieldType.getField(org.joda.time.Chronology)",
        "snippet": "        public DurationField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n            \n            switch (iOrdinal) {\n                case ERAS:\n                    return chronology.eras();\n                case CENTURIES:\n                    return chronology.centuries();\n                case WEEKYEARS:\n                    return chronology.weekyears();\n                case YEARS:\n                    return chronology.years();\n                case MONTHS:\n                    return chronology.months();\n                case WEEKS:\n                    return chronology.weeks();\n                case DAYS:\n                    return chronology.days();\n                case HALFDAYS:\n                    return chronology.halfdays();\n                case HOURS:\n                    return chronology.hours();\n                case MINUTES:\n                    return chronology.minutes();\n                case SECONDS:\n                    return chronology.seconds();\n                case MILLIS:\n                    return chronology.millis();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }\n",
        "begin_line": 281,
        "end_line": 313,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.133
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.yearMonthDay#1357",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.yearMonthDay()",
        "snippet": "    public static DateTimeFormatter yearMonthDay() {\n        if (ymd == null) {\n            ymd = new DateTimeFormatterBuilder()\n                .append(yearElement())\n                .append(monthElement())\n                .append(dayOfMonthElement())\n                .toFormatter();\n        }\n        return ymd;\n    }\n",
        "begin_line": 1357,
        "end_line": 1366,
        "comment": "\n     * Returns a formatter for a four digit year, two digit month of year, and\n     * two digit day of month. (yyyy-MM-dd)\n     * \n     * @return a formatter for yyyy-MM-dd\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1323
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#2611",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology, int, org.joda.time.DateTimeZone, java.util.Locale)",
        "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n",
        "begin_line": 2611,
        "end_line": 2628,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1316
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#1177",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology, int, org.joda.time.DateTimeZone, java.util.Locale)",
        "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n",
        "begin_line": 1177,
        "end_line": 1181,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1293
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.getField#479",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getField(org.joda.time.Chronology)",
        "snippet": "        public DateTimeField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n\n            switch (iOrdinal) {\n                case ERA:\n                    return chronology.era();\n                case YEAR_OF_ERA:\n                    return chronology.yearOfEra();\n                case CENTURY_OF_ERA:\n                    return chronology.centuryOfEra();\n                case YEAR_OF_CENTURY:\n                    return chronology.yearOfCentury();\n                case YEAR:\n                    return chronology.year();\n                case DAY_OF_YEAR:\n                    return chronology.dayOfYear();\n                case MONTH_OF_YEAR:\n                    return chronology.monthOfYear();\n                case DAY_OF_MONTH:\n                    return chronology.dayOfMonth();\n                case WEEKYEAR_OF_CENTURY:\n                    return chronology.weekyearOfCentury();\n                case WEEKYEAR:\n                    return chronology.weekyear();\n                case WEEK_OF_WEEKYEAR:\n                    return chronology.weekOfWeekyear();\n                case DAY_OF_WEEK:\n                    return chronology.dayOfWeek();\n                case HALFDAY_OF_DAY:\n                    return chronology.halfdayOfDay();\n                case HOUR_OF_HALFDAY:\n                    return chronology.hourOfHalfday();\n                case CLOCKHOUR_OF_HALFDAY:\n                    return chronology.clockhourOfHalfday();\n                case CLOCKHOUR_OF_DAY:\n                    return chronology.clockhourOfDay();\n                case HOUR_OF_DAY:\n                    return chronology.hourOfDay();\n                case MINUTE_OF_DAY:\n                    return chronology.minuteOfDay();\n                case MINUTE_OF_HOUR:\n                    return chronology.minuteOfHour();\n                case SECOND_OF_DAY:\n                    return chronology.secondOfDay();\n                case SECOND_OF_MINUTE:\n                    return chronology.secondOfMinute();\n                case MILLIS_OF_DAY:\n                    return chronology.millisOfDay();\n                case MILLIS_OF_SECOND:\n                    return chronology.millisOfSecond();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }\n",
        "begin_line": 479,
        "end_line": 533,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.printTo#1433",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology, int, org.joda.time.DateTimeZone, java.util.Locale)",
        "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n",
        "begin_line": 1433,
        "end_line": 1442,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1286
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.print#581",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.print(org.joda.time.ReadableInstant)",
        "snippet": "    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }\n",
        "begin_line": 581,
        "end_line": 585,
        "comment": "\n     * Prints a ReadableInstant to a String.\n     * <p>\n     * This method will use the override zone and the override chronololgy if\n     * they are set. Otherwise it will use the chronology and zone of the instant.\n     *\n     * @param instant  instant to format, null means now\n     * @return the printed result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1282
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.printTo#458",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)",
        "snippet": "    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }\n",
        "begin_line": 458,
        "end_line": 462,
        "comment": "\n     * Prints a ReadableInstant, using the chronology supplied by the instant.\n     *\n     * @param buf  the destination to format to, not null\n     * @param instant  instant to format, null means now\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.128
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.printTo#617",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.Chronology)",
        "snippet": "    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }\n",
        "begin_line": 617,
        "end_line": 632,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.literalTElement#1652",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.literalTElement()",
        "snippet": "    private static DateTimeFormatter literalTElement() {\n        if (lte == null) {\n            lte = new DateTimeFormatterBuilder()\n                .appendLiteral('T')\n                .toFormatter();\n        }\n        return lte;\n    }\n",
        "begin_line": 1652,
        "end_line": 1659,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1219
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.DateTimeFormatter#122",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.DateTimeFormatter(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser, java.util.Locale, boolean, org.joda.time.Chronology, org.joda.time.DateTimeZone, java.lang.Integer, int)",
        "snippet": "    private DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser,\n            Locale locale, boolean offsetParsed,\n            Chronology chrono, DateTimeZone zone,\n            Integer pivotYear, int defaultYear) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = locale;\n        iOffsetParsed = offsetParsed;\n        iChrono = chrono;\n        iZone = zone;\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n",
        "begin_line": 122,
        "end_line": 136,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1214
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#2607",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n",
        "begin_line": 2607,
        "end_line": 2609,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.117
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.offsetElement#1702",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.offsetElement()",
        "snippet": "    private static DateTimeFormatter offsetElement() {\n        if (ze == null) {\n            ze = new DateTimeFormatterBuilder()\n                .appendTimeZoneOffset(\"Z\", true, 2, 4)\n                .toFormatter();\n        }\n        return ze;\n    }\n",
        "begin_line": 1702,
        "end_line": 1709,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1153
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#2098",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n",
        "begin_line": 2098,
        "end_line": 2107,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1143
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.getInstantChronology#163",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getInstantChronology(org.joda.time.ReadableInstant)",
        "snippet": "    public static final Chronology getInstantChronology(ReadableInstant instant) {\n        if (instant == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = instant.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n",
        "begin_line": 163,
        "end_line": 172,
        "comment": "\n     * Gets the chronology from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, or the instant's chronology is\n     * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n     * Otherwise, the chronology from the object is returned.\n     * \n     * @param instant  the instant to examine, null means ISO in the default zone\n     * @return the chronology, never null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1136
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.requirePrinter#656",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.requirePrinter()",
        "snippet": "    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }\n",
        "begin_line": 656,
        "end_line": 662,
        "comment": "\n     * Checks whether printing is supported.\n     * \n     * @throws UnsupportedOperationException if printing is not supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1128
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.Fraction#1856",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Fraction.Fraction(org.joda.time.DateTimeFieldType, int, int)",
        "snippet": "        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            // Limit the precision requirements.\n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n",
        "begin_line": 1856,
        "end_line": 1865,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1126
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#1867",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Fraction.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n",
        "begin_line": 1867,
        "end_line": 1869,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1126
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimateParsedLength#2025",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Fraction.estimateParsedLength()",
        "snippet": "        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n",
        "begin_line": 2025,
        "end_line": 2027,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1126
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendFraction#530",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeFieldType, int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n",
        "begin_line": 530,
        "end_line": 542,
        "comment": "\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1126
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendFractionOfSecond#558",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n",
        "begin_line": 558,
        "end_line": 560,
        "comment": "\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1126
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.previousTransition#118",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.previousTransition(long)",
        "snippet": "    public long previousTransition(long instant) {\n        return iZone.previousTransition(instant);\n    }\n",
        "begin_line": 118,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1125
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimateParsedLength#2235",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.estimateParsedLength()",
        "snippet": "        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n",
        "begin_line": 2235,
        "end_line": 2237,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.112
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.getOffsetFromLocal#880",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getOffsetFromLocal(long)",
        "snippet": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n",
        "begin_line": 880,
        "end_line": 911,
        "comment": "\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1112
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.getInstantMillis#145",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getInstantMillis(org.joda.time.ReadableInstant)",
        "snippet": "    public static final long getInstantMillis(ReadableInstant instant) {\n        if (instant == null) {\n            return DateTimeUtils.currentTimeMillis();\n        }\n        return instant.getMillis();\n    }\n",
        "begin_line": 145,
        "end_line": 150,
        "comment": "\n     * Gets the millisecond instant from the specified instant object handling null.\n     * <p>\n     * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}\n     * will be returned. Otherwise, the millis from the object are returned.\n     * \n     * @param instant  the instant to examine, null means now\n     * @return the time in milliseconds from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1108
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendTimeZoneOffset#1050",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n",
        "begin_line": 1050,
        "end_line": 1055,
        "comment": "\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1097
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.TimeZoneOffset#2079",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.TimeZoneOffset.TimeZoneOffset(java.lang.String, java.lang.String, boolean, int, int)",
        "snippet": "        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                boolean showSeparators,\n                                int minFields, int maxFields)\n        {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n",
        "begin_line": 2079,
        "end_line": 2096,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1093
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.localToUTC#138",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.localToUTC(long)",
        "snippet": "    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }\n",
        "begin_line": 138,
        "end_line": 148,
        "comment": "\n     * @param instant instant from 1970-01-01T00:00:00 local time\n     * @return instant from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1086
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.secondElement#1680",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.secondElement()",
        "snippet": "    private static DateTimeFormatter secondElement() {\n        if (sme == null) {\n            sme = new DateTimeFormatterBuilder()\n                .appendLiteral(':')\n                .appendSecondOfMinute(2)\n                .toFormatter();\n        }\n        return sme;\n    }\n",
        "begin_line": 1680,
        "end_line": 1688,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1082
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.minuteElement#1670",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.minuteElement()",
        "snippet": "    private static DateTimeFormatter minuteElement() {\n        if (mhe == null) {\n            mhe = new DateTimeFormatterBuilder()\n                .appendLiteral(':')\n                .appendMinuteOfHour(2)\n                .toFormatter();\n        }\n        return mhe;\n    }\n",
        "begin_line": 1670,
        "end_line": 1678,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1079
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getDateTimeMillis#114",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)",
        "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }\n",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1079
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.hourElement#1661",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.hourElement()",
        "snippet": "    private static DateTimeFormatter hourElement() {\n        if (hde == null) {\n            hde = new DateTimeFormatterBuilder()\n                .appendHourOfDay(2)\n                .toFormatter();\n        }\n        return hde;\n    }\n",
        "begin_line": 1661,
        "end_line": 1668,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1077
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.getTotalMillisByYearMonth#138",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.getTotalMillisByYearMonth(int, int)",
        "snippet": "    long getTotalMillisByYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        }\n    }\n",
        "begin_line": 138,
        "end_line": 144,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1062
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.getDaysInYearMonth#119",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInYearMonth(int, int)",
        "snippet": "    int getDaysInYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n        }\n    }\n",
        "begin_line": 119,
        "end_line": 125,
        "comment": "\n     * Gets the number of days in the specified month and year.\n     * \n     * @param year  the year\n     * @param month  the month\n     * @return the number of days\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1057
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendSecondOfMinute#646",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)",
        "snippet": "    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n",
        "begin_line": 646,
        "end_line": 648,
        "comment": "\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1057
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.createInfo#151",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.createInfo(long)",
        "snippet": "    private Info createInfo(long millis) {\n        long periodStart = millis & (0xffffffffL << 32);\n        Info info = new Info(iZone, periodStart);\n        \n        long end = periodStart | 0xffffffffL;\n        Info chain = info;\n        while (true) {\n            long next = iZone.nextTransition(periodStart);\n            if (next == periodStart || next > end) {\n                break;\n            }\n            periodStart = next;\n            chain = (chain.iNextInfo = new Info(iZone, periodStart));\n        }\n\n        return info;\n    }\n",
        "begin_line": 151,
        "end_line": 167,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1039
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.dayOfMonthElement#1603",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()",
        "snippet": "    private static DateTimeFormatter dayOfMonthElement() {\n        if (dme == null) {\n            dme = new DateTimeFormatterBuilder()\n                .appendLiteral('-')\n                .appendDayOfMonth(2)\n                .toFormatter();\n        }\n        return dme;\n    }\n",
        "begin_line": 1603,
        "end_line": 1611,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1023
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.monthElement#1593",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.monthElement()",
        "snippet": "    private static DateTimeFormatter monthElement() {\n        if (mye == null) {\n            mye = new DateTimeFormatterBuilder()\n                .appendLiteral('-')\n                .appendMonthOfYear(2)\n                .toFormatter();\n        }\n        return mye;\n    }\n",
        "begin_line": 1593,
        "end_line": 1601,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1019
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendMinuteOfHour#666",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)",
        "snippet": "    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n",
        "begin_line": 666,
        "end_line": 668,
        "comment": "\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1007
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISODateTimeFormat.yearElement#1584",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/ISODateTimeFormat.java",
        "class_name": "org.joda.time.format.ISODateTimeFormat",
        "signature": "org.joda.time.format.ISODateTimeFormat.yearElement()",
        "snippet": "    private static DateTimeFormatter yearElement() {\n        if (ye == null) {\n            ye = new DateTimeFormatterBuilder()\n                .appendYear(4, 9)\n                .toFormatter();\n        }\n        return ye;\n    }\n",
        "begin_line": 1584,
        "end_line": 1591,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1005
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getLeapDurationField#516",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.getLeapDurationField()",
        "snippet": "        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }\n",
        "begin_line": 516,
        "end_line": 518,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1001
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getMinimumValue#549",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.getMinimumValue()",
        "snippet": "        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }\n",
        "begin_line": 549,
        "end_line": 551,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1001
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getMaximumValue#566",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.getMaximumValue()",
        "snippet": "        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }\n",
        "begin_line": 566,
        "end_line": 568,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1001
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendHourOfDay#686",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)",
        "snippet": "    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n",
        "begin_line": 686,
        "end_line": 688,
        "comment": "\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0996
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getInstance#184",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)",
        "snippet": "    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n\n        ArrayList<GJChronology> chronos = cCache.get(zone);\n        if (chronos == null) {\n            chronos = new ArrayList<GJChronology>(2);\n            cCache.put(zone, chronos);\n        } else {\n            for (int i=chronos.size(); --i>=0; ) {\n                chrono = chronos.get(i);\n                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                    cutoverInstant.equals(chrono.getGregorianCutover())) {\n                    \n                    return chrono;\n                }\n            }\n        }\n\n        if (zone == DateTimeZone.UTC) {\n            chrono = new GJChronology\n                (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                 cutoverInstant);\n        } else {\n            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n            chrono = new GJChronology\n                (ZonedChronology.getInstance(chrono, zone),\n                 chrono.iJulianChronology,\n                 chrono.iGregorianChronology,\n                 chrono.iCutoverInstant);\n        }\n\n        chronos.add(chrono);\n\n        return chrono;\n    }\n",
        "begin_line": 184,
        "end_line": 231,
        "comment": "\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0985
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getGregorianCutover#396",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.getGregorianCutover()",
        "snippet": "    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }\n",
        "begin_line": 396,
        "end_line": 398,
        "comment": "\n     * Gets the cutover instant between Gregorian and Julian chronologies.\n     * @return the cutover instant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0985
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getMinimumDaysInFirstWeek#405",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()",
        "snippet": "    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }\n",
        "begin_line": 405,
        "end_line": 407,
        "comment": "\n     * Gets the minimum days needed for a week to be the first week in a year.\n     * \n     * @return the minimum days\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0985
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.selectChronology#938",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.selectChronology(org.joda.time.Chronology)",
        "snippet": "    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }\n",
        "begin_line": 938,
        "end_line": 947,
        "comment": "\n     * Determines the correct chronology to use.\n     *\n     * @param chrono  the proposed chronology\n     * @return the actual chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0984
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendMonthOfYear#778",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)",
        "snippet": "    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n",
        "begin_line": 778,
        "end_line": 780,
        "comment": "\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0983
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getDurationField#498",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.getDurationField()",
        "snippet": "        public final DurationField getDurationField() {\n            return iDurationField;\n        }\n",
        "begin_line": 498,
        "end_line": 500,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0979
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getRangeDurationField#502",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.getRangeDurationField()",
        "snippet": "        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n",
        "begin_line": 502,
        "end_line": 504,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0979
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.GJChronology#277",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)",
        "snippet": "    private GJChronology(Chronology base,\n                         JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(base, new Object[] {julian, gregorian, cutoverInstant});\n    }\n",
        "begin_line": 277,
        "end_line": 282,
        "comment": "\n     * Called when applying a time zone.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0979
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.assemble#464",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }\n",
        "begin_line": 464,
        "end_line": 572,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0979
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.withUTC#306",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.withUTC()",
        "snippet": "    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }\n",
        "begin_line": 306,
        "end_line": 308,
        "comment": "\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0973
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.withZone#316",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.withZone(org.joda.time.DateTimeZone)",
        "snippet": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }\n",
        "begin_line": 316,
        "end_line": 324,
        "comment": "\n     * Gets the Chronology in a specific time zone.\n     * \n     * @param zone  the zone to get the chronology in, null is default\n     * @return the chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0973
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getZone#291",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n",
        "begin_line": 291,
        "end_line": 297,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0971
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.set#464",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.set(long, int)",
        "snippet": "        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n            if (get(result) != value) {\n                throw new IllegalFieldValueException(iField.getType(), Integer.valueOf(value),\n                    \"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n                    \" (\" + iZone.getID() + \")\");\n            }\n            return result;\n        }\n",
        "begin_line": 464,
        "end_line": 475,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0971
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendDayOfMonth#736",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)",
        "snippet": "    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n",
        "begin_line": 736,
        "end_line": 738,
        "comment": "\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0969
        },
        "num_failing_tests": 7
    },
    {
        "name": "Instant.toInstant#143",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Instant.java",
        "class_name": "org.joda.time.Instant",
        "signature": "org.joda.time.Instant.toInstant()",
        "snippet": "    public Instant toInstant() {\n        return this;\n    }\n",
        "begin_line": 143,
        "end_line": 145,
        "comment": "\n     * Get this object as an Instant by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0969
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendYear#790",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n",
        "begin_line": 790,
        "end_line": 792,
        "comment": "\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0955
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.convertLocalToUTC#950",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.convertLocalToUTC(long, boolean, long)",
        "snippet": "    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }\n",
        "begin_line": 950,
        "end_line": 958,
        "comment": "\n     * Converts a local instant to a standard UTC instant with the same\n     * local time attempting to use the same offset as the original.\n     * <p>\n     * This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     * Whenever possible, the same offset as the original offset will be used.\n     * This is most significant during a daylight savings overlap.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @param originalInstantUTC  the original instant that the calculation is based on\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 2.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0953
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.convertLocalToUTC#972",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.convertLocalToUTC(long, boolean)",
        "snippet": "    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\n                                DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n                                \" (\" + getID() + \")\");\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }\n",
        "begin_line": 972,
        "end_line": 1015,
        "comment": "\n     * Converts a local instant to a standard UTC instant with the same\n     * local time. This conversion is used after performing a calculation\n     * where the calculation was done using a simple local zone.\n     *\n     * @param instantLocal  the local instant to convert to UTC\n     * @param strict  whether the conversion should reject non-existent local times\n     * @return the UTC instant with the same local time, \n     * @throws ArithmeticException if the result overflows a long\n     * @throws IllegalArgumentException if the zone has no equivalent local time\n     * @since 1.5\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0953
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.decompose#2712",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.decompose(java.util.List<java.lang.Object>, java.util.List<java.lang.Object>, java.util.List<java.lang.Object>)",
        "snippet": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n",
        "begin_line": 2712,
        "end_line": 2733,
        "comment": "\n         * Processes the element pairs, putting results into the given printer\n         * and parser lists.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0944
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.addArrayToList#2735",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.addArrayToList(java.util.List<java.lang.Object>, java.lang.Object[])",
        "snippet": "        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n",
        "begin_line": 2735,
        "end_line": 2741,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0944
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendSignedDecimal#446",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeFieldType, int, int)",
        "snippet": "    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n",
        "begin_line": 446,
        "end_line": 462,
        "comment": "\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0943
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.getDateTimeMillis#125",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)",
        "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n            // Only call specialized implementation if applicable fields are the same.\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n",
        "begin_line": 125,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0943
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.append#208",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)",
        "snippet": "    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n",
        "begin_line": 208,
        "end_line": 213,
        "comment": "\n     * Appends another formatter.\n     *\n     * @param formatter  the formatter to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if formatter is null or of an invalid type\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0934
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.getParser#171",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.getParser()",
        "snippet": "    public DateTimeParser getParser() {\n        return iParser;\n    }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "\n     * Gets the internal parser object that performs the real parsing work.\n     * \n     * @return the internal parser; is null if parsing not supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0933
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.getPrinter#153",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.getPrinter()",
        "snippet": "    public DateTimePrinter getPrinter() {\n        return iPrinter;\n    }\n",
        "begin_line": 153,
        "end_line": 155,
        "comment": "\n     * Gets the internal printer object that performs the real printing work.\n     * \n     * @return the internal printer; is null if printing not supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0924
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.append0#343",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)",
        "snippet": "    private DateTimeFormatterBuilder append0(\n            DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n",
        "begin_line": 343,
        "end_line": 349,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0922
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.isParser#1136",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)",
        "snippet": "    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n",
        "begin_line": 1136,
        "end_line": 1144,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0913
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.isPrinter#1126",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)",
        "snippet": "    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n",
        "begin_line": 1126,
        "end_line": 1134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0912
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.getFormatter#1099",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.getFormatter()",
        "snippet": "    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n",
        "begin_line": 1099,
        "end_line": 1124,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0911
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipUndoDateTimeField.SkipUndoDateTimeField#52",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipUndoDateTimeField.java",
        "class_name": "org.joda.time.field.SkipUndoDateTimeField",
        "signature": "org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField(org.joda.time.Chronology, org.joda.time.DateTimeField)",
        "snippet": "    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Constructor that reinserts zero.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipUndoDateTimeField.SkipUndoDateTimeField#63",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipUndoDateTimeField.java",
        "class_name": "org.joda.time.field.SkipUndoDateTimeField",
        "signature": "org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField(org.joda.time.Chronology, org.joda.time.DateTimeField, int)",
        "snippet": "    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min + 1;\n        } else if (min == skip + 1) {\n            iMinValue = skip;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }\n",
        "begin_line": 63,
        "end_line": 75,
        "comment": "\n     * Constructor.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     * @param skip  the value to skip\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipUndoDateTimeField.set#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipUndoDateTimeField.java",
        "class_name": "org.joda.time.field.SkipUndoDateTimeField",
        "signature": "org.joda.time.field.SkipUndoDateTimeField.set(long, int)",
        "snippet": "    public long set(long millis, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\n        if (value <= iSkip) {\n            value--;\n        }\n        return super.set(millis, value);\n    }\n",
        "begin_line": 86,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipUndoDateTimeField.getMinimumValue#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipUndoDateTimeField.java",
        "class_name": "org.joda.time.field.SkipUndoDateTimeField",
        "signature": "org.joda.time.field.SkipUndoDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iMinValue;\n    }\n",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipDateTimeField.get#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipDateTimeField.java",
        "class_name": "org.joda.time.field.SkipDateTimeField",
        "signature": "org.joda.time.field.SkipDateTimeField.get(long)",
        "snippet": "    public int get(long millis) {\n        int value = super.get(millis);\n        if (value <= iSkip) {\n            value--;\n        }\n        return value;\n    }\n",
        "begin_line": 79,
        "end_line": 85,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.set#151",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n        return super.set(instant, value - iOffset);\n    }\n",
        "begin_line": 151,
        "end_line": 154,
        "comment": "\n     * Set the specified amount of offset units to the specified time instant.\n     * \n     * @param instant  the time instant in millis to update.\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "BuddhistChronology.getInstance#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BuddhistChronology.java",
        "class_name": "org.joda.time.chrono.BuddhistChronology",
        "signature": "org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        BuddhistChronology chrono = cCache.get(zone);\n        if (chrono == null) {\n            // First create without a lower limit.\n            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n            // Impose lower limit and make another BuddhistChronology.\n            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n            cCache.put(zone, chrono);\n        }\n        return chrono;\n    }\n",
        "begin_line": 103,
        "end_line": 117,
        "comment": "\n     * Standard instance of a Buddhist Chronology, that matches\n     * Sun's BuddhistCalendar class. This means that it follows the\n     * GregorianJulian calendar rules with a cutover date.\n     *\n     * @param zone  the time zone to use, null is default\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "BuddhistChronology.BuddhistChronology#127",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BuddhistChronology.java",
        "class_name": "org.joda.time.chrono.BuddhistChronology",
        "signature": "org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)",
        "snippet": "    private BuddhistChronology(Chronology base, Object param) {\n        super(base, param);\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * Restricted constructor.\n     *\n     * @param param if non-null, then don't change the field set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "BuddhistChronology.assemble#203",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BuddhistChronology.java",
        "class_name": "org.joda.time.chrono.BuddhistChronology",
        "signature": "org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getParam() == null) {\n            // julian chrono removed zero, but we need to put it back\n            DateTimeField field = fields.year;\n            fields.year = new OffsetDateTimeField(\n                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n            \n            // one era, so yearOfEra is the same\n            field = fields.yearOfEra;\n            fields.yearOfEra = new DelegatedDateTimeField(\n                fields.year, DateTimeFieldType.yearOfEra());\n            \n            // julian chrono removed zero, but we need to put it back\n            field = fields.weekyear;\n            fields.weekyear = new OffsetDateTimeField(\n                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n            \n            field = new OffsetDateTimeField(fields.yearOfEra, 99);\n            fields.centuryOfEra = new DividedDateTimeField(\n                field, DateTimeFieldType.centuryOfEra(), 100);\n            \n            field = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra);\n            fields.yearOfCentury = new OffsetDateTimeField(\n                field, DateTimeFieldType.yearOfCentury(), 1);\n            \n            field = new RemainderDateTimeField(\n                fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n            fields.weekyearOfCentury = new OffsetDateTimeField(\n                field, DateTimeFieldType.weekyearOfCentury(), 1);\n            \n            fields.era = ERA_FIELD;\n        }\n    }\n",
        "begin_line": 203,
        "end_line": 236,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipDateTimeField.getMinimumValue#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipDateTimeField.java",
        "class_name": "org.joda.time.field.SkipDateTimeField",
        "signature": "org.joda.time.field.SkipDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iMinValue;\n    }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDateTimeField.set#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int value) {\n        return iField.set(instant, value);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.adjustYearForSet#77",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.adjustYearForSet(int)",
        "snippet": "    static int adjustYearForSet(int year) {\n        if (year <= 0) {\n            if (year == 0) {\n                throw new IllegalFieldValueException\n                    (DateTimeFieldType.year(), Integer.valueOf(year), null, null);\n            }\n            year++;\n        }\n        return year;\n    }\n",
        "begin_line": 77,
        "end_line": 86,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getInstance#169",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)",
        "snippet": "    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }\n",
        "begin_line": 169,
        "end_line": 174,
        "comment": "\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * <p>The first day of the week is designated to be\n     * {@link org.joda.time.DateTimeConstants#MONDAY Monday},\n     * and the minimum days in the first week of the year is 4.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0898
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getMinimumValue#792",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.getMinimumValue()",
        "snippet": "        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }\n",
        "begin_line": 792,
        "end_line": 796,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0897
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getMaximumValue#823",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.getMaximumValue()",
        "snippet": "        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }\n",
        "begin_line": 823,
        "end_line": 827,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0897
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.set#709",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.set(long, int)",
        "snippet": "        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }\n",
        "begin_line": 709,
        "end_line": 738,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.gregorianToJulian#911",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.gregorianToJulian(long)",
        "snippet": "        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }\n",
        "begin_line": 911,
        "end_line": 917,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.gregorianToJulianByYear#578",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)",
        "snippet": "    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }\n",
        "begin_line": 578,
        "end_line": 580,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.getMaximumValue#227",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseChronology.getDateTimeMillis#127",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.getDateTimeMillis(int, int, int, int, int, int, int)",
        "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        long instant = year().set(0, year);\n        instant = monthOfYear().set(instant, monthOfYear);\n        instant = dayOfMonth().set(instant, dayOfMonth);\n        instant = hourOfDay().set(instant, hourOfDay);\n        instant = minuteOfHour().set(instant, minuteOfHour);\n        instant = secondOfMinute().set(instant, secondOfMinute);\n        return millisOfSecond().set(instant, millisOfSecond);\n    }\n",
        "begin_line": 127,
        "end_line": 139,
        "comment": "\n     * Returns a datetime millisecond instant, formed from the given year,\n     * month, day, hour, minute, second, and millisecond values. The set of\n     * given values must refer to a valid datetime, or else an\n     * IllegalArgumentException is thrown.\n     * <p>\n     * The default implementation calls upon separate DateTimeFields to\n     * determine the result. Subclasses are encouraged to provide a more\n     * efficient implementation.\n     *\n     * @param year year to use\n     * @param monthOfYear month to use\n     * @param dayOfMonth day of month to use\n     * @param hourOfDay hour to use\n     * @param minuteOfHour minute to use\n     * @param secondOfMinute second to use\n     * @param millisOfSecond millisecond to use\n     * @return millisecond instant from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.set#171",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int value) {\n        return iField.set(instant, value);\n    }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.get#643",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.get(long)",
        "snippet": "        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }\n",
        "begin_line": 643,
        "end_line": 649,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0893
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getDateMidnightMillis#204",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getDateMidnightMillis(int, int, int)",
        "snippet": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n        throws IllegalArgumentException\n    {\n        return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n    }\n",
        "begin_line": 204,
        "end_line": 208,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0892
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getMaximumValue#227",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iField.getMaximumValue();\n    }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0891
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.calculateFirstDayOfYearMillis#200",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.calculateFirstDayOfYearMillis(int)",
        "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }\n",
        "begin_line": 200,
        "end_line": 218,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0886
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getLeapDurationField#787",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.getLeapDurationField()",
        "snippet": "        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }\n",
        "begin_line": 787,
        "end_line": 789,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0875
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getRangeDurationField#767",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.getRangeDurationField()",
        "snippet": "        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }\n",
        "begin_line": 767,
        "end_line": 769,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.calculateFirstDayOfYearMillis#214",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.calculateFirstDayOfYearMillis(int)",
        "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n        // Calculate relative to the nearest leap year and account for the\n        // difference later.\n\n        int relativeYear = year - 1968;\n        int leapYears;\n        if (relativeYear <= 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers.\n            leapYears = (relativeYear + 3) >> 2;\n        } else {\n            leapYears = relativeYear >> 2;\n            // For post 1968 an adjustment is needed as jan1st is before leap day\n            if (!isLeapYear(year)) {\n                leapYears++;\n            }\n        }\n        \n        long millis = (relativeYear * 365L + leapYears) * (long)DateTimeConstants.MILLIS_PER_DAY;\n\n        // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n\n        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;\n    }\n",
        "begin_line": 214,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.roundCeiling#126",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.roundCeiling(long)",
        "snippet": "    public long roundCeiling(long instant) {\n        int year = get(instant);\n        long yearStartMillis = iChronology.getYearMillis(year);\n        if (instant != yearStartMillis) {\n            // Bump up to start of next year.\n            instant = iChronology.getYearMillis(year + 1);\n        }\n        return instant;\n    }\n",
        "begin_line": 126,
        "end_line": 134,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.LinkedDurationField#1082",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.LinkedDurationField.LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology.ImpreciseCutoverField)",
        "snippet": "        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {\n            super(durationField, durationField.getType());\n            iField = dateTimeField;\n        }\n",
        "begin_line": 1082,
        "end_line": 1085,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.ImpreciseCutoverField#933",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField(org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)",
        "snippet": "        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, null, cutoverMillis, false);\n        }\n",
        "begin_line": 933,
        "end_line": 935,
        "comment": "\n         * Creates a duration field that links back to this.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.ImpreciseCutoverField#942",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField(org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, long)",
        "snippet": "        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField, long cutoverMillis)\n        {\n            this(julianField, gregorianField, durationField, cutoverMillis, false);\n        }\n",
        "begin_line": 942,
        "end_line": 946,
        "comment": "\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.ImpreciseCutoverField#953",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.ImpreciseCutoverField.ImpreciseCutoverField(org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, long, boolean)",
        "snippet": "        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                              DurationField durationField,\n                              long cutoverMillis, boolean convertByWeekyear)\n        {\n            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);\n            if (durationField == null) {\n                durationField = new LinkedDurationField(iDurationField, this);\n            }\n            iDurationField = durationField;\n        }\n",
        "begin_line": 953,
        "end_line": 962,
        "comment": "\n         * Uses a shared duration field rather than creating a new one.\n         *\n         * @param durationField shared duration field\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.CutoverField#611",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.CutoverField(org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)",
        "snippet": "        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\n            this(julianField, gregorianField, cutoverMillis, false);\n        }\n",
        "begin_line": 611,
        "end_line": 613,
        "comment": "\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.CutoverField#621",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.CutoverField(org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)",
        "snippet": "        CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                     long cutoverMillis, boolean convertByWeekyear) {\n            super(gregorianField.getType());\n            iJulianField = julianField;\n            iGregorianField = gregorianField;\n            iCutover = cutoverMillis;\n            iConvertByWeekyear = convertByWeekyear;\n            // Although average length of Julian and Gregorian years differ,\n            // use the Gregorian duration field because it is more accurate.\n            iDurationField = gregorianField.getDurationField();\n\n            DurationField rangeField = gregorianField.getRangeDurationField();\n            if (rangeField == null) {\n                rangeField = julianField.getRangeDurationField();\n            }\n            iRangeDurationField = rangeField;\n        }\n",
        "begin_line": 621,
        "end_line": 637,
        "comment": "\n         * @param julianField field from the chronology used before the cutover instant\n         * @param gregorianField field from the chronology used at and after the cutover\n         * @param cutoverMillis  the millis of the cutover\n         * @param convertByWeekyear\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.getDurationField#763",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.CutoverField.getDurationField()",
        "snippet": "        public DurationField getDurationField() {\n            return iDurationField;\n        }\n",
        "begin_line": 763,
        "end_line": 765,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.convertByYear#82",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)",
        "snippet": "    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }\n",
        "begin_line": 82,
        "end_line": 88,
        "comment": "\n     * Convert a datetime from one chronology to another.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.GJChronology#268",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)",
        "snippet": "    private GJChronology(JulianChronology julian,\n                         GregorianChronology gregorian,\n                         Instant cutoverInstant) {\n        super(null, new Object[] {julian, gregorian, cutoverInstant});\n    }\n",
        "begin_line": 268,
        "end_line": 272,
        "comment": "\n     * @param julian chronology used before the cutover instant\n     * @param gregorian chronology used at and after the cutover instant\n     * @param cutoverInstant instant when the gregorian chronology began\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJChronology.julianToGregorianByYear#574",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJChronology.java",
        "class_name": "org.joda.time.chrono.GJChronology",
        "signature": "org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)",
        "snippet": "    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }\n",
        "begin_line": 574,
        "end_line": 576,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0869
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.add#71",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.add(long, int)",
        "snippet": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        return set(instant, get(instant) + years);\n    }\n",
        "begin_line": 71,
        "end_line": 76,
        "comment": "\n     * Add the specified years to the specified time instant.\n     * \n     * @see org.joda.time.DateTimeField#add\n     * @param instant  the time instant in millis to update.\n     * @param years  the years to add (can be negative).\n     * @return the updated time instant.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0868
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.isLeapYear#210",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.isLeapYear(int)",
        "snippet": "    boolean isLeapYear(int year) {\n        return (year & 3) == 0;\n    }\n",
        "begin_line": 210,
        "end_line": 212,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getAverageMillisPerYearDividedByTwo#252",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerYearDividedByTwo()",
        "snippet": "    long getAverageMillisPerYearDividedByTwo() {\n        return MILLIS_PER_YEAR / 2;\n    }\n",
        "begin_line": 252,
        "end_line": 254,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getApproxMillisAtEpochDividedByTwo#260",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getApproxMillisAtEpochDividedByTwo()",
        "snippet": "    long getApproxMillisAtEpochDividedByTwo() {\n        return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n    }\n",
        "begin_line": 260,
        "end_line": 262,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.roundCeiling#885",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.roundCeiling(long)",
        "snippet": "    public long roundCeiling(long instant) {\n        long newInstant = roundFloor(instant);\n        if (newInstant != instant) {\n            instant = add(newInstant, 1);\n        }\n        return instant;\n    }\n",
        "begin_line": 885,
        "end_line": 891,
        "comment": "\n     * Round to the highest whole unit of this field. The value of this field\n     * and all fields of a higher magnitude may be incremented in order to\n     * achieve this result. The fractional millis that cannot be expressed in\n     * whole increments of this field are set to minimum.\n     * <p>\n     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n     * highest whole hour is 2002-11-03T00:00:00.000.\n     * <p>\n     * The default implementation calls roundFloor, and if the instant is\n     * modified as a result, adds one field unit. Subclasses are encouraged to\n     * provide a more efficient implementation.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @return rounded milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.set#127",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds(this, Math.abs(year),\n                                     iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( instant );\n        if ( thisWeekyear == year ) {\n            return instant;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.getDayOfWeek(instant);\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workInstant = instant; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workInstant = iChronology.setYear( workInstant, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = get( workInstant );\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n        // No range check required (we already know it is OK).\n        workInstant = workInstant + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        // Note: This works fine, but it ideally shouldn't invoke other\n        // fields from within a field.\n        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n        //\n        // Return result.\n        //\n        return workInstant;\n    }\n",
        "begin_line": 127,
        "end_line": 205,
        "comment": "\n     * Set the Year of a week based year component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#set\n     * @param instant  the time instant in millis to update.\n     * @param year  the year (-9999,9999) to set the date to.\n     * @return the updated DateTime.\n     * @throws IllegalArgumentException  if year is invalid.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0867
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.roundFloor#231",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.roundFloor(long)",
        "snippet": "    public long roundFloor(long instant) {\n        // Note: This works fine, but it ideally shouldn't invoke other\n        // fields from within a field.\n        instant = iChronology.weekOfWeekyear().roundFloor(instant);\n        int wow = iChronology.getWeekOfWeekyear(instant);\n        if (wow > 1) {\n            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n        }\n        return instant;\n    }\n",
        "begin_line": 231,
        "end_line": 240,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0866
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDayOfWeek#530",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDayOfWeek(long)",
        "snippet": "    int getDayOfWeek(long instant) {\n        // 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (instant >= 0) {\n            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }\n",
        "begin_line": 530,
        "end_line": 545,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0865
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDateTimeMillis#149",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDateTimeMillis(int, int, int, int)",
        "snippet": "    public long getDateTimeMillis(\n            int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n            throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        FieldUtils.verifyValueBounds\n            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1);\n        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n    }\n",
        "begin_line": 149,
        "end_line": 160,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0865
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#1173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return 1;\n        }\n",
        "begin_line": 1173,
        "end_line": 1175,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimateParsedLength#1197",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral.estimateParsedLength()",
        "snippet": "        public int estimateParsedLength() {\n            return 1;\n        }\n",
        "begin_line": 1197,
        "end_line": 1199,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.get#95",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iField.get(instant);\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getMinimumDaysInFirstWeek#184",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMinimumDaysInFirstWeek()",
        "snippet": "    public int getMinimumDaysInFirstWeek() {\n        return iMinDaysInFirstWeek;\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getWeekyear#492",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getWeekyear(long)",
        "snippet": "    int getWeekyear(long instant) {\n        int year = getYear(instant);\n        int week = getWeekOfWeekyear(instant, year);\n        if (week == 1) {\n            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n        } else if (week > 51) {\n            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n        } else {\n            return year;\n        }\n    }\n",
        "begin_line": 492,
        "end_line": 502,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.getZone#268",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getZone(org.joda.time.DateTimeZone)",
        "snippet": "    public static final DateTimeZone getZone(DateTimeZone zone) {\n        if (zone == null) {\n            return DateTimeZone.getDefault();\n        }\n        return zone;\n    }\n",
        "begin_line": 268,
        "end_line": 273,
        "comment": "\n     * Gets the zone handling null.\n     * <p>\n     * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n     * will be returned. Otherwise, the zone specified is returned.\n     * \n     * @param zone  the time zone to use, null means the default zone\n     * @return the time zone, never null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0862
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimateParsedLength#1287",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter.estimateParsedLength()",
        "snippet": "        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n",
        "begin_line": 1287,
        "end_line": 1289,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0861
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.roundFloor#91",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.roundFloor(long)",
        "snippet": "    public long roundFloor(long instant) {\n        if (instant >= 0) {\n            return instant - instant % iUnitMillis;\n        } else {\n            instant += 1;\n            return instant - instant % iUnitMillis - iUnitMillis;\n        }\n    }\n",
        "begin_line": 91,
        "end_line": 98,
        "comment": "\n     * This method assumes that this field is properly rounded on\n     * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n     * method as follows:\n     * <pre>\n     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n     * </pre>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.086
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.CharacterLiteral#1168",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral.CharacterLiteral(char)",
        "snippet": "        CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n",
        "begin_line": 1168,
        "end_line": 1171,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0859
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.appendLiteral#358",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)",
        "snippet": "    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n",
        "begin_line": 358,
        "end_line": 360,
        "comment": "\n     * Instructs the printer to emit a specific character, and the parser to\n     * expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0859
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.Composite#2568",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.Composite(java.util.List<java.lang.Object>)",
        "snippet": "        Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n",
        "begin_line": 2568,
        "end_line": 2605,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0859
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekOfWeekyearDateTimeField.roundFloor#64",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.roundFloor(long)",
        "snippet": "    public long roundFloor(long instant) {\n        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n    }\n",
        "begin_line": 64,
        "end_line": 67,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0858
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#1429",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n",
        "begin_line": 1429,
        "end_line": 1431,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0858
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getWeeksInYear#326",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getWeeksInYear(int)",
        "snippet": "    int getWeeksInYear(int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n    }\n",
        "begin_line": 326,
        "end_line": 330,
        "comment": "\n     * Get the number of weeks in the year.\n     *\n     * @param year  the year to use\n     * @return number of weeks in the year\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0858
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.PaddedNumber#1422",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.PaddedNumber.PaddedNumber(org.joda.time.DateTimeFieldType, int, boolean, int)",
        "snippet": "        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                     boolean signed, int minPrintedDigits)\n        {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n",
        "begin_line": 1422,
        "end_line": 1427,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.NumberFormatter#1279",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.NumberFormatter.NumberFormatter(org.joda.time.DateTimeFieldType, int, boolean)",
        "snippet": "        NumberFormatter(DateTimeFieldType fieldType,\n                int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n",
        "begin_line": 1279,
        "end_line": 1285,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDateTimeField.get#78",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        if (instant >= 0) {\n            return (int) ((instant / getUnitMillis()) % iRange);\n        } else {\n            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n        }\n    }\n",
        "begin_line": 78,
        "end_line": 84,
        "comment": "\n     * Get the amount of fractional units from the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n     * @return the amount of fractional units extracted from the input.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0857
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.isPrinter#2700",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.isPrinter()",
        "snippet": "        boolean isPrinter() {\n            return iPrinters != null;\n        }\n",
        "begin_line": 2700,
        "end_line": 2702,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.isParser#2704",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.isParser()",
        "snippet": "        boolean isParser() {\n            return iParsers != null;\n        }\n",
        "begin_line": 2704,
        "end_line": 2706,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0856
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.getMaximumValueForSet#162",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet(long, int)",
        "snippet": "    protected int getMaximumValueForSet(long instant, int value) {\n        return getMaximumValue(instant);\n    }\n",
        "begin_line": 162,
        "end_line": 164,
        "comment": "\n     * Called by the set method to get the maximum allowed value. By default,\n     * returns getMaximumValue(instant). Override to provide a faster\n     * implementation.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0855
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getMillisOfDay#550",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMillisOfDay(long)",
        "snippet": "    int getMillisOfDay(long instant) {\n        if (instant >= 0) {\n            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n        } else {\n            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n        }\n    }\n",
        "begin_line": 550,
        "end_line": 557,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0853
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.get#59",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iChronology.getWeekyear(instant);\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": "\n     * Get the Year of a week based year component of the specified time instant.\n     * \n     * @see org.joda.time.DateTimeField#get\n     * @param instant  the time instant in millis to query.\n     * @return the year extracted from the input.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0853
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJDayOfWeekDateTimeField.getMinimumValue#102",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return DateTimeConstants.MONDAY;\n    }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n     * Get the minimum value that this field can have.\n     * \n     * @return the field's minimum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0852
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJDayOfWeekDateTimeField.getMaximumValue#111",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return DateTimeConstants.SUNDAY;\n    }\n",
        "begin_line": 111,
        "end_line": 113,
        "comment": "\n     * Get the maximum value that this field can have.\n     * \n     * @return the field's maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0852
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.getMaximumValue#791",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.getMaximumValue(long)",
        "snippet": "    public int getMaximumValue(long instant) {\n        return getMaximumValue();\n    }\n",
        "begin_line": 791,
        "end_line": 793,
        "comment": "\n     * Get the maximum value for this field evaluated at the specified time.\n     * <p>\n     * This implementation returns the same as {@link #getMaximumValue()}.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n     * @return the maximum value for this field, in the units of the field\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getFirstWeekOfYearMillis#338",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getFirstWeekOfYearMillis(int)",
        "snippet": "    long getFirstWeekOfYearMillis(int year) {\n        long jan1millis = getYearMillis(year);\n        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n        \n        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n            // First week is end of previous year because it doesn't have enough days.\n            return jan1millis + (8 - jan1dayOfWeek)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            // First week is start of this year because it has enough days.\n            return jan1millis - (jan1dayOfWeek - 1)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        }\n    }\n",
        "begin_line": 338,
        "end_line": 351,
        "comment": "\n     * Get the millis for the first week of a year.\n     *\n     * @param year  the year to use\n     * @return millis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0848
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getWeekOfWeekyear#507",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getWeekOfWeekyear(long)",
        "snippet": "    int getWeekOfWeekyear(long instant) {\n        return getWeekOfWeekyear(instant, getYear(instant));\n    }\n",
        "begin_line": 507,
        "end_line": 509,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDurationField.getUnitMillis#100",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDurationField.java",
        "class_name": "org.joda.time.field.DecoratedDurationField",
        "signature": "org.joda.time.field.DecoratedDurationField.getUnitMillis()",
        "snippet": "    public long getUnitMillis() {\n        return iField.getUnitMillis();\n    }\n",
        "begin_line": 100,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getInstance#113",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static JulianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Gets an instance of the JulianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getInstance#124",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)",
        "snippet": "    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        JulianChronology chrono;\n        synchronized (cCache) {\n            JulianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new JulianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new JulianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }\n",
        "begin_line": 124,
        "end_line": 153,
        "comment": "\n     * Gets an instance of the JulianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.JulianChronology#161",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getMinYear#240",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getMinYear()",
        "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }\n",
        "begin_line": 240,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getMaxYear#244",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getMaxYear()",
        "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }\n",
        "begin_line": 244,
        "end_line": 246,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getAverageMillisPerYear#248",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerYear()",
        "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }\n",
        "begin_line": 248,
        "end_line": 250,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.getAverageMillisPerMonth#256",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerMonth()",
        "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }\n",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "JulianChronology.assemble#264",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/JulianChronology.java",
        "class_name": "org.joda.time.chrono.JulianChronology",
        "signature": "org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n            // Julian chronology has no year zero.\n            fields.year = new SkipDateTimeField(this, fields.year);\n            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n        }\n    }\n",
        "begin_line": 264,
        "end_line": 271,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0846
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.get#405",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.get(long)",
        "snippet": "        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }\n",
        "begin_line": 405,
        "end_line": 408,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0844
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getWeekOfWeekyear#515",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getWeekOfWeekyear(long, int)",
        "snippet": "    int getWeekOfWeekyear(long instant, int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        if (instant < firstWeekMillis1) {\n            return getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        if (instant >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }\n",
        "begin_line": 515,
        "end_line": 525,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0843
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.toFormatter#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.toFormatter()",
        "snippet": "    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n",
        "begin_line": 103,
        "end_line": 117,
        "comment": "\n     * Constructs a DateTimeFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link DateTimeFormatter#isPrinter()} and\n     * {@link DateTimeFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     *\n     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatter.DateTimeFormatter#106",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java",
        "class_name": "org.joda.time.format.DateTimeFormatter",
        "signature": "org.joda.time.format.DateTimeFormatter.DateTimeFormatter(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)",
        "snippet": "    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }\n",
        "begin_line": 106,
        "end_line": 117,
        "comment": "\n     * Creates a new formatter, however you will normally use the factory\n     * or the builder.\n     * \n     * @param printer  the internal printer, null if cannot print\n     * @param parser  the internal parser, null if cannot parse\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0842
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.append0#335",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)",
        "snippet": "    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n",
        "begin_line": 335,
        "end_line": 341,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.084
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFormatterBuilder.DateTimeFormatterBuilder#82",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()",
        "snippet": "    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n",
        "begin_line": 82,
        "end_line": 85,
        "comment": "\n     * Creates a DateTimeFormatterBuilder.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0838
        },
        "num_failing_tests": 7
    },
    {
        "name": "Instant.Instant#117",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Instant.java",
        "class_name": "org.joda.time.Instant",
        "signature": "org.joda.time.Instant.Instant(long)",
        "snippet": "    public Instant(long instant) {\n        super();\n        iMillis = instant;\n    }\n",
        "begin_line": 117,
        "end_line": 120,
        "comment": "\n     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0825
        },
        "num_failing_tests": 7
    },
    {
        "name": "Instant.getMillis#255",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/Instant.java",
        "class_name": "org.joda.time.Instant",
        "signature": "org.joda.time.Instant.getMillis()",
        "snippet": "    public long getMillis() {\n        return iMillis;\n    }\n",
        "begin_line": 255,
        "end_line": 257,
        "comment": "\n     * Gets the milliseconds of the instant.\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.082
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.getOffset#1527",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.getOffset(long)",
        "snippet": "        public int getOffset(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            if (i >= 0) {\n                return iWallOffsets[i];\n            }\n            i = ~i;\n            if (i < transitions.length) {\n                if (i > 0) {\n                    return iWallOffsets[i - 1];\n                }\n                return 0;\n            }\n            if (iTailZone == null) {\n                return iWallOffsets[i - 1];\n            }\n            return iTailZone.getOffset(instant);\n        }\n",
        "begin_line": 1527,
        "end_line": 1544,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0817
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.nextTransition#1569",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.nextTransition(long)",
        "snippet": "        public long nextTransition(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            i = (i >= 0) ? (i + 1) : ~i;\n            if (i < transitions.length) {\n                return transitions[i];\n            }\n            if (iTailZone == null) {\n                return instant;\n            }\n            long end = transitions[transitions.length - 1];\n            if (instant < end) {\n                instant = end;\n            }\n            return iTailZone.nextTransition(instant);\n        }\n",
        "begin_line": 1569,
        "end_line": 1584,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0816
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.getChronology#303",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.getChronology()",
        "snippet": "    public Chronology getChronology() {\n        return iChronology;\n    }\n",
        "begin_line": 303,
        "end_line": 305,
        "comment": "\n     * Gets the chronology of the datetime.\n     * \n     * @return the Chronology that the datetime is using\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.081
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOChronology.getInstance#95",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }\n",
        "begin_line": 95,
        "end_line": 113,
        "comment": "\n     * Gets an instance of the ISOChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0809
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicSingleEraDateTimeField.BasicSingleEraDateTimeField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
        "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.BasicSingleEraDateTimeField(java.lang.String)",
        "snippet": "    BasicSingleEraDateTimeField(String text) {\n        super(DateTimeFieldType.era());\n        iEraText = text;\n    }\n",
        "begin_line": 50,
        "end_line": 53,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0795
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicSingleEraDateTimeField.getDurationField#105",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
        "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }\n",
        "begin_line": 105,
        "end_line": 107,
        "comment": " @inheritDoc ",
        "resolved_comments": {
            "org.joda.time.field.BaseDateTimeField": "\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"hour of day\", then the unit duration is an hour.\n     *\n     * @return the duration of this field, or UnsupportedDurationField if field\n     * has no duration\n     "
        },
        "susp": {
            "ochiai_susp": 0.0795
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicSingleEraDateTimeField.getRangeDurationField#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicSingleEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
        "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 110,
        "end_line": 112,
        "comment": " @inheritDoc ",
        "resolved_comments": {
            "org.joda.time.field.BaseDateTimeField": "\n     * Returns the range duration of this field. For example, if this field\n     * represents \"hour of day\", then the range duration is a day.\n     *\n     * @return the range duration of this field, or null if field has no range\n     "
        },
        "susp": {
            "ochiai_susp": 0.0795
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.LimitDurationField#391",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.LimitDurationField.LimitDurationField(org.joda.time.DurationField)",
        "snippet": "        LimitDurationField(DurationField field) {\n            super(field, field.getType());\n        }\n",
        "begin_line": 391,
        "end_line": 393,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.LimitDateTimeField#450",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.LimitDateTimeField.LimitDateTimeField(org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "        LimitDateTimeField(DateTimeField field,\n                           DurationField durationField,\n                           DurationField rangeDurationField,\n                           DurationField leapDurationField) {\n            super(field, field.getType());\n            iDurationField = durationField;\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n",
        "begin_line": 450,
        "end_line": 458,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.getInstance#64",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)",
        "snippet": "    public static LimitChronology getInstance(Chronology base,\n                                              ReadableDateTime lowerLimit,\n                                              ReadableDateTime upperLimit) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n\n        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n\n        if (lowerLimit != null && upperLimit != null) {\n            if (!lowerLimit.isBefore(upperLimit)) {\n                throw new IllegalArgumentException\n                    (\"The lower limit must be come before than the upper limit\");\n            }\n        }\n\n        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);\n    }\n",
        "begin_line": 64,
        "end_line": 82,
        "comment": "\n     * Wraps another chronology, with datetime limits. When withUTC or\n     * withZone is called, the returned LimitChronology instance has\n     * the same limits, except they are time zone adjusted.\n     *\n     * @param base  base chronology to wrap\n     * @param lowerLimit  inclusive lower limit, or null if none\n     * @param upperLimit  exclusive upper limit, or null if none\n     * @throws IllegalArgumentException if chronology is null or limits are invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.LimitChronology#97",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)",
        "snippet": "    private LimitChronology(Chronology base,\n                            DateTime lowerLimit, DateTime upperLimit) {\n        super(base, null);\n        // These can be set after assembly.\n        iLowerLimit = lowerLimit;\n        iUpperLimit = upperLimit;\n    }\n",
        "begin_line": 97,
        "end_line": 103,
        "comment": "\n     * Wraps another chronology, with datetime limits. When withUTC or\n     * withZone is called, the returned LimitChronology instance has\n     * the same limits, except they are time zone adjusted.\n     *\n     * @param lowerLimit  inclusive lower limit, or null if none\n     * @param upperLimit  exclusive upper limit, or null if none\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.assemble#206",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n",
        "begin_line": 206,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.convertField#255",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        LimitDurationField limitField = new LimitDurationField(field);\n        converted.put(field, limitField);\n        return limitField;\n    }\n",
        "begin_line": 255,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "LimitChronology.convertField#267",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/LimitChronology.java",
        "class_name": "org.joda.time.chrono.LimitChronology",
        "signature": "org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        LimitDateTimeField limitField =\n            new LimitDateTimeField(field,\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, limitField);\n        return limitField;\n    }\n",
        "begin_line": 267,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTime.toDateTime#526",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTime.java",
        "class_name": "org.joda.time.DateTime",
        "signature": "org.joda.time.DateTime.toDateTime()",
        "snippet": "    public DateTime toDateTime() {\n        return this;\n    }\n",
        "begin_line": 526,
        "end_line": 528,
        "comment": "\n     * Get this object as a DateTime by returning <code>this</code>.\n     * \n     * @return <code>this</code>\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0794
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTime.DateTime#507",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTime.java",
        "class_name": "org.joda.time.DateTime",
        "signature": "org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)",
        "snippet": "    public DateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n    }\n",
        "begin_line": 507,
        "end_line": 518,
        "comment": "\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.isSupported#87",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.isSupported()",
        "snippet": "    public boolean isSupported() {\n        return iField.isSupported();\n    }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0777
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getLeapDurationField#207",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iField.getLeapDurationField();\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0777
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getDurationField#191",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0777
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getType#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getType()",
        "snippet": "    public DateTimeFieldType getType() {\n        return iType;\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0775
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.convertUTCToLocal#923",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.convertUTCToLocal(long)",
        "snippet": "    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }\n",
        "begin_line": 923,
        "end_line": 931,
        "comment": "\n     * Converts a standard UTC instant to a local instant with the same\n     * local time. This conversion is used before performing a calculation\n     * so that the calculation can be done using a simple local zone.\n     *\n     * @param instantUTC  the UTC instant to convert to local\n     * @return the local instant with the same local time\n     * @throws ArithmeticException if the result overflows a long\n     * @since 1.5\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0769
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipDateTimeField.SkipDateTimeField#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipDateTimeField.java",
        "class_name": "org.joda.time.field.SkipDateTimeField",
        "signature": "org.joda.time.field.SkipDateTimeField.SkipDateTimeField(org.joda.time.Chronology, org.joda.time.DateTimeField)",
        "snippet": "    public SkipDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Constructor that skips zero.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0758
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getRangeDurationField#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }\n",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0758
        },
        "num_failing_tests": 7
    },
    {
        "name": "SkipDateTimeField.SkipDateTimeField#64",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/SkipDateTimeField.java",
        "class_name": "org.joda.time.field.SkipDateTimeField",
        "signature": "org.joda.time.field.SkipDateTimeField.SkipDateTimeField(org.joda.time.Chronology, org.joda.time.DateTimeField, int)",
        "snippet": "    public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min - 1;\n        } else if (min == skip) {\n            iMinValue = skip + 1;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }\n",
        "begin_line": 64,
        "end_line": 76,
        "comment": "\n     * Constructor.\n     * \n     * @param chronology  the chronoogy to use\n     * @param field  the field to skip zero on\n     * @param skip  the value to skip\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0758
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.getMinimumValue#211",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iField.getMinimumValue();\n    }\n",
        "begin_line": 211,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0758
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.getMinimumValue#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iChronology.getMinYear();\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0757
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.DelegatedDateTimeField#51",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)",
        "snippet": "    public DelegatedDateTimeField(DateTimeField field) {\n        this(field, null);\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0755
        },
        "num_failing_tests": 7
    },
    {
        "name": "DelegatedDateTimeField.DelegatedDateTimeField#61",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DelegatedDateTimeField.java",
        "class_name": "org.joda.time.field.DelegatedDateTimeField",
        "signature": "org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super();\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        iField = field;\n        iType = (type == null ? field.getType() : type);\n    }\n",
        "begin_line": 61,
        "end_line": 68,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     * @param type  the field type override\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0755
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.getMinimumValue#114",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iChronology.getMinYear();\n    }\n",
        "begin_line": 114,
        "end_line": 116,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.075
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDaysInMonthMax#574",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDaysInMonthMax(long)",
        "snippet": "    int getDaysInMonthMax(long instant) {\n        int thisYear = getYear(instant);\n        int thisMonth = getMonthOfYear(instant, thisYear);\n        return getDaysInYearMonth(thisYear, thisMonth);\n    }\n",
        "begin_line": 574,
        "end_line": 578,
        "comment": "\n     * Gets the maximum number of days in the month specified by the instant.\n     * \n     * @param instant  millis from 1970-01-01T00:00:00Z\n     * @return the maximum number of days in the month\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0748
        },
        "num_failing_tests": 2
    },
    {
        "name": "BaseDateTime.getMillis#294",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.getMillis()",
        "snippet": "    public long getMillis() {\n        return iMillis;\n    }\n",
        "begin_line": 294,
        "end_line": 296,
        "comment": "\n     * Gets the milliseconds of the datetime instant from the Java epoch\n     * of 1970-01-01T00:00:00Z.\n     * \n     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0741
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.setYear#174",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.setYear(long, int)",
        "snippet": "    long setYear(long instant, int year) {\n        int thisYear = getYear(instant);\n        int dayOfYear = getDayOfYear(instant, thisYear);\n        int millisOfDay = getMillisOfDay(instant);\n\n        if (dayOfYear > (31 + 28)) { // after Feb 28\n            if (isLeapYear(thisYear)) {\n                // Current date is Feb 29 or later.\n                if (!isLeapYear(year)) {\n                    // Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                // Current date is Mar 01 or later.\n                if (isLeapYear(year)) {\n                    // Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n        instant += millisOfDay;\n\n        return instant;\n    }\n",
        "begin_line": 174,
        "end_line": 199,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0735
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.getLeapDurationField#164",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }\n",
        "begin_line": 164,
        "end_line": 166,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.073
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getMonthOfYear#434",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMonthOfYear(long)",
        "snippet": "    int getMonthOfYear(long millis) {\n        return getMonthOfYear(millis, getYear(millis));\n    }\n",
        "begin_line": 434,
        "end_line": 436,
        "comment": "\n     * @param millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0709
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicMonthOfYearDateTimeField.get#71",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * Get the Month component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#get(long)\n     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n     * @param instant  the time instant in millis to query.\n     * @return the month extracted from the input.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0708
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDateTimeMillis#162",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDateTimeMillis(int, int, int, int, int, int, int)",
        "snippet": "    public long getDateTimeMillis(\n            int year, int monthOfYear, int dayOfMonth,\n            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n            throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n\n        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n            + millisOfSecond;\n    }\n",
        "begin_line": 162,
        "end_line": 182,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0693
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJDayOfWeekDateTimeField.get#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfWeek(instant);\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Get the value of the specified time instant.\n     * \n     * @param instant  the time instant in millis to query\n     * @return the day of the week extracted from the input\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0679
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.getDaysInMonthMaxForSet#133",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInMonthMaxForSet(long, int)",
        "snippet": "    int getDaysInMonthMaxForSet(long instant, int value) {\n        return (value > 28 ? getDaysInMonthMax(instant) : 28);\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0673
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfMonthDateTimeField.getMaximumValueForSet#95",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMaximumValueForSet(long, int)",
        "snippet": "    protected int getMaximumValueForSet(long instant, int value) {\n        return iChronology.getDaysInMonthMaxForSet(instant, value);\n    }\n",
        "begin_line": 95,
        "end_line": 97,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0673
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicMonthOfYearDateTimeField.set#291",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n",
        "begin_line": 291,
        "end_line": 305,
        "comment": "\n     * Set the Month component of the specified time instant.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 to month 6 = 06-30<p>\n     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n     * \n     * @param instant  the time instant in millis to update.\n     * @param month  the month (1,12) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if month is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0673
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDayOfMonth#457",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long, int)",
        "snippet": "    int getDayOfMonth(long millis, int year) {\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }\n",
        "begin_line": 457,
        "end_line": 460,
        "comment": "\n     * @param millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0673
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDateTimeField.set#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n        return instant + (value - get(instant)) * iUnitMillis;\n    }\n",
        "begin_line": 110,
        "end_line": 113,
        "comment": "\n     * Set the specified amount of units to the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.067
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.set#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds\n            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n        return iChronology.setYear(instant, year);\n    }\n",
        "begin_line": 81,
        "end_line": 85,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.067
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfMonthDateTimeField.getMinimumValue#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 1;\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0667
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.getOffset#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.Info.getOffset(long)",
        "snippet": "        public int getOffset(long millis) {\n            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n                if (iOffset == Integer.MIN_VALUE) {\n                    iOffset = iZoneRef.getOffset(iPeriodStart);\n                }\n                return iOffset;\n            }\n            return iNextInfo.getOffset(millis);\n        }\n",
        "begin_line": 195,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0664
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.getOffset#102",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.getOffset(long)",
        "snippet": "    public int getOffset(long instant) {\n        return getInfo(instant).getOffset(instant);\n    }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0664
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.Info#180",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.Info.Info(org.joda.time.DateTimeZone, long)",
        "snippet": "        Info(DateTimeZone zone, long periodStart) {\n            iPeriodStart = periodStart;\n            iZoneRef = zone;\n        }\n",
        "begin_line": 180,
        "end_line": 183,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0663
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.getInfo#139",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.getInfo(long)",
        "snippet": "    private Info getInfo(long millis) {\n        int period = (int)(millis >> 32);\n        Info[] cache = iInfoCache;\n        int index = period & cInfoCacheMask;\n        Info info = cache[index];\n        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {\n            info = createInfo(millis);\n            cache[index] = info;\n        }\n        return info;\n    }\n",
        "begin_line": 139,
        "end_line": 149,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0663
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.getZone#105",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = iBase) != null) {\n            return base.getZone();\n        }\n        return null;\n    }\n",
        "begin_line": 105,
        "end_line": 111,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0663
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.set#77",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.set(long, int)",
        "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n                                     getMaximumValueForSet(instant, value));\n        return instant + (value - get(instant)) * iUnitMillis;\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Set the specified amount of units to the specified time instant.\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n     * @param value  value of units to set.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException if value is too large or too small.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0662
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDayOfYear#484",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDayOfYear(long, int)",
        "snippet": "    int getDayOfYear(long instant, int year) {\n        long yearStart = getYearMillis(year);\n        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }\n",
        "begin_line": 484,
        "end_line": 487,
        "comment": "\n     * @param instant millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.066
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.BaseDateTime#243",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.BaseDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)",
        "snippet": "    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        iChronology = checkChronology(chronology);\n        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iMillis = checkInstant(instant, iChronology);\n    }\n",
        "begin_line": 243,
        "end_line": 257,
        "comment": "\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDateTimeField.getMaximumValue#130",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iRange - 1;\n    }\n",
        "begin_line": 130,
        "end_line": 132,
        "comment": "\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0657
        },
        "num_failing_tests": 7
    },
    {
        "name": "FieldUtils.verifyValueBounds#214",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)",
        "snippet": "    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n",
        "begin_line": 214,
        "end_line": 221,
        "comment": "\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0648
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDateMidnightMillis#602",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDateMidnightMillis(int, int, int)",
        "snippet": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    }\n",
        "begin_line": 602,
        "end_line": 607,
        "comment": "\n     * Gets the milliseconds for a date at midnight.\n     * \n     * @param year  the year\n     * @param monthOfYear  the month\n     * @param dayOfMonth  the day\n     * @return the milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0647
        },
        "num_failing_tests": 7
    },
    {
        "name": "FieldUtils.verifyValueBounds#232",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeFieldType, int, int, int)",
        "snippet": "    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n",
        "begin_line": 232,
        "end_line": 239,
        "comment": "\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     * @since 1.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0647
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getMaxMonth#681",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth(int)",
        "snippet": "    int getMaxMonth(int year) {\n        return getMaxMonth();\n    }\n",
        "begin_line": 681,
        "end_line": 683,
        "comment": "\n     * Gets the maximum month for the specified year.\n     * This implementation calls getMaxMonth().\n     * \n     * @param year  the year\n     * @return the maximum month value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0647
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOChronology.getInstanceUTC#76",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.getInstanceUTC()",
        "snippet": "    public static ISOChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }\n",
        "begin_line": 76,
        "end_line": 78,
        "comment": "\n     * Gets an instance of the ISOChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0643
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfMonthDateTimeField.get#46",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfMonth(instant);\n    }\n",
        "begin_line": 46,
        "end_line": 48,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0633
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDayOfMonth#447",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long)",
        "snippet": "    int getDayOfMonth(long millis) {\n        int year = getYear(millis);\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }\n",
        "begin_line": 447,
        "end_line": 451,
        "comment": "\n     * @param millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0633
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.get#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.get(long)",
        "snippet": "    public int get(long instant) {\n        return iChronology.getYear(instant);\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0632
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getDayOfMonth#467",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long, int, int)",
        "snippet": "    int getDayOfMonth(long millis, int year, int month) {\n        long dateMillis = getYearMillis(year);\n        dateMillis += getTotalMillisByYearMonth(year, month);\n        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }\n",
        "begin_line": 467,
        "end_line": 471,
        "comment": "\n     * @param millis from 1970-01-01T00:00:00Z\n     * @param year precalculated year of millis\n     * @param month precalculated month of millis\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0631
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getMinYear#220",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getMinYear()",
        "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }\n",
        "begin_line": 220,
        "end_line": 222,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.063
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.getMonthOfYear#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.getMonthOfYear(long, int)",
        "snippet": "    int getMonthOfYear(long millis, int year) {\n        // Perform a binary search to get the month. To make it go even faster,\n        // compare using ints instead of longs. The number of milliseconds per\n        // year exceeds the limit of a 32-bit int's capacity, so divide by\n        // 1024. No precision is lost (except time of day) since the number of\n        // milliseconds per day contains 1024 as a factor. After the division,\n        // the instant isn't measured in milliseconds, but in units of\n        // (128/125)seconds.\n\n        int i = (int)((millis - getYearMillis(year)) >> 10);\n\n        // There are 86400000 milliseconds per day, but divided by 1024 is\n        // 84375. There are 84375 (128/125)seconds per day.\n\n        return\n            (isLeapYear(year))\n            ? ((i < 182 * 84375)\n               ? ((i < 91 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n               : ((i < 274 * 84375)\n                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n            : ((i < 181 * 84375)\n               ? ((i < 90 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n               : ((i < 273 * 84375)\n                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n    }\n",
        "begin_line": 79,
        "end_line": 109,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0628
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getAverageMillisPerYearDividedByTwo#232",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYearDividedByTwo()",
        "snippet": "    long getAverageMillisPerYearDividedByTwo() {\n        return MILLIS_PER_YEAR / 2;\n    }\n",
        "begin_line": 232,
        "end_line": 234,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0626
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getApproxMillisAtEpochDividedByTwo#240",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getApproxMillisAtEpochDividedByTwo()",
        "snippet": "    long getApproxMillisAtEpochDividedByTwo() {\n        return (1970L * MILLIS_PER_YEAR) / 2;\n    }\n",
        "begin_line": 240,
        "end_line": 242,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0626
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.isLeapYear#196",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.isLeapYear(int)",
        "snippet": "    boolean isLeapYear(int year) {\n        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n    }\n",
        "begin_line": 196,
        "end_line": 198,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.062
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getYearMonthDayMillis#384",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getYearMonthDayMillis(int, int, int)",
        "snippet": "    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n    }\n",
        "begin_line": 384,
        "end_line": 388,
        "comment": "\n     * Get the milliseconds for a particular date.\n     *\n     * @param year The year to use.\n     * @param month The month to use\n     * @param dayOfMonth The day of the month to use\n     * @return millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0614
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.checkInstant#283",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.checkInstant(long, org.joda.time.Chronology)",
        "snippet": "    protected long checkInstant(long instant, Chronology chronology) {\n        return instant;\n    }\n",
        "begin_line": 283,
        "end_line": 285,
        "comment": "\n     * Checks the specified instant before storing it, potentially altering it.\n     * This method must not access any instance variables.\n     * <p>\n     * This implementation simply returns the instant.\n     *\n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n     * @param chronology  the chronology to use, not null\n     * @return the instant to store in this datetime\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0612
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTime.checkChronology#269",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/BaseDateTime.java",
        "class_name": "org.joda.time.base.BaseDateTime",
        "signature": "org.joda.time.base.BaseDateTime.checkChronology(org.joda.time.Chronology)",
        "snippet": "    protected Chronology checkChronology(Chronology chronology) {\n        return DateTimeUtils.getChronology(chronology);\n    }\n",
        "begin_line": 269,
        "end_line": 271,
        "comment": "\n     * Checks the specified chronology before storing it, potentially altering it.\n     * This method must not access any instance variables.\n     * <p>\n     * This implementation converts nulls to ISOChronology in the default zone.\n     *\n     * @param chronology  the chronology to use, may be null\n     * @return the chronology to store in this datetime, not null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0604
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.YearInfo#770",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.YearInfo.YearInfo(int, long)",
        "snippet": "        YearInfo(int year, long firstDayMillis) {\n            iYear = year;\n            iFirstDayMillis = firstDayMillis;\n        }\n",
        "begin_line": 770,
        "end_line": 773,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0603
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getYearMillis#359",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getYearMillis(int)",
        "snippet": "    long getYearMillis(int year) {\n        return getYearInfo(year).iFirstDayMillis;\n    }\n",
        "begin_line": 359,
        "end_line": 361,
        "comment": "\n     * Get the milliseconds for the start of a year.\n     *\n     * @param year The year to use.\n     * @return millis from 1970-01-01T00:00:00Z\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0603
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getYearInfo#737",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getYearInfo(int)",
        "snippet": "    private YearInfo getYearInfo(int year) {\n        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n        if (info == null || info.iYear != year) {\n            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n            iYearInfoCache[year & CACHE_MASK] = info;\n        }\n        return info;\n    }\n",
        "begin_line": 737,
        "end_line": 744,
        "comment": " Although accessed by multiple threads, this method doesn't need to be synchronized.",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0603
        },
        "num_failing_tests": 7
    },
    {
        "name": "AbstractDateTime.AbstractDateTime#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractDateTime.java",
        "class_name": "org.joda.time.base.AbstractDateTime",
        "signature": "org.joda.time.base.AbstractDateTime.AbstractDateTime()",
        "snippet": "    protected AbstractDateTime() {\n        super();\n    }\n",
        "begin_line": 50,
        "end_line": 52,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0603
        },
        "num_failing_tests": 7
    },
    {
        "name": "AbstractInstant.AbstractInstant#60",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/base/AbstractInstant.java",
        "class_name": "org.joda.time.base.AbstractInstant",
        "signature": "org.joda.time.base.AbstractInstant.AbstractInstant()",
        "snippet": "    protected AbstractInstant() {\n        super();\n    }\n",
        "begin_line": 60,
        "end_line": 62,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0588
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.FixedMillisProvider#414",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.FixedMillisProvider.FixedMillisProvider(long)",
        "snippet": "        FixedMillisProvider(long fixedMillis) {\n            iMillis = fixedMillis;\n        }\n",
        "begin_line": 414,
        "end_line": 416,
        "comment": "\n         * Constructor.\n         * @param offsetMillis  the millis offset\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0568
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.setCurrentMillisFixed#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
        "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }\n",
        "begin_line": 81,
        "end_line": 84,
        "comment": "\n     * Sets the current time to return a fixed millisecond time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, the same millisecond time will be returned.\n     * \n     * @param fixedMillis  the fixed millisecond time to use\n     * @throws SecurityException if the application does not have sufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0568
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.setCurrentMillisSystem#67",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
        "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }\n",
        "begin_line": 67,
        "end_line": 70,
        "comment": "\n     * Resets the current time to return the system time.\n     * <p>\n     * This method changes the behaviour of {@link #currentTimeMillis()}.\n     * Whenever the current time is queried, {@link System#currentTimeMillis()} is used.\n     * \n     * @throws SecurityException if the application does not have sufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0568
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.checkPermission#128",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.checkPermission()",
        "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }\n",
        "begin_line": 128,
        "end_line": 133,
        "comment": "\n     * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.\n     * \n     * @throws SecurityException if the provider may not be changed\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0568
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeUtils.getChronology#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeUtils.java",
        "class_name": "org.joda.time.DateTimeUtils",
        "signature": "org.joda.time.DateTimeUtils.getChronology(org.joda.time.Chronology)",
        "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }\n",
        "begin_line": 251,
        "end_line": 256,
        "comment": "\n     * Gets the chronology handling null.\n     * <p>\n     * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n     * will be returned. Otherwise, the chronology is returned.\n     * \n     * @param chrono  the chronology to use, null means ISO in the default zone\n     * @return the chronology, never null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0564
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOChronology.withUTC#132",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
        "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }\n",
        "begin_line": 132,
        "end_line": 134,
        "comment": "\n     * Gets the Chronology in the UTC time zone.\n     * \n     * @return the chronology in UTC\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0563
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.hashCode#122",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
        "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }\n",
        "begin_line": 122,
        "end_line": 124,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0557
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJEraDateTimeField.getDurationField#126",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0554
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJEraDateTimeField.getRangeDurationField#130",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 130,
        "end_line": 132,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0554
        },
        "num_failing_tests": 7
    },
    {
        "name": "UnsupportedDurationField.getUnitMillis#217",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
        "snippet": "    public long getUnitMillis() {\n        return 0;\n    }\n",
        "begin_line": 217,
        "end_line": 219,
        "comment": "\n     * Always returns zero.\n     *\n     * @return zero always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ScaledDurationField.getUnitMillis#108",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
        "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }\n",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.ZonedDurationField#283",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)",
        "snippet": "        ZonedDurationField(DurationField field, DateTimeZone zone) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iTimeField = useTimeArithmetic(field);\n            iZone = zone;\n        }\n",
        "begin_line": 283,
        "end_line": 291,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getUnitMillis#297",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDurationField.getUnitMillis()",
        "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }\n",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.ZonedDateTimeField#384",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedDateTimeField.ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "        ZonedDateTimeField(DateTimeField field,\n                           DateTimeZone zone,\n                           DurationField durationField,\n                           DurationField rangeDurationField,\n                           DurationField leapDurationField) {\n            super(field.getType());\n            if (!field.isSupported()) {\n                throw new IllegalArgumentException();\n            }\n            iField = field;\n            iZone = zone;\n            iDurationField = durationField;\n            iTimeField = useTimeArithmetic(durationField);\n            iRangeDurationField = rangeDurationField;\n            iLeapDurationField = leapDurationField;\n        }\n",
        "begin_line": 384,
        "end_line": 399,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getInstance#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)",
        "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }\n",
        "begin_line": 55,
        "end_line": 67,
        "comment": "\n     * Create a ZonedChronology for any chronology, overriding any time zone it\n     * may already have.\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     * @throws IllegalArgumentException if chronology or time zone is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.useTimeArithmetic#69",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)",
        "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }\n",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.ZonedChronology#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)",
        "snippet": "    private ZonedChronology(Chronology base, DateTimeZone zone) {\n        super(base, zone);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * Restricted constructor\n     *\n     * @param base base chronology to wrap\n     * @param zone the time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.getZone#85",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.assemble#150",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }\n",
        "begin_line": 150,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.convertField#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n",
        "begin_line": 199,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZonedChronology.convertField#211",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ZonedChronology.java",
        "class_name": "org.joda.time.chrono.ZonedChronology",
        "signature": "org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap<java.lang.Object, java.lang.Object>)",
        "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }\n",
        "begin_line": 211,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.hashCode#1249",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.hashCode()",
        "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }\n",
        "begin_line": 1249,
        "end_line": 1251,
        "comment": "\n     * Gets a hash code compatable with equals.\n     * \n     * @return suitable hashcode\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZeroIsMaxDateTimeField.getLeapDurationField#100",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ZeroIsMaxDateTimeField.java",
        "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
        "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }\n",
        "begin_line": 100,
        "end_line": 102,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "ScaledDurationField.hashCode#146",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
        "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }\n",
        "begin_line": 146,
        "end_line": 152,
        "comment": "\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationField.hashCode#141",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
        "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }\n",
        "begin_line": 141,
        "end_line": 146,
        "comment": "\n     * Gets a hash code for this instance.\n     * \n     * @return a suitable hashcode\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.getType#48",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.getType()",
        "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }\n",
        "begin_line": 48,
        "end_line": 50,
        "comment": "------------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.hashCode#154",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.hashCode()",
        "snippet": "    public int hashCode() {\n        return (int) getUnitMillis();\n    }\n",
        "begin_line": 154,
        "end_line": 156,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDurationField.getWrappedField#68",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDurationField.java",
        "class_name": "org.joda.time.field.DecoratedDurationField",
        "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
        "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Gets the wrapped duration field.\n     * \n     * @return the wrapped DurationField\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.getLeapDurationField#725",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }\n",
        "begin_line": 725,
        "end_line": 727,
        "comment": "\n     * If this field were to leap, then it would be in units described by the\n     * returned duration. If this field doesn't ever leap, null is returned.\n     * <p>\n     * This implementation returns null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.getLeapDurationField#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n",
        "begin_line": 110,
        "end_line": 112,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.getLeapDurationField#219",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }\n",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicMonthOfYearDateTimeField.getLeapDurationField#327",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
        "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n",
        "begin_line": 327,
        "end_line": 329,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0552
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJDayOfWeekDateTimeField.getRangeDurationField#93",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }\n",
        "begin_line": 93,
        "end_line": 95,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0551
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.getRangeDurationField#138",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }\n",
        "begin_line": 138,
        "end_line": 140,
        "comment": "\n     * Returns a scaled version of the wrapped field's unit duration field.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDateTimeField.getRangeDurationField#89",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }\n",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.getParam#314",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
        "snippet": "    protected final Object getParam() {\n        return iParam;\n    }\n",
        "begin_line": 314,
        "end_line": 316,
        "comment": "\n     * Returns the same param object as passed into the constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.setDefault#173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)",
        "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }\n",
        "begin_line": 173,
        "end_line": 184,
        "comment": "\n     * Sets the default time zone.\n     * <p>\n     * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n     * \n     * @param zone  the default datetime zone object, must not be null\n     * @throws IllegalArgumentException if the zone is null\n     * @throws SecurityException if the application has insufficient security rights\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDurationField.getType#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.getType()",
        "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.getRangeDurationField#207",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfYearDateTimeField.getRangeDurationField#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.055
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicMonthOfYearDateTimeField.getRangeDurationField#308",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n",
        "begin_line": 308,
        "end_line": 310,
        "comment": "-----------------------------------------------------------------------",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0549
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfMonthDateTimeField.getRangeDurationField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }\n",
        "begin_line": 50,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0549
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.getRangeDurationField#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }\n",
        "begin_line": 94,
        "end_line": 96,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0549
        },
        "num_failing_tests": 7
    },
    {
        "name": "ImpreciseDateTimeField.getUnitMillis#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.LinkedDurationField.getUnitMillis()",
        "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDateTimeField.getRangeDurationField#121",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
        "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * Returns the range duration of this field. For example, if this field\n     * represents \"minute of hour\", then the range duration field is an hours.\n     *\n     * @return the range duration of this field, or null if field has no range\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()",
        "snippet": "    private ISOYearOfEraDateTimeField() {\n        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOYearOfEraDateTimeField.getMinimumValue#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOYearOfEraDateTimeField.getMaximumValue#90",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOChronology.ISOChronology#121",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)",
        "snippet": "    private ISOChronology(Chronology base) {\n        super(base, null);\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "ISOChronology.assemble#168",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/ISOChronology.java",
        "class_name": "org.joda.time.chrono.ISOChronology",
        "signature": "org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }\n",
        "begin_line": 168,
        "end_line": 180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getInstanceUTC#80",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
        "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }\n",
        "begin_line": 80,
        "end_line": 82,
        "comment": "\n     * Gets an instance of the GregorianChronology.\n     * The time zone of the returned instance is UTC.\n     * \n     * @return a singleton UTC instance of the chronology\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0547
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getZone#141",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getZone()",
        "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }\n",
        "begin_line": 141,
        "end_line": 147,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.getDurationField#140",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }\n",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Returns the duration per unit value of this field. For example, if this\n     * field represents \"minute of hour\", then the duration field is minutes.\n     *\n     * @return the duration of this field, or UnsupportedDurationField if field\n     * has no duration\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0546
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.setFields#318",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
        "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }\n",
        "begin_line": 318,
        "end_line": 386,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getInstance#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)",
        "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }\n",
        "begin_line": 99,
        "end_line": 101,
        "comment": "\n     * Gets an instance of the GregorianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getInstance#110",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)",
        "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }\n",
        "begin_line": 110,
        "end_line": 139,
        "comment": "\n     * Gets an instance of the GregorianChronology in the given time zone.\n     * \n     * @param zone  the time zone to get the chronology in, null is default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     * @return a chronology in the specified time zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.GregorianChronology#147",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.assemble#190",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }\n",
        "begin_line": 190,
        "end_line": 194,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getMaxYear#224",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
        "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }\n",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getAverageMillisPerYear#228",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
        "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }\n",
        "begin_line": 228,
        "end_line": 230,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "GregorianChronology.getAverageMillisPerMonth#236",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GregorianChronology.java",
        "class_name": "org.joda.time.chrono.GregorianChronology",
        "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
        "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }\n",
        "begin_line": 236,
        "end_line": 238,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicGJChronology.BasicGJChronology#74",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicGJChronology.java",
        "class_name": "org.joda.time.chrono.BasicGJChronology",
        "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }\n",
        "begin_line": 74,
        "end_line": 76,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.getMaxMonth#690",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
        "snippet": "    int getMaxMonth() {\n        return 12;\n    }\n",
        "begin_line": 690,
        "end_line": 692,
        "comment": "\n     * Gets the maximum number of months.\n     * \n     * @return 12\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.054
        },
        "num_failing_tests": 7
    },
    {
        "name": "UnsupportedDurationField.isSupported#91",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
        "snippet": "    public boolean isSupported() {\n        return false;\n    }\n",
        "begin_line": 91,
        "end_line": 93,
        "comment": "\n     * This field is not supported.\n     *\n     * @return false always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.isSupported#61",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.isSupported()",
        "snippet": "    public boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "\n     * Returns true as this field is supported.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.copyFieldsFrom#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.copyFieldsFrom(org.joda.time.Chronology)",
        "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }\n",
        "begin_line": 442,
        "end_line": 555,
        "comment": "\n         * Copy the supported fields from a chronology into this container.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.isSupported#557",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.isSupported(org.joda.time.DurationField)",
        "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }\n",
        "begin_line": 557,
        "end_line": 559,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.isSupported#561",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.isSupported(org.joda.time.DateTimeField)",
        "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }\n",
        "begin_line": 561,
        "end_line": 563,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.millis#155",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millis()",
        "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }\n",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.millisOfSecond#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
        "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.millisOfDay#163",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
        "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.seconds#167",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
        "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }\n",
        "begin_line": 167,
        "end_line": 169,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.secondOfMinute#171",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
        "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }\n",
        "begin_line": 171,
        "end_line": 173,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.secondOfDay#175",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
        "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }\n",
        "begin_line": 175,
        "end_line": 177,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.minutes#179",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
        "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }\n",
        "begin_line": 179,
        "end_line": 181,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.minuteOfHour#183",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
        "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }\n",
        "begin_line": 183,
        "end_line": 185,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.minuteOfDay#187",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
        "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }\n",
        "begin_line": 187,
        "end_line": 189,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.hours#191",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hours()",
        "snippet": "    public final DurationField hours() {\n        return iHours;\n    }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.hourOfDay#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
        "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }\n",
        "begin_line": 195,
        "end_line": 197,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.clockhourOfDay#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
        "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }\n",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.halfdays#203",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
        "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }\n",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.hourOfHalfday#207",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
        "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.clockhourOfHalfday#211",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
        "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }\n",
        "begin_line": 211,
        "end_line": 213,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.halfdayOfDay#215",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
        "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }\n",
        "begin_line": 215,
        "end_line": 217,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.days#219",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.days()",
        "snippet": "    public final DurationField days() {\n        return iDays;\n    }\n",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.dayOfWeek#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
        "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }\n",
        "begin_line": 223,
        "end_line": 225,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.dayOfMonth#227",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
        "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }\n",
        "begin_line": 227,
        "end_line": 229,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.dayOfYear#231",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
        "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }\n",
        "begin_line": 231,
        "end_line": 233,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.weeks#235",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
        "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.weekOfWeekyear#239",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
        "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }\n",
        "begin_line": 239,
        "end_line": 241,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.weekyears#243",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
        "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }\n",
        "begin_line": 243,
        "end_line": 245,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.weekyear#247",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
        "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }\n",
        "begin_line": 247,
        "end_line": 249,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.weekyearOfCentury#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
        "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }\n",
        "begin_line": 251,
        "end_line": 253,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.months#255",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.months()",
        "snippet": "    public final DurationField months() {\n        return iMonths;\n    }\n",
        "begin_line": 255,
        "end_line": 257,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.monthOfYear#259",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
        "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }\n",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.years#263",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.years()",
        "snippet": "    public final DurationField years() {\n        return iYears;\n    }\n",
        "begin_line": 263,
        "end_line": 265,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.yearOfEra#271",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
        "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }\n",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.yearOfCentury#275",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
        "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }\n",
        "begin_line": 275,
        "end_line": 277,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.centuries#279",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
        "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }\n",
        "begin_line": 279,
        "end_line": 281,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.centuryOfEra#283",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
        "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }\n",
        "begin_line": 283,
        "end_line": 285,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.eras#287",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.eras()",
        "snippet": "    public final DurationField eras() {\n        return iEras;\n    }\n",
        "begin_line": 287,
        "end_line": 289,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.era#291",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.era()",
        "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }\n",
        "begin_line": 291,
        "end_line": 293,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ZeroIsMaxDateTimeField.java",
        "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
        "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }\n",
        "begin_line": 44,
        "end_line": 49,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the field type this field will actually use\n     * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "UnsupportedDurationField.getInstance#47",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(org.joda.time.DurationFieldType)",
        "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }\n",
        "begin_line": 47,
        "end_line": 60,
        "comment": "\n     * Gets an instance of UnsupportedDurationField for a specific named field.\n     * The returned instance is cached.\n     * \n     * @param type  the type to obtain\n     * @return the instance\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "ScaledDurationField.ScaledDurationField#46",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ScaledDurationField.java",
        "class_name": "org.joda.time.field.ScaledDurationField",
        "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, org.joda.time.DurationFieldType, int)",
        "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }\n",
        "begin_line": 46,
        "end_line": 52,
        "comment": "\n     * Constructor\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the type this field will actually use\n     * @param scalar  scalar, such as 100 years in a century\n     * @throws IllegalArgumentException if scalar is zero or one.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }\n",
        "begin_line": 50,
        "end_line": 67,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#75",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField)",
        "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }\n",
        "begin_line": 75,
        "end_line": 77,
        "comment": "\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.RemainderDateTimeField#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }\n",
        "begin_line": 86,
        "end_line": 90,
        "comment": "\n     * Construct a RemainderDateTimeField that compliments the given\n     * DividedDateTimeField.\n     *\n     * @param dividedField  complimentary divided field, like \"century()\".\n     * @param type  the field type this field actually uses\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.getMinimumValue#147",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 147,
        "end_line": 149,
        "comment": "\n     * Get the minimum value for the field, which is always zero.\n     * \n     * @return the minimum value of zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "RemainderDateTimeField.getMaximumValue#157",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/RemainderDateTimeField.java",
        "class_name": "org.joda.time.field.RemainderDateTimeField",
        "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": "\n     * Get the maximum value for the field, which is always one less than the\n     * divisor.\n     * \n     * @return the maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationField.PreciseDurationField#42",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(org.joda.time.DurationFieldType, long)",
        "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }\n",
        "begin_line": 42,
        "end_line": 45,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the unit milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationField.isPrecise#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
        "snippet": "    public final boolean isPrecise() {\n        return true;\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * This field is precise.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationField.getUnitMillis#62",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }\n",
        "begin_line": 62,
        "end_line": 64,
        "comment": "\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return the unit size of this field, in milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField#47",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(org.joda.time.DateTimeFieldType, org.joda.time.DurationField)",
        "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }\n",
        "begin_line": 47,
        "end_line": 60,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unit  precise unit duration, like \"days()\".\n     * @throws IllegalArgumentException if duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.getMinimumValue#149",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 0;\n    }\n",
        "begin_line": 149,
        "end_line": 151,
        "comment": "\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDurationDateTimeField.getUnitMillis#153",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
        "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }\n",
        "begin_line": 153,
        "end_line": 155,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "PreciseDateTimeField.PreciseDateTimeField#55",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDateTimeField.java",
        "class_name": "org.joda.time.field.PreciseDateTimeField",
        "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(org.joda.time.DateTimeFieldType, org.joda.time.DurationField, org.joda.time.DurationField)",
        "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }\n",
        "begin_line": 55,
        "end_line": 70,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type this field uses\n     * @param unit  precise unit duration, like \"seconds()\".\n     * @param range precise range duration, preferably a multiple of the unit,\n     * like \"minutes()\".\n     * @throws IllegalArgumentException if either duration field is imprecise\n     * @throws IllegalArgumentException if unit milliseconds is less than one\n     * or effective value range is less than two.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 45,
        "end_line": 47,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.OffsetDateTimeField#71",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int, int, int)",
        "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }\n",
        "begin_line": 71,
        "end_line": 91,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field actually uses\n     * @param offset  offset to add to field values\n     * @param minValue  minimum allowed value\n     * @param maxValue  maximum allowed value\n     * @throws IllegalArgumentException if offset is zero\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.getMinimumValue#173",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }\n",
        "begin_line": 173,
        "end_line": 175,
        "comment": "\n     * Get the minimum value for the field.\n     * \n     * @return the minimum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "OffsetDateTimeField.getMaximumValue#182",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/OffsetDateTimeField.java",
        "class_name": "org.joda.time.field.OffsetDateTimeField",
        "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }\n",
        "begin_line": 182,
        "end_line": 184,
        "comment": "\n     * Get the maximum value for the field.\n     * \n     * @return the maximum value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.MillisDurationField#43",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.MillisDurationField()",
        "snippet": "    private MillisDurationField() {\n        super();\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.isPrecise#70",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
        "snippet": "    public final boolean isPrecise() {\n        return true;\n    }\n",
        "begin_line": 70,
        "end_line": 72,
        "comment": "\n     * Returns true as this field is precise.\n     * \n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "MillisDurationField.getUnitMillis#79",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
        "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }\n",
        "begin_line": 79,
        "end_line": 81,
        "comment": "\n     * Returns the amount of milliseconds per unit value of this field.\n     *\n     * @return one always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "ImpreciseDateTimeField.LinkedDurationField#151",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.LinkedDurationField.LinkedDurationField(org.joda.time.DurationFieldType)",
        "snippet": "        LinkedDurationField(DurationFieldType type) {\n            super(type);\n        }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "ImpreciseDateTimeField.ImpreciseDateTimeField#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(org.joda.time.DateTimeFieldType, long)",
        "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }\n",
        "begin_line": 54,
        "end_line": 58,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the field type\n     * @param unitMillis  the average duration unit milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "ImpreciseDateTimeField.getDurationField#136",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/ImpreciseDateTimeField.java",
        "class_name": "org.joda.time.field.ImpreciseDateTimeField",
        "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
        "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }\n",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DividedDateTimeField.DividedDateTimeField#54",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DividedDateTimeField.java",
        "class_name": "org.joda.time.field.DividedDateTimeField",
        "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType, int)",
        "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }\n",
        "begin_line": 54,
        "end_line": 80,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field to wrap, like \"year()\".\n     * @param type  the field type this field will actually use\n     * @param divisor  divisor, such as 100 years in a century\n     * @throws IllegalArgumentException if divisor is less than two\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DividedDateTimeField.getDurationField#181",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DividedDateTimeField.java",
        "class_name": "org.joda.time.field.DividedDateTimeField",
        "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Returns a scaled version of the wrapped field's unit duration field.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDurationField.DecoratedDurationField#51",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDurationField.java",
        "class_name": "org.joda.time.field.DecoratedDurationField",
        "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, org.joda.time.DurationFieldType)",
        "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }\n",
        "begin_line": 51,
        "end_line": 60,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the base field\n     * @param type  the type to actually use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDateTimeField.DecoratedDateTimeField#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeFieldType)",
        "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }\n",
        "begin_line": 53,
        "end_line": 62,
        "comment": "\n     * Constructor.\n     * \n     * @param field  the field being decorated\n     * @param type  allow type to be overridden\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDateTimeField.getWrappedField#69",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
        "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }\n",
        "begin_line": 69,
        "end_line": 71,
        "comment": "\n     * Gets the wrapped date time field.\n     * \n     * @return the wrapped DateTimeField\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DecoratedDateTimeField.getDurationField#85",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/DecoratedDateTimeField.java",
        "class_name": "org.joda.time.field.DecoratedDateTimeField",
        "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
        "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }\n",
        "begin_line": 85,
        "end_line": 87,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDurationField.BaseDurationField#46",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(org.joda.time.DurationFieldType)",
        "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }\n",
        "begin_line": 46,
        "end_line": 52,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDurationField.isSupported#65",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDurationField.java",
        "class_name": "org.joda.time.field.BaseDurationField",
        "signature": "org.joda.time.field.BaseDurationField.isSupported()",
        "snippet": "    public final boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 65,
        "end_line": 67,
        "comment": "\n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.BaseDateTimeField#49",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(org.joda.time.DateTimeFieldType)",
        "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }\n",
        "begin_line": 49,
        "end_line": 55,
        "comment": "\n     * Constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.getType#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.getType()",
        "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }\n",
        "begin_line": 57,
        "end_line": 59,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseDateTimeField.isSupported#68",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
        "snippet": "    public final boolean isSupported() {\n        return true;\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * @return true always\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField#39",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }\n",
        "begin_line": 39,
        "end_line": 42,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJYearOfEraDateTimeField.getMinimumValue#92",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
        "snippet": "    public int getMinimumValue() {\n        return 1;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJYearOfEraDateTimeField.getMaximumValue#96",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
        "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField#36",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJEraDateTimeField.GJEraDateTimeField#45",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJEraDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJEraDateTimeField",
        "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }\n",
        "begin_line": 45,
        "end_line": 48,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java",
        "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
        "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.BasicYearDateTimeField#44",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }\n",
        "begin_line": 44,
        "end_line": 47,
        "comment": "\n     * Restricted constructor.\n     * \n     * @param chronology  the chronology this field belogs to\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicYearDateTimeField.getMaximumValue#118",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
        "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }\n",
        "begin_line": 118,
        "end_line": 120,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField#43",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(org.joda.time.chrono.BasicChronology)",
        "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }\n",
        "begin_line": 43,
        "end_line": 46,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField#41",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicWeekOfWeekyearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
        "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }\n",
        "begin_line": 41,
        "end_line": 44,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField#50",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(org.joda.time.chrono.BasicChronology, int)",
        "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }\n",
        "begin_line": 50,
        "end_line": 55,
        "comment": "\n     * Restricted constructor.\n     * \n     * @param leapMonth the month of year that leaps\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField#40",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": "\n     * Restricted constructor\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField#40",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
        "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(org.joda.time.chrono.BasicChronology, org.joda.time.DurationField)",
        "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }\n",
        "begin_line": 40,
        "end_line": 43,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.HalfdayField#749",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.HalfdayField.HalfdayField()",
        "snippet": "        HalfdayField() {\n            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);\n        }\n",
        "begin_line": 749,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.BasicChronology#130",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(org.joda.time.Chronology, java.lang.Object, int)",
        "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }\n",
        "begin_line": 130,
        "end_line": 139,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BasicChronology.assemble#237",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicChronology.java",
        "class_name": "org.joda.time.chrono.BasicChronology",
        "signature": "org.joda.time.chrono.BasicChronology.assemble(org.joda.time.chrono.AssembledChronology.Fields)",
        "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }\n",
        "begin_line": 237,
        "end_line": 298,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseChronology.eras#659",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.eras()",
        "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }\n",
        "begin_line": 659,
        "end_line": 661,
        "comment": "\n     * Get the eras duration field for this chronology.\n     * \n     * @return DurationField or UnsupportedDurationField if unsupported\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.Fields#436",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.Fields.Fields()",
        "snippet": "        Fields() {\n        }\n",
        "begin_line": 436,
        "end_line": 437,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.AssembledChronology#99",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)",
        "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }\n",
        "begin_line": 99,
        "end_line": 103,
        "comment": "\n     * Constructor calls the assemble method, enabling subclasses to define its\n     * supported fields. If a base chronology is supplied, the field set\n     * initially contains references to each base chronology field.\n     * <p>\n     * Other methods in this class will delegate to the base chronology, if it\n     * can be determined that the base chronology will produce the same results\n     * as AbstractChronology.\n     *\n     * @param base optional base chronology to copy initial fields from\n     * @param param optional param object avalable for assemble method\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.year#267",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.year()",
        "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }\n",
        "begin_line": 267,
        "end_line": 269,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "AssembledChronology.getBase#307",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/AssembledChronology.java",
        "class_name": "org.joda.time.chrono.AssembledChronology",
        "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
        "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }\n",
        "begin_line": 307,
        "end_line": 309,
        "comment": "\n     * Returns the same base chronology as passed into the constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.getDurationType#451",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getDurationType()",
        "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }\n",
        "begin_line": 451,
        "end_line": 453,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.getRangeDurationType#456",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.getRangeDurationType()",
        "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }\n",
        "begin_line": 456,
        "end_line": 458,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.millisOfSecond#163",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
        "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }\n",
        "begin_line": 163,
        "end_line": 165,
        "comment": "\n     * Get the millis of second field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.millisOfDay#172",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
        "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }\n",
        "begin_line": 172,
        "end_line": 174,
        "comment": "\n     * Get the millis of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.secondOfMinute#181",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
        "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }\n",
        "begin_line": 181,
        "end_line": 183,
        "comment": "\n     * Get the second of minute field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.secondOfDay#190",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
        "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }\n",
        "begin_line": 190,
        "end_line": 192,
        "comment": "\n     * Get the second of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.minuteOfDay#208",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
        "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }\n",
        "begin_line": 208,
        "end_line": 210,
        "comment": "\n     * Get the minute of day field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.hourOfDay#217",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
        "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }\n",
        "begin_line": 217,
        "end_line": 219,
        "comment": "\n     * Get the hour of day (0-23) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.hourOfHalfday#235",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
        "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }\n",
        "begin_line": 235,
        "end_line": 237,
        "comment": "\n     * Get the hour of am/pm (0-11) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.clockhourOfHalfday#244",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
        "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }\n",
        "begin_line": 244,
        "end_line": 246,
        "comment": "\n     * Get the hour of am/pm (offset to 1-12) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.halfdayOfDay#253",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
        "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }\n",
        "begin_line": 253,
        "end_line": 255,
        "comment": "\n     * Get the AM(0) PM(1) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.dayOfWeek#263",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
        "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }\n",
        "begin_line": 263,
        "end_line": 265,
        "comment": "\n     * Get the day of week field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.dayOfYear#281",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
        "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }\n",
        "begin_line": 281,
        "end_line": 283,
        "comment": "\n     * Get the day of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.weekOfWeekyear#290",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
        "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }\n",
        "begin_line": 290,
        "end_line": 292,
        "comment": "\n     * Get the week of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.weekyear#299",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekyear()",
        "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }\n",
        "begin_line": 299,
        "end_line": 301,
        "comment": "\n     * Get the year of a week based year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.weekyearOfCentury#308",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
        "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }\n",
        "begin_line": 308,
        "end_line": 310,
        "comment": "\n     * Get the year of a week based year within a century field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.monthOfYear#317",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
        "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }\n",
        "begin_line": 317,
        "end_line": 319,
        "comment": "\n     * Get the month of year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.yearOfEra#335",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
        "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }\n",
        "begin_line": 335,
        "end_line": 337,
        "comment": "\n     * Get the year of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.yearOfCentury#344",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
        "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }\n",
        "begin_line": 344,
        "end_line": 346,
        "comment": "\n     * Get the year of century field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.centuryOfEra#353",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
        "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }\n",
        "begin_line": 353,
        "end_line": 355,
        "comment": "\n     * Get the century of era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.era#362",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.era()",
        "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }\n",
        "begin_line": 362,
        "end_line": 364,
        "comment": "\n     * Get the era field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "FixedDateTimeZone.hashCode#101",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
        "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "UnsupportedDurationField.UnsupportedDurationField#70",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/UnsupportedDurationField.java",
        "class_name": "org.joda.time.field.UnsupportedDurationField",
        "signature": "org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(org.joda.time.DurationFieldType)",
        "snippet": "    private UnsupportedDurationField(DurationFieldType type) {\n        iType = type;\n    }\n",
        "begin_line": 70,
        "end_line": 72,
        "comment": "\n     * Constructor.\n     * \n     * @param type  the type to use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.minuteOfHour#199",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
        "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }\n",
        "begin_line": 199,
        "end_line": 201,
        "comment": "\n     * Get the minute of hour field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.clockhourOfDay#226",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
        "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }\n",
        "begin_line": 226,
        "end_line": 228,
        "comment": "\n     * Get the hour of day (offset to 1-24) field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.dayOfMonth#272",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
        "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }\n",
        "begin_line": 272,
        "end_line": 274,
        "comment": "\n     * Get the day of month field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.year#326",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.year()",
        "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }\n",
        "begin_line": 326,
        "end_line": 328,
        "comment": "\n     * Get the year field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.halfdays#140",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.halfdays()",
        "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }\n",
        "begin_line": 140,
        "end_line": 142,
        "comment": "\n     * Get the halfdays field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.weekyears#168",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.weekyears()",
        "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }\n",
        "begin_line": 168,
        "end_line": 170,
        "comment": "\n     * Get the weekyears field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.eras#204",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.eras()",
        "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }\n",
        "begin_line": 204,
        "end_line": 206,
        "comment": "\n     * Get the eras field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.StandardDateTimeFieldType#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.StandardDateTimeFieldType.StandardDateTimeFieldType(java.lang.String, byte, org.joda.time.DurationFieldType, org.joda.time.DurationFieldType)",
        "snippet": "        StandardDateTimeFieldType(String name, byte ordinal,\n                                  DurationFieldType unitType, DurationFieldType rangeType) {\n            super(name);\n            iOrdinal = ordinal;\n            iUnitType = unitType;\n            iRangeType = rangeType;\n        }\n",
        "begin_line": 442,
        "end_line": 448,
        "comment": "\n         * Constructor.\n         * \n         * @param name  the name to use\n         * @param ordinal  the byte value for the oridinal index\n         * @param unitType  the unit duration type\n         * @param rangeType  the range duration type\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeFieldType.DateTimeFieldType#152",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeFieldType.java",
        "class_name": "org.joda.time.DateTimeFieldType",
        "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(java.lang.String)",
        "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }\n",
        "begin_line": 152,
        "end_line": 155,
        "comment": "\n     * Constructor.\n     * \n     * @param name  the name to use\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0539
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.centuries#195",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.centuries()",
        "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }\n",
        "begin_line": 195,
        "end_line": 197,
        "comment": "\n     * Get the centuries field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0538
        },
        "num_failing_tests": 7
    },
    {
        "name": "BaseChronology.BaseChronology#53",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BaseChronology.java",
        "class_name": "org.joda.time.chrono.BaseChronology",
        "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
        "snippet": "    protected BaseChronology() {\n        super();\n    }\n",
        "begin_line": 53,
        "end_line": 55,
        "comment": "\n     * Restricted constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0537
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.hashCode#276",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.StandardDurationFieldType.hashCode()",
        "snippet": "        @Override\n        public int hashCode() {\n            return (1 << iOrdinal);\n        }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": " @inheritdoc ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0535
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.getDefault#132",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefault()",
        "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }\n",
        "begin_line": 132,
        "end_line": 162,
        "comment": "\n     * Gets the default time zone.\n     * <p>\n     * The default time zone is derived from the system property {@code user.timezone}.\n     * If that is {@code null} or is not a valid identifier, then the value of the\n     * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n     * <p>\n     * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n     * method, then the change will not be picked up here.\n     * \n     * @return the default datetime zone object\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0534
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.weeks#159",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.weeks()",
        "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }\n",
        "begin_line": 159,
        "end_line": 161,
        "comment": "\n     * Get the weeks field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0532
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.months#177",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.months()",
        "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }\n",
        "begin_line": 177,
        "end_line": 179,
        "comment": "\n     * Get the months field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0532
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.years#186",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.years()",
        "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }\n",
        "begin_line": 186,
        "end_line": 188,
        "comment": "\n     * Get the years field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0532
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.seconds#113",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.seconds()",
        "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }\n",
        "begin_line": 113,
        "end_line": 115,
        "comment": "\n     * Get the seconds field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.minutes#122",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.minutes()",
        "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }\n",
        "begin_line": 122,
        "end_line": 124,
        "comment": "\n     * Get the minutes field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.hours#131",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.hours()",
        "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }\n",
        "begin_line": 131,
        "end_line": 133,
        "comment": "\n     * Get the hours field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.millis#104",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.millis()",
        "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }\n",
        "begin_line": 104,
        "end_line": 106,
        "comment": "\n     * Get the millis field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.days#150",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.days()",
        "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }\n",
        "begin_line": 150,
        "end_line": 152,
        "comment": "\n     * Get the days field type.\n     * \n     * @return the DateTimeFieldType constant\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.StandardDurationFieldType#258",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.StandardDurationFieldType.StandardDurationFieldType(java.lang.String, byte)",
        "snippet": "        StandardDurationFieldType(String name, byte ordinal) {\n            super(name);\n            iOrdinal = ordinal;\n        }\n",
        "begin_line": 258,
        "end_line": 261,
        "comment": "\n         * Constructor.\n         * \n         * @param name  the name to use\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "DurationFieldType.DurationFieldType#93",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DurationFieldType.java",
        "class_name": "org.joda.time.DurationFieldType",
        "signature": "org.joda.time.DurationFieldType.DurationFieldType(java.lang.String)",
        "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }\n",
        "begin_line": 93,
        "end_line": 96,
        "comment": "\n     * Constructor.\n     * \n     * @param name  the name to use, which by convention, are plural.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0531
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.getZone#135",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(java.lang.String)",
        "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }\n",
        "begin_line": 135,
        "end_line": 163,
        "comment": "\n     * If an error is thrown while loading zone data, uncaughtException is\n     * called to log the error and null is returned for this and all future\n     * requests.\n     * \n     * @param id  the id to load\n     * @return the loaded zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.loadZoneData#223",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)",
        "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }\n",
        "begin_line": 223,
        "end_line": 242,
        "comment": "\n     * Loads the time zone data for one id.\n     * \n     * @param id  the id to load\n     * @return the zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#739",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.readFrom(java.io.DataInput)",
        "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }\n",
        "begin_line": 739,
        "end_line": 741,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.Recurrence#747",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.Recurrence(org.joda.time.tz.DateTimeZoneBuilder.OfYear, java.lang.String, int)",
        "snippet": "        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\n            iOfYear = ofYear;\n            iNameKey = nameKey;\n            iSaveMillis = saveMillis;\n        }\n",
        "begin_line": 747,
        "end_line": 751,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1339",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }\n",
        "begin_line": 1339,
        "end_line": 1377,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.PrecalculatedZone#1497",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.PrecalculatedZone.PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder.DSTZone)",
        "snippet": "        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\n                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n        {\n            super(id);\n            iTransitions = transitions;\n            iWallOffsets = wallOffsets;\n            iStandardOffsets = standardOffsets;\n            iNameKeys = nameKeys;\n            iTailZone = tailZone;\n        }\n",
        "begin_line": 1497,
        "end_line": 1506,
        "comment": "\n         * Constructor used ONLY for valid input, loaded via static methods.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#481",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.readFrom(java.io.DataInput)",
        "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }\n",
        "begin_line": 481,
        "end_line": 488,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.OfYear#499",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.OfYear(char, int, int, int, boolean, int)",
        "snippet": "        OfYear(char mode,\n               int monthOfYear,\n               int dayOfMonth,\n               int dayOfWeek, boolean advanceDayOfWeek,\n               int millisOfDay)\n        {\n            if (mode != 'u' && mode != 'w' && mode != 's') {\n                throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n            }\n\n            iMode = mode;\n            iMonthOfYear = monthOfYear;\n            iDayOfMonth = dayOfMonth;\n            iDayOfWeek = dayOfWeek;\n            iAdvance = advanceDayOfWeek;\n            iMillisOfDay = millisOfDay;\n        }\n",
        "begin_line": 499,
        "end_line": 515,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#1165",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }\n",
        "begin_line": 1165,
        "end_line": 1168,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.DSTZone#1174",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder.Recurrence, org.joda.time.tz.DateTimeZoneBuilder.Recurrence)",
        "snippet": "        DSTZone(String id, int standardOffset,\n                Recurrence startRecurrence, Recurrence endRecurrence) {\n            super(id);\n            iStandardOffset = standardOffset;\n            iStartRecurrence = startRecurrence;\n            iEndRecurrence = endRecurrence;\n        }\n",
        "begin_line": 1174,
        "end_line": 1180,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#94",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }\n",
        "begin_line": 94,
        "end_line": 100,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readFrom#109",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)",
        "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }\n",
        "begin_line": 109,
        "end_line": 125,
        "comment": "\n     * Decodes a built DateTimeZone from the given stream, as encoded by\n     * writeTo.\n     *\n     * @param in input stream to read encoded DateTimeZone from.\n     * @param id time zone id to assign\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.readMillis#182",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)",
        "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }\n",
        "begin_line": 182,
        "end_line": 211,
        "comment": "\n     * Reads encoding generated by writeMillis.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.forZone#67",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)",
        "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }\n",
        "begin_line": 67,
        "end_line": 72,
        "comment": "\n     * Returns a new CachedDateTimeZone unless given zone is already cached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "CachedDateTimeZone.CachedDateTimeZone#86",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/CachedDateTimeZone.java",
        "class_name": "org.joda.time.tz.CachedDateTimeZone",
        "signature": "org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)",
        "snippet": "    private CachedDateTimeZone(DateTimeZone zone) {\n        super(zone.getID());\n        iZone = zone;\n    }\n",
        "begin_line": 86,
        "end_line": 89,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.forID#202",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.forID(java.lang.String)",
        "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }\n",
        "begin_line": 202,
        "end_line": 224,
        "comment": "\n     * Gets a time zone instance for the specified time zone id.\n     * <p>\n     * The time zone id may be one of those returned by getAvailableIDs.\n     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n     * All IDs must be specified in the long format.\n     * The exception is UTC, which is an acceptable id.\n     * <p>\n     * Alternatively a locale independent, fixed offset, datetime zone can\n     * be specified. The form <code>[+-]hh:mm</code> can be used.\n     * \n     * @param id  the ID of the datetime zone, null means default\n     * @return the DateTimeZone object for the ID\n     * @throws IllegalArgumentException if the ID is not recognised\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0521
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.getID#704",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getID()",
        "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }\n",
        "begin_line": 704,
        "end_line": 707,
        "comment": "\n     * Gets the ID of this datetime zone.\n     * \n     * @return the ID of this datetime zone\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)",
        "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }\n",
        "begin_line": 81,
        "end_line": 83,
        "comment": "\n     * ZoneInfoProvider searches the given ClassLoader resource path for\n     * compiled data files. Resources are loaded from the ClassLoader that\n     * loaded this class.\n     *\n     * @throws IOException if directory or map file cannot be read\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.ZoneInfoProvider#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)",
        "snippet": "    private ZoneInfoProvider(String resourcePath,\n                             ClassLoader loader, boolean favorSystemLoader) \n        throws IOException\n    {\n        if (resourcePath == null) {\n            throw new IllegalArgumentException(\"No resource path provided\");\n        }\n        if (!resourcePath.endsWith(\"/\")) {\n            resourcePath += '/';\n        }\n\n        iFileDir = null;\n        iResourcePath = resourcePath;\n\n        if (loader == null && !favorSystemLoader) {\n            loader = getClass().getClassLoader();\n        }\n\n        iLoader = loader;\n\n        iZoneInfoMap = loadZoneInfoMap(openResource(\"ZoneInfoMap\"));\n    }\n",
        "begin_line": 103,
        "end_line": 124,
        "comment": "\n     * @param favorSystemLoader when true, use the system class loader if\n     * loader null. When false, use the current class loader if loader is null.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.getAvailableIDs#170",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
        "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }\n",
        "begin_line": 170,
        "end_line": 175,
        "comment": "\n     * Gets a list of all the available zone ids.\n     * \n     * @return the zone ids\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.openResource#194",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)",
        "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuffer buf = new StringBuffer(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }\n",
        "begin_line": 194,
        "end_line": 215,
        "comment": "\n     * Opens a resource from file or classpath.\n     * \n     * @param name  the name to open\n     * @return the input stream\n     * @throws IOException if an error occurs\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.loadZoneInfoMap#251",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)",
        "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }\n",
        "begin_line": 251,
        "end_line": 264,
        "comment": "\n     * Loads the zone info map.\n     * \n     * @param in  the input stream\n     * @return the map\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "ZoneInfoProvider.readZoneInfoMap#272",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/ZoneInfoProvider.java",
        "class_name": "org.joda.time.tz.ZoneInfoProvider",
        "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(java.io.DataInputStream, java.util.Map<java.lang.String, java.lang.Object>)",
        "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }\n",
        "begin_line": 272,
        "end_line": 289,
        "comment": "\n     * Reads the zone info map from file.\n     * \n     * @param din  the input stream\n     * @param zimap  gets filled with string id to string id mappings\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "FixedDateTimeZone.FixedDateTimeZone#36",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)",
        "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }\n",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "FixedDateTimeZone.equals#87",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/FixedDateTimeZone.java",
        "class_name": "org.joda.time.tz.FixedDateTimeZone",
        "signature": "org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)",
        "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone) obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }\n",
        "begin_line": 87,
        "end_line": 99,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DefaultNameProvider.DefaultNameProvider#39",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
        "snippet": "    public DefaultNameProvider() {\n    }\n",
        "begin_line": 39,
        "end_line": 40,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DefaultNameProvider.createCache#98",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DefaultNameProvider.java",
        "class_name": "org.joda.time.tz.DefaultNameProvider",
        "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
        "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }\n",
        "begin_line": 98,
        "end_line": 100,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.setProvider0#414",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)",
        "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }\n",
        "begin_line": 414,
        "end_line": 431,
        "comment": "\n     * Sets the zone provider factory without performing the security check.\n     * \n     * @param provider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.getDefaultProvider#442",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
        "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }\n",
        "begin_line": 442,
        "end_line": 474,
        "comment": "\n     * Gets the default zone provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n     * Then uses <code>UTCProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.setNameProvider0#513",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)",
        "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }\n",
        "begin_line": 513,
        "end_line": 518,
        "comment": "\n     * Sets the name provider factory without performing the security check.\n     * \n     * @param nameProvider  provider to use, or null for default\n     * @throws IllegalArgumentException if the provider is invalid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.getDefaultNameProvider#528",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
        "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }\n",
        "begin_line": 528,
        "end_line": 549,
        "comment": "\n     * Gets the default name provider.\n     * <p>\n     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n     * Then uses <code>DefaultNameProvider</code>.\n     * \n     * @return the default name provider\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZone.DateTimeZone#689",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/DateTimeZone.java",
        "class_name": "org.joda.time.DateTimeZone",
        "signature": "org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)",
        "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }\n",
        "begin_line": 689,
        "end_line": 694,
        "comment": "\n     * Constructor.\n     * \n     * @param id  the id to use\n     * @throws IllegalArgumentException if the id is null\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.052
        },
        "num_failing_tests": 7
    },
    {
        "name": "DateTimeZoneBuilder.previous#589",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.previous(long, int, int)",
        "snippet": "        public long previous(long instant, int standardOffset, int saveMillis) {\n            int offset;\n            if (iMode == 'w') {\n                offset = standardOffset + saveMillis;\n            } else if (iMode == 's') {\n                offset = standardOffset;\n            } else {\n                offset = 0;\n            }\n\n            // Convert from UTC to local time.\n            instant += offset;\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n            // Be lenient with millisOfDay.\n            prev = chrono.millisOfDay().set(prev, 0);\n            prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n            prev = setDayOfMonthPrevious(chrono, prev);\n\n            if (iDayOfWeek == 0) {\n                if (prev >= instant) {\n                    prev = chrono.year().add(prev, -1);\n                    prev = setDayOfMonthPrevious(chrono, prev);\n                }\n            } else {\n                prev = setDayOfWeek(chrono, prev);\n                if (prev >= instant) {\n                    prev = chrono.year().add(prev, -1);\n                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n                    prev = setDayOfMonthPrevious(chrono, prev);\n                    prev = setDayOfWeek(chrono, prev);\n                }\n            }\n\n            // Convert from local time to UTC.\n            return prev - offset;\n        }\n",
        "begin_line": 589,
        "end_line": 626,
        "comment": "\n         * @param standardOffset standard offset just before previous recurrence\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0517
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.previous#767",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.previous(long, int, int)",
        "snippet": "        public long previous(long instant, int standardOffset, int saveMillis) {\n            return iOfYear.previous(instant, standardOffset, saveMillis);\n        }\n",
        "begin_line": 767,
        "end_line": 769,
        "comment": "\n         * @param standardOffset standard offset just before previous recurrence\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0507
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.setDayOfMonthPrevious#689",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)",
        "snippet": "        private long setDayOfMonthPrevious(Chronology chrono, long prev) {\n            try {\n                prev = setDayOfMonth(chrono, prev);\n            } catch (IllegalArgumentException e) {\n                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n                    while (chrono.year().isLeap(prev) == false) {\n                        prev = chrono.year().add(prev, -1);\n                    }\n                    prev = setDayOfMonth(chrono, prev);\n                } else {\n                    throw e;\n                }\n            }\n            return prev;\n        }\n",
        "begin_line": 689,
        "end_line": 703,
        "comment": "\n         * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0507
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.previousTransition#1238",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.previousTransition(long)",
        "snippet": "        public long previousTransition(long instant) {\n            // Increment in order to handle the case where instant is exactly at\n            // a transition.\n            instant++;\n\n            int standardOffset = iStandardOffset;\n            Recurrence startRecurrence = iStartRecurrence;\n            Recurrence endRecurrence = iEndRecurrence;\n\n            long start, end;\n\n            try {\n                start = startRecurrence.previous\n                    (instant, standardOffset, endRecurrence.getSaveMillis());\n                if (instant < 0 && start > 0) {\n                    // Overflowed.\n                    start = instant;\n                }\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                start = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                start = instant;\n            }\n\n            try {\n                end = endRecurrence.previous\n                    (instant, standardOffset, startRecurrence.getSaveMillis());\n                if (instant < 0 && end > 0) {\n                    // Overflowed.\n                    end = instant;\n                }\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                end = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                end = instant;\n            }\n\n            return ((start > end) ? start : end) - 1;\n        }\n",
        "begin_line": 1238,
        "end_line": 1280,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0507
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeFormatterBuilder.parseInto#1201",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)",
        "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n",
        "begin_line": 1201,
        "end_line": 1222,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0453
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.next#547",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.next(long, int, int)",
        "snippet": "        public long next(long instant, int standardOffset, int saveMillis) {\n            int offset;\n            if (iMode == 'w') {\n                offset = standardOffset + saveMillis;\n            } else if (iMode == 's') {\n                offset = standardOffset;\n            } else {\n                offset = 0;\n            }\n\n            // Convert from UTC to local time.\n            instant += offset;\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n            long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n            // Be lenient with millisOfDay.\n            next = chrono.millisOfDay().set(next, 0);\n            next = chrono.millisOfDay().add(next, iMillisOfDay);\n            next = setDayOfMonthNext(chrono, next);\n\n            if (iDayOfWeek == 0) {\n                if (next <= instant) {\n                    next = chrono.year().add(next, 1);\n                    next = setDayOfMonthNext(chrono, next);\n                }\n            } else {\n                next = setDayOfWeek(chrono, next);\n                if (next <= instant) {\n                    next = chrono.year().add(next, 1);\n                    next = chrono.monthOfYear().set(next, iMonthOfYear);\n                    next = setDayOfMonthNext(chrono, next);\n                    next = setDayOfWeek(chrono, next);\n                }\n            }\n\n            // Convert from local time to UTC.\n            return next - offset;\n        }\n",
        "begin_line": 547,
        "end_line": 584,
        "comment": "\n         * @param standardOffset standard offset just before next recurrence\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0425
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.setDayOfMonth#705",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfMonth(org.joda.time.Chronology, long)",
        "snippet": "        private long setDayOfMonth(Chronology chrono, long instant) {\n            if (iDayOfMonth >= 0) {\n                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n            } else {\n                instant = chrono.dayOfMonth().set(instant, 1);\n                instant = chrono.monthOfYear().add(instant, 1);\n                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n            }\n            return instant;\n        }\n",
        "begin_line": 705,
        "end_line": 714,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0425
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.setDayOfWeek#716",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfWeek(org.joda.time.Chronology, long)",
        "snippet": "        private long setDayOfWeek(Chronology chrono, long instant) {\n            int dayOfWeek = chrono.dayOfWeek().get(instant);\n            int daysToAdd = iDayOfWeek - dayOfWeek;\n            if (daysToAdd != 0) {\n                if (iAdvance) {\n                    if (daysToAdd < 0) {\n                        daysToAdd += 7;\n                    }\n                } else {\n                    if (daysToAdd > 0) {\n                        daysToAdd -= 7;\n                    }\n                }\n                instant = chrono.dayOfWeek().add(instant, daysToAdd);\n            }\n            return instant;\n        }\n",
        "begin_line": 716,
        "end_line": 732,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0425
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.getOffset#1186",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.getOffset(long)",
        "snippet": "        public int getOffset(long instant) {\n            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();\n        }\n",
        "begin_line": 1186,
        "end_line": 1188,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0424
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeFormatterBuilder.parseInto#2687",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)",
        "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n",
        "begin_line": 2687,
        "end_line": 2698,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0423
        },
        "num_failing_tests": 2
    },
    {
        "name": "DateTimeZoneBuilder.findMatchingRecurrence#1303",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.findMatchingRecurrence(long)",
        "snippet": "        private Recurrence findMatchingRecurrence(long instant) {\n            int standardOffset = iStandardOffset;\n            Recurrence startRecurrence = iStartRecurrence;\n            Recurrence endRecurrence = iEndRecurrence;\n\n            long start, end;\n\n            try {\n                start = startRecurrence.next\n                    (instant, standardOffset, endRecurrence.getSaveMillis());\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                start = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                start = instant;\n            }\n\n            try {\n                end = endRecurrence.next\n                    (instant, standardOffset, startRecurrence.getSaveMillis());\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                end = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                end = instant;\n            }\n\n            return (start > end) ? startRecurrence : endRecurrence;\n        }\n",
        "begin_line": 1303,
        "end_line": 1333,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0422
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.nextTransition#1198",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.DSTZone.nextTransition(long)",
        "snippet": "        public long nextTransition(long instant) {\n            int standardOffset = iStandardOffset;\n            Recurrence startRecurrence = iStartRecurrence;\n            Recurrence endRecurrence = iEndRecurrence;\n\n            long start, end;\n\n            try {\n                start = startRecurrence.next\n                    (instant, standardOffset, endRecurrence.getSaveMillis());\n                if (instant > 0 && start < 0) {\n                    // Overflowed.\n                    start = instant;\n                }\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                start = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                start = instant;\n            }\n\n            try {\n                end = endRecurrence.next\n                    (instant, standardOffset, startRecurrence.getSaveMillis());\n                if (instant > 0 && end < 0) {\n                    // Overflowed.\n                    end = instant;\n                }\n            } catch (IllegalArgumentException e) {\n                // Overflowed.\n                end = instant;\n            } catch (ArithmeticException e) {\n                // Overflowed.\n                end = instant;\n            }\n\n            return (start > end) ? end : start;\n        }\n",
        "begin_line": 1198,
        "end_line": 1236,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0416
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.next#760",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.next(long, int, int)",
        "snippet": "        public long next(long instant, int standardOffset, int saveMillis) {\n            return iOfYear.next(instant, standardOffset, saveMillis);\n        }\n",
        "begin_line": 760,
        "end_line": 762,
        "comment": "\n         * @param standardOffset standard offset just before next recurrence\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0415
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.getSaveMillis#775",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.Recurrence.getSaveMillis()",
        "snippet": "        public int getSaveMillis() {\n            return iSaveMillis;\n        }\n",
        "begin_line": 775,
        "end_line": 777,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0415
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeZoneBuilder.setDayOfMonthNext#670",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java",
        "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
        "signature": "org.joda.time.tz.DateTimeZoneBuilder.OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)",
        "snippet": "        private long setDayOfMonthNext(Chronology chrono, long next) {\n            try {\n                next = setDayOfMonth(chrono, next);\n            } catch (IllegalArgumentException e) {\n                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n                    while (chrono.year().isLeap(next) == false) {\n                        next = chrono.year().add(next, 1);\n                    }\n                    next = setDayOfMonth(chrono, next);\n                } else {\n                    throw e;\n                }\n            }\n            return next;\n        }\n",
        "begin_line": 670,
        "end_line": 684,
        "comment": "\n         * If month-day is 02-29 and year isn't leap, advances to next leap year.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0415
        },
        "num_failing_tests": 3
    },
    {
        "name": "BaseDateTimeField.add#252",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/BaseDateTimeField.java",
        "class_name": "org.joda.time.field.BaseDateTimeField",
        "signature": "org.joda.time.field.BaseDateTimeField.add(long, int)",
        "snippet": "    public long add(long instant, int value) {\n        return getDurationField().add(instant, value);\n    }\n",
        "begin_line": 252,
        "end_line": 254,
        "comment": "\n     * Adds a value (which may be negative) to the instant value,\n     * overflowing into larger fields if necessary.\n     * <p>\n     * The value will be added to this field. If the value is too large to be\n     * added solely to this field, larger fields will increase as required.\n     * Smaller fields should be unaffected, except where the result would be\n     * an invalid value for a smaller field. In this case the smaller field is\n     * adjusted to be in range.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 2000-08-20 add six months is 2001-02-20<br>\n     * 2000-08-20 add twenty months is 2002-04-20<br>\n     * 2000-08-20 add minus nine months is 1999-11-20<br>\n     * 2001-01-31 add one month  is 2001-02-28<br>\n     * 2001-01-31 add two months is 2001-03-31<br>\n     * \n     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n     * @param value  the value to add, in the units of the field\n     * @return the updated milliseconds\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0414
        },
        "num_failing_tests": 3
    },
    {
        "name": "BasicMonthOfYearDateTimeField.add#91",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long, int)",
        "snippet": "    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n",
        "begin_line": 91,
        "end_line": 147,
        "comment": "\n     * Add the specified month to the specified time instant.\n     * The amount added may be negative.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 - (1 month) = 06-30<p>\n     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n     * \n     * @see org.joda.time.DateTimeField#add\n     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0413
        },
        "num_failing_tests": 3
    },
    {
        "name": "BasicYearDateTimeField.add#57",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/chrono/BasicYearDateTimeField.java",
        "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
        "signature": "org.joda.time.chrono.BasicYearDateTimeField.add(long, int)",
        "snippet": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        int thisYear = get(instant);\n        int newYear = FieldUtils.safeAdd(thisYear, years);\n        return set(instant, newYear);\n    }\n",
        "begin_line": 57,
        "end_line": 64,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0407
        },
        "num_failing_tests": 3
    },
    {
        "name": "DateTimeFormatterBuilder.estimatePrintedLength#1366",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java",
        "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
        "signature": "org.joda.time.format.DateTimeFormatterBuilder.UnpaddedNumber.estimatePrintedLength()",
        "snippet": "        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n",
        "begin_line": 1366,
        "end_line": 1368,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0403
        },
        "num_failing_tests": 2
    },
    {
        "name": "MillisDurationField.add#116",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/MillisDurationField.java",
        "class_name": "org.joda.time.field.MillisDurationField",
        "signature": "org.joda.time.field.MillisDurationField.add(long, int)",
        "snippet": "    public long add(long instant, int value) {\n        return FieldUtils.safeAdd(instant, value);\n    }\n",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0398
        },
        "num_failing_tests": 3
    },
    {
        "name": "FieldUtils.safeAdd#63",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeAdd(int, int)",
        "snippet": "    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n",
        "begin_line": 63,
        "end_line": 71,
        "comment": "\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0388
        },
        "num_failing_tests": 3
    },
    {
        "name": "PreciseDurationField.add#103",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/PreciseDurationField.java",
        "class_name": "org.joda.time.field.PreciseDurationField",
        "signature": "org.joda.time.field.PreciseDurationField.add(long, int)",
        "snippet": "    public long add(long instant, int value) {\n        long addition = value * iUnitMillis;  // safe\n        return FieldUtils.safeAdd(instant, addition);\n    }\n",
        "begin_line": 103,
        "end_line": 106,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0384
        },
        "num_failing_tests": 3
    },
    {
        "name": "FieldUtils.safeAdd#81",
        "is_bug": false,
        "src_path": "src/main/java/org/joda/time/field/FieldUtils.java",
        "class_name": "org.joda.time.field.FieldUtils",
        "signature": "org.joda.time.field.FieldUtils.safeAdd(long, long)",
        "snippet": "    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n",
        "begin_line": 81,
        "end_line": 89,
        "comment": "\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0362
        },
        "num_failing_tests": 3
    }
]