[
    {
        "name": "AbstractRealMatrix.toString#989",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.toString()",
        "snippet": "    @Override\n    public String toString() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final StringBuffer res = new StringBuffer();\n        String fullClassName = getClass().getName();\n        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n        res.append(shortClassName).append(\"{\");\n\n        for (int i = 0; i < nRows; ++i) {\n            if (i > 0) {\n                res.append(\",\");\n            }\n            res.append(\"{\");\n            for (int j = 0; j < nCols; ++j) {\n                if (j > 0) {\n                    res.append(\",\");\n                }\n                res.append(getEntry(i, j));\n            } \n            res.append(\"}\");\n        } \n\n        res.append(\"}\");\n        return res.toString();\n\n    } \n",
        "begin_line": 989,
        "end_line": 1015,
        "comment": "\n     * Get a string representation for this matrix.\n     * @return a string representation for this matrix\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MatrixUtils.checkMultiplicationCompatible#625",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(org.apache.commons.math.linear.AnyMatrix, org.apache.commons.math.linear.AnyMatrix)",
        "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }\n",
        "begin_line": 625,
        "end_line": 633,
        "comment": "\n     * Check if matrices are multiplication compatible\n     * @param left left hand side matrix\n     * @param right right hand side matrix\n     * @exception IllegalArgumentException if matrices are not multiplication compatible\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DenseRealMatrix.multiply#488",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.multiply(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    @Override\n    public DenseRealMatrix multiply(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return multiply((DenseRealMatrix) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final DenseRealMatrix out = new DenseRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth      = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart      = kBlock * BLOCK_SIZE;\n                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n                            final int lEnd   = lStart + kWidth;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                }\n                                outBlock[k++] += sum;\n                            }\n                        }\n                    }\n\n                    // go to next block\n                    ++blockIndex;\n\n                }\n            }\n\n            return out;\n\n        }\n    }\n",
        "begin_line": 488,
        "end_line": 542,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Compute the sum of this and m.\n     *\n     * @param m    matrix to be added\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     "
        },
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "DenseRealMatrix.multiply#552",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.multiply(org.apache.commons.math.linear.DenseRealMatrix)",
        "snippet": "    public DenseRealMatrix multiply(DenseRealMatrix m) throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final DenseRealMatrix out = new DenseRealMatrix(rows, m.columns);\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n                final int jWidth2 = jWidth  + jWidth;\n                final int jWidth3 = jWidth2 + jWidth;\n                final int jWidth4 = jWidth3 + jWidth;\n\n                // select current block\n                final double[] outBlock = out.blocks[blockIndex];\n\n                // perform multiplication on current block\n                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                    final int kWidth = blockWidth(kBlock);\n                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n                        final int lStart = (p - pStart) * kWidth;\n                        final int lEnd   = lStart + kWidth;\n                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n                            double sum = 0;\n                            int l = lStart;\n                            int n = nStart;\n                            while (l < lEnd - 3) {\n                                sum += tBlock[l] * mBlock[n] +\n                                       tBlock[l + 1] * mBlock[n + jWidth] +\n                                       tBlock[l + 2] * mBlock[n + jWidth2] +\n                                       tBlock[l + 3] * mBlock[n + jWidth3];\n                                l += 4;\n                                n += jWidth4;\n                            }\n                            while (l < lEnd) {\n                                sum += tBlock[l++] * mBlock[n];\n                                n += jWidth;\n                            }\n                            outBlock[k++] += sum;\n                        }\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n\n    }\n",
        "begin_line": 552,
        "end_line": 612,
        "comment": "\n     * Returns the result of postmultiplying this by m.\n     *\n     * @param m    matrix to postmultiply by\n     * @return     this * m\n     * @throws     IllegalArgumentException\n     *             if columnDimension(this) != rowDimension(m)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "CholeskyDecompositionImpl.CholeskyDecompositionImpl#71",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
        "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.CholeskyDecompositionImpl(org.apache.commons.math.linear.RealMatrix)",
        "snippet": "    public CholeskyDecompositionImpl(final RealMatrix matrix)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }\n",
        "begin_line": 71,
        "end_line": 76,
        "comment": "\n     * Calculates the Cholesky decomposition of the given matrix.\n     * <p>\n     * Calling this constructor is equivalent to call {@link\n     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n     * thresholds set to the default values {@link\n     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n     * </p>\n     * @param matrix the matrix to decompose\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 2
    },
    {
        "name": "CholeskyDecompositionImpl.CholeskyDecompositionImpl#93",
        "is_bug": true,
        "src_path": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
        "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.CholeskyDecompositionImpl(org.apache.commons.math.linear.RealMatrix, double, double)",
        "snippet": "    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n",
        "begin_line": 93,
        "end_line": 151,
        "comment": "\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.getData#615",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.getData()",
        "snippet": "    @Override\n    public double[][] getData() {\n\n        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n            int regularPos   = 0;\n            int lastPos      = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                final double[] dataP = data[p];\n                int blockIndex = iBlock * blockColumns;\n                int dataPos    = 0;\n                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                    dataPos += BLOCK_SIZE;\n                }\n                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n                regularPos += BLOCK_SIZE;\n                lastPos    += lastColumns;\n            }\n        }\n\n        return data;\n        \n    }\n",
        "begin_line": 615,
        "end_line": 642,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns matrix entries as a two-dimensional array.\n     *\n     * @return    2-dimensional array of entries\n     "
        },
        "susp": {
            "ochiai_susp": 0.4264
        },
        "num_failing_tests": 2
    },
    {
        "name": "MatrixUtils.createRealMatrix#87",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/MatrixUtils.java",
        "class_name": "org.apache.commons.math.linear.MatrixUtils",
        "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
        "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return new DenseRealMatrix(data);\n    }\n",
        "begin_line": 87,
        "end_line": 89,
        "comment": "\n     * Returns a {@link RealMatrix} whose entries are the the values in the\n     * the input array.  The input array is copied, not referenced.\n     * \n     * @param data input array\n     * @return  RealMatrix containing the values of the array\n     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>data</code> is null\n     * @see #createRealMatrix(int, int)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.DenseRealMatrix#124",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(double[][])",
        "snippet": "    public DenseRealMatrix(final double[][] rawData)\n        throws IllegalArgumentException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }\n",
        "begin_line": 124,
        "end_line": 127,
        "comment": "\n     * Create a new dense matrix copying entries from raw layout data.\n     * <p>The input array <em>must</em> already be in raw layout.</p>\n     * <p>Calling this constructor is equivalent to call:\n     * <pre>matrix = new DenseRealMatrix(rawData.length, rawData[0].length,\n     *                                   toBlocksLayout(rawData), false);</pre>\n     * </p>\n     * @param rawData data for new matrix, in raw layout\n     *\n     * @exception IllegalArgumentException if <code>blockData</code> shape is\n     * inconsistent with block layout\n     * @see #DenseRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.DenseRealMatrix#144",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(int, int, double[][], boolean)",
        "snippet": "    public DenseRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"wrong array shape (block length = {0}, expected {1})\",\n                            blockData[index].length, iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n\n    }\n",
        "begin_line": 144,
        "end_line": 179,
        "comment": "\n     * Create a new dense matrix copying entries from block layout data.\n     * <p>The input array <em>must</em> already be in blocks layout.</p>\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @param blockData data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     *\n     * @exception IllegalArgumentException if <code>blockData</code> shape is\n     * inconsistent with block layout\n     * @see #createBlocksLayout(int, int)\n     * @see #toBlocksLayout(double[][])\n     * @see #DenseRealMatrix(double[][])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.toBlocksLayout#203",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(double[][])",
        "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws IllegalArgumentException {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"some rows have length {0} while others have length {1}\",\n                        columns, length); \n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                }\n\n            }\n        }\n\n        return blocks;\n\n    }\n",
        "begin_line": 203,
        "end_line": 246,
        "comment": "\n     * Convert a data array from raw layout to blocks layout.\n     * <p>\n     * Raw layout is the straightforward layout where element at row i and\n     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n     * is the layout used in {@link DenseRealMatrix} instances, where the matrix\n     * is split in square blocks (except at right and bottom side where blocks may\n     * be rectangular to fit matrix size) and each block is stored in a flattened\n     * one-dimensional array.\n     * </p>\n     * <p>\n     * This method creates an array in blocks layout from an input array in raw layout.\n     * It can be used to provide the array argument of the {@link\n     * DenseRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rawData data array in raw layout\n     * @return a new data array containing the same entries but in blocks layout\n     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n     *  (not all rows have the same length)\n     * @see #createBlocksLayout(int, int)\n     * @see #DenseRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.getRowDimension#1315",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.getRowDimension()",
        "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }\n",
        "begin_line": 1315,
        "end_line": 1318,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of rows in the matrix.\n     *\n     * @return rowDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.getColumnDimension#1321",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.getColumnDimension()",
        "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }\n",
        "begin_line": 1321,
        "end_line": 1324,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Returns the number of columns in the matrix.\n     *\n     * @return columnDimension\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.blockHeight#1625",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.blockHeight(int)",
        "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1625,
        "end_line": 1627,
        "comment": "\n     * Get the height of a block.\n     * @param blockRow row index (in block sense) of the block\n     * @return height (number of rows) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.blockWidth#1634",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.blockWidth(int)",
        "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }\n",
        "begin_line": 1634,
        "end_line": 1636,
        "comment": "\n     * Get the width of a block.\n     * @param blockColumn column index (in block sense) of the block\n     * @return width (number of columns) of the block\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealMatrix.AbstractRealMatrix#54",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int, int)",
        "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }\n",
        "begin_line": 54,
        "end_line": 67,
        "comment": "\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "AbstractRealMatrix.isSquare#638",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/AbstractRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
        "signature": "org.apache.commons.math.linear.AbstractRealMatrix.isSquare()",
        "snippet": "    public boolean isSquare() {\n        return (getColumnDimension() == getRowDimension());\n    }\n",
        "begin_line": 638,
        "end_line": 640,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.RealMatrix": null,
            "org.apache.commons.math.linear.AnyMatrix": "\n     * Is this a square matrix?\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 2
    },
    {
        "name": "DenseRealMatrix.getEntry#1210",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.getEntry(int, int)",
        "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            return blocks[iBlock * blockColumns + jBlock][k];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }\n",
        "begin_line": 1210,
        "end_line": 1224,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy \n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     * \n     * @param row  row location of entry to be fetched\n     * @param column  column location of entry to be fetched\n     * @return matrix entry in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     "
        },
        "susp": {
            "ochiai_susp": 0.4082
        },
        "num_failing_tests": 1
    },
    {
        "name": "DenseRealMatrix.DenseRealMatrix#95",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(int, int)",
        "snippet": "    public DenseRealMatrix(final int rows, final int columns)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n\n    }\n",
        "begin_line": 95,
        "end_line": 109,
        "comment": "\n     * Create a new matrix with the supplied row and column dimensions.\n     *\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "DenseRealMatrix.createBlocksLayout#260",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(int, int)",
        "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n\n    }\n",
        "begin_line": 260,
        "end_line": 280,
        "comment": "\n     * Create a data array in blocks layout.\n     * <p>\n     * This method can be used to create the array argument of the {@link\n     * DenseRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor.\n     * </p>\n     * @param rows  the number of rows in the new matrix\n     * @param columns  the number of columns in the new matrix\n     * @return a new data array in blocks layout\n     * @see #toBlocksLayout(double[][])\n     * @see #DenseRealMatrix(int, int, double[][], boolean)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "DenseRealMatrix.transpose#1278",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/DenseRealMatrix.java",
        "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
        "signature": "org.apache.commons.math.linear.DenseRealMatrix.transpose()",
        "snippet": "    @Override\n    public DenseRealMatrix transpose() {\n\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final DenseRealMatrix out = new DenseRealMatrix(nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final double[] outBlock = out.blocks[blockIndex];\n                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n                for (int p = pStart, k = 0; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n                        outBlock[k++] = tBlock[l];\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n\n    }\n",
        "begin_line": 1278,
        "end_line": 1312,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.AbstractRealMatrix": " {@inheritDoc} ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealMatrix": "\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "CholeskyDecompositionImpl.getL#154",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
        "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.getL()",
        "snippet": "    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }\n",
        "begin_line": 154,
        "end_line": 159,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.CholeskyDecomposition": "\n     * Returns the matrix L of the decomposition. \n     * <p>L is an lower-triangular matrix</p>\n     * @return the L matrix\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "CholeskyDecompositionImpl.getLT#162",
        "is_bug": false,
        "src_path": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java",
        "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
        "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.getLT()",
        "snippet": "    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        // return the cached matrix\n        return cachedLT;\n\n    }\n",
        "begin_line": 162,
        "end_line": 171,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.CholeskyDecomposition": "\n     * Returns the transpose of the matrix L of the decomposition.\n     * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n     * @return the transpose of the matrix L of the decomposition\n     "
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    }
]