[
    {
        "name": "LocalizedFormats.LocalizedFormats#305",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/LocalizedFormats.java",
        "class_name": "org.apache.commons.math.util.LocalizedFormats",
        "signature": "org.apache.commons.math.util.LocalizedFormats.LocalizedFormats(java.lang.String)",
        "snippet": "    private LocalizedFormats(final String sourceFormat) {\n        this.sourceFormat = sourceFormat;\n    }\n",
        "begin_line": 305,
        "end_line": 307,
        "comment": " Simple constructor.\n     * @param sourceFormat source English format to use when no\n     * localized version is available\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getResult#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getResult()",
        "snippet": "    public double getResult() {\n        checkResultComputed();\n        return result;\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Get the result of the last run of the optimizer.\n     *\n     * @return the optimum.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getResult#96",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getResult()",
        "snippet": "    public double getResult() {\n        return optimizer.getResult();\n    }\n",
        "begin_line": 96,
        "end_line": 98,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Get the result of the last run of the optimizer.\n     *\n     * @return the optimum.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy#101",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }\n",
        "begin_line": 101,
        "end_line": 103,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual absolute accuracy.\n     *\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getRelativeAccuracy#126",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }\n",
        "begin_line": 126,
        "end_line": 128,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual relative accuracy.\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy#146",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy(double)",
        "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }\n",
        "begin_line": 146,
        "end_line": 148,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the absolute accuracy.\n     * <p>\n     * The default is usually chosen so that results in the interval\n     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n     * expected absolute value of your results is of much smaller magnitude, set\n     * this to a smaller value.</p>\n     * <p>\n     * Algorithms are advised to do a plausibility check with the relative\n     * accuracy, but clients should not rely on this.</p>\n     *\n     * @param accuracy the accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     * the solver or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setRelativeAccuracy#161",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setRelativeAccuracy(double)",
        "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }\n",
        "begin_line": 161,
        "end_line": 163,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the relative accuracy.\n     * <p>\n     * This is used to stop iterations if the absolute accuracy can't be\n     * achieved due to large values or short mantissa length.</p>\n     * <p>\n     * If this should be the primary criterion for convergence rather then a\n     * safety measure, set the absolute accuracy to a ridiculously small value,\n     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n     *\n     * @param accuracy the relative accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     *  the algorithm or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getOptima#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptima()",
        "snippet": "    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n",
        "begin_line": 192,
        "end_line": 197,
        "comment": " Get all the optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>The optimizer stores all the optima found during a set of\n     * restarts. The {@link #optimize(UnivariateRealFunction, GoalType,\n     * double, double) optimize} method returns the best point only. This\n     * method returns all the points found at the end of each starts,\n     * including the best one already returned by the {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method.\n     * </p>\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptimaValues()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.getOptimaValues#218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptimaValues()",
        "snippet": "    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }\n",
        "begin_line": 218,
        "end_line": 223,
        "comment": " Get all the function values at optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptima()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.optimize#226",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws ConvergenceException,\n            FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        // multi-start loop\n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        // sort the optima from best to worst, followed by NaN elements\n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                // the current element should be inserted closer to the beginning\n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        // return the found point given the best objective function value\n        return optima[0];\n\n    }\n",
        "begin_line": 226,
        "end_line": 310,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Find an optimum in the given interval.\n     * <p>\n     * An optimizer may require that the interval brackets a single optimum.\n     * </p>\n     * @param f the function to optimize.\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n     * or {@link GoalType#MINIMIZE}.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return a value where the function is optimum.\n     * @throws ConvergenceException if the maximum iteration count is exceeded\n     * or the optimizer detects convergence problems otherwise.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if min > max or the endpoints do not\n     * satisfy the requirements specified by the optimizer.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathRuntimeException.createIllegalStateException#442",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/MathRuntimeException.java",
        "class_name": "org.apache.commons.math.MathRuntimeException",
        "signature": "org.apache.commons.math.MathRuntimeException.createIllegalStateException(org.apache.commons.math.util.Localizable, java.lang.Object...)",
        "snippet": "    public static IllegalStateException createIllegalStateException(final Localizable pattern,\n                                                                    final Object ... arguments) {\n        return new IllegalStateException() {\n\n            /** Serializable version identifier. */\n            private static final long serialVersionUID = 6880901520234515725L;\n\n            /** {@inheritDoc} */\n            @Override\n            public String getMessage() {\n                return buildMessage(Locale.US, pattern, arguments);\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public String getLocalizedMessage() {\n                return buildMessage(Locale.getDefault(), pattern, arguments);\n            }\n\n        };\n    }\n",
        "begin_line": 442,
        "end_line": 462,
        "comment": "\n     * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n     * Message formatting is delegated to {@link java.text.MessageFormat}.\n     * @param pattern format specifier\n     * @param arguments format arguments\n     * @return built exception\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
        "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }\n",
        "begin_line": 77,
        "end_line": 79,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the absolute accuracy.\n     * <p>\n     * The default is usually chosen so that results in the interval\n     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n     * expected absolute value of your results is of much smaller magnitude, set\n     * this to a smaller value.</p>\n     * <p>\n     * Algorithms are advised to do a plausibility check with the relative\n     * accuracy, but clients should not rely on this.</p>\n     *\n     * @param accuracy the accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     * the solver or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.getAbsoluteAccuracy#82",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 82,
        "end_line": 84,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual absolute accuracy.\n     *\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.setRelativeAccuracy#107",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setRelativeAccuracy(double)",
        "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        relativeAccuracy = accuracy;\n    }\n",
        "begin_line": 107,
        "end_line": 109,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the relative accuracy.\n     * <p>\n     * This is used to stop iterations if the absolute accuracy can't be\n     * achieved due to large values or short mantissa length.</p>\n     * <p>\n     * If this should be the primary criterion for convergence rather then a\n     * safety measure, set the absolute accuracy to a ridiculously small value,\n     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n     *\n     * @param accuracy the relative accuracy.\n     * @throws IllegalArgumentException if the accuracy can't be achieved by\n     *  the algorithm or is otherwise deemed unreasonable.\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.getRelativeAccuracy#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 112,
        "end_line": 114,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the actual relative accuracy.\n     * @return the accuracy\n     "
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#42",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer()",
        "snippet": "    public BrentOptimizer() {\n        super(100, 1E-10);\n    }\n",
        "begin_line": 42,
        "end_line": 44,
        "comment": "\n     * Construct a solver.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.optimize#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n    }\n",
        "begin_line": 54,
        "end_line": 59,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Find an optimum in the given interval.\n     * <p>\n     * An optimizer may require that the interval brackets a single optimum.\n     * </p>\n     * @param f the function to optimize.\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n     * or {@link GoalType#MINIMIZE}.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return a value where the function is optimum.\n     * @throws ConvergenceException if the maximum iteration count is exceeded\n     * or the optimizer detects convergence problems otherwise.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if min > max or the endpoints do not\n     * satisfy the requirements specified by the optimizer.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.localMin#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.localMin(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double, double, double)",
        "snippet": "    private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n                            double a, double b, final double eps, final double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        double x = a + GOLDEN_SECTION * (b - a);\n        double v = x;\n        double w = x;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            double tol = eps * Math.abs(x) + t;\n            double t2 = 2 * tol;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double d = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n                }\n\n                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (((u - a) < t2) || ((b - u) < t2)) {\n                        d = (x < m) ? tol : -tol;\n                    }\n                } else { // Golden section step.\n                    e = ((x < m) ? b : a) - x;\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // f must not be evaluated too close to a or b.\n                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if ((fu <= fw) || (w == x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n\n            ++count;\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n\n    }\n",
        "begin_line": 85,
        "end_line": 189,
        "comment": "\n     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n     *\n     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n     * this method finds an approximation {@code x} to the point at which {@code f}\n     * attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n     * {@code f} is never evaluated at two points closer together than {@code tol}.\n     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n     * machine precision. {@code t} should be positive.\n     * @param f the function to solve\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n     * or {@link GoalType#MINIMIZE}\n     * @param a Lower bound of the interval\n     * @param b Higher bound of the interval\n     * @param eps Relative accuracy\n     * @param t Absolute accuracy\n     * @return the point at which the function is minimal.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer(int, double)",
        "snippet": "    protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n                                              final double defaultAbsoluteAccuracy) {\n        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n        resultComputed = false;\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n",
        "begin_line": 61,
        "end_line": 66,
        "comment": "\n     * Construct a solver with given iteration count and accuracy.\n     * FunctionEvaluationExceptionFunctionEvaluationException\n     * @param defaultAbsoluteAccuracy maximum absolute error\n     * @param defaultMaximalIterationCount maximum number of iterations\n     * @throws IllegalArgumentException if f is null or the\n     * defaultAbsoluteAccuracy is not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.checkResultComputed#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.checkResultComputed()",
        "snippet": "    protected void checkResultComputed() throws IllegalStateException {\n        if (!resultComputed) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n        }\n    }\n",
        "begin_line": 71,
        "end_line": 75,
        "comment": " Check if a result has been computed.\n     * @exception IllegalStateException if no result has been computed\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getFunctionValue#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getFunctionValue()",
        "snippet": "    public double getFunctionValue() {\n        checkResultComputed();\n        return functionValue;\n    }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": "\n     * Get the result of the last run of the optimizer.\n     *\n     * @return the value of the function at the optimum.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.setResult#96",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setResult(double, double, int)",
        "snippet": "    protected final void setResult(final double x, final double fx,\n                                   final int iterationCount) {\n        this.result         = x;\n        this.functionValue  = fx;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }\n",
        "begin_line": 96,
        "end_line": 102,
        "comment": "\n     * Convenience function for implementations.\n     *\n     * @param x the result to set\n     * @param fx the result to set\n     * @param iterationCount the iteration count to set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.clearResult#107",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.clearResult()",
        "snippet": "    protected final void clearResult() {\n        this.resultComputed = false;\n    }\n",
        "begin_line": 107,
        "end_line": 109,
        "comment": "\n     * Convenience function for implementations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.setMaxEvaluations#112",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n",
        "begin_line": 112,
        "end_line": 114,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Set the maximal number of functions evaluations.\n     * @param maxEvaluations maximal number of function evaluations\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getEvaluations#122",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations;\n    }\n",
        "begin_line": 122,
        "end_line": 124,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Get the number of evaluations of the objective function.\n     * <p>\n     * The number of evaluations corresponds to the last call to the\n     * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method. It is 0 if the method has not been called yet.\n     * </p>\n     * @return the number of evaluations of the objective function.\n     ",
            "org.apache.commons.math.ConvergingAlgorithmImpl": null,
            "org.apache.commons.math.ConvergingAlgorithm": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.computeObjectiveValue#134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.computeObjectiveValue(org.apache.commons.math.analysis.UnivariateRealFunction, double)",
        "snippet": "    protected double computeObjectiveValue(final UnivariateRealFunction f,\n                                           final double point)\n        throws FunctionEvaluationException {\n        if (++evaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        return f.value(point);\n    }\n",
        "begin_line": 134,
        "end_line": 142,
        "comment": "\n     * Compute the objective function value.\n     * @param f objective function\n     * @param point point at which the objective function must be evaluated\n     * @return objective function value at specified point\n     * @exception FunctionEvaluationException if the function cannot be evaluated\n     * or the maximal number of iterations is exceeded\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer(org.apache.commons.math.optimization.UnivariateRealOptimizer, int, org.apache.commons.math.random.RandomGenerator)",
        "snippet": "    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n",
        "begin_line": 78,
        "end_line": 88,
        "comment": "\n     * Create a multi-start optimizer from a single-start optimizer\n     * @param optimizer single-start optimizer to wrap\n     * @param starts number of starts to perform (including the\n     * first one), multi-start is disabled if value is less than or\n     * equal to 1\n     * @param generator random generator to use for restarts\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setMaximalIterationCount#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaximalIterationCount(int)",
        "snippet": "    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }\n",
        "begin_line": 151,
        "end_line": 153,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": null,
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the upper limit for the number of iterations.\n     * <p>\n     * Usually a high iteration count indicates convergence problems. However,\n     * the \"reasonable value\" varies widely for different algorithms. Users are\n     * advised to use the default value supplied by the algorithm.</p>\n     * <p>\n     * A {@link ConvergenceException} will be thrown if this number\n     * is exceeded.</p>\n     *\n     * @param count maximum number of iterations\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.setMaxEvaluations#156",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n",
        "begin_line": 156,
        "end_line": 158,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.UnivariateRealOptimizer": " Set the maximal number of functions evaluations.\n     * @param maxEvaluations maximal number of function evaluations\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int, double)",
        "snippet": "    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }\n",
        "begin_line": 60,
        "end_line": 69,
        "comment": "\n     * Construct an algorithm with given iteration count and accuracy.\n     *\n     * @param defaultAbsoluteAccuracy maximum absolute error\n     * @param defaultMaximalIterationCount maximum number of iterations\n     * @throws IllegalArgumentException if f is null or the\n     * defaultAbsoluteAccuracy is not valid\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.getIterationCount#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getIterationCount()",
        "snippet": "    public int getIterationCount() {\n        return iterationCount;\n    }\n",
        "begin_line": 72,
        "end_line": 74,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Get the number of iterations in the last run of the algorithm.\n     * <p>\n     * This is mainly meant for testing purposes. It may occasionally\n     * help track down performance problems: if the iteration count\n     * is notoriously high, check whether the problem is evaluated\n     * properly, and whether another algorithm is more amenable to the\n     * problem.</p>\n     *\n     * @return the last iteration count.\n     * @throws IllegalStateException if there is no result available, either\n     * because no result was yet computed or the last attempt failed.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "ConvergingAlgorithmImpl.setMaximalIterationCount#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java",
        "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
        "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
        "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ConvergingAlgorithm": "\n     * Set the upper limit for the number of iterations.\n     * <p>\n     * Usually a high iteration count indicates convergence problems. However,\n     * the \"reasonable value\" varies widely for different algorithms. Users are\n     * advised to use the default value supplied by the algorithm.</p>\n     * <p>\n     * A {@link ConvergenceException} will be thrown if this number\n     * is exceeded.</p>\n     *\n     * @param count maximum number of iterations\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    }
]