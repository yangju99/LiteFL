[
    {
        "name": "OpenIntToDoubleHashMap.advance#560",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator.advance()",
        "snippet": "        public void advance()\n            throws ConcurrentModificationException, NoSuchElementException {\n\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n\n            // advance on step\n            current = next;\n\n            // prepare next step\n            try {\n                while (states[++next] != FULL) {\n                    // nothing to do\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                next = -2;\n                if (current < 0) {\n                    throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n                }\n            }\n\n        }\n",
        "begin_line": 560,
        "end_line": 582,
        "comment": "\n         * Advance iterator one step further.\n         * @exception ConcurrentModificationException if the map is modified during iteration\n         * @exception NoSuchElementException if there is no element left in the map\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.containsKey#208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int)",
        "snippet": "    public boolean containsKey(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return true;\n        }\n\n        if (states[index] == FREE) {\n            return false;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n",
        "begin_line": 208,
        "end_line": 231,
        "comment": "\n     * Check if a value is associated with a key.\n     * @param key key to check\n     * @return true if a value is associated with key\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.ebeMultiply#367",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(org.apache.commons.math.linear.RealVector)",
        "snippet": "    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n",
        "begin_line": 367,
        "end_line": 376,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.SparseRealVector": null,
            "org.apache.commons.math.linear.AbstractRealVector": "\n     * Check if instance and specified vectors have the same dimension.\n     *\n     * @param v Vector to compare instance with.\n     * @throws DimensionMismatchException if the vectors do not\n     * have the same dimension.\n     ",
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealVector": "\n     * Compute the sum of this vector and {@code v}.\n     *\n     * @param v Vector to be added.\n     * @return {@code this} + {@code v}.\n     * @throws org.apache.commons.math.exception.DimensionMismatchException\n     * if {@code v} is not the same size as this vector.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealVector.checkVectorDimensions#62",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealVector.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealVector",
        "signature": "org.apache.commons.math.linear.AbstractRealVector.checkVectorDimensions(int)",
        "snippet": "    protected void checkVectorDimensions(int n) {\n        int d = getDimension();\n        if (d != n) {\n            throw new DimensionMismatchException(d, n);\n        }\n    }\n",
        "begin_line": 62,
        "end_line": 67,
        "comment": "\n     * Check if instance dimension is equal to some expected value.\n     *\n     * @param n Expected dimension.\n     * @throws DimensionMismatchException if the dimension is\n     * inconsistent with the vector size.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.get#178",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.get(int)",
        "snippet": "    public double get(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return values[index];\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return values[index];\n            }\n        }\n\n        return missingEntries;\n\n    }\n",
        "begin_line": 178,
        "end_line": 201,
        "comment": "\n     * Get the stored value associated with the given key\n     * @param key key associated with the data\n     * @return data associated with the key\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.remove#352",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.remove(int)",
        "snippet": "    public double remove(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return doRemove(index);\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return doRemove(index);\n            }\n        }\n\n        return missingEntries;\n\n    }\n",
        "begin_line": 352,
        "end_line": 375,
        "comment": "\n     * Remove the value associated with a key.\n     * @param key key to which the value is associated\n     * @return removed value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.doRemove#393",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.doRemove(int)",
        "snippet": "    private double doRemove(int index) {\n        keys[index]   = 0;\n        states[index] = REMOVED;\n        final double previous = values[index];\n        values[index] = missingEntries;\n        --size;\n        ++count;\n        return previous;\n    }\n",
        "begin_line": 393,
        "end_line": 401,
        "comment": "\n     * Remove an element at specified index.\n     * @param index index of the element to remove\n     * @return removed value\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.setEntry#662",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.setEntry(int, double)",
        "snippet": "    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n",
        "begin_line": 662,
        "end_line": 669,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.SparseRealVector": null,
            "org.apache.commons.math.linear.AbstractRealVector": null,
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealVector": "\n     * Set a single element.\n     * @param index element index.\n     * @param value new value for the element.\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the index is not valid.\n     * @see #getEntry(int)\n     "
        },
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(org.apache.commons.math.util.OpenIntToDoubleHashMap)",
        "snippet": "    public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n        final int length = source.keys.length;\n        keys = new int[length];\n        System.arraycopy(source.keys, 0, keys, 0, length);\n        values = new double[length];\n        System.arraycopy(source.values, 0, values, 0, length);\n        states = new byte[length];\n        System.arraycopy(source.states, 0, states, 0, length);\n        missingEntries = source.missingEntries;\n        size  = source.size;\n        mask  = source.mask;\n        count = source.count;\n    }\n",
        "begin_line": 133,
        "end_line": 145,
        "comment": "\n     * Copy constructor.\n     * @param source map to copy\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.OpenMapRealVector#74",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.OpenMapRealVector(int, double)",
        "snippet": "    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n",
        "begin_line": 74,
        "end_line": 78,
        "comment": "\n     * Construct a vector of zeroes, specifying zero tolerance.\n     *\n     * @param dimension Size of the vector.\n     * @param epsilon Tolerance below which a value considered zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.OpenMapRealVector#179",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.OpenMapRealVector(org.apache.commons.math.linear.OpenMapRealVector)",
        "snippet": "    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n",
        "begin_line": 179,
        "end_line": 183,
        "comment": "\n     * Copy constructor.\n     *\n     * @param v Instance to copy from.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.key#527",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator.key()",
        "snippet": "        public int key()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current < 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return keys[current];\n        }\n",
        "begin_line": 527,
        "end_line": 536,
        "comment": "\n         * Get the key of current entry.\n         * @return key of current entry\n         * @exception ConcurrentModificationException if the map is modified during iteration\n         * @exception NoSuchElementException if there is no element left in the map\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.getEntries#207",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.getEntries()",
        "snippet": "    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n",
        "begin_line": 207,
        "end_line": 209,
        "comment": "\n     * Get the entries of this instance.\n     *\n     * @return the entries of this instance.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.Iterator#498",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator.Iterator()",
        "snippet": "        private Iterator() {\n\n            // preserve the modification count of the map to detect concurrent modifications later\n            referenceCount = count;\n\n            // initialize current index\n            next = -1;\n            try {\n                advance();\n            } catch (NoSuchElementException nsee) {\n                // ignored\n            }\n\n        }\n",
        "begin_line": 498,
        "end_line": 511,
        "comment": "\n         * Simple constructor.\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.hasNext#517",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator.hasNext()",
        "snippet": "        public boolean hasNext() {\n            return next >= 0;\n        }\n",
        "begin_line": 517,
        "end_line": 519,
        "comment": "\n         * Check if there is a next element in the map.\n         * @return true if there is a next element\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.value#544",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator.value()",
        "snippet": "        public double value()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current < 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return values[current];\n        }\n",
        "begin_line": 544,
        "end_line": 553,
        "comment": "\n         * Get the value of current entry.\n         * @return value of current entry\n         * @exception ConcurrentModificationException if the map is modified during iteration\n         * @exception NoSuchElementException if there is no element left in the map\n         ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.iterator#240",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.iterator()",
        "snippet": "    public Iterator iterator() {\n        return new Iterator();\n    }\n",
        "begin_line": 240,
        "end_line": 242,
        "comment": "\n     * Get an iterator over map elements.\n     * <p>The specialized iterators returned are fail-fast: they throw a\n     * <code>ConcurrentModificationException</code> when they detect the map\n     * has been modified during iteration.</p>\n     * @return iterator over the map elements\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3536
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.getEntry#478",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.getEntry(int)",
        "snippet": "    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n",
        "begin_line": 478,
        "end_line": 481,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.SparseRealVector": null,
            "org.apache.commons.math.linear.AbstractRealVector": null,
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealVector": "\n     * Returns the entry in the specified index.\n     *\n     * @param index Index location of entry to be fetched.\n     * @return the vector entry at {@code index}.\n     * @throws org.apache.commons.math.exception.OutOfRangeException\n     * if the index is not valid.\n     * @see #setEntry(int, double)\n     "
        },
        "susp": {
            "ochiai_susp": 0.3333
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.containsKey#384",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int, int)",
        "snippet": "    private boolean containsKey(final int key, final int index) {\n        return (key != 0 || states[index] == FULL) && keys[index] == key;\n    }\n",
        "begin_line": 384,
        "end_line": 386,
        "comment": "\n     * Check if the tables contain an element associated with specified key\n     * at specified index.\n     * @param key key to check\n     * @param index index to check\n     * @return true if an element is associated with key at index\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractRealVector.checkIndex#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/AbstractRealVector.java",
        "class_name": "org.apache.commons.math.linear.AbstractRealVector",
        "signature": "org.apache.commons.math.linear.AbstractRealVector.checkIndex(int)",
        "snippet": "    protected void checkIndex(final int index) {\n        if (index < 0 ||\n            index >= getDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX,\n                                          index, 0, getDimension() - 1);\n        }\n    }\n",
        "begin_line": 75,
        "end_line": 81,
        "comment": "\n     * Check if an index is valid.\n     *\n     * @param index Index to check.\n     * @exception OutOfRangeException if {@code index} is not valid.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#102",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(double)",
        "snippet": "    public OpenIntToDoubleHashMap(final double missingEntries) {\n        this(DEFAULT_EXPECTED_SIZE, missingEntries);\n    }\n",
        "begin_line": 102,
        "end_line": 104,
        "comment": "\n     * Build an empty map with default size\n     * @param missingEntries value to return when a missing entry is fetched\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(int, double)",
        "snippet": "    public OpenIntToDoubleHashMap(final int expectedSize,\n                                  final double missingEntries) {\n        final int capacity = computeCapacity(expectedSize);\n        keys   = new int[capacity];\n        values = new double[capacity];\n        states = new byte[capacity];\n        this.missingEntries = missingEntries;\n        mask   = capacity - 1;\n    }\n",
        "begin_line": 119,
        "end_line": 127,
        "comment": "\n     * Build an empty map with specified size.\n     * @param expectedSize expected number of elements in the map\n     * @param missingEntries value to return when a missing entry is fetched\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.computeCapacity#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.computeCapacity(int)",
        "snippet": "    private static int computeCapacity(final int expectedSize) {\n        if (expectedSize == 0) {\n            return 1;\n        }\n        final int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n        final int powerOfTwo = Integer.highestOneBit(capacity);\n        if (powerOfTwo == capacity) {\n            return capacity;\n        }\n        return nextPowerOfTwo(capacity);\n    }\n",
        "begin_line": 152,
        "end_line": 162,
        "comment": "\n     * Compute the capacity needed for a given size.\n     * @param expectedSize expected size of the map\n     * @return capacity to use for the specified size\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.findInsertionIndex#258",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int)",
        "snippet": "    private int findInsertionIndex(final int key) {\n        return findInsertionIndex(keys, states, key, mask);\n    }\n",
        "begin_line": 258,
        "end_line": 260,
        "comment": "\n     * Find the index at which a key should be inserted\n     * @param key key to lookup\n     * @return index at which key should be inserted\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.findInsertionIndex#270",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int[], byte[], int, int)",
        "snippet": "    private static int findInsertionIndex(final int[] keys, final byte[] states,\n                                          final int key, final int mask) {\n        final int hash = hashOf(key);\n        int index = hash & mask;\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL && keys[index] == key) {\n            return changeIndexSign(index);\n        }\n\n        int perturb = perturb(hash);\n        int j = index;\n        if (states[index] == FULL) {\n            while (true) {\n                j = probe(perturb, j);\n                index = j & mask;\n                perturb >>= PERTURB_SHIFT;\n\n                if (states[index] != FULL || keys[index] == key) {\n                    break;\n                }\n            }\n        }\n\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL) {\n            // due to the loop exit condition,\n            // if (states[index] == FULL) then keys[index] == key\n            return changeIndexSign(index);\n        }\n\n        final int firstRemoved = index;\n        while (true) {\n            j = probe(perturb, j);\n            index = j & mask;\n\n            if (states[index] == FREE) {\n                return firstRemoved;\n            } else if (states[index] == FULL && keys[index] == key) {\n                return changeIndexSign(index);\n            }\n\n            perturb >>= PERTURB_SHIFT;\n\n        }\n\n    }\n",
        "begin_line": 270,
        "end_line": 317,
        "comment": "\n     * Find the index at which a key should be inserted\n     * @param keys keys table\n     * @param states states table\n     * @param key key to lookup\n     * @param mask bit mask for hash values\n     * @return index at which key should be inserted\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.put#409",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.put(int, double)",
        "snippet": "    public double put(final int key, final double value) {\n        int index = findInsertionIndex(key);\n        double previous = missingEntries;\n        boolean newMapping = true;\n        if (index < 0) {\n            index = changeIndexSign(index);\n            previous = values[index];\n            newMapping = false;\n        }\n        keys[index]   = key;\n        states[index] = FULL;\n        values[index] = value;\n        if (newMapping) {\n            ++size;\n            if (shouldGrowTable()) {\n                growTable();\n            }\n            ++count;\n        }\n        return previous;\n\n    }\n",
        "begin_line": 409,
        "end_line": 430,
        "comment": "\n     * Put a value associated with a key in the map.\n     * @param key key to which value is associated\n     * @param value value to put in the map\n     * @return previous value associated with the key\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.shouldGrowTable#468",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.shouldGrowTable()",
        "snippet": "    private boolean shouldGrowTable() {\n        return size > (mask + 1) * LOAD_FACTOR;\n    }\n",
        "begin_line": 468,
        "end_line": 470,
        "comment": "\n     * Check if tables should grow due to increased size.\n     * @return true if  tables should grow\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenIntToDoubleHashMap.hashOf#477",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java",
        "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
        "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.hashOf(int)",
        "snippet": "    private static int hashOf(final int key) {\n        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n",
        "begin_line": 477,
        "end_line": 480,
        "comment": "\n     * Compute the hash value of a key\n     * @param key key to hash\n     * @return hash value of the key\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ceil#3748",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.ceil(double)",
        "snippet": "    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3748,
        "end_line": 3767,
        "comment": " Get the smallest whole number larger than x.\n     * @param x number from which ceil is requested\n     * @return a double number c such that c is an integer c - 1.0 < x <= c\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.isDefaultValue#219",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.isDefaultValue(double)",
        "snippet": "    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n",
        "begin_line": 219,
        "end_line": 221,
        "comment": "\n     * Determine if this value is within epsilon of zero.\n     *\n     * @param value Value to test\n     * @return {@code true} if this value is within epsilon to zero,\n     * {@code false} otherwise.\n     * @since 2.1\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "OpenMapRealVector.getDimension#421",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
        "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
        "signature": "org.apache.commons.math.linear.OpenMapRealVector.getDimension()",
        "snippet": "    public int getDimension() {\n        return virtualSize;\n    }\n",
        "begin_line": 421,
        "end_line": 423,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.linear.SparseRealVector": null,
            "org.apache.commons.math.linear.AbstractRealVector": null,
            "java.io.Serializable": null,
            "org.apache.commons.math.linear.RealVector": "\n     * Returns the size of the vector.\n     * @return size\n     "
        },
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.floor#3721",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.floor(double)",
        "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3721,
        "end_line": 3742,
        "comment": " Get the largest whole number smaller than x.\n     * @param x number from which floor is requested\n     * @return a double number f such that f is an integer f <= x < f + 1.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3409",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3409,
        "end_line": 3411,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2582
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowexp#1011",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowexp(double, double[])",
        "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1011,
        "end_line": 1038,
        "comment": "\n     *  For x between 0 and 1, returns exp(x), uses extended precision\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n     *  @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.split#1045",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.split(double, double[])",
        "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n",
        "begin_line": 1045,
        "end_line": 1055,
        "comment": " Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.resplit#1061",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
        "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n",
        "begin_line": 1061,
        "end_line": 1074,
        "comment": " Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitMult#1081",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[])",
        "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n",
        "begin_line": 1081,
        "end_line": 1087,
        "comment": " Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitAdd#1094",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[])",
        "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n",
        "begin_line": 1094,
        "end_line": 1099,
        "comment": " Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitReciprocal#1119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[])",
        "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n",
        "begin_line": 1119,
        "end_line": 1147,
        "comment": " Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.quadMult#1154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[])",
        "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n",
        "begin_line": 1154,
        "end_line": 1201,
        "comment": " Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.expint#1208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.expint(int, double[])",
        "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1208,
        "end_line": 1246,
        "comment": " Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowLog#1742",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
        "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n",
        "begin_line": 1742,
        "end_line": 1784,
        "comment": " xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowSin#1792",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowSin(double, double[])",
        "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1792,
        "end_line": 1826,
        "comment": "\n     * For x between 0 and pi/4 compute sine.\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowCos#1834",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowCos(double, double[])",
        "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1834,
        "end_line": 1869,
        "comment": "\n     *  For x between 0 and pi/4 compute cosine\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.buildSinCosTables#1873",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
        "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n",
        "begin_line": 1873,
        "end_line": 1965,
        "comment": " Build the sine and cosine tables.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    }
]