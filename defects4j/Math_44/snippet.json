[
    {
        "name": "AdaptiveStepsizeIntegrator.setInitialStepSize#208",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.setInitialStepSize(double)",
        "snippet": "  public void setInitialStepSize(final double initialStepSize) {\n    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n      initialStep = -1.0;\n    } else {\n      initialStep = initialStepSize;\n    }\n  }\n",
        "begin_line": 208,
        "end_line": 214,
        "comment": " Set the initial step size.\n   * <p>This method allows the user to specify an initial positive\n   * step size instead of letting the integrator guess it by\n   * itself. If this method is not called before integration is\n   * started, the initial step size will be estimated by the\n   * integrator.</p>\n   * @param initialStepSize initial step size to use (must be positive even\n   * for backward integration ; providing a negative value or a value\n   * outside of the min/max step interval will lead the integrator to\n   * ignore the value and compute the initial step size by itself)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.initializeStep#246",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.initializeStep(boolean, int, double[], double, double[], double[], double[], double[])",
        "snippet": "  public double initializeStep(final boolean forward, final int order, final double[] scale,\n                               final double t0, final double[] y0, final double[] yDot0,\n                               final double[] y1, final double[] yDot1) {\n\n    if (initialStep > 0) {\n      // use the user provided value\n      return forward ? initialStep : -initialStep;\n    }\n\n    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n    // this guess will be used to perform an Euler step\n    double ratio;\n    double yOnScale2 = 0;\n    double yDotOnScale2 = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = y0[j] / scale[j];\n      yOnScale2    += ratio * ratio;\n      ratio         = yDot0[j] / scale[j];\n      yDotOnScale2 += ratio * ratio;\n    }\n\n    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n               1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\n    if (! forward) {\n      h = -h;\n    }\n\n    // perform an Euler step using the preceding rough guess\n    for (int j = 0; j < y0.length; ++j) {\n      y1[j] = y0[j] + h * yDot0[j];\n    }\n    computeDerivatives(t0 + h, y1, yDot1);\n\n    // estimate the second derivative of the solution\n    double yDDotOnScale = 0;\n    for (int j = 0; j < scale.length; ++j) {\n      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n      yDDotOnScale += ratio * ratio;\n    }\n    yDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\n\n    // step size is computed such that\n    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n    final double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\n    final double h1 = (maxInv2 < 1.0e-15) ?\n                      FastMath.max(1.0e-6, 0.001 * FastMath.abs(h)) :\n                      FastMath.pow(0.01 / maxInv2, 1.0 / order);\n    h = FastMath.min(100.0 * FastMath.abs(h), h1);\n    h = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\n    if (h < getMinStep()) {\n      h = getMinStep();\n    }\n    if (h > getMaxStep()) {\n      h = getMaxStep();\n    }\n    if (! forward) {\n      h = -h;\n    }\n\n    return h;\n\n  }\n",
        "begin_line": 246,
        "end_line": 307,
        "comment": " Initialize the integration step.\n   * @param forward forward integration indicator\n   * @param order order of the method\n   * @param scale scaling vector for the state vector (can be shorter than state vector)\n   * @param t0 start time\n   * @param y0 state vector at t0\n   * @param yDot0 first time derivative of y0\n   * @param y1 work array for a state vector\n   * @param yDot1 work array for the first time derivative of y1\n   * @return first integration step\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5773
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ceil#3361",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.ceil(double)",
        "snippet": "    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3361,
        "end_line": 3380,
        "comment": " Get the smallest whole number larger than x.\n     * @param x number from which ceil is requested\n     * @return a double number c such that c is an integer c - 1.0 < x <= c\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.378
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.reset#327",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.reset(double, double[])",
        "snippet": "    public boolean reset(final double t, final double[] y) {\n\n        if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.Action.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.Action.RESET_STATE) ||\n               (nextAction == EventHandler.Action.RESET_DERIVATIVES);\n\n    }\n",
        "begin_line": 327,
        "end_line": 342,
        "comment": " Let the event handler reset the state if it wants.\n     * @param t value of the independent <i>time</i> variable at the\n     * beginning of the next step\n     * @param y array were to put the desired state vector at the beginning\n     * of the next step\n     * @return true if the integrator should reset the derivatives too\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.3162
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.doSolve#142",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.doSolve()",
        "snippet": "    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n",
        "begin_line": 142,
        "end_line": 345,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the root.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the initial search interval does not bracket\n     * a root and the solver requires it.\n     ",
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.2887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.acceptStep#274",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.acceptStep(org.apache.commons.math.ode.sampling.AbstractStepInterpolator, double[], double[], double)",
        "snippet": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // trigger the event\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n",
        "begin_line": 274,
        "end_line": 374,
        "comment": " Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2773
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.guessX#361",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.guessX(double, double[], double[], int, int)",
        "snippet": "    private double guessX(final double targetY, final double[] x, final double[] y,\n                          final int start, final int end) {\n\n        // compute Q Newton coefficients by divided differences\n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        // evaluate Q(targetY)\n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n",
        "begin_line": 361,
        "end_line": 380,
        "comment": " Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n     * <p>\n     * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q\n     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),\n     * Q(y<sub>i</sub>) = x<sub>i</sub>.\n     * </p>\n     * @param targetY target value for y\n     * @param x reference points abscissas for interpolation,\n     * note that this array <em>is</em> modified during computation\n     * @param y reference points ordinates for interpolation\n     * @param start start index of the points to consider (inclusive)\n     * @param end end index of the points to consider (exclusive)\n     * @return guessed root (will be a NaN if two points share the same y)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.solve#383",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.solve(int, org.apache.commons.math.analysis.UnivariateRealFunction, double, double, org.apache.commons.math.analysis.solvers.AllowedSolution)",
        "snippet": "    public double solve(int maxEval, UnivariateRealFunction f, double min,\n                        double max, AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max);\n    }\n",
        "begin_line": 383,
        "end_line": 387,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": "\n     * Solve for a zero in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return A value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     ",
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.25
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.setSoftPreviousTime#319",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setSoftPreviousTime(double)",
        "snippet": "  public void setSoftPreviousTime(final double softPreviousTime) {\n      this.softPreviousTime = softPreviousTime;\n  }\n",
        "begin_line": 319,
        "end_line": 321,
        "comment": " Restrict step range to a limited part of the global step.\n   * <p>\n   * This method can be used to restrict a step and make it appear\n   * as if the original step was smaller. Calling this method\n   * <em>only</em> changes the value returned by {@link #getPreviousTime()},\n   * it does not change any other property\n   * </p>\n   * @param softPreviousTime start of the restricted step\n   * @since 2.2\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.setSoftCurrentTime#333",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setSoftCurrentTime(double)",
        "snippet": "  public void setSoftCurrentTime(final double softCurrentTime) {\n      this.softCurrentTime  = softCurrentTime;\n  }\n",
        "begin_line": 333,
        "end_line": 335,
        "comment": " Restrict step range to a limited part of the global step.\n   * <p>\n   * This method can be used to restrict a step and make it appear\n   * as if the original step was smaller. Calling this method\n   * <em>only</em> changes the value returned by {@link #getCurrentTime()},\n   * it does not change any other property\n   * </p>\n   * @param softCurrentTime end of the restricted step\n   * @since 2.2\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.evaluateStep#187",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.evaluateStep(org.apache.commons.math.ode.sampling.StepInterpolator)",
        "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws ConvergenceException {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (FastMath.abs(dt) < convergence) {\n                // we cannot do anything on such a small step, don't trigger any events\n                return false;\n            }\n            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h = dt / n;\n\n            final UnivariateRealFunction f = new UnivariateRealFunction() {\n                public double value(final double t) {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, interpolator.getInterpolatedState());\n                }\n            };\n\n            double ta = t0;\n            double ga = g0;\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    // find the event time making sure we select a solution just at or past the exact root\n                    final double root;\n                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n                        @SuppressWarnings(\"unchecked\")\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n                        root = forward ?\n                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                    } else {\n                        final double baseRoot = forward ?\n                                                solver.solve(maxIterationCount, f, ta, tb) :\n                                                solver.solve(maxIterationCount, f, tb, ta);\n                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                        root = forward ?\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                    }\n\n                    if ((!Double.isNaN(previousEventTime)) &&\n                        (FastMath.abs(root - ta) <= convergence) &&\n                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event,\n                        // retry the substep excluding this value\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                        --i;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        // no sign change: there is no event for now\n                        ta = tb;\n                        ga = gb;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n    }\n",
        "begin_line": 187,
        "end_line": 278,
        "comment": " Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step\n     * @exception ConvergenceException if an event cannot be located\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.compare#295",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.Anonymous-7abe9683-477e-4b4d-b967-19a7d0419bdc.compare(org.apache.commons.math.ode.events.EventState, org.apache.commons.math.ode.events.EventState)",
        "snippet": "                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n",
        "begin_line": 295,
        "end_line": 297,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": null
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.addEventHandler#124",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.addEventHandler(org.apache.commons.math.ode.events.EventHandler, double, double, int)",
        "snippet": "    public void addEventHandler(final EventHandler handler,\n                                final double maxCheckInterval,\n                                final double convergence,\n                                final int maxIterationCount) {\n        addEventHandler(handler, maxCheckInterval, convergence,\n                        maxIterationCount,\n                        new BracketingNthOrderBrentSolver(convergence, 5));\n    }\n",
        "begin_line": 124,
        "end_line": 131,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Add an event handler to the integrator.\n     * Uses a default {@link UnivariateRealSolver}\n     * with an absolute accuracy equal to the given convergence threshold,\n     * as root-finding algorithm to detect the state events.\n     * @param handler event handler\n     * @param maxCheckInterval maximal time interval between switching\n     * function checks (this interval prevents missing sign changes in\n     * case the integration steps becomes very large)\n     * @param convergence convergence threshold in the event time search\n     * @param maxIterationCount upper limit of the iteration count in\n     * the event time search\n     * @see #getEventHandlers()\n     * @see #clearEventHandlers()\n     "
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifySequence#351",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifySequence(double, double, double)",
        "snippet": "    public static void verifySequence(final double lower,\n                                      final double initial,\n                                      final double upper) {\n        verifyInterval(lower, initial);\n        verifyInterval(initial, upper);\n    }\n",
        "begin_line": 351,
        "end_line": 356,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n     * {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver#79",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver(double, int)",
        "snippet": "    public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\n                                         final int maximalOrder)\n        throws NumberIsTooSmallException {\n        super(absoluteAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n",
        "begin_line": 79,
        "end_line": 88,
        "comment": "\n     * Construct a solver.\n     *\n     * @param absoluteAccuracy Absolute accuracy.\n     * @param maximalOrder maximal order.\n     * @exception NumberIsTooSmallException if maximal order is lower than 2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getStartValue#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.solve#194",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(int, FUNC, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max) {\n        return solve(maxEval, f, min, max, min + 0.5 * (max - min));\n    }\n",
        "begin_line": 194,
        "end_line": 196,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Solve for a zero root in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.verifySequence#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.verifySequence(double, double, double)",
        "snippet": "    protected void verifySequence(final double lower,\n                                  final double initial,\n                                  final double upper) {\n        UnivariateRealSolverUtils.verifySequence(lower, initial, upper);\n    }\n",
        "begin_line": 265,
        "end_line": 269,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n     * if {@code lower >= initial} or {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2425
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.getEventTime#284",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.getEventTime()",
        "snippet": "    public double getEventTime() {\n        return pendingEvent ?\n               pendingEventTime :\n               (forward ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n    }\n",
        "begin_line": 284,
        "end_line": 288,
        "comment": " Get the occurrence time of the event triggered in the current step.\n     * @return occurrence time of the event triggered in the current\n     * step or infinity if no events are triggered\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.stepAccepted#296",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.stepAccepted(double, double[])",
        "snippet": "    public void stepAccepted(final double t, final double[] y) {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.Action.CONTINUE;\n        }\n    }\n",
        "begin_line": 296,
        "end_line": 310,
        "comment": " Acknowledge the fact the step has been accepted by the integrator.\n     * @param t value of the independent <i>time</i> variable at the\n     * end of the step\n     * @param y array containing the current value of the state vector\n     * at the end of the step\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver(double)",
        "snippet": "    protected BaseAbstractUnivariateRealSolver(final double absoluteAccuracy) {\n        this(DEFAULT_RELATIVE_ACCURACY,\n             absoluteAccuracy,\n             DEFAULT_FUNCTION_VALUE_ACCURACY);\n    }\n",
        "begin_line": 64,
        "end_line": 68,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealSolver.AbstractUnivariateRealSolver#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver.AbstractUnivariateRealSolver(double)",
        "snippet": "    protected AbstractUnivariateRealSolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n",
        "begin_line": 36,
        "end_line": 38,
        "comment": "\n     * Construct a solver with given absolute accuracy.\n     *\n     * @param absoluteAccuracy Maximum absolute error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2357
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.value#201",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.Anonymous-acda784a-1bcb-43a1-8910-7b73bdaca375.value(double)",
        "snippet": "                public double value(final double t) {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, interpolator.getInterpolatedState());\n                }\n",
        "begin_line": 201,
        "end_line": 204,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.stop#316",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.stop()",
        "snippet": "    public boolean stop() {\n        return nextAction == EventHandler.Action.STOP;\n    }\n",
        "begin_line": 316,
        "end_line": 318,
        "comment": " Check if the integration should be stopped at the end of the\n     * current step.\n     * @return true if the integration should be stopped\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.addEventHandler#134",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.addEventHandler(org.apache.commons.math.ode.events.EventHandler, double, double, int, org.apache.commons.math.analysis.solvers.UnivariateRealSolver)",
        "snippet": "    public void addEventHandler(final EventHandler handler,\n                                final double maxCheckInterval,\n                                final double convergence,\n                                final int maxIterationCount,\n                                final UnivariateRealSolver solver) {\n        eventsStates.add(new EventState(handler, maxCheckInterval, convergence,\n                                        maxIterationCount, solver));\n    }\n",
        "begin_line": 134,
        "end_line": 141,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Add an event handler to the integrator.\n     * @param handler event handler\n     * @param maxCheckInterval maximal time interval between switching\n     * function checks (this interval prevents missing sign changes in\n     * case the integration steps becomes very large)\n     * @param convergence convergence threshold in the event time search\n     * @param maxIterationCount upper limit of the iteration count in\n     * the event time search\n     * @param solver The root-finding algorithm to use to detect the state\n     * events.\n     * @see #getEventHandlers()\n     * @see #clearEventHandlers()\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifyInterval#334",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifyInterval(double, double)",
        "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper) {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }\n",
        "begin_line": 334,
        "end_line": 340,
        "comment": "\n     * Check that the endpoints specify an interval.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMin#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMax#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the absolute accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getRelativeAccuracy#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the relative accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy()",
        "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }\n",
        "begin_line": 139,
        "end_line": 141,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * @return the function value accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.computeObjectiveValue#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.setup#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.setup(int, FUNC, double, double, double)",
        "snippet": "    protected void setup(int maxEval,\n                         FUNC f,\n                         double min, double max,\n                         double startValue) {\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 168,
        "end_line": 182,
        "comment": "\n     * Prepare for computation.\n     * Subclasses must call this method if they override any of the\n     * {@code solve} methods.\n     *\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.solve#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(int, FUNC, double, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n        // Initialization.\n        setup(maxEval, f, min, max, startValue);\n\n        // Perform computation.\n        return doSolve();\n    }\n",
        "begin_line": 185,
        "end_line": 191,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.incrementEvaluationCount#292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount() {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }\n",
        "begin_line": 292,
        "end_line": 298,
        "comment": "\n     * Increment the evaluation count by one.\n     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n     * It is provided for subclasses that do not exclusively use\n     * {@code computeObjectiveValue} to solve the function.\n     * See e.g. {@link AbstractDifferentiableUnivariateRealSolver}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2294
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.EventState#100",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.EventState(org.apache.commons.math.ode.events.EventHandler, double, double, int, org.apache.commons.math.analysis.solvers.UnivariateRealSolver)",
        "snippet": "    public EventState(final EventHandler handler, final double maxCheckInterval,\n                      final double convergence, final int maxIterationCount,\n                      final UnivariateRealSolver solver) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = FastMath.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n        this.solver            = solver;\n\n        // some dummy values ...\n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.Action.CONTINUE;\n\n    }\n",
        "begin_line": 100,
        "end_line": 119,
        "comment": " Simple constructor.\n     * @param handler event handler\n     * @param maxCheckInterval maximal time interval between switching\n     * function checks (this interval prevents missing sign changes in\n     * case the integration steps becomes very large)\n     * @param convergence convergence threshold in the event time search\n     * @param maxIterationCount upper limit of the iteration count in\n     * the event time search\n     * @param solver Root-finding algorithm to use to detect state events\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "EventState.reinitializeBegin#152",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java",
        "class_name": "org.apache.commons.math.ode.events.EventState",
        "signature": "org.apache.commons.math.ode.events.EventState.reinitializeBegin(org.apache.commons.math.ode.sampling.StepInterpolator)",
        "snippet": "    public void reinitializeBegin(final StepInterpolator interpolator) {\n\n        t0 = interpolator.getPreviousTime();\n        interpolator.setInterpolatedTime(t0);\n        g0 = handler.g(t0, interpolator.getInterpolatedState());\n        if (g0 == 0) {\n            // excerpt from MATH-421 issue:\n            // If an ODE solver is setup with an EventHandler that return STOP\n            // when the even is triggered, the integrator stops (which is exactly\n            // the expected behavior). If however the user wants to restart the\n            // solver from the final state reached at the event with the same\n            // configuration (expecting the event to be triggered again at a\n            // later time), then the integrator may fail to start. It can get stuck\n            // at the previous event. The use case for the bug MATH-421 is fairly\n            // general, so events occurring exactly at start in the first step should\n            // be ignored.\n\n            // extremely rare case: there is a zero EXACTLY at interval start\n            // we will use the sign slightly after step beginning to force ignoring this zero\n            final double epsilon = FastMath.max(solver.getAbsoluteAccuracy(),\n                                                FastMath.abs(solver.getRelativeAccuracy() * t0));\n            final double tStart = t0 + 0.5 * epsilon;\n            interpolator.setInterpolatedTime(tStart);\n            g0 = handler.g(tStart, interpolator.getInterpolatedState());\n        }\n        g0Positive = g0 >= 0;\n\n    }\n",
        "begin_line": 152,
        "end_line": 179,
        "comment": " Reinitialize the beginning of the step.\n     * @param interpolator valid for the current step\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver(double, double, double)",
        "snippet": "    protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2236
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives#314",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives(double, double)",
        "snippet": "  @Override\n  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH) {\n\n    if (! vectorsInitialized) {\n\n      if (v == null) {\n        v = new double[7][];\n        for (int k = 0; k < 7; ++k) {\n          v[k] = new double[interpolatedState.length];\n        }\n      }\n\n      // perform the last evaluations if they have not been done yet\n      finalizeStep();\n\n      // compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot1  = yDotK[0][i];\n          final double yDot6  = yDotK[5][i];\n          final double yDot7  = yDotK[6][i];\n          final double yDot8  = yDotK[7][i];\n          final double yDot9  = yDotK[8][i];\n          final double yDot10 = yDotK[9][i];\n          final double yDot11 = yDotK[10][i];\n          final double yDot12 = yDotK[11][i];\n          final double yDot13 = yDotK[12][i];\n          final double yDot14 = yDotKLast[0][i];\n          final double yDot15 = yDotKLast[1][i];\n          final double yDot16 = yDotKLast[2][i];\n          v[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\n                    B_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\n                    B_11 * yDot11 + B_12 * yDot12;\n          v[1][i] = yDot1 - v[0][i];\n          v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n          for (int k = 0; k < D.length; ++k) {\n              v[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\n                          D[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\n                          D[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\n                          D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n          }\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    final double eta      = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double theta2   = theta * theta;\n    final double dot1 = 1 - twoTheta;\n    final double dot2 = theta * (2 - 3 * theta);\n    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n\n    for (int i = 0; i < interpolatedState.length; ++i) {\n      interpolatedState[i] = currentState[i] -\n                             oneMinusThetaH * (v[0][i] -\n                                               theta * (v[1][i] +\n                                                        theta * (v[2][i] +\n                                                                 eta * (v[3][i] +\n                                                                        theta * (v[4][i] +\n                                                                                 eta * (v[5][i] +\n                                                                                        theta * (v[6][i])))))));\n      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n                                    dot3 * v[3][i] + dot4 * v[4][i] +\n                                    dot5 * v[5][i] + dot6 * v[6][i];\n    }\n\n  }\n",
        "begin_line": 314,
        "end_line": 385,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Compute the state and derivatives at the interpolated time.\n   * This is the main processing method that should be implemented by\n   * the derived classes to perform the interpolation.\n   * @param theta normalized interpolation abscissa within the step\n   * (theta is zero at the previous time step and one at the current time step)\n   * @param oneMinusThetaH time gap between the interpolated time and\n   * the current time\n   "
        },
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doFinalize#388",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doFinalize()",
        "snippet": "  @Override\n  protected void doFinalize() {\n\n    if (currentState == null) {\n      // we are finalizing an uninitialized instance\n      return;\n    }\n\n    double s;\n    final double[] yTmp = new double[currentState.length];\n    final double pT = getGlobalPreviousTime();\n\n    // k14\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n\n    // k15\n    for (int j = 0; j < currentState.length; ++j) {\n     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n         K15_14 * yDotKLast[0][j];\n     yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n\n    // k16\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n\n  }\n",
        "begin_line": 388,
        "end_line": 429,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": "\n   * Really finalize the step.\n   * The default implementation of this method does nothing.\n   "
        },
        "susp": {
            "ochiai_susp": 0.2041
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#242",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator(org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator)",
        "snippet": "  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState == null) {\n\n      yDotKLast = null;\n      v         = null;\n      vectorsInitialized = false;\n\n    } else {\n\n      final int dimension = interpolator.currentState.length;\n\n      yDotKLast    = new double[3][];\n      for (int k = 0; k < yDotKLast.length; ++k) {\n        yDotKLast[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n                         dimension);\n      }\n\n      v = new double[7][];\n      for (int k = 0; k < v.length; ++k) {\n        v[k] = new double[dimension];\n        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n      }\n\n      vectorsInitialized = interpolator.vectorsInitialized;\n\n    }\n\n  }\n",
        "begin_line": 242,
        "end_line": 273,
        "comment": " Copy constructor.\n   * @param interpolator interpolator to copy from. The copy is a deep\n   * copy: its arrays are separated from the original arrays of the\n   * instance\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.doCopy#276",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doCopy()",
        "snippet": "  @Override\n  protected StepInterpolator doCopy() {\n    return new DormandPrince853StepInterpolator(this);\n  }\n",
        "begin_line": 276,
        "end_line": 279,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Really copy the finalized instance.\n    * <p>This method is called by {@link #copy()} after the\n    * step has been finalized. It must perform a deep copy\n    * to have an new instance completely independent for the\n    * original instance.\n    * @return a copy of the finalized instance\n    "
        },
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.reinitialize#282",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  @Override\n  public void reinitialize(final AbstractIntegrator integrator,\n                           final double[] y, final double[][] yDotK, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n\n    super.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\n\n    final int dimension = currentState.length;\n\n    yDotKLast = new double[3][];\n    for (int k = 0; k < yDotKLast.length; ++k) {\n      yDotKLast[k] = new double[dimension];\n    }\n\n    v = new double[7][];\n    for (int k = 0; k < v.length; ++k) {\n      v[k]  = new double[dimension];\n    }\n\n    vectorsInitialized = false;\n\n  }\n",
        "begin_line": 282,
        "end_line": 304,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   "
        },
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.storeTime#307",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.storeTime(double)",
        "snippet": "  @Override\n  public void storeTime(final double t) {\n    super.storeTime(t);\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 307,
        "end_line": 311,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator": null,
            "org.apache.commons.math.ode.sampling.AbstractStepInterpolator": " Store the current step time.\n   * @param t current time\n   "
        },
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.estimateError#251",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.estimateError(double[][], double[], double[], double)",
        "snippet": "  @Override\n  protected double estimateError(final double[][] yDotK,\n                                 final double[] y0, final double[] y1,\n                                 final double h) {\n    double error1 = 0;\n    double error2 = 0;\n\n    for (int j = 0; j < mainSetDimension; ++j) {\n      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\n                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\n                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\n                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\n      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\n                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\n                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\n                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n\n      final double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\n      final double tol = (vecAbsoluteTolerance == null) ?\n                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n      final double ratio1  = errSum1 / tol;\n      error1        += ratio1 * ratio1;\n      final double ratio2  = errSum2 / tol;\n      error2        += ratio2 * ratio2;\n    }\n\n    double den = error1 + 0.01 * error2;\n    if (den <= 0.0) {\n      den = 1.0;\n    }\n\n    return FastMath.abs(h) * error1 / FastMath.sqrt(mainSetDimension * den);\n\n  }\n",
        "begin_line": 251,
        "end_line": 285,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator": " Compute the error ratio.\n   * @param yDotK derivatives computed during the first stages\n   * @param y0 estimate of the step at the start of the step\n   * @param y1 estimate of the step at the end of the step\n   * @param h  current step\n   * @return error ratio, greater than 1 if step should be rejected\n   "
        },
        "susp": {
            "ochiai_susp": 0.1924
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.DormandPrince853Integrator#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator(double, double, double, double)",
        "snippet": "  public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n          new DormandPrince853StepInterpolator(),\n          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n  }\n",
        "begin_line": 217,
        "end_line": 223,
        "comment": " Simple constructor.\n   * Build an eighth order Dormand-Prince integrator with the given step bounds\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#266",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Precision.java",
        "class_name": "org.apache.commons.math.util.Precision",
        "signature": "org.apache.commons.math.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 266,
        "end_line": 281,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1857
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator#230",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator()",
        "snippet": "  public DormandPrince853StepInterpolator() {\n    super();\n    yDotKLast = null;\n    v         = null;\n    vectorsInitialized = false;\n  }\n",
        "begin_line": 230,
        "end_line": 235,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n   * prototyping design pattern to create the step interpolators by\n   * cloning an uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1796
        },
        "num_failing_tests": 1
    },
    {
        "name": "DormandPrince853Integrator.getOrder#245",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
        "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.getOrder()",
        "snippet": "  @Override\n  public int getOrder() {\n    return 8;\n  }\n",
        "begin_line": 245,
        "end_line": 248,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator": " Get the order of the method.\n   * @return order of the method\n   "
        },
        "susp": {
            "ochiai_susp": 0.1796
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.checkNotNull#513",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 513,
        "end_line": 518,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.integrate#191",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = new double[y.length];\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    setStateInitialized(false);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // local error is small enough: accept the step, trigger events and step handlers\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              // save the last evaluation for the next step\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // stepsize control for next step\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n",
        "begin_line": 191,
        "end_line": 332,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator": " {@inheritDoc} ",
            "org.apache.commons.math.ode.AbstractIntegrator": " Integrate a set of differential equations up to the given time.\n     * <p>This method solves an Initial Value Problem (IVP).</p>\n     * <p>The set of differential equations is composed of a main set, which\n     * can be extended by some sets of secondary equations. The set of\n     * equations must be already set up with initial time and partial states.\n     * At integration completion, the final time and partial states will be\n     * available in the same object.</p>\n     * <p>Since this method stores some internal state variables made\n     * available in its public interface during integration ({@link\n     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n     * @param equations complete set of differential equations to integrate\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws MathIllegalStateException if the integrator cannot perform integration\n     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n     * too small integration span)\n     "
        },
        "susp": {
            "ochiai_susp": 0.1562
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator(java.lang.String, boolean, double[], double[][], double[], org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator, double, double, double, double)",
        "snippet": "  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }\n",
        "begin_line": 109,
        "end_line": 131,
        "comment": " Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1387
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.floor#3334",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.floor(double)",
        "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }\n",
        "begin_line": 3334,
        "end_line": 3355,
        "comment": " Get the largest whole number smaller than x.\n     * @param x number from which floor is requested\n     * @return a double number f such that f is an integer f <= x < f + 1.0\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1291
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setSafety#186",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setSafety(double)",
        "snippet": "  public void setSafety(final double safety) {\n    this.safety = safety;\n  }\n",
        "begin_line": 186,
        "end_line": 188,
        "comment": " Set the safety factor for stepsize control.\n   * @param safety safety factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMinReduction#344",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMinReduction(double)",
        "snippet": "  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }\n",
        "begin_line": 344,
        "end_line": 346,
        "comment": " Set the minimal reduction factor for stepsize control.\n   * @param minReduction minimal reduction factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 1
    },
    {
        "name": "EmbeddedRungeKuttaIntegrator.setMaxGrowth#358",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMaxGrowth(double)",
        "snippet": "  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }\n",
        "begin_line": 358,
        "end_line": 360,
        "comment": " Set the maximal growth factor for stepsize control.\n   * @param maxGrowth maximal growth factor\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.124
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3494",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(int, int)",
        "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }\n",
        "begin_line": 3494,
        "end_line": 3496,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.117
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.exp#817",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.exp(double, double, double[])",
        "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }\n",
        "begin_line": 817,
        "end_line": 932,
        "comment": "\n     * Internal helper method for exponential function.\n     * @param x original argument of the exponential function\n     * @param extra extra bits of precision on input (To Be Confirmed)\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1091
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.filterStep#318",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.filterStep(double, boolean, boolean)",
        "snippet": "  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n    throws NumberIsTooSmallException {\n\n      double filteredH = h;\n      if (FastMath.abs(h) < minStep) {\n          if (acceptSmall) {\n              filteredH = forward ? minStep : -minStep;\n          } else {\n              throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,\n                                                  minStep, FastMath.abs(h), true);\n          }\n      }\n\n      if (filteredH > maxStep) {\n          filteredH = maxStep;\n      } else if (filteredH < -maxStep) {\n          filteredH = -maxStep;\n      }\n\n      return filteredH;\n\n  }\n",
        "begin_line": 318,
        "end_line": 339,
        "comment": " Filter the integration step.\n   * @param h signed step\n   * @param forward forward integration indicator\n   * @param acceptSmall if true, steps smaller than the minimal value\n   * are silently increased up to this value, if false such small\n   * steps generate an exception\n   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n   * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1037
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator#105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator(java.lang.String, double, double, double, double)",
        "snippet": "  public AdaptiveStepsizeIntegrator(final String name,\n                                    final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n\n    super(name);\n    setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n    resetInternalState();\n\n  }\n",
        "begin_line": 105,
        "end_line": 114,
        "comment": " Build an integrator with the given stepsize bounds.\n   * The default step handler does nothing.\n   * @param name name of the method\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.setStepSizeControl#153",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.setStepSizeControl(double, double, double, double)",
        "snippet": "  public void setStepSizeControl(final double minimalStep, final double maximalStep,\n                                 final double absoluteTolerance,\n                                 final double relativeTolerance) {\n\n      minStep     = FastMath.abs(minimalStep);\n      maxStep     = FastMath.abs(maximalStep);\n      initialStep = -1;\n\n      scalAbsoluteTolerance = absoluteTolerance;\n      scalRelativeTolerance = relativeTolerance;\n      vecAbsoluteTolerance  = null;\n      vecRelativeTolerance  = null;\n\n  }\n",
        "begin_line": 153,
        "end_line": 166,
        "comment": " Set the adaptive step size control parameters.\n   * <p>\n   * A side effect of this method is to also reset the initial\n   * step so it will be automatically computed by the integrator\n   * if {@link #setInitialStepSize(double) setInitialStepSize}\n   * is not called by the user.\n   * </p>\n   * @param minimalStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maximalStep maximal step (must be positive even for backward\n   * integration)\n   * @param absoluteTolerance allowed absolute error\n   * @param relativeTolerance allowed relative error\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1021
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#171",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator(org.apache.commons.math.ode.sampling.AbstractStepInterpolator)",
        "snippet": "  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\n    globalPreviousTime = interpolator.globalPreviousTime;\n    globalCurrentTime  = interpolator.globalCurrentTime;\n    softPreviousTime   = interpolator.softPreviousTime;\n    softCurrentTime    = interpolator.softCurrentTime;\n    h                  = interpolator.h;\n    interpolatedTime   = interpolator.interpolatedTime;\n\n    if (interpolator.currentState == null) {\n        currentState     = null;\n        primaryMapper    = null;\n        secondaryMappers = null;\n        allocateInterpolatedArrays(-1);\n    } else {\n      currentState                     = interpolator.currentState.clone();\n      interpolatedState                = interpolator.interpolatedState.clone();\n      interpolatedDerivatives          = interpolator.interpolatedDerivatives.clone();\n      interpolatedPrimaryState         = interpolator.interpolatedPrimaryState.clone();\n      interpolatedPrimaryDerivatives   = interpolator.interpolatedPrimaryDerivatives.clone();\n      interpolatedSecondaryState       = new double[interpolator.interpolatedSecondaryState.length][];\n      interpolatedSecondaryDerivatives = new double[interpolator.interpolatedSecondaryDerivatives.length][];\n      for (int i = 0; i < interpolatedSecondaryState.length; ++i) {\n          interpolatedSecondaryState[i]       = interpolator.interpolatedSecondaryState[i].clone();\n          interpolatedSecondaryDerivatives[i] = interpolator.interpolatedSecondaryDerivatives[i].clone();\n      }\n    }\n\n    finalized        = interpolator.finalized;\n    forward          = interpolator.forward;\n    dirtyState       = interpolator.dirtyState;\n    primaryMapper    = interpolator.primaryMapper;\n    secondaryMappers = (interpolator.secondaryMappers == null) ?\n                       null : interpolator.secondaryMappers.clone();\n\n  }\n",
        "begin_line": 171,
        "end_line": 206,
        "comment": " Copy constructor.\n\n   * <p>The copied interpolator should have been finalized before the\n   * copy, otherwise the copy will not be able to perform correctly\n   * any derivative computation and will throw a {@link\n   * NullPointerException} later. Since we don't want this constructor\n   * to throw the exceptions finalization may involve and since we\n   * don't want this method to modify the state of the copied\n   * interpolator, finalization is <strong>not</strong> done\n   * automatically, it remains under user control.</p>\n\n   * <p>The copy is a deep copy: its arrays are separated from the\n   * original arrays of the instance.</p>\n\n   * @param interpolator interpolator to copy from.\n\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0995
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#80",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator(org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator)",
        "snippet": "  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState != null) {\n      final int dimension = currentState.length;\n\n      yDotK = new double[interpolator.yDotK.length][];\n      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n        yDotK[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotK[k], 0,\n                         yDotK[k], 0, dimension);\n      }\n\n    } else {\n      yDotK = null;\n    }\n\n    // we cannot keep any reference to the equations in the copy\n    // the interpolator should have been finalized before\n    integrator = null;\n\n  }\n",
        "begin_line": 80,
        "end_line": 102,
        "comment": " Copy constructor.\n\n  * <p>The copied interpolator should have been finalized before the\n  * copy, otherwise the copy will not be able to perform correctly any\n  * interpolation and will throw a {@link NullPointerException}\n  * later. Since we don't want this constructor to throw the\n  * exceptions finalization may involve and since we don't want this\n  * method to modify the state of the copied interpolator,\n  * finalization is <strong>not</strong> done automatically, it\n  * remains under user control.</p>\n\n  * <p>The copy is a deep copy: its arrays are separated from the\n  * original arrays of the instance.</p>\n\n  * @param interpolator interpolator to copy from.\n\n  ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0995
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.sanityChecks#217",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.sanityChecks(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "  @Override\n  protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n      throws DimensionMismatchException, NumberIsTooSmallException {\n\n      super.sanityChecks(equations, t);\n\n      mainSetDimension = equations.getPrimaryMapper().getDimension();\n\n      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\n          throw new DimensionMismatchException(mainSetDimension, vecAbsoluteTolerance.length);\n      }\n\n      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != mainSetDimension)) {\n          throw new DimensionMismatchException(mainSetDimension, vecRelativeTolerance.length);\n      }\n\n  }\n",
        "begin_line": 217,
        "end_line": 233,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.AbstractIntegrator": " Integrate a set of differential equations up to the given time.\n     * <p>This method solves an Initial Value Problem (IVP).</p>\n     * <p>The set of differential equations is composed of a main set, which\n     * can be extended by some sets of secondary equations. The set of\n     * equations must be already set up with initial time and partial states.\n     * At integration completion, the final time and partial states will be\n     * available in the same object.</p>\n     * <p>Since this method stores some internal state variables made\n     * available in its public interface during integration ({@link\n     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n     * @param equations complete set of differential equations to integrate\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws MathIllegalStateException if the integrator cannot perform integration\n     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n     * too small integration span)\n     "
        },
        "susp": {
            "ochiai_susp": 0.0995
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.reinitialize#244",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.reinitialize(double[], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  protected void reinitialize(final double[] y, final boolean isForward,\n                              final EquationsMapper primary,\n                              final EquationsMapper[] secondary) {\n\n    globalPreviousTime    = Double.NaN;\n    globalCurrentTime     = Double.NaN;\n    softPreviousTime      = Double.NaN;\n    softCurrentTime       = Double.NaN;\n    h                     = Double.NaN;\n    interpolatedTime      = Double.NaN;\n    currentState          = y;\n    finalized             = false;\n    this.forward          = isForward;\n    this.dirtyState       = true;\n    this.primaryMapper    = primary;\n    this.secondaryMappers = secondary.clone();\n    allocateInterpolatedArrays(y.length);\n\n  }\n",
        "begin_line": 244,
        "end_line": 262,
        "comment": " Reinitialize the instance\n   * @param y reference to the integrator array holding the state at the end of the step\n   * @param isForward integration direction indicator\n   * @param primary equations mapper for the primary equations set\n   * @param secondary equations mappers for the secondary equations sets\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.copy#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.copy()",
        "snippet": "   public StepInterpolator copy() {\n\n     // finalize the step before performing copy\n     finalizeStep();\n\n     // create the new independent instance\n     return doCopy();\n\n   }\n",
        "begin_line": 265,
        "end_line": 273,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": " Copy the instance.\n   * <p>The copied instance is guaranteed to be independent from the\n   * original one. Both can be used with different settings for\n   * interpolated time without any side effect.</p>\n   * @return a deep copy of the instance, which can be used independently.\n   * @see #setInterpolatedTime(double)\n   "
        },
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.finalizeStep#481",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.finalizeStep()",
        "snippet": "  public final void finalizeStep() {\n    if (! finalized) {\n      doFinalize();\n      finalized = true;\n    }\n  }\n",
        "begin_line": 481,
        "end_line": 486,
        "comment": "\n   * Finalize the step.\n\n   * <p>Some embedded Runge-Kutta integrators need fewer functions\n   * evaluations than their counterpart step interpolators. These\n   * interpolators should perform the last evaluations they need by\n   * themselves only if they need them. This method triggers these\n   * extra evaluations. It can be called directly by the user step\n   * handler and it is called automatically if {@link\n   * #setInterpolatedTime} is called.</p>\n\n   * <p>Once this method has been called, <strong>no</strong> other\n   * evaluation will be performed on this step. If there is a need to\n   * have some side effects between the step handler and the\n   * differential equations (for example update some data in the\n   * equations once the step has been done), it is advised to call\n   * this method explicitly from the step handler before these side\n   * effects are set up. If the step handler induces no side effect,\n   * then this method can safely be ignored, it will be called\n   * transparently as needed.</p>\n\n   * <p><strong>Warning</strong>: since the step interpolator provided\n   * to the step handler as a parameter of the {@link\n   * StepHandler#handleStep handleStep} is valid only for the duration\n   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n   * simply store a reference and reuse it later. One should first\n   * finalize the instance, then copy this finalized instance into a\n   * new object that can be kept.</p>\n\n   * <p>This method calls the protected <code>doFinalize</code> method\n   * if it has never been called during this step and set a flag\n   * indicating that it has been called once. It is the <code>\n   * doFinalize</code> method which should perform the evaluations.\n   * This wrapping prevents from calling <code>doFinalize</code> several\n   * times and hence evaluating the differential equations too often.\n   * Therefore, subclasses are not allowed not reimplement it, they\n   * should rather reimplement <code>doFinalize</code>.</p>\n\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.reinitialize#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.reinitialize(org.apache.commons.math.ode.AbstractIntegrator, double[], double[][], boolean, org.apache.commons.math.ode.EquationsMapper, org.apache.commons.math.ode.EquationsMapper[])",
        "snippet": "  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
        "begin_line": 127,
        "end_line": 134,
        "comment": " Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0981
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3469",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.min(double, double)",
        "snippet": "    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n",
        "begin_line": 3469,
        "end_line": 3487,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0976
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadLnMant#6173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadLnMant()",
        "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT;\n    }\n",
        "begin_line": 6173,
        "end_line": 6175,
        "comment": "\n     * Load \"LN_MANT\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0967
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.log#1105",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.log(double, double[])",
        "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            double numer = bits & 0x3ffffffffffL;\n            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }\n",
        "begin_line": 1105,
        "end_line": 1325,
        "comment": "\n     * Internal helper method for natural logarithm function.\n     * @param x original argument of the natural logarithm function\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n     * @return log(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0967
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.pow#1419",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.pow(double, double)",
        "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }\n",
        "begin_line": 1419,
        "end_line": 1577,
        "comment": "\n     * Power function.  Compute x^y.\n     *\n     * @param x   a double\n     * @param y   a double\n     * @return double\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0967
        },
        "num_failing_tests": 1
    },
    {
        "name": "AdaptiveStepsizeIntegrator.resetInternalState#352",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
        "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.resetInternalState()",
        "snippet": "  protected void resetInternalState() {\n    stepStart = Double.NaN;\n    stepSize  = FastMath.sqrt(minStep * maxStep);\n  }\n",
        "begin_line": 352,
        "end_line": 355,
        "comment": " Reset internal state to dummy values. ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0953
        },
        "num_failing_tests": 1
    },
    {
        "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator#57",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
        "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator()",
        "snippet": "  protected RungeKuttaStepInterpolator() {\n    super();\n    yDotK      = null;\n    integrator = null;\n  }\n",
        "begin_line": 57,
        "end_line": 61,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. The {@link RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n   * pattern to create the step interpolators by cloning an\n   * uninitialized model and latter initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0928
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.AbstractStepInterpolator#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator()",
        "snippet": "  protected AbstractStepInterpolator() {\n    globalPreviousTime = Double.NaN;\n    globalCurrentTime  = Double.NaN;\n    softPreviousTime   = Double.NaN;\n    softCurrentTime    = Double.NaN;\n    h                  = Double.NaN;\n    interpolatedTime   = Double.NaN;\n    currentState       = null;\n    finalized          = false;\n    this.forward       = true;\n    this.dirtyState    = true;\n    primaryMapper      = null;\n    secondaryMappers   = null;\n    allocateInterpolatedArrays(-1);\n  }\n",
        "begin_line": 111,
        "end_line": 125,
        "comment": " Simple constructor.\n   * This constructor builds an instance that is not usable yet, the\n   * {@link #reinitialize} method should be called before using the\n   * instance in order to initialize the internal arrays. This\n   * constructor is used only in order to delay the initialization in\n   * some cases. As an example, the {@link\n   * org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator}\n   * class uses the prototyping design pattern to create the step\n   * interpolators by cloning an uninitialized model and latter\n   * initializing the copy.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0924
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.allocateInterpolatedArrays#211",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.allocateInterpolatedArrays(int)",
        "snippet": "  private void allocateInterpolatedArrays(final int dimension) {\n      if (dimension < 0) {\n          interpolatedState                = null;\n          interpolatedDerivatives          = null;\n          interpolatedPrimaryState         = null;\n          interpolatedPrimaryDerivatives   = null;\n          interpolatedSecondaryState       = null;\n          interpolatedSecondaryDerivatives = null;\n      } else {\n          interpolatedState                = new double[dimension];\n          interpolatedDerivatives          = new double[dimension];\n          interpolatedPrimaryState         = new double[primaryMapper.getDimension()];\n          interpolatedPrimaryDerivatives   = new double[primaryMapper.getDimension()];\n          if (secondaryMappers == null) {\n              interpolatedSecondaryState       = null;\n              interpolatedSecondaryDerivatives = null;\n          } else {\n              interpolatedSecondaryState       = new double[secondaryMappers.length][];\n              interpolatedSecondaryDerivatives = new double[secondaryMappers.length][];\n              for (int i = 0; i < secondaryMappers.length; ++i) {\n                  interpolatedSecondaryState[i]       = new double[secondaryMappers[i].getDimension()];\n                  interpolatedSecondaryDerivatives[i] = new double[secondaryMappers[i].getDimension()];\n              }\n          }\n      }\n  }\n",
        "begin_line": 211,
        "end_line": 236,
        "comment": " Allocate the various interpolated states arrays.\n   * @param dimension total dimension (negative if arrays should be set to null)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0924
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3537",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3537,
        "end_line": 3555,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0905
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntA#6141",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntA()",
        "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A;\n    }\n",
        "begin_line": 6141,
        "end_line": 6143,
        "comment": "\n     * Load \"EXP_INT_A\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpIntB#6149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntB()",
        "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B;\n    }\n",
        "begin_line": 6149,
        "end_line": 6151,
        "comment": "\n     * Load \"EXP_INT_B\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracA#6157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracA()",
        "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A;\n    }\n",
        "begin_line": 6157,
        "end_line": 6159,
        "comment": "\n     * Load \"EXP_FRAC_A\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMathLiteralArrays.loadExpFracB#6165",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMathLiteralArrays.java",
        "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
        "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracB()",
        "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B;\n    }\n",
        "begin_line": 6165,
        "end_line": 6167,
        "comment": "\n     * Load \"EXP_FRAC_B\".\n     *\n     * @return the data array.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0894
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getPreviousTime#358",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getPreviousTime()",
        "snippet": "  public double getPreviousTime() {\n    return softPreviousTime;\n  }\n",
        "begin_line": 358,
        "end_line": 360,
        "comment": "\n   * Get the previous soft grid point time.\n   * @return previous soft grid point time\n   * @see #setSoftPreviousTime(double)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0887
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getCurrentTime#367",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getCurrentTime()",
        "snippet": "  public double getCurrentTime() {\n    return softCurrentTime;\n  }\n",
        "begin_line": 367,
        "end_line": 369,
        "comment": "\n   * Get the current soft grid point time.\n   * @return current soft grid point time\n   * @see #setSoftCurrentTime(double)\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0874
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#374",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 374,
        "end_line": 376,
        "comment": " Compute the square root of a number.\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.087
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getGlobalPreviousTime#341",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getGlobalPreviousTime()",
        "snippet": "  public double getGlobalPreviousTime() {\n    return globalPreviousTime;\n  }\n",
        "begin_line": 341,
        "end_line": 343,
        "comment": "\n   * Get the previous global grid point time.\n   * @return previous global grid point time\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0854
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getGlobalCurrentTime#349",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getGlobalCurrentTime()",
        "snippet": "  public double getGlobalCurrentTime() {\n    return globalCurrentTime;\n  }\n",
        "begin_line": 349,
        "end_line": 351,
        "comment": "\n   * Get the current global grid point time.\n   * @return current global grid point time\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0854
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3004",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 3004,
        "end_line": 3006,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0851
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.isForward#383",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.isForward()",
        "snippet": "  public boolean isForward() {\n    return forward;\n  }\n",
        "begin_line": 383,
        "end_line": 385,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": " Check if the natural integration direction is forward.\n   * <p>This method provides the integration direction as specified by\n   * the integrator itself, it avoid some nasty problems in\n   * degenerated cases like null steps due to cancellation at step\n   * initialization, step control or discrete events\n   * triggering.</p>\n   * @return true if the integration variable (time) increases during\n   * integration\n   "
        },
        "susp": {
            "ochiai_susp": 0.0848
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getTotalDimension#95",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getTotalDimension()",
        "snippet": "    public int getTotalDimension() {\n        if (components.isEmpty()) {\n            // there are no secondary equations, the complete set is limited to the primary set\n            return primaryMapper.getDimension();\n        } else {\n            // there are secondary equations, the complete set ends after the last set\n            final EquationsMapper lastMapper = components.get(components.size() - 1).mapper;\n            return lastMapper.getFirstIndex() + lastMapper.getDimension();\n        }\n    }\n",
        "begin_line": 95,
        "end_line": 104,
        "comment": " Return the dimension of the complete set of equations.\n     * <p>\n     * The complete set of equations correspond to the primary set plus all secondary sets.\n     * </p>\n     * @return dimension of the complete set of equations\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0845
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.evaluateCompleteInterpolatedState#400",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.evaluateCompleteInterpolatedState()",
        "snippet": "  private void evaluateCompleteInterpolatedState() {\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n  }\n",
        "begin_line": 400,
        "end_line": 408,
        "comment": " Lazy evaluation of complete interpolated state.\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0839
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.getInterpolatedState#411",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedState()",
        "snippet": "  public double[] getInterpolatedState() {\n      evaluateCompleteInterpolatedState();\n      primaryMapper.extractEquationData(interpolatedState,\n                                        interpolatedPrimaryState);\n      return interpolatedPrimaryState;\n  }\n",
        "begin_line": 411,
        "end_line": 416,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Get the state vector of the interpolated point.\n   * <p>The returned vector is a reference to a reused array, so\n   * it should not be modified and it should be copied if it needs\n   * to be preserved across several calls.</p>\n   * @return state vector at time {@link #getInterpolatedTime}\n   * @see #getInterpolatedDerivatives()\n   "
        },
        "susp": {
            "ochiai_susp": 0.0839
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.computeDerivatives#111",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.computeDerivatives(double, double[], double[])",
        "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n\n        // compute derivatives of the primary equations\n        primaryMapper.extractEquationData(y, primaryState);\n        primary.computeDerivatives(t, primaryState, primaryStateDot);\n        primaryMapper.insertEquationData(primaryStateDot, yDot);\n\n        // Add contribution for secondary equations\n        for (final SecondaryComponent component : components) {\n            component.mapper.extractEquationData(y, component.state);\n            component.equation.computeDerivatives(t, primaryState, primaryStateDot,\n                                                  component.state, component.stateDot);\n            component.mapper.insertEquationData(component.stateDot, yDot);\n        }\n\n    }\n",
        "begin_line": 111,
        "end_line": 126,
        "comment": " Get the current time derivative of the complete state vector.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the complete state vector\n     * @param yDot placeholder array where to put the time derivative of the complete state vector\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.computeDerivatives#247",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.computeDerivatives(double, double[], double[])",
        "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws MaxCountExceededException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n",
        "begin_line": 247,
        "end_line": 251,
        "comment": " Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0836
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getSecondaryMappers#162",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getSecondaryMappers()",
        "snippet": "    public EquationsMapper[] getSecondaryMappers() {\n        final EquationsMapper[] mappers = new EquationsMapper[components.size()];\n        for (int i = 0; i < mappers.length; ++i) {\n            mappers[i] = components.get(i).mapper;\n        }\n        return mappers;\n    }\n",
        "begin_line": 162,
        "end_line": 168,
        "comment": " Get the equations mappers for the secondary equations sets.\n     * @return equations mappers for the secondary equations sets\n     * @see #getPrimaryMapper()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getCompleteState#282",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getCompleteState()",
        "snippet": "    public double[] getCompleteState() {\n\n        // allocate complete array\n        double[] completeState = new double[getTotalDimension()];\n\n        // set the data\n        primaryMapper.insertEquationData(primaryState, completeState);\n        for (final SecondaryComponent component : components) {\n            component.mapper.insertEquationData(component.state, completeState);\n        }\n\n        return completeState;\n\n    }\n",
        "begin_line": 282,
        "end_line": 295,
        "comment": " Get the complete current state.\n     * @return complete current state\n     * @throws DimensionMismatchException if the dimension of the complete state does not\n     * match the complete equations sets dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.insertEquationData#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.insertEquationData(double[], double[])",
        "snippet": "    public void insertEquationData(double[] equationData, double[] complete)\n        throws DimensionMismatchException {\n        if (equationData.length != dimension) {\n            throw new DimensionMismatchException(equationData.length, dimension);\n        }\n        System.arraycopy(equationData, 0, complete, firstIndex, dimension);\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": " Insert equation data into a complete state or derivative array.\n     * @param equationData equation data to be inserted into the complete array\n     * @param complete placeholder where to put equation data (only the\n     * part corresponding to the equation will be overwritten)\n     * @throws DimensionMismatchException if the dimension of the equation data does not\n     * match the mapper dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setEquations#191",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setEquations(org.apache.commons.math.ode.ExpandableStatefulODE)",
        "snippet": "    protected void setEquations(final ExpandableStatefulODE equations) {\n        this.expandable = equations;\n    }\n",
        "begin_line": 191,
        "end_line": 193,
        "comment": " Set the equations.\n     * @param equations equations to set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.integrate#196",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.integrate(org.apache.commons.math.ode.FirstOrderDifferentialEquations, double, double[], double, double[])",
        "snippet": "    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0, final double t, final double[] y)\n        throws MathIllegalStateException, MathIllegalArgumentException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        // prepare expandable stateful equations\n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        // perform integration\n        integrate(expandableODE, t);\n\n        // extract results back from the stateful equations\n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n",
        "begin_line": 196,
        "end_line": 219,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": " Integrate the differential equations up to the given time.\n   * <p>This method solves an Initial Value Problem (IVP).</p>\n   * <p>Since this method stores some internal state variables made\n   * available in its public interface during integration ({@link\n   * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n   * @param equations differential equations to integrate\n   * @param t0 initial time\n   * @param y0 initial value of the state vector at t0\n   * @param t target time for the integration\n   * (can be set to a value smaller than <code>t0</code> for backward integration)\n   * @param y placeholder where to put the state vector at each successful\n   *  step (and hence at the end of integration), can be the same object as y0\n   * @return stop time, will be the same as target time if integration reached its\n   * target, but may be different if some {@link\n   * org.apache.commons.math.ode.events.EventHandler} stops it at some point.\n   * @throws MathIllegalStateException if the integrator cannot perform integration\n   * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n   * too small integration span)\n   "
        },
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setStateInitialized#260",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setStateInitialized(boolean)",
        "snippet": "    protected void setStateInitialized(final boolean stateInitialized) {\n        this.statesInitialized = stateInitialized;\n    }\n",
        "begin_line": 260,
        "end_line": 262,
        "comment": " Set the stateInitialized flag.\n     * <p>This method must be called by integrators with the value\n     * {@code false} before they start integration, so a proper lazy\n     * initialization is done automatically on the first step.</p>\n     * @param stateInitialized new value for the flag\n     * @since 2.2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0833
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.083
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getPrimaryMapper#154",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getPrimaryMapper()",
        "snippet": "    public EquationsMapper getPrimaryMapper() {\n        return primaryMapper;\n    }\n",
        "begin_line": 154,
        "end_line": 156,
        "comment": " Get an equations mapper for the primary equations set.\n     * @return mapper for the primary set\n     * @see #getSecondaryMappers()\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.083
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.sanityChecks#381",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.sanityChecks(org.apache.commons.math.ode.ExpandableStatefulODE, double)",
        "snippet": "    protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n        throws NumberIsTooSmallException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                                                dt, threshold, false);\n        }\n\n    }\n",
        "begin_line": 381,
        "end_line": 392,
        "comment": " Check the integration span.\n     * @param equations set of differential equations\n     * @param t target time for the integration\n     * @exception NumberIsTooSmallException if integration span is too small\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.083
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ulp#3031",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.ulp(double)",
        "snippet": "    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n",
        "begin_line": 3031,
        "end_line": 3036,
        "comment": "\n     * Compute least significant bit (Unit in Last Position) for a number.\n     * @param x number from which ulp is requested\n     * @return ulp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.ExpandableStatefulODE#72",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.ExpandableStatefulODE(org.apache.commons.math.ode.FirstOrderDifferentialEquations)",
        "snippet": "    public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {\n        final int n          = primary.getDimension();\n        this.primary         = primary;\n        this.primaryMapper   = new EquationsMapper(0, n);\n        this.time            = Double.NaN;\n        this.primaryState    = new double[n];\n        this.primaryStateDot = new double[n];\n        this.components      = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();\n    }\n",
        "begin_line": 72,
        "end_line": 80,
        "comment": " Build an expandable set from its primary ODE set.\n     * @param primary the primary set of differential equations to be integrated.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.setTime#173",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.setTime(double)",
        "snippet": "    public void setTime(final double time) {\n        this.time = time;\n    }\n",
        "begin_line": 173,
        "end_line": 175,
        "comment": " Set current time.\n     * @param time current time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.getTime#180",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.getTime()",
        "snippet": "    public double getTime() {\n        return time;\n    }\n",
        "begin_line": 180,
        "end_line": 182,
        "comment": " Get current time.\n     * @return current time\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 1
    },
    {
        "name": "ExpandableStatefulODE.setPrimaryState#189",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java",
        "class_name": "org.apache.commons.math.ode.ExpandableStatefulODE",
        "signature": "org.apache.commons.math.ode.ExpandableStatefulODE.setPrimaryState(double[])",
        "snippet": "    public void setPrimaryState(final double[] primaryState) throws DimensionMismatchException {\n\n        // safety checks\n        if (primaryState.length != this.primaryState.length) {\n            throw new DimensionMismatchException(primaryState.length, this.primaryState.length);\n        }\n\n        // set the data\n        System.arraycopy(primaryState, 0, this.primaryState, 0, primaryState.length);\n\n    }\n",
        "begin_line": 189,
        "end_line": 199,
        "comment": " Set primary part of the current state.\n     * @param primaryState primary part of the current state\n     * @throws DimensionMismatchException if the dimension of the array does not\n     * match the primary set\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0822
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.shift#288",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.shift()",
        "snippet": "  public void shift() {\n    globalPreviousTime = globalCurrentTime;\n    softPreviousTime   = globalPreviousTime;\n    softCurrentTime    = globalCurrentTime;\n  }\n",
        "begin_line": 288,
        "end_line": 292,
        "comment": " Shift one step forward.\n   * Copy the current time into the previous time, hence preparing the\n   * interpolator for future calls to {@link #storeTime storeTime}\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0819
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.storeTime#297",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.storeTime(double)",
        "snippet": "  public void storeTime(final double t) {\n\n    globalCurrentTime = t;\n    softCurrentTime   = globalCurrentTime;\n    h                 = globalCurrentTime - globalPreviousTime;\n    setInterpolatedTime(t);\n\n    // the step is not finalized anymore\n    finalized  = false;\n\n  }\n",
        "begin_line": 297,
        "end_line": 307,
        "comment": " Store the current step time.\n   * @param t current time\n   ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0819
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractStepInterpolator.setInterpolatedTime#377",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java",
        "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
        "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setInterpolatedTime(double)",
        "snippet": "  public void setInterpolatedTime(final double time) {\n      interpolatedTime = time;\n      dirtyState       = true;\n  }\n",
        "begin_line": 377,
        "end_line": 380,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.sampling.StepInterpolator": "\n   * Set the time of the interpolated point.\n   * <p>Setting the time outside of the current step is now allowed, but\n   * should be used with care since the accuracy of the interpolator will\n   * probably be very poor far from this step. This allowance has been\n   * added to simplify implementation of search algorithms near the\n   * step endpoints.</p>\n   * <p>Setting the time changes the instance internal state. If a\n   * specific state must be preserved, a copy of the instance must be\n   * created using {@link #copy()}.</p>\n   * @param time time of the interpolated point\n   "
        },
        "susp": {
            "ochiai_susp": 0.0819
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.extractEquationData#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.extractEquationData(double[], double[])",
        "snippet": "    public void extractEquationData(double[] complete, double[] equationData)\n        throws DimensionMismatchException {\n        if (equationData.length != dimension) {\n            throw new DimensionMismatchException(equationData.length, dimension);\n        }\n        System.arraycopy(complete, firstIndex, equationData, 0, dimension);\n    }\n",
        "begin_line": 75,
        "end_line": 81,
        "comment": " Extract equation data from a complete state or derivative array.\n     * @param complete complete state or derivative array from which\n     * equation data should be retrieved\n     * @param equationData placeholder where to put equation data\n     * @throws DimensionMismatchException if the dimension of the equation data does not\n     * match the mapper dimension\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0819
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.getDimension#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.getDimension()",
        "snippet": "    public int getDimension() {\n        return dimension;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": " Get the dimension of the secondary state parameters.\n     * @return dimension of the secondary state parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0816
        },
        "num_failing_tests": 1
    },
    {
        "name": "EquationsMapper.EquationsMapper#49",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/EquationsMapper.java",
        "class_name": "org.apache.commons.math.ode.EquationsMapper",
        "signature": "org.apache.commons.math.ode.EquationsMapper.EquationsMapper(int, int)",
        "snippet": "    public EquationsMapper(final int firstIndex, final int dimension) {\n        this.firstIndex = firstIndex;\n        this.dimension  = dimension;\n    }\n",
        "begin_line": 49,
        "end_line": 52,
        "comment": " simple constructor.\n     * @param firstIndex index of the first equation element in complete state arrays\n     * @param dimension dimension of the secondary state parameters\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0808
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.AbstractIntegrator#85",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.AbstractIntegrator(java.lang.String)",
        "snippet": "    public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsStates = new ArrayList<EventState>();\n        statesInitialized = false;\n        evaluations = new Incrementor();\n        setMaxEvaluations(-1);\n        resetEvaluations();\n    }\n",
        "begin_line": 85,
        "end_line": 95,
        "comment": " Build an instance.\n     * @param name name of the method\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0788
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.setMaxEvaluations#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n    }\n",
        "begin_line": 168,
        "end_line": 170,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.ode.FirstOrderIntegrator": null,
            "org.apache.commons.math.ode.ODEIntegrator": " Set the maximal number of differential equations function evaluations.\n     * <p>The purpose of this method is to avoid infinite loops which can occur\n     * for example when stringent error constraints are set or when lots of\n     * discrete events are triggered, thus leading to many rejected steps.</p>\n     * @param maxEvaluations maximal number of function evaluations (negative\n     * values are silently converted to maximal integer value, thus representing\n     * almost unlimited evaluations)\n     "
        },
        "susp": {
            "ochiai_susp": 0.0788
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractIntegrator.resetEvaluations#184",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java",
        "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
        "signature": "org.apache.commons.math.ode.AbstractIntegrator.resetEvaluations()",
        "snippet": "    protected void resetEvaluations() {\n        evaluations.resetCount();\n    }\n",
        "begin_line": 184,
        "end_line": 186,
        "comment": " Reset the number of evaluations to zero.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0788
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 60,
        "end_line": 68,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int, org.apache.commons.math.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3022",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3022,
        "end_line": 3024,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.0786
        },
        "num_failing_tests": 1
    }
]