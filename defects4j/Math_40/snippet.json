[
    {
        "name": "MathIllegalStateException.getMessage#78",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math.exception.MathIllegalStateException.getMessage()",
        "snippet": "    @Override\n    public String getMessage() {\n        return context.getMessage();\n    }\n",
        "begin_line": 78,
        "end_line": 81,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.exception.util.ExceptionContextProvider": null,
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.getLocalizedMessage#84",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math.exception.MathIllegalStateException.getLocalizedMessage()",
        "snippet": "    @Override\n    public String getLocalizedMessage() {\n        return context.getLocalizedMessage();\n    }\n",
        "begin_line": 84,
        "end_line": 87,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.exception.util.ExceptionContextProvider": null,
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 1.0
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.trigger#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Anonymous-e8b827d9-2ba0-429d-a84c-4338f3fbb6cc.trigger(int)",
        "snippet": "                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#149",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }\n",
        "begin_line": 149,
        "end_line": 153,
        "comment": "\n     * Adds one to the current iteration count.\n     * At counter exhaustion, this method will call the\n     * {@link MaxCountExceededCallback#trigger(int) trigger} method of the\n     * callback object passed to the\n     * {@link #Incrementor(int,MaxCountExceededCallback) constructor}.\n     * If not explictly set, a default callback is used that will throw\n     * a {@code MaxCountExceededException}.\n     *\n     * @throws MaxCountExceededException at counter exhaustion, unless a\n     * custom {@link MaxCountExceededCallback callback} has been set at\n     * construction.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "TooManyEvaluationsException.TooManyEvaluationsException#36",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/TooManyEvaluationsException.java",
        "class_name": "org.apache.commons.math.exception.TooManyEvaluationsException",
        "signature": "org.apache.commons.math.exception.TooManyEvaluationsException.TooManyEvaluationsException(java.lang.Number)",
        "snippet": "    public TooManyEvaluationsException(Number max) {\n        super(max);\n        getContext().addMessage(LocalizedFormats.EVALUATIONS);\n    }\n",
        "begin_line": 36,
        "end_line": 39,
        "comment": "\n     * Construct the exception.\n     *\n     * @param max Maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaxCountExceededException.MaxCountExceededException#41",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java",
        "class_name": "org.apache.commons.math.exception.MaxCountExceededException",
        "signature": "org.apache.commons.math.exception.MaxCountExceededException.MaxCountExceededException(java.lang.Number)",
        "snippet": "    public MaxCountExceededException(Number max) {\n        this(LocalizedFormats.MAX_COUNT_EXCEEDED, max);\n    }\n",
        "begin_line": 41,
        "end_line": 43,
        "comment": "\n     * Construct the exception.\n     *\n     * @param max Maximum.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaxCountExceededException.MaxCountExceededException#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java",
        "class_name": "org.apache.commons.math.exception.MaxCountExceededException",
        "signature": "org.apache.commons.math.exception.MaxCountExceededException.MaxCountExceededException(org.apache.commons.math.exception.util.Localizable, java.lang.Number, java.lang.Object...)",
        "snippet": "    public MaxCountExceededException(Localizable specific,\n                                     Number max,\n                                     Object ... args) {\n        getContext().addMessage(specific, max, args);\n        this.max = max;\n    }\n",
        "begin_line": 51,
        "end_line": 56,
        "comment": "\n     * Construct the exception with a specific context.\n     *\n     * @param specific Specific context pattern.\n     * @param max Maximum.\n     * @param args Additional arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MaxCountExceededException.getMax#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java",
        "class_name": "org.apache.commons.math.exception.MaxCountExceededException",
        "signature": "org.apache.commons.math.exception.MaxCountExceededException.getMax()",
        "snippet": "    public Number getMax() {\n        return max;\n    }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "\n     * @return the maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math.exception.MathIllegalStateException.MathIllegalStateException(org.apache.commons.math.exception.util.Localizable, java.lang.Object...)",
        "snippet": "    public MathIllegalStateException(Localizable pattern,\n                                     Object ... args) {\n        context = new ExceptionContext(this);\n        context.addMessage(pattern, args);\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Simple constructor.\n     *\n     * @param pattern Message pattern explaining the cause of the error.\n     * @param args Arguments.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.MathIllegalStateException#68",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math.exception.MathIllegalStateException.MathIllegalStateException()",
        "snippet": "    public MathIllegalStateException() {\n        this(LocalizedFormats.ILLEGAL_STATE);\n    }\n",
        "begin_line": 68,
        "end_line": 70,
        "comment": "\n     * Default constructor.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathIllegalStateException.getContext#73",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/exception/MathIllegalStateException.java",
        "class_name": "org.apache.commons.math.exception.MathIllegalStateException",
        "signature": "org.apache.commons.math.exception.MathIllegalStateException.getContext()",
        "snippet": "    public ExceptionContext getContext() {\n        return context;\n    }\n",
        "begin_line": 73,
        "end_line": 75,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.exception.util.ExceptionContextProvider": "\n     * Gets a reference to the \"rich context\" data structure that allows to\n     * customize error messages and store key, value pairs in exceptions.\n     *\n     * @return a reference to the exception context.\n     ",
            "java.lang.IllegalStateException": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.solve#390",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.solve(int, org.apache.commons.math.analysis.UnivariateFunction, double, double, double, org.apache.commons.math.analysis.solvers.AllowedSolution)",
        "snippet": "    public double solve(int maxEval, UnivariateFunction f, double min,\n                        double max, double startValue,\n                        AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n",
        "begin_line": 390,
        "end_line": 395,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": "\n     * Solve for a zero in the given interval.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return A value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     ",
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.incrementEvaluationCount#292",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.incrementEvaluationCount()",
        "snippet": "    protected void incrementEvaluationCount() {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }\n",
        "begin_line": 292,
        "end_line": 298,
        "comment": "\n     * Increment the evaluation count by one.\n     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n     * It is provided for subclasses that do not exclusively use\n     * {@code computeObjectiveValue} to solve the function.\n     * See e.g. {@link AbstractDifferentiableUnivariateRealSolver}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver#119",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.BracketingNthOrderBrentSolver(double, double, double, int)",
        "snippet": "    public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n                                         final double absoluteAccuracy,\n                                         final double functionValueAccuracy,\n                                         final int maximalOrder)\n        throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        if (maximalOrder < 2) {\n            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n",
        "begin_line": 119,
        "end_line": 130,
        "comment": "\n     * Construct a solver.\n     *\n     * @param relativeAccuracy Relative accuracy.\n     * @param absoluteAccuracy Absolute accuracy.\n     * @param functionValueAccuracy Function value accuracy.\n     * @param maximalOrder maximal order.\n     * @exception NumberIsTooSmallException if maximal order is lower than 2\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.5
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealSolver.AbstractUnivariateRealSolver#56",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver.AbstractUnivariateRealSolver(double, double, double)",
        "snippet": "    protected AbstractUnivariateRealSolver(final double relativeAccuracy,\n                                           final double absoluteAccuracy,\n                                           final double functionValueAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n    }\n",
        "begin_line": 56,
        "end_line": 60,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.4472
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.doSolve#142",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.doSolve()",
        "snippet": "    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n",
        "begin_line": 142,
        "end_line": 345,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the root.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the initial search interval does not bracket\n     * a root and the solver requires it.\n     ",
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": null,
            "org.apache.commons.math.analysis.solvers.UnivariateRealSolver": null
        },
        "susp": {
            "ochiai_susp": 0.2673
        },
        "num_failing_tests": 1
    },
    {
        "name": "BracketingNthOrderBrentSolver.guessX#361",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.guessX(double, double[], double[], int, int)",
        "snippet": "    private double guessX(final double targetY, final double[] x, final double[] y,\n                          final int start, final int end) {\n\n        // compute Q Newton coefficients by divided differences\n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        // evaluate Q(targetY)\n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n",
        "begin_line": 361,
        "end_line": 380,
        "comment": " Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n     * <p>\n     * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q\n     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),\n     * Q(y<sub>i</sub>) = x<sub>i</sub>.\n     * </p>\n     * @param targetY target value for y\n     * @param x reference points abscissas for interpolation,\n     * note that this array <em>is</em> modified during computation\n     * @param y reference points ordinates for interpolation\n     * @param start start index of the points to consider (inclusive)\n     * @param end end index of the points to consider (exclusive)\n     * @return guessed root (will be a NaN if two points share the same y)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.2
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy#127",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getAbsoluteAccuracy()",
        "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }\n",
        "begin_line": 127,
        "end_line": 129,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Get the absolute accuracy of the solver.  Solutions returned by the\n     * solver should be accurate to this tolerance, i.e., if &epsilon; is the\n     * absolute accuracy of the solver and {@code v} is a value returned by\n     * one of the {@code solve} methods, then a root of the function should\n     * exist somewhere in the interval ({@code v} - &epsilon;, {@code v} + &epsilon;).\n     *\n     * @return the absolute accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getRelativeAccuracy#133",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getRelativeAccuracy()",
        "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }\n",
        "begin_line": 133,
        "end_line": 135,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Get the relative accuracy of the solver.  The contract for relative\n     * accuracy is the same as {@link #getAbsoluteAccuracy()}, but using\n     * relative, rather than absolute error.  If &rho; is the relative accuracy\n     * configured for a solver and {@code v} is a value returned, then a root\n     * of the function should exist somewhere in the interval\n     * ({@code v} - &rho; {@code v}, {@code v} + &rho; {@code v}).\n     *\n     * @return the relative accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy#139",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getFunctionValueAccuracy()",
        "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }\n",
        "begin_line": 139,
        "end_line": 141,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Get the function value accuracy of the solver.  If {@code v} is\n     * a value returned by the solver for a function {@code f},\n     * then by contract, {@code |f(v)|} should be less than or equal to\n     * the function value accuracy configured for the solver.\n     *\n     * @return the function value accuracy.\n     "
        },
        "susp": {
            "ochiai_susp": 0.1961
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.checkNotNull#255",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(java.lang.Object)",
        "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }\n",
        "begin_line": 255,
        "end_line": 260,
        "comment": "\n     * Checks that an object is not null.\n     *\n     * @param o Object to be checked.\n     * @throws NullArgumentException if {@code o} is {@code null}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifyInterval#334",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifyInterval(double, double)",
        "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper) {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }\n",
        "begin_line": 334,
        "end_line": 340,
        "comment": "\n     * Check that the endpoints specify an interval.\n     *\n     * @param lower Lower endpoint.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealSolverUtils.verifySequence#351",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java",
        "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils",
        "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.verifySequence(double, double, double)",
        "snippet": "    public static void verifySequence(final double lower,\n                                      final double initial,\n                                      final double upper) {\n        verifyInterval(lower, initial);\n        verifyInterval(initial, upper);\n    }\n",
        "begin_line": 351,
        "end_line": 356,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n     * {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMin#109",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 109,
        "end_line": 111,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getMax#115",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 115,
        "end_line": 117,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.getStartValue#121",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 121,
        "end_line": 123,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.computeObjectiveValue#151",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }\n",
        "begin_line": 151,
        "end_line": 155,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.setup#168",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.setup(int, FUNC, double, double, double)",
        "snippet": "    protected void setup(int maxEval,\n                         FUNC f,\n                         double min, double max,\n                         double startValue) {\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n    }\n",
        "begin_line": 168,
        "end_line": 182,
        "comment": "\n     * Prepare for computation.\n     * Subclasses must call this method if they override any of the\n     * {@code solve} methods.\n     *\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param maxEval Maximum number of evaluations.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.solve#185",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(int, FUNC, double, double, double)",
        "snippet": "    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n        // Initialization.\n        setup(maxEval, f, min, max, startValue);\n\n        // Perform computation.\n        return doSolve();\n    }\n",
        "begin_line": 185,
        "end_line": 191,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.analysis.solvers.BaseUnivariateRealSolver": "\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     "
        },
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.verifySequence#265",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.verifySequence(double, double, double)",
        "snippet": "    protected void verifySequence(final double lower,\n                                  final double initial,\n                                  final double upper) {\n        UnivariateRealSolverUtils.verifySequence(lower, initial, upper);\n    }\n",
        "begin_line": 265,
        "end_line": 269,
        "comment": "\n     * Check that {@code lower < initial < upper}.\n     *\n     * @param lower Lower endpoint.\n     * @param initial Initial value.\n     * @param upper Upper endpoint.\n     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n     * if {@code lower >= initial} or {@code initial >= upper}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.189
        },
        "num_failing_tests": 1
    },
    {
        "name": "BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java",
        "class_name": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver",
        "signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.BaseAbstractUnivariateRealSolver(double, double, double)",
        "snippet": "    protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }\n",
        "begin_line": 90,
        "end_line": 96,
        "comment": "\n     * Construct a solver with given accuracies.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     * @param functionValueAccuracy Maximum function value error.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1741
        },
        "num_failing_tests": 1
    },
    {
        "name": "Precision.equals#276",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Precision.java",
        "class_name": "org.apache.commons.math.util.Precision",
        "signature": "org.apache.commons.math.util.Precision.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 276,
        "end_line": 291,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1644
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3537",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n",
        "begin_line": 3537,
        "end_line": 3555,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.127
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3004",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 3004,
        "end_line": 3006,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1204
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3022",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }\n",
        "begin_line": 3022,
        "end_line": 3024,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1098
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#90",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 90,
        "end_line": 92,
        "comment": "\n     * Sets the upper limit for the counter.\n     * This does not automatically reset the current count to zero (see\n     * {@link #resetCount()}).\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#158",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 158,
        "end_line": 160,
        "comment": "\n     * Resets the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.1085
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#60",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int)",
        "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }\n",
        "begin_line": 60,
        "end_line": 68,
        "comment": "\n     * Defines a maximal count.\n     *\n     * @param max Maximal count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.106
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#51",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor()",
        "snippet": "    public Incrementor() {\n        this(0);\n    }\n",
        "begin_line": 51,
        "end_line": 53,
        "comment": "\n     * Default constructor.\n     * For the new instance to be useful, the maximal count must be set\n     * by calling {@link #setMaximalCount(int) setMaximalCount}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.106
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.Incrementor#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.Incrementor(int, org.apache.commons.math.util.Incrementor.MaxCountExceededCallback)",
        "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        maximalCount = max;\n        maxCountCallback = cb;\n    }\n",
        "begin_line": 77,
        "end_line": 81,
        "comment": "\n     * Defines a maximal count and a callback method to be triggered at\n     * counter exhaustion.\n     *\n     * @param max Maximal count.\n     * @param cb Function to be called when the maximal count has been reached.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.106
        },
        "num_failing_tests": 1
    }
]