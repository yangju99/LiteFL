[
    {
        "name": "MathUtils.equals#416",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.equals(double, double)",
        "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n",
        "begin_line": 416,
        "end_line": 418,
        "comment": "\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MathUtils.equals#476",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/MathUtils.java",
        "class_name": "org.apache.commons.math.util.MathUtils",
        "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, int)",
        "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        // Check that \"maxUlps\" is non-negative and small enough so that\n        // NaN won't compare as equal to anything (except another NaN).\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n",
        "begin_line": 476,
        "end_line": 495,
        "comment": "\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or less) floating point numbers between them (i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are less than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.setMaximalCount#43",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
        "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }\n",
        "begin_line": 43,
        "end_line": 45,
        "comment": "\n     * Set the upper limit for the counter.\n     *\n     * @param max Upper limit of the counter.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getMaximalCount#52",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.getMaximalCount()",
        "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }\n",
        "begin_line": 52,
        "end_line": 54,
        "comment": "\n     * Get the upper limit of the counter.\n     *\n     * @return the counter upper limit.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.getCount#61",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.getCount()",
        "snippet": "    public int getCount() {\n        return count;\n    }\n",
        "begin_line": 61,
        "end_line": 63,
        "comment": "\n     * Get the current count.\n     *\n     * @return the current count.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.incrementCount#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
        "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            throw new MaxCountExceededException(maximalCount);\n        }\n    }\n",
        "begin_line": 83,
        "end_line": 87,
        "comment": "\n     * Add one to the current iteration count.\n     *\n     * @throws MaxCountExceededException at counter exhaustion.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "Incrementor.resetCount#92",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/Incrementor.java",
        "class_name": "org.apache.commons.math.util.Incrementor",
        "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
        "snippet": "    public void resetCount() {\n        count = 0;\n    }\n",
        "begin_line": 92,
        "end_line": 94,
        "comment": "\n     * Reset the counter to 0.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.sqrt#218",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
        "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }\n",
        "begin_line": 218,
        "end_line": 220,
        "comment": " Compute the square root of a number.\n     * @param a number on which evaluation is done\n     * @return square root of a\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowexp#679",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowexp(double, double[])",
        "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 679,
        "end_line": 706,
        "comment": "\n     *  For x between 0 and 1, returns exp(x), uses extended precision\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n     *  @return exp(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.split#713",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.split(double, double[])",
        "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * 1073741824.0;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * 1073741824.0;\n            split[1] = d - split[0];\n        }\n    }\n",
        "begin_line": 713,
        "end_line": 723,
        "comment": " Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.resplit#729",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
        "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * 1073741824.0;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * 1073741824.0;\n            a[1] = c - a[0] + d;\n        }\n    }\n",
        "begin_line": 729,
        "end_line": 742,
        "comment": " Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitMult#749",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitMult(double[], double[], double[])",
        "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n",
        "begin_line": 749,
        "end_line": 755,
        "comment": " Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitAdd#762",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[], double[], double[])",
        "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n",
        "begin_line": 762,
        "end_line": 767,
        "comment": " Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.splitReciprocal#787",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[], double[])",
        "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n",
        "begin_line": 787,
        "end_line": 815,
        "comment": " Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.quadMult#822",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.quadMult(double[], double[], double[])",
        "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }\n",
        "begin_line": 822,
        "end_line": 869,
        "comment": " Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.expint#876",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.expint(int, double[])",
        "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 876,
        "end_line": 914,
        "comment": " Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowLog#1395",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
        "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n",
        "begin_line": 1395,
        "end_line": 1437,
        "comment": " xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowSin#1445",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowSin(double, double[])",
        "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1445,
        "end_line": 1479,
        "comment": "\n     * For x between 0 and pi/4 compute sine.\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return sin(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.slowCos#1487",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.slowCos(double, double[])",
        "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n",
        "begin_line": 1487,
        "end_line": 1522,
        "comment": "\n     *  For x between 0 and pi/4 compute cosine\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return cos(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.buildSinCosTables#1526",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
        "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }\n",
        "begin_line": 1526,
        "end_line": 1618,
        "comment": " Build the sine and cosine tables.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3015",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(long)",
        "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }\n",
        "begin_line": 3015,
        "end_line": 3017,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.abs#3033",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.abs(double)",
        "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : x;\n    }\n",
        "begin_line": 3033,
        "end_line": 3035,
        "comment": "\n     * Absolute value.\n     * @param x number from which absolute value is requested\n     * @return abs(x)\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.ulp#3043",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.ulp(double)",
        "snippet": "    public static double ulp(double x) {\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }\n",
        "begin_line": 3043,
        "end_line": 3045,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.min#3223",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.min(double, double)",
        "snippet": "    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }\n",
        "begin_line": 3223,
        "end_line": 3225,
        "comment": " Compute the minimum of two values\n     * @param a first value\n     * @param b second value\n     * @return a if a is lesser or equal to b, b otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "FastMath.max#3259",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/util/FastMath.java",
        "class_name": "org.apache.commons.math.util.FastMath",
        "signature": "org.apache.commons.math.util.FastMath.max(double, double)",
        "snippet": "    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }\n",
        "begin_line": 3259,
        "end_line": 3261,
        "comment": " Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealPointValuePair.UnivariateRealPointValuePair#44",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealPointValuePair.java",
        "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
        "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.UnivariateRealPointValuePair(double, double)",
        "snippet": "    public UnivariateRealPointValuePair(final double point,\n                                        final double value) {\n        this.point = point;\n        this.value = value;\n    }\n",
        "begin_line": 44,
        "end_line": 48,
        "comment": "\n     * Build a point/objective function value pair.\n     *\n     * @param point Point.\n     * @param value Value of an objective function at the point\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealPointValuePair.getPoint#55",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealPointValuePair.java",
        "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
        "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.getPoint()",
        "snippet": "    public double getPoint() {\n        return point;\n    }\n",
        "begin_line": 55,
        "end_line": 57,
        "comment": "\n     * Get the point.\n     *\n     * @return the point.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "UnivariateRealPointValuePair.getValue#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealPointValuePair.java",
        "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
        "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.getValue()",
        "snippet": "    public double getValue() {\n        return value;\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": "\n     * Get the value of the objective function.\n     *\n     * @return the stored value of the objective function.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.sortPairs#190",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.sortPairs(org.apache.commons.math.optimization.GoalType)",
        "snippet": "    private void sortPairs(final GoalType goal) {\n        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n                public int compare(final UnivariateRealPointValuePair o1,\n                                   final UnivariateRealPointValuePair o2) {\n                    if (o1 == null) {\n                        return (o2 == null) ? 0 : 1;\n                    } else if (o2 == null) {\n                        return -1;\n                    }\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goal == GoalType.MINIMIZE) ?\n                        Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            });\n    }\n",
        "begin_line": 190,
        "end_line": 205,
        "comment": "\n     * Sort the optima from best to worst, followed by {@code null} elements.\n     *\n     * @param goal Goal type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.compare#192",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.Anonymous-fe33579d-eb42-446f-a0ff-996f1a31fb83.compare(org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair, org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair)",
        "snippet": "                public int compare(final UnivariateRealPointValuePair o1,\n                                   final UnivariateRealPointValuePair o2) {\n                    if (o1 == null) {\n                        return (o2 == null) ? 0 : 1;\n                    } else if (o2 == null) {\n                        return -1;\n                    }\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goal == GoalType.MINIMIZE) ?\n                        Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n",
        "begin_line": 192,
        "end_line": 203,
        "comment": "",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer#70",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer(org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer<FUNC>, int, org.apache.commons.math.random.RandomGenerator)",
        "snippet": "    public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer = optimizer;\n        this.starts = starts;\n        this.generator = generator;\n    }\n",
        "begin_line": 70,
        "end_line": 76,
        "comment": "\n     * Create a multi-start optimizer from a single-start optimizer.\n     *\n     * @param optimizer Single-start optimizer to wrap.\n     * @param starts Number of starts to perform (including the\n     * first one), multi-start is disabled if value is less than or\n     * equal to 1.\n     * @param generator Random generator to use for restarts.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.optimize#142",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.optimize(FUNC, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                 final GoalType goal,\n                                                 final double min, final double max)\n        throws FunctionEvaluationException {\n        return optimize(f, goal, min, max, 0);\n    }\n",
        "begin_line": 142,
        "end_line": 147,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": "\n     * Find an optimum in the given interval.\n     *\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math.exception.ConvergenceException\n     * if the optimizer detects a convergence problem.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "MultiStartUnivariateRealOptimizer.optimize#150",
        "is_bug": true,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.optimize(FUNC, org.apache.commons.math.optimization.GoalType, double, double, double)",
        "snippet": "    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                 final double min, final double max,\n                                                 final double startValue)\n        throws FunctionEvaluationException {\n        optima = new UnivariateRealPointValuePair[starts];\n        totalEvaluations = 0;\n\n        // Multi-start loop.\n        for (int i = 0; i < starts; ++i) {\n            try {\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n            } catch (FunctionEvaluationException fee) {\n                optima[i] = null;\n            } catch (ConvergenceException ce) {\n                optima[i] = null;\n            }\n\n            final int usedEvaluations = optimizer.getEvaluations();\n            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n            totalEvaluations += usedEvaluations;\n        }\n\n        sortPairs(goal);\n\n        if (optima[0] == null) {\n            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                                           starts);\n        }\n\n        // Return the point with the best objective function value.\n        return optima[0];\n    }\n",
        "begin_line": 150,
        "end_line": 183,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": "\n     * Find an optimum in the given interval, start at startValue.\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math.exception.ConvergenceException if the\n     * optimizer detects a convergence problem.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     * @throws org.apache.commons.math.exception.NullArgumentException if any\n     * argument is {@code null}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.BrentOptimizer#75",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer(double, double)",
        "snippet": "    public BrentOptimizer(double rel,\n                          double abs) {\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }\n",
        "begin_line": 75,
        "end_line": 85,
        "comment": "\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "BrentOptimizer.doOptimize#88",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.doOptimize()",
        "snippet": "    protected UnivariateRealPointValuePair doOptimize()\n        throws FunctionEvaluationException {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariateRealPointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariateRealPointValuePair previous = null;\n        UnivariateRealPointValuePair current\n            = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        MathUtils.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               MathUtils.equals(v, x) ||\n                               MathUtils.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n\n                previous = current;\n                current = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n\n                // User-defined convergence checker.\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }\n",
        "begin_line": 88,
        "end_line": 251,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer": "\n     * Method for implementing actual optimization algorithms in derived\n     * classes.\n     *\n     * @return the optimum and its corresponding function value.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.setMaxEvaluations#54",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setMaxEvaluations(int)",
        "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount(maxEvaluations);\n    }\n",
        "begin_line": 54,
        "end_line": 56,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.BaseOptimizer": "\n     * Set the maximal number of function evaluations.\n     *\n     * @param maxEvaluations Maximal number of function evaluations.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getMaxEvaluations#59",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMaxEvaluations()",
        "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }\n",
        "begin_line": 59,
        "end_line": 61,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.BaseOptimizer": "\n     * Get the maximal number of function evaluations.\n     *\n     * @return the maximal number of function evaluations.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getEvaluations#64",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getEvaluations()",
        "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }\n",
        "begin_line": 64,
        "end_line": 66,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.BaseOptimizer": "\n     * Get the number of evaluations of the objective function.\n     * The number of evaluations corresponds to the last call to the\n     * {@code optimize} method. It is 0 if the method has not been\n     * called yet.\n     *\n     * @return the number of evaluations of the objective function.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getGoalType#71",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getGoalType()",
        "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }\n",
        "begin_line": 71,
        "end_line": 73,
        "comment": "\n     * @return the optimization type.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getMin#77",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMin()",
        "snippet": "    public double getMin() {\n        return searchMin;\n    }\n",
        "begin_line": 77,
        "end_line": 79,
        "comment": "\n     * @return the lower end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getMax#83",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMax()",
        "snippet": "    public double getMax() {\n        return searchMax;\n    }\n",
        "begin_line": 83,
        "end_line": 85,
        "comment": "\n     * @return the higher end of the search interval.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getStartValue#89",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getStartValue()",
        "snippet": "    public double getStartValue() {\n        return searchStart;\n    }\n",
        "begin_line": 89,
        "end_line": 91,
        "comment": "\n     * @return the initial guess.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.computeObjectiveValue#103",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.computeObjectiveValue(double)",
        "snippet": "    protected double computeObjectiveValue(double point)\n        throws FunctionEvaluationException {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }\n",
        "begin_line": 103,
        "end_line": 111,
        "comment": "\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the objective function value at specified point.\n     * @throws FunctionEvaluationException if the function cannot be\n     * evaluated.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     ",
        "resolved_comments": {},
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.optimize#114",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double, double)",
        "snippet": "    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max,\n                                                 double startValue)\n        throws FunctionEvaluationException {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        goal = goalType;\n        function = f;\n        evaluations.resetCount();\n\n        // Perform computation.\n        return doOptimize();\n    }\n",
        "begin_line": 114,
        "end_line": 137,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": "\n     * Find an optimum in the given interval, start at startValue.\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math.exception.ConvergenceException if the\n     * optimizer detects a convergence problem.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     * @throws org.apache.commons.math.exception.NullArgumentException if any\n     * argument is {@code null}.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.optimize#140",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.optimize(org.apache.commons.math.analysis.UnivariateRealFunction, org.apache.commons.math.optimization.GoalType, double, double)",
        "snippet": "    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max)\n        throws FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n    }\n",
        "begin_line": 140,
        "end_line": 145,
        "comment": " {@inheritDoc} ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": "\n     * Find an optimum in the given interval.\n     *\n     * An optimizer may require that the interval brackets a single optimum.\n     *\n     * @param f Function to optimize.\n     * @param goalType Type of optimization goal: either\n     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @return a (point, value) pair where the function is optimum.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n     * if the maximum evaluation count is exceeded.\n     * @throws org.apache.commons.math.exception.ConvergenceException\n     * if the optimizer detects a convergence problem.\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function.\n     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n     * do not satisfy the requirements specified by the optimizer.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    },
    {
        "name": "AbstractUnivariateRealOptimizer.getConvergenceChecker#157",
        "is_bug": false,
        "src_path": "src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java",
        "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
        "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getConvergenceChecker()",
        "snippet": "    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n        return checker;\n    }\n",
        "begin_line": 157,
        "end_line": 159,
        "comment": "\n     * {@inheritDoc}\n     ",
        "resolved_comments": {
            "org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.univariate.BaseUnivariateRealOptimizer": null,
            "org.apache.commons.math.optimization.BaseOptimizer": "\n     * Get the convergence checker.\n     *\n     * @return the object used to check for convergence.\n     "
        },
        "susp": {
            "ochiai_susp": 0.7071
        },
        "num_failing_tests": 1
    }
]